<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Docker 高级篇 | Mofan</title><meta name="author" content="默烦,cy.mofan@foxmail.com"><meta name="copyright" content="默烦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Develop faster. Run anywhere.">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker 高级篇">
<meta property="og:url" content="https://mofan212.github.io/posts/Docker-Advanced/">
<meta property="og:site_name" content="Mofan">
<meta property="og:description" content="Develop faster. Run anywhere.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/158.png">
<meta property="article:published_time" content="2025-02-22T16:00:00.000Z">
<meta property="article:modified_time" content="2025-02-22T16:00:00.000Z">
<meta property="article:author" content="默烦">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/158.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker 高级篇",
  "url": "https://mofan212.github.io/posts/Docker-Advanced/",
  "image": "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/158.png",
  "datePublished": "2025-02-22T16:00:00.000Z",
  "dateModified": "2025-02-22T16:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "默烦",
      "url": "https://mofan212.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/favicon.png"><link rel="canonical" href="https://mofan212.github.io/posts/Docker-Advanced/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 默烦","link":"链接: ","source":"来源: Mofan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://testingcf.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker 高级篇',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><link rel="stylesheet" href="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources@master/css/myStyle.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css" /><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" /><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Mofan" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources/css/minimal.min.css"/><script src="https://testingcf.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">174</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/reward/"><i class="fa-fw fa-solid fa-coins"></i><span> 赞助</span></a></li><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/post_top_img.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Mofan</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/reward/"><i class="fa-fw fa-solid fa-coins"></i><span> 赞助</span></a></li><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Docker 高级篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-22T16:00:00.000Z" title="发表于 2025-02-23 00:00:00">2025-02-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-22T16:00:00.000Z" title="更新于 2025-02-23 00:00:00">2025-02-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Docker/">Docker</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">16.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>62分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;距离本文上次更新已经过去&quot;,&quot;messageNext&quot;:&quot;天，请注意时效性。&quot;,&quot;postUpdate&quot;:&quot;2025-02-23 00:00:00&quot;}" hidden></div>
    <style>
      .highlight-tools {
        background: #262931 !important;
      }
    </style>
    <html><head></head><body><p>封面来源：本文封面来源于 Docker 官网，如有侵权，请联系删除。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gr4y1U7CY/">尚硅谷Docker实战教程</a></p>
<h1 id="1-安装-MySQL-主从复制"><a class="header-anchor" href="#1-安装-MySQL-主从复制"></a>1. 安装 MySQL 主从复制</h1>
<blockquote>
<p>新建主服务器容器实例 3307</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -p</span><span style="color:#98C379"> 3307:3306</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> mysql-master</span><span style="color:#56B6C2"> \</span></span>
<span class="line"><span style="color:#ABB2BF">-v </span><span style="color:#98C379">/mydata/mysql-master/log:/var/log/mysql</span><span style="color:#56B6C2"> \</span></span>
<span class="line"><span style="color:#ABB2BF">-v </span><span style="color:#98C379">/mydata/mysql-master/data:/var/lib/mysql</span><span style="color:#56B6C2"> \</span></span>
<span class="line"><span style="color:#ABB2BF">-v </span><span style="color:#98C379">/mydata/mysql-master/conf:/etc/mysql</span><span style="color:#56B6C2"> \</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 指定 MySQL 的密码</span></span>
<span class="line"><span style="color:#61AFEF">-e</span><span style="color:#98C379"> MYSQL_ROOT_PASSWORD=root</span><span style="color:#56B6C2"> \</span></span>
<span class="line"><span style="color:#ABB2BF">-d </span><span style="color:#98C379">mysql:5.7</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>进入 <code>/mydata/mysql-master/conf</code> 目录下新建 <code>my.cnf</code> 文件</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#56B6C2">cd</span><span style="color:#98C379"> /mydata/mysql-master/conf</span></span>
<span class="line"><span style="color:#61AFEF">vim</span><span style="color:#98C379"> my.cnf</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><code>my.cnf</code> 文件内容如下：</p>
<figure class="highlight properties line-numbers" data-language="PROPERTIES">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">[mysqld]</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## 设置 server_id，同一局域网中需要唯一</span></span>
<span class="line"><span style="color:#C678DD">server_id</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">101</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## 指定不需要同步的数据库名称</span></span>
<span class="line"><span style="color:#C678DD">binlog-ignore-db</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">mysql</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## 开启二进制日志功能</span></span>
<span class="line"><span style="color:#C678DD">log-bin</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">mall-mysql-bin  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## 设置二进制日志使用内存大小（事务）</span></span>
<span class="line"><span style="color:#C678DD">binlog_cache_size</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">1M</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## 设置使用的二进制日志格式（mixed,statement,row）</span></span>
<span class="line"><span style="color:#C678DD">binlog_format</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">mixed</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## 二进制日志过期清理时间。默认值为 0，表示不自动清理。</span></span>
<span class="line"><span style="color:#C678DD">expire_logs_days</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">7</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免 slave 端复制中断。</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## 如：1062 错误是指一些主键重复，1032 错误是因为主从数据库数据不一致</span></span>
<span class="line"><span style="color:#C678DD">slave_skip_errors</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">1062</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>修改完配置后重启 master 实例</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> restart</span><span style="color:#98C379"> mysql-master</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>进入 mysql-master 容器</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> exec</span><span style="color:#D19A66"> -it</span><span style="color:#98C379"> mysql-master</span><span style="color:#98C379"> /bin/bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>mysql -uroot -proot</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>master 容器实例内创建数据同步用户</p>
</blockquote>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>-- 创建 slave 用户</span></span>
<span class="line"><span>CREATE USER 'slave'@'%' IDENTIFIED BY '123456';</span></span>
<span class="line"><span>-- 为 slave 用户授权</span></span>
<span class="line"><span>GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'slave'@'%';</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>新建从服务器容器实例 3308</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -p</span><span style="color:#98C379"> 3308:3306</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> mysql-slave</span><span style="color:#56B6C2"> \</span></span>
<span class="line"><span style="color:#ABB2BF">-v </span><span style="color:#98C379">/mydata/mysql-slave/log:/var/log/mysql</span><span style="color:#56B6C2"> \</span></span>
<span class="line"><span style="color:#ABB2BF">-v </span><span style="color:#98C379">/mydata/mysql-slave/data:/var/lib/mysql</span><span style="color:#56B6C2"> \</span></span>
<span class="line"><span style="color:#ABB2BF">-v </span><span style="color:#98C379">/mydata/mysql-slave/conf:/etc/mysql</span><span style="color:#56B6C2"> \</span></span>
<span class="line"><span style="color:#ABB2BF">-e </span><span style="color:#98C379">MYSQL_ROOT_PASSWORD=root</span><span style="color:#56B6C2">  \</span></span>
<span class="line"><span style="color:#ABB2BF">-d </span><span style="color:#98C379">mysql:5.7</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>执行 <code>docker ps</code> 命令检查主机、从机所在的容器是否都正常运行。</p>
<blockquote>
<p>进入 <code>/mydata/mysql-slave/conf</code> 目录下新建 <code>my.cnf</code> 文件</p>
</blockquote>
<p><code>my.cnf</code> 文件，内容如下：</p>
<figure class="highlight properties line-numbers" data-language="PROPERTIES">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">[mysqld]</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## 设置 server_id，同一局域网中需要唯一</span></span>
<span class="line"><span style="color:#C678DD">server_id</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">102</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## 指定不需要同步的数据库名称</span></span>
<span class="line"><span style="color:#C678DD">binlog-ignore-db</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">mysql</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## 开启二进制日志功能，以备 slave 作为其它数据库实例的 master 时使用</span></span>
<span class="line"><span style="color:#C678DD">log-bin</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">mall-mysql-slave1-bin</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## 设置二进制日志使用内存大小（事务）</span></span>
<span class="line"><span style="color:#C678DD">binlog_cache_size</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">1M</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## 设置使用的二进制日志格式（mixed,statement,row）</span></span>
<span class="line"><span style="color:#C678DD">binlog_format</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">mixed</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## 二进制日志过期清理时间。默认值为 0，表示不自动清理。</span></span>
<span class="line"><span style="color:#C678DD">expire_logs_days</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">7</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免 slave 端复制中断。</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## 如：1062 错误是指一些主键重复，1032 错误是因为主从数据库数据不一致</span></span>
<span class="line"><span style="color:#C678DD">slave_skip_errors</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">1062</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## relay_log配置中继日志</span></span>
<span class="line"><span style="color:#C678DD">relay_log</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">mall-mysql-relay-bin</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## log_slave_updates 表示slave 将复制事件写进自己的二进制日志</span></span>
<span class="line"><span style="color:#C678DD">log_slave_updates</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">1</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">## slave 设置为只读（具有 super 权限的用户除外）</span></span>
<span class="line"><span style="color:#C678DD">read_only</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">1</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>修改完配置后重启 slave 实例</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> restart</span><span style="color:#98C379"> mysql-slave</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>在 <strong>主数据库</strong> 中查看主从同步状态</p>
</blockquote>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>show master status;</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%9F%A5%E7%9C%8B%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81.png" alt="主数据库中查看主从同步状态"></p>
<blockquote>
<p>进入 mysql-slave 容器</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> exec</span><span style="color:#D19A66"> -it</span><span style="color:#98C379"> mysql-slave</span><span style="color:#98C379"> /bin/bash</span></span>
<span class="line"><span style="color:#61AFEF">mysql</span><span style="color:#D19A66"> -uroot</span><span style="color:#D19A66"> -proot</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>在 <strong>从数据库</strong> 中配置主从复制</p>
</blockquote>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>change master to master_host='宿主机IP', master_user='slave', master_password='123456', </span></span>
<span class="line"><span>master_port=3307, master_log_file='mall-mysql-bin.000001', master_log_pos=617, master_connect_retry=30;</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>主从复制命令参数说明：</p>
<ul>
<li>
<p><code>master_host</code> 主数据库的 IP 地址；</p>
</li>
<li>
<p><code>master_port</code> 主数据库的运行端口；</p>
</li>
<li>
<p><code>master_user</code> 在主数据库创建的用于同步数据的用户账号；</p>
</li>
<li>
<p><code>master_password</code> 在主数据库创建的用于同步数据的用户密码；</p>
</li>
<li>
<p><code>master_log_file</code> 指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取 File 参数；</p>
</li>
<li>
<p><code>master_log_pos</code> 指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取 Position 参数；</p>
</li>
<li>
<p><code>master_connect_retry</code> 连接失败重试的时间间隔，单位为秒。</p>
</li>
</ul>
<p>如果使用的是云服务器，<code>master_host</code> 填写对应内网 IP。 <mark>注意，是内网 IP，不是公网 IP！</mark> 阿里云下指「主私网 IP」。</p>
<p><code>master_log_file</code> 和 <code>master_log_pos</code> 填写的信息需要在主数据中执行 <code>show master status;</code> 命令获得。</p>
<blockquote>
<p>在 <strong>从数据库</strong> 中查看主从同步状态</p>
</blockquote>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>show slave status \G;</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%9F%A5%E7%9C%8B%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81.png" alt="从数据库中查看主从同步状态"></p>
<blockquote>
<p>在 <strong>从数据库</strong> 中开启主从同步</p>
</blockquote>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>start slave;</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>查看 <strong>从数据库</strong> 状态发现已经同步</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">show</span><span style="color:#98C379"> slave</span><span style="color:#98C379"> status</span><span style="color:#56B6C2"> \G</span><span style="color:#ABB2BF">;</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E5%86%8D%E6%AC%A1%E6%9F%A5%E7%9C%8B%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81.png" alt="再次查看从数据库中的主从同步状态"></p>
<p>此时的 <code>Slave_IO_Running</code> 和 <code>Slave_SQL_Running</code> 信息均为 <code>Yes</code>，证明主从复制配置完成。</p>
<p>在某些情况下，<code>Slave_IO_Running</code> 的值可能会是 <code>Connecting</code>。这可能是因为使用了较高的 MySQL 版本，比如 MySQL 8.0，此时需要在 <strong>主数据库</strong> 中执行以下两条命令：</p>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>ALTER USER 'slave'@'%' IDENTIFIED WITH mysql_native_password BY '123456';</span></span></code></pre></td></tr></tbody></table>
      </figure>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>flush privileges;</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>执行完成后，重启从数据库即可。</p>
<blockquote>
<p>主从复制测试</p>
</blockquote>
<p>现在主数据库里创建一个数据库：</p>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>CREATE DATABASE db01;</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>使用这个数据库：</p>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>USE db01;</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>新建一张表：</p>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>CREATE TABLE t1 (id INT, name VARCHAR(20));</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>向表里插入一条数据：</p>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>INSERT INTO t1 VALUES(1, 'mofan');</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>查询这张表里的所有数据：</p>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>SELECT * FROM t1;</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>mysql&gt; SELECT * FROM t1;
+------+-------+
| id   | name  |
+------+-------+
|    1 | mofan |
+------+-------+
1 row in set (0.00 sec)
</pre>
<p>接下来切换到从数据库，尝试使用同名的数据库：</p>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>USE db01;</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>命令执行后没有报错，再尝试查询表里所有数据：</p>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>SELECT * FROM t1;</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>最终能够查询到在主数据库中添加的数据，证明主从复制功能无误。</p>
<h1 id="2-分布式数据分区算法"><a class="header-anchor" href="#2-分布式数据分区算法"></a>2. 分布式数据分区算法</h1>
<p>如果有亿级数据需要缓存，应该如何设计这个存储案例？</p>
<p>此时使用单机 Redis 肯定是不行的，需要使用到分布式存储，那应该怎么落地？</p>
<p>目前业界关于分布式数据分区有三种解决方案：</p>
<ol>
<li>哈希取余算法</li>
<li>一致性哈希算法</li>
<li>哈希槽算法</li>
</ol>
<h2 id="2-1-哈希取余算法"><a class="header-anchor" href="#2-1-哈希取余算法"></a>2.1 哈希取余算法</h2>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E5%93%88%E5%B8%8C%E5%8F%96%E4%BD%99%E7%AE%97%E6%B3%95%E5%9B%BE%E7%A4%BA.png" alt="哈希取余算法图示"></p>
<p>以 2 亿条记录为例，在 Redis 里就是 2 亿个 KV 键值对，必须要使用分布式多机。</p>
<p>假设 N 台机器构成一个集群，用户每次读写操作都要根据以下公式计算出哈希值，用来决定数据映射到哪一个 Redis 节点上：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mtext>&nbsp;</mtext><mi mathvariant="normal">%</mi><mtext>&nbsp;</mtext><mi>N</mi></mrow><annotation encoding="application/x-tex">hash(key) \ \% \ N
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ha</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mclose">)</span><span class="mspace">&nbsp;</span><span class="mord">%</span><span class="mspace">&nbsp;</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span></p>
<blockquote>
<p>优点</p>
</blockquote>
<p>简单粗暴，直接有效，只需要预估好数据就能规划好节点，能保证一段时间的数据支撑。使用 Hash 算法让固定的一部分请求落到同一台服务器上，每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡与分而治之的作用。</p>
<blockquote>
<p>缺点</p>
</blockquote>
<p>如果集群进行了扩容或缩容导致节点数量发生变动，映射关系就需要重新计算。在服务器数量固定不变时没有问题，而在需要弹性扩容或故障停机的情况下，原来取模公式中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 就会发生变化，此时运算结果会发生很大的变化，导致根据公式获取的服务器信息变得不可控。</p>
<h2 id="2-2-一致性哈希算法"><a class="header-anchor" href="#2-2-一致性哈希算法"></a>2.2 一致性哈希算法</h2>
<p>一致性哈希算法在 1997 年由麻省理工学院提出，设计目标是为了解决分布式缓存数据变动和映射问题。</p>
<p>使用一致性哈希算法，当服务器个数发生变动时， 尽量减少客户端与服务器之间的映射关系的影响。</p>
<p>一致性哈希算法分为 3 步：</p>
<ol>
<li>构建哈希环</li>
<li>节点映射</li>
<li>落键规则</li>
</ol>
<blockquote>
<p>构建哈希环</p>
</blockquote>
<p>首先需要一个 <code>hash</code> 函数用于计算哈希值，其所有可能的哈希值会构成一个全量集，该集合构成一个范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,2^{32}-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 的线性哈希区间。在一致性哈希算法中，需要通过适当的逻辑将线性哈希区间首尾相连，此时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span> 在同一个位置，让它在逻辑上形成一个环形空间。</p>
<p>一致性哈希算法也将哈希取余算法类似的取模方法，只不过不再是对节点（服务器）的数量进行取模，而是对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span> 进行取模。</p>
<p>简单来说，一致性哈希算法将整个哈希值空间组织成一个虚拟的圆环。假设某哈希函数 <code>H</code> 的值空间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,2^{32}-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>（即哈希值是一个 32 位无符号整型），整个哈希环如下图：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E6%9E%84%E5%BB%BA%E5%93%88%E5%B8%8C%E7%8E%AF.jpg" alt="构建哈希环"></p>
<p>整个空间按顺时针方向组织，圆环正上方的点代表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 点右侧的第一个点代表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，并以此类推，直到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，也就是说 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 点左侧的第一个点是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 在零点钟方向重合，把这个由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span> 个点组成的圆环称为哈希环。</p>
<blockquote>
<p>节点映射</p>
</blockquote>
<p>得到哈希环之后，需要将集群中各个节点映射到环上的某个位置。</p>
<p>使用服务器的 IP 或主机名作为关键词，在利用先前的 <code>Hash</code> 进行计算得到各个节点的哈希值，确定集群中每台机器在哈希环上的位置。</p>
<p>假如有 4 个节点 A、B、C、D，经过计算后，它们在哈希环上的空间位置如下：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%98%A0%E5%B0%84.jpg" alt="一致性哈希算法中的节点映射"></p>
<blockquote>
<p>落键规则</p>
</blockquote>
<p>在 Redis 集群上使用一致性哈希算法，当需要存储一个 KV 键值对时，首先计算 Key 的哈希值确定其在哈希环上的位置，之后从此位置沿环顺时针移动，遇到的第一台 Redis 就是目标存机器，之后将键值对保存在该节点上。</p>
<p>假如有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mtext>&nbsp;</mtext><mi>A</mi></mrow><annotation encoding="application/x-tex">Object \ A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mspace">&nbsp;</span><span class="mord mathnormal">A</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mtext>&nbsp;</mtext><mi>B</mi></mrow><annotation encoding="application/x-tex">Object \ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mspace">&nbsp;</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mtext>&nbsp;</mtext><mi>C</mi></mrow><annotation encoding="application/x-tex">Object \ C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mspace">&nbsp;</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mtext>&nbsp;</mtext><mi>D</mi></mrow><annotation encoding="application/x-tex">Object \ D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mspace">&nbsp;</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> 四个数据对象，经过计算后，它们在环空间上的位置如下：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E8%90%BD%E9%94%AE%E8%A7%84%E5%88%99.jpg" alt="一致性哈希算法的落键规则"></p>
<p>根据一致性哈希算法，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mtext>&nbsp;</mtext><mi>A</mi></mrow><annotation encoding="application/x-tex">Object \ A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mspace">&nbsp;</span><span class="mord mathnormal">A</span></span></span></span> 会被定位到 Node A 上，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mtext>&nbsp;</mtext><mi>B</mi></mrow><annotation encoding="application/x-tex">Object \ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mspace">&nbsp;</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 被定位到 Node B 上，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mtext>&nbsp;</mtext><mi>C</mi></mrow><annotation encoding="application/x-tex">Object \ C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mspace">&nbsp;</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 被定位到 Node C 上，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mtext>&nbsp;</mtext><mi>D</mi></mrow><annotation encoding="application/x-tex">Object \ D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mspace">&nbsp;</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> 被定为到 Node D 上。</p>
<blockquote>
<p>一致性哈希算法的优点</p>
</blockquote>
<p>一致性哈希算法具有一定的容错性和扩展性。</p>
<p><strong>容错性：</strong></p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%B9%E9%94%99%E6%80%A7.jpg" alt="一致性哈希算法的容错性"></p>
<p>假设 Node C 宕机，此时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mtext>&nbsp;</mtext><mi>A</mi></mrow><annotation encoding="application/x-tex">Object \ A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mspace">&nbsp;</span><span class="mord mathnormal">A</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mtext>&nbsp;</mtext><mi>B</mi></mrow><annotation encoding="application/x-tex">Object \ B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mspace">&nbsp;</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mtext>&nbsp;</mtext><mi>D</mi></mrow><annotation encoding="application/x-tex">Object \ D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mspace">&nbsp;</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> 不会受到影响，只有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>b</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mtext>&nbsp;</mtext><mi>C</mi></mrow><annotation encoding="application/x-tex">Object \ C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mspace">&nbsp;</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 会被重定位到 Node D。</p>
<p>在一致性哈希算法中，如果一台服务器不可用，受影响的数据仅仅是此服务器到其环空间中的前一台服务器（沿逆时针方向移动遇到的第一台服务器）之间数据，其它数据不会受到影响。</p>
<p>简单说来说，当 Node C 宕机了，只有 Node B 和 Node C 之间的数据会受到影响，这些数据会转移到 Node D 进行存储。</p>
<p><strong>扩展性：</strong></p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A9%E5%B1%95%E6%80%A7.jpg" alt="一致性哈希算法的扩展性"></p>
<p>如果需要增加一个节点 Node X，其位于 Node B 和 Node C 之间，此时受到影响的只有 Node B 到 Node X 之间的数据，这使得 Node B 到 Node X 之间的数据会被写入 Node X 中，而不会导致所有数据重新洗牌。</p>
<blockquote>
<p>一致性哈希算法的缺点</p>
</blockquote>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C.webp" alt="一致性哈希算法的数据倾斜"></p>
<p>当节点数量太少时，会出现因为节点分布不均而导致数据倾斜，大量数据会集中打向同一个节点。</p>
<p>为了解决这个问题，一致性哈希算法引入了虚拟节点机制。对每一个节点计算多个哈希值，每个计算结果位置都放置一个相同的服务节点（称为虚拟节点）。</p>
<p>具体做法可以先确定每个节点关联的虚拟节点数量，然后原本节点名称后面加上编号。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9%E6%9C%BA%E5%88%B6.jpg" alt="一致性哈希算法的虚拟节点机制"></p>
<p>例如对 Node A 节点虚拟出 NodeA#1、NodeA#2 和 NodeA#3 共 3 个节点，对 Node B 虚拟出 NodeB#1、NodeB#2 和 NodeB#3 共 3 个节点，总共形成 6 个虚拟节点。</p>
<p>如果再加入或删除节点，只会影响哈希环中顺时针方向相邻节点，而对其他节点无影响。</p>
<p>此时数据的分布和节点的位置有关，因为这些虚拟节点不是均匀分布在哈希环上的，所以无法均匀地存储数据。</p>
<h2 id="2-3-哈希槽算法"><a class="header-anchor" href="#2-3-哈希槽算法"></a>2.3 哈希槽算法</h2>
<p>哈希槽的本质是一个数组，数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mn>14</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,2^{14} -1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 形成哈希槽（hash slot）空间。</p>
<p>使用哈希槽能够解决数据不均匀分配的问题。在数据和节点之间添加一层哈希槽（slot），用于管理数据和节点之间的关系，此时节点上放的是槽，槽里放的才是数据。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/data-slot-redis.png" alt="data-slot-redis"></p>
<p>槽解决的是粒度问题，相当于把粒度变大了，更便于数据移动。哈希解决的是映射问题，使用 Key 的哈希值来计算所在的槽，更便于数据分配。</p>
<p>一个 Redis 集群只能有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16384</mn></mrow><annotation encoding="application/x-tex">16384</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16384</span></span></span></span> 个槽，编号范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mn>14</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,2^{14}-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16383</mn></mrow><annotation encoding="application/x-tex">16383</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16383</span></span></span></span>。Redis 根据节点数量将这些槽大致均等地分配给集群中的所有主节点，对分配策略没有要求，可以指定哪些编号的槽分配给哪个主节点，集群会记录节点和槽的对应关系。</p>
<p>解决了节点和槽的关系后，接下来就需要对 Key 求哈希值，然后对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16384</mn></mrow><annotation encoding="application/x-tex">16384</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16384</span></span></span></span> 取余，根据结果确定 Key 归属的槽：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>s</mi><mi>l</mi><mi>o</mi><mi>t</mi><mo>=</mo><mi>C</mi><mi>R</mi><mi>C</mi><mn>16</mn><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mtext>&nbsp;</mtext><mi mathvariant="normal">%</mi><mtext>&nbsp;</mtext><mn>16384</mn></mrow><annotation encoding="application/x-tex">slot = CRC16(key) \ \% \ 16384
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">CRC</span><span class="mord">16</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mclose">)</span><span class="mspace">&nbsp;</span><span class="mord">%</span><span class="mspace">&nbsp;</span><span class="mord">16384</span></span></span></span></span></p>
<p>之后会以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</p>
<blockquote>
<p>Redis 集群为什么只能有 16384 个槽</p>
</blockquote>
<p>原 GitHub issue：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/issues/2576">why redis-cluster use 16384 slots? · Issue #2576 · redis/redis</a></p>
<p>可以参考的中文回答：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/issues/2576#issuecomment-798880470">issues#2576#issuecomment</a></p>
<p>CRC16 算法产生的 hash 值有 16bit，该算法可以产生 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>65536</mn></mrow><annotation encoding="application/x-tex">2^{16} = 65536</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">65536</span></span></span></span> 个值，但为了心跳方便和数据传输最大化，槽的数量只能有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup></mrow><annotation encoding="application/x-tex">2^{14}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span></span></span></span> 个（即 16384）。</p>
<p>如果槽位数量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>65536</mn></mrow><annotation encoding="application/x-tex">65536</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">65536</span></span></span></span> 个，那么发送心跳信息的消息头将达到 8k，发送的心跳包过于庞大。在消息头中最占空间的是 <code>myslots[CLUSTER_SLOTS/8]</code>。当槽位为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>65536</mn></mrow><annotation encoding="application/x-tex">65536</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">65536</span></span></span></span> 时，这块的大小是 ：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>65536</mn><mo>÷</mo><mn>8</mn><mo>÷</mo><mn>1024</mn><mo>=</mo><mn>8</mn><mi>K</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">65536 \div 8 \div 1024 = 8Kb
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">65536</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1024</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">8</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal">b</span></span></span></span></span></p>
<p>Redis 节点每秒需要发送一定数量的 ping 消息作为心跳，如果槽位为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>65536</mn></mrow><annotation encoding="application/x-tex">65536</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">65536</span></span></span></span>，那么这个 ping 消息头就会太大而浪费带宽。</p>
<p>Redis 集群的主节点数量基本不可能超过 1000 个。集群节点越多，心跳包的消息体内携带的数据越多（心跳包带有节点的完整配置，可以用幂等的方式替换旧节点的配置，以更新旧节点）。如果节点超过 1000 个，也会导致网络拥堵。因此 Redis 作者不建议 Redis 集群节点超过 1000 个。对于节点数在 1000 以内的 Redis 集群，16384 个槽位足够了，没有必要扩展到 65536 个。</p>
<p>槽位越小，节点少的情况下压缩比越高，更容易传输。Redis 主节点的配置信息中，它所负责的哈希槽是通过一个 Bitmap 来保存的，在传输过程中会对 Bitmap 进行压缩，但如果 Bitmap 的填充率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>l</mi><mi>o</mi><mi>t</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">slots / N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>（ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 为节点数）很高，Bitmap 的压缩率会很低。如果节点数很少，但哈希槽很多，Bitmap 的压缩率就会很低。</p>
<h1 id="3-安装-Redis-集群"><a class="header-anchor" href="#3-安装-Redis-集群"></a>3. 安装 Redis 集群</h1>
<h2 id="3-1-三主三从-Redis-集群配置"><a class="header-anchor" href="#3-1-三主三从-Redis-集群配置"></a>3.1 三主三从 Redis 集群配置</h2>
<blockquote>
<p>新建 6 个 Docker 容器实例</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic"># 启动第 1 台节点</span></span>
<span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> redis-node-1</span><span style="color:#D19A66"> --net</span><span style="color:#98C379"> host</span><span style="color:#D19A66"> --privileged=true</span><span style="color:#D19A66"> -v</span><span style="color:#98C379"> /app/redis-cluster/share/redis-node-1:/data</span><span style="color:#98C379"> redis:6.0.8</span><span style="color:#D19A66"> --cluster-enabled</span><span style="color:#98C379"> yes</span><span style="color:#D19A66"> --appendonly</span><span style="color:#98C379"> yes</span><span style="color:#D19A66"> --port</span><span style="color:#D19A66"> 6381</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 启动第 2 台节点</span></span>
<span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> redis-node-2</span><span style="color:#D19A66"> --net</span><span style="color:#98C379"> host</span><span style="color:#D19A66"> --privileged=true</span><span style="color:#D19A66"> -v</span><span style="color:#98C379"> /app/redis-cluster/share/redis-node-2:/data</span><span style="color:#98C379"> redis:6.0.8</span><span style="color:#D19A66"> --cluster-enabled</span><span style="color:#98C379"> yes</span><span style="color:#D19A66"> --appendonly</span><span style="color:#98C379"> yes</span><span style="color:#D19A66"> --port</span><span style="color:#D19A66"> 6382</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 启动第 3 台节点</span></span>
<span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> redis-node-3</span><span style="color:#D19A66"> --net</span><span style="color:#98C379"> host</span><span style="color:#D19A66"> --privileged=true</span><span style="color:#D19A66"> -v</span><span style="color:#98C379"> /app/redis-cluster/share/redis-node-3:/data</span><span style="color:#98C379"> redis:6.0.8</span><span style="color:#D19A66"> --cluster-enabled</span><span style="color:#98C379"> yes</span><span style="color:#D19A66"> --appendonly</span><span style="color:#98C379"> yes</span><span style="color:#D19A66"> --port</span><span style="color:#D19A66"> 6383</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 启动第 4 台节点</span></span>
<span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> redis-node-4</span><span style="color:#D19A66"> --net</span><span style="color:#98C379"> host</span><span style="color:#D19A66"> --privileged=true</span><span style="color:#D19A66"> -v</span><span style="color:#98C379"> /app/redis-cluster/share/redis-node-4:/data</span><span style="color:#98C379"> redis:6.0.8</span><span style="color:#D19A66"> --cluster-enabled</span><span style="color:#98C379"> yes</span><span style="color:#D19A66"> --appendonly</span><span style="color:#98C379"> yes</span><span style="color:#D19A66"> --port</span><span style="color:#D19A66"> 6384</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 启动第 5 台节点</span></span>
<span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> redis-node-5</span><span style="color:#D19A66"> --net</span><span style="color:#98C379"> host</span><span style="color:#D19A66"> --privileged=true</span><span style="color:#D19A66"> -v</span><span style="color:#98C379"> /app/redis-cluster/share/redis-node-5:/data</span><span style="color:#98C379"> redis:6.0.8</span><span style="color:#D19A66"> --cluster-enabled</span><span style="color:#98C379"> yes</span><span style="color:#D19A66"> --appendonly</span><span style="color:#98C379"> yes</span><span style="color:#D19A66"> --port</span><span style="color:#D19A66"> 6385</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 启动第 6 台节点</span></span>
<span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> redis-node-6</span><span style="color:#D19A66"> --net</span><span style="color:#98C379"> host</span><span style="color:#D19A66"> --privileged=true</span><span style="color:#D19A66"> -v</span><span style="color:#98C379"> /app/redis-cluster/share/redis-node-6:/data</span><span style="color:#98C379"> redis:6.0.8</span><span style="color:#D19A66"> --cluster-enabled</span><span style="color:#98C379"> yes</span><span style="color:#D19A66"> --appendonly</span><span style="color:#98C379"> yes</span><span style="color:#D19A66"> --port</span><span style="color:#D19A66"> 6386</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>命令解析：</p>
<ul>
<li><code>--net host</code> 使用宿主机的 IP 和端口，默认</li>
<li><code>--cluster-enabled yes</code> 开启 Redis 集群</li>
<li><code>--appendonly yes</code> 开启 Redis 持久化</li>
<li><code>--port 6381</code> 配置 Redis 端口号</li>
</ul>
<p>启动 6 个容器实例后，执行 <code>docker ps</code> 命令检查容器状态：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/Docker%E6%88%90%E5%8A%9F%E5%90%AF%E5%8A%A86%E5%8F%B0Redis.png" alt="Docker成功启动6台Redis"></p>
<blockquote>
<p>进入容器 <code>redis-node-1</code> 并为 6 台机器构建集群关系</p>
</blockquote>
<p>进入容器 <code>redis-node-1</code>：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> exec</span><span style="color:#D19A66"> -it</span><span style="color:#98C379"> redis-node-1</span><span style="color:#98C379"> /bin/bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>在容器内构建 Redis 主从关系：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> --cluster</span><span style="color:#98C379"> create</span><span style="color:#98C379"> 宿主机IP:6381</span><span style="color:#98C379"> 宿主机IP:6382</span><span style="color:#98C379"> 宿主机IP:6383</span><span style="color:#98C379"> 宿主机IP:6384</span><span style="color:#98C379"> 宿主机IP:6385</span><span style="color:#98C379"> 宿主机IP:6386</span><span style="color:#D19A66"> --cluster-replicas</span><span style="color:#D19A66"> 1</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><code>--cluster-replicas 1</code> 表示为每个 master 构建一个 slave 节点。</p>
<p>如果使用的是云服务器，此处的宿主机 IP 使用私网 IP，阿里云下就是「主私网IP」，并且记得在安全组里开放指定的 6 个端口。</p>
<p>执行命令后能够看到哈希槽的分配情况和 Redis 主从关系：</p>
<pre>&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...
Master[0] -&gt; Slots 0 - 5460
Master[1] -&gt; Slots 5461 - 10922
Master[2] -&gt; Slots 10923 - 16383
Adding replica 宿主机IP:6385 to 宿主机IP:6381
Adding replica 宿主机IP:6386 to 宿主机IP:6382
Adding replica 宿主机IP:6384 to 宿主机IP:6383
</pre>
<p>同时出现以下询问：</p>
<pre>Can I set the above configuration? (type '<font style="color:green">yes</font>' to accept): 
</pre>
<p>键入 <code>yes</code> 即可。之后如果得到如下信息，证明主从关系构建成功：</p>
<pre><font style="color:green">[OK] All nodes agree about slots configuration.</font>
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
<font style="color:green">[OK] All 16384 slots covered.</font>
</pre>
<blockquote>
<p>在容器 <code>redis-node-1</code> 登入 Redis，并将其作为切入点，查看集群状态</p>
</blockquote>
<p>登入 Redis：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> -p</span><span style="color:#D19A66"> 6381</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>查看集群信息：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">cluster</span><span style="color:#98C379"> info</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>root@mofan:/data# redis-cli -p 6381
127.0.0.1:6381&gt; cluster info
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
</pre>
<p>可以看到：</p>
<ul>
<li>集群状态 <code>cluster_state</code> 是 <code>ok</code></li>
<li>被分配的哈希槽数量 <code>cluster_slots_assigned</code> 有 <code>16384</code> 个</li>
<li>集群中已知的节点 <code>cluster_known_nodes</code> 有 <code>6</code> 个</li>
</ul>
<p>执行以下命令查看集群节点情况：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">cluster</span><span style="color:#98C379"> nodes</span></span></code></pre></td></tr></tbody></table>
      </figure>
<h2 id="3-2-主从容错切换迁移"><a class="header-anchor" href="#3-2-主从容错切换迁移"></a>3.2 主从容错切换迁移</h2>
<blockquote>
<p>数据读写存储</p>
</blockquote>
<p>先进入 <code>redis-node-1</code> 容器：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> exec</span><span style="color:#D19A66"> -it</span><span style="color:#98C379"> redis-node-1</span><span style="color:#98C379"> /bin/bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>进入 Redis：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> -p</span><span style="color:#D19A66"> 6381</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>查看所有键信息：</p>
<pre>127.0.0.1:6381&gt; keys *
(empty array)
</pre>
<p>添加一个键值对：</p>
<pre>127.0.0.1:6381&gt; set k1 v1
(error) MOVED 12706 宿主机IP:6383
</pre>
<p>居然出现了 error？😲</p>
<p>换一个试试：</p>
<pre>127.0.0.1:6381&gt; set k2 v2
OK
</pre>
<p>可以存储 <code>k2-v2</code> 的键值对。这又是为什么呢？</p>
<p>添加 <code>k1</code> 时，计算得到的哈希槽为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12706</mn></mrow><annotation encoding="application/x-tex">12706</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12706</span></span></span></span>，但是当前连接的 redis-server 为 <code>6381</code>，它的哈希槽编号范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>5460</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,5460]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5460</span><span class="mclose">]</span></span></span></span>，所以会存不进去导致报错。 添加 <code>k2</code> 能够成功，自然是因为这时计算出的哈希槽编号在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>−</mo><mn>5460</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0-5460]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5460</span><span class="mclose">]</span></span></span></span> 区间之间。</p>
<p>为解决这个问题，在连接 Redis 时需要添加 <code>-c</code> 选项防止路由失效：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> -p</span><span style="color:#D19A66"> 6381</span><span style="color:#D19A66"> -c</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>再添加 <code>k1-v1</code> 键值对：</p>
<pre>127.0.0.1:6381&gt; set k1 v1
-&gt; Redirected to slot [12706] located at 宿主机IP:6383
OK
宿主机IP:6383&gt;
</pre>
<p>键值对添加成功，并显示重定向到端口 <code>6383</code> 的 Redis。</p>
<blockquote>
<p>集群信息检查</p>
</blockquote>
<p>进入容器后，输入任意一个 master 节点地址进行集群检查。以 <code>6381</code> 为例：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> --cluster</span><span style="color:#98C379"> check</span><span style="color:#98C379"> 宿主机IP:6381</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>如果使用的是云服务器，此处的宿主机 IP 使用私网 IP，阿里云下就是「主私网IP」。</p>
<p>执行上述命令后会返回以下信息：</p>
<ul>
<li>当前集群各节点存储的 key 的数量</li>
<li>主从机信息</li>
</ul>
<h2 id="3-3-主从容错切换迁移"><a class="header-anchor" href="#3-3-主从容错切换迁移"></a>3.3 主从容错切换迁移</h2>
<p>已知当前 Redis 集群信息如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">主机名称:端口</th>
<th style="text-align:center">对应从机名称:端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>redis-node-1:6381</code></td>
<td style="text-align:center"><code>redis-node-4:6384</code></td>
</tr>
<tr>
<td style="text-align:center"><code>redis-node-2:6382</code></td>
<td style="text-align:center"><code>redis-node-5:6385</code></td>
</tr>
<tr>
<td style="text-align:center"><code>redis-node-3:6383</code></td>
<td style="text-align:center"><code>redis-node-6:6386</code></td>
</tr>
</tbody>
</table>
<p>模拟 <code>6381</code> 端口的 <code>redis-node-1</code> 容器宕机。</p>
<p>查找 <code>6381</code> 端口的 PID：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">lsof</span><span style="color:#D19A66"> -i:6381</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>COMMAND     PID    USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
redis-ser 25946 polkitd    6u  IPv6 83743781      0t0  TCP *:6381 (LISTEN)
</pre>
<p><code>kill</code> 掉 PID 为 <code>25946</code> 的进程：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#56B6C2">kill</span><span style="color:#D19A66"> -9</span><span style="color:#D19A66"> 25946</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>再使用 <code>docker ps -a</code> 命令查看所有容器状态，会发现 <code>redis-node-1</code> 容器已经停止运行。</p>
<p>进入 <code>redis-node-2</code> 容器：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> exec</span><span style="color:#D19A66"> -it</span><span style="color:#98C379"> redis-node-2</span><span style="color:#98C379"> /bin/bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>登入 <code>6382</code> 端口的 Redis：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> -p</span><span style="color:#D19A66"> 6382</span><span style="color:#D19A66"> -c</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>查看当前集群信息：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">cluster</span><span style="color:#98C379"> nodes</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>此时 <code>6381</code> 端口的 Redis 已经失去连接，显示 <code>disconnected</code>，同时其原本对应的从机 —— <code>6384</code> 端口的 Redis 已经称为主机。</p>
<p>在上一节中向 Redis 内添加了 <code>k1-v1</code> 和 <code>k2-v2</code> 键值对，此时尝试通过 Key 获取对应的 Value 也是完全可行的：</p>
<pre>127.0.0.1:6382&gt; get k1
-&gt; Redirected to slot [12706] located at 宿主机IP:6383
"v1"
宿主机IP:6383&gt; get k2
-&gt; Redirected to slot [449] located at 宿主机IP:6384
"v2"
</pre>
<p>那如果这时宕机的 <code>6381</code> 又活了过来呢？使用 <code>docker start 容器ID</code>  模拟 <code>6381</code> 复活。</p>
<p>再次查看当前集群信息：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">cluster</span><span style="color:#98C379"> nodes</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>尽管此时 <code>6381</code> 端口的 Redis 已经恢复连接，显示 <code>connected</code>，但它变成了从机，而 <code>6384</code> 端口的 Redis 依旧是主机。</p>
<p>如果又断开 <code>6384</code> 的连接呢？</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic"># 简单处理，用 docker stop 命令断开连接</span></span>
<span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> stop</span><span style="color:#98C379"> 6384Redis对应的容器ID</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>这时 <code>6381</code> 又会恢复成主机，如果 <code>6384</code> 再复活，它也还是只能是从机。</p>
<h2 id="3-4-主从扩容"><a class="header-anchor" href="#3-4-主从扩容"></a>3.4 主从扩容</h2>
<p>现在需要往 3 主 3 从的集群里再添加 1 主 1 从两个节点。</p>
<p>首先启动 2 个新的容器，并指定端口信息：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> redis-node-7</span><span style="color:#D19A66"> --net</span><span style="color:#98C379"> host</span><span style="color:#D19A66"> --privileged=true</span><span style="color:#D19A66"> -v</span><span style="color:#98C379"> /app/redis-cluster/share/redis-node-7:/data</span><span style="color:#98C379"> redis:6.0.8</span><span style="color:#D19A66"> --cluster-enabled</span><span style="color:#98C379"> yes</span><span style="color:#D19A66"> --appendonly</span><span style="color:#98C379"> yes</span><span style="color:#D19A66"> --port</span><span style="color:#D19A66"> 6387</span></span></code></pre></td></tr></tbody></table>
      </figure>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> redis-node-8</span><span style="color:#D19A66"> --net</span><span style="color:#98C379"> host</span><span style="color:#D19A66"> --privileged=true</span><span style="color:#D19A66"> -v</span><span style="color:#98C379"> /app/redis-cluster/share/redis-node-8:/data</span><span style="color:#98C379"> redis:6.0.8</span><span style="color:#D19A66"> --cluster-enabled</span><span style="color:#98C379"> yes</span><span style="color:#D19A66"> --appendonly</span><span style="color:#98C379"> yes</span><span style="color:#D19A66"> --port</span><span style="color:#D19A66"> 6388</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>使用 <code>docker ps</code> 查看当前正在运行的容器，可以看到新增两个名为 <code>redis-node-7</code> 和 <code>redis-node-8</code> 的容器。</p>
<p>进入 <code>redis-node-7</code> 容器内部：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> exec</span><span style="color:#D19A66"> -it</span><span style="color:#98C379"> redis-node-7</span><span style="color:#98C379"> /bin/bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>将该容器内的 Redis 作为 master 节点加入原有集群：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> --cluster</span><span style="color:#98C379"> add-node</span><span style="color:#98C379"> 宿主机IP:6387</span><span style="color:#98C379"> 宿主机IP:6381</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>其中的 <code>宿主机IP:6387</code> 表示加入集群的节点地址，<code>宿主机IP:6381</code> 可以是目标集群中任意一个节点的地址，甚至用 <code>宿主机IP:6386</code> 也行。</p>
<p>添加成功后查看集群状态：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> --cluster</span><span style="color:#98C379"> check</span><span style="color:#98C379"> 宿主机IP:6381</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>M: 2c02d6705ec757cee03219f51091b2afc3a6d6c5 宿主机IP:6387
   slots: (0 slots) master
</pre>
<p>可以看到 <code>6387</code> 已经作为 master 节点加入了集群，但是该节点还没有分配槽位，即 <code>0 slots</code>。</p>
<p>执行以下命令重新分配槽位：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> --cluster</span><span style="color:#98C379"> reshard</span><span style="color:#98C379"> 宿主机IP:6381</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>最后的 <code>宿主机IP:6381</code> 可以是集群中任意节点的地址，甚至可以是刚刚加入集群的 <code>宿主机IP:6387</code>。</p>
<p>执行命令后会提示需要移动多少个槽位：</p>
<pre>How many slots do you want to move (from 1 to 16384)?
</pre>
<p>由于总共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16384</mn></mrow><annotation encoding="application/x-tex">16384</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16384</span></span></span></span> 个槽位，现在有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 台主机，根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16384</mn><mo>÷</mo><mn>4</mn><mo>=</mo><mn>4096</mn></mrow><annotation encoding="application/x-tex">16384 \div 4 = 4096</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16384</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4096</span></span></span></span>，因此需要移动的槽位数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4096</mn></mrow><annotation encoding="application/x-tex">4096</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4096</span></span></span></span>。</p>
<p>输入 <code>4096</code> 后回车，又会提示需要输入接受节点 ID：</p>
<pre>What is the receiving node ID?
</pre>
<p>输入先前的 <code>6387</code> 节点的 ID，表示将 <code>4096</code> 个槽位分配给 <code>6387</code> 节点。</p>
<p>节点 ID 是查看节点信息时前面很长的那串十六进制字符串：</p>
<pre>M: 2c02d6705ec757cee03219f51091b2afc3a6d6c5 宿主机IP:6387
   slots: (0 slots) master
</pre>
<p>比如这里 <code>6387</code> 节点的 ID 就是 <code>2c02d6705ec757cee03219f51091b2afc3a6d6c5</code>。</p>
<p>输入 <code>6387</code> 节点 ID 后再次回车，接下来又会提示：</p>
<pre>Please enter all the source node IDs.
  Type 'all' to use all the nodes as source nodes for the hash slots.
  Type 'done' once you entered all the source nodes IDs.
Source node #1:
</pre>
<p>要求输入需要以哪些节点为源节点来分配槽到 <code>6387</code> 节点，这里需要将所有节点作为源节点，表示从每个节点里都「匀」点槽给 <code>6387</code> 节点，因此输入 <code>all</code>。</p>
<p>接下来遇到最后一个提示信息：</p>
<pre>Do you want to proceed with the proposed reshard plan (yes/no)?
</pre>
<p>询问是否需要继续执行哈希槽分配计划，输入 <code>yes</code> 即可。</p>
<p>耐心等待 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16384</mn></mrow><annotation encoding="application/x-tex">16384</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16384</span></span></span></span> 个槽的重新分配，之后再次查看集群信息：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> --cluster</span><span style="color:#98C379"> check</span><span style="color:#98C379"> 宿主机IP:6381</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>root@mofan:/data# redis-cli --cluster check 宿主机IP:6381
宿主机IP:6381 (282567ff...) -&gt; 0 keys | 4096 slots | 1 slaves.
宿主机IP:6383 (910bf425...) -&gt; 1 keys | 4096 slots | 1 slaves.
宿主机IP:6382 (daae6662...) -&gt; 0 keys | 4096 slots | 1 slaves.
宿主机IP:6387 (2c02d670...) -&gt; 1 keys | 4096 slots | 0 slaves.
[OK] 2 keys in 4 masters.
0.00 keys per slot on average.
&gt;&gt;&gt; Performing Cluster Check (using node 宿主机IP:6381)
M: 282567ffb3946e7017e5f92b6560c5a56e505bca 宿主机IP:6381
   slots:[1365-5460] (4096 slots) master
   1 additional replica(s)
S: 5f56f6e19ae385a327bc224fd7818f4e296e6cbc 宿主机IP:6386
   slots: (0 slots) slave
   replicates 910bf425f16e7481486658734565f10b8ededcbd
M: 910bf425f16e7481486658734565f10b8ededcbd 宿主机IP:6383
   slots:[12288-16383] (4096 slots) master
   1 additional replica(s)
M: daae6662affc36ac6fa68af021fc049cfbdad391 宿主机IP:6382
   slots:[6827-10922] (4096 slots) master
   1 additional replica(s)
M: 2c02d6705ec757cee03219f51091b2afc3a6d6c5 宿主机IP:6387
   slots:[0-1364],[5461-6826],[10923-12287] (4096 slots) master
S: 1facb270069567af4f26a2ddbc66d7b76341c33e 宿主机IP:6385
   slots: (0 slots) slave
   replicates daae6662affc36ac6fa68af021fc049cfbdad391
S: 8759bf90bbf13e795bc76a677b34db1a433626c4 宿主机IP:6384
   slots: (0 slots) slave
   replicates 282567ffb3946e7017e5f92b6560c5a56e505bca
[OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
[OK] All 16384 slots covered.
</pre>
<p>可以看到：</p>
<ul>
<li>现在集群里有 7 台 Redis，其中 4 主 3 从；</li>
<li>分配槽位时，原本每台主机都给 <code>6387</code> 「匀」了一点，<code>6387</code> 占有的槽位编号是 <code>[0-1364],[5461-6826],[10923-12287]</code>，共 <code>4096</code> 个。</li>
</ul>
<p>接下来需要为 <code>6387</code> 分配 <code>6388</code> 从节点：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> --cluster</span><span style="color:#98C379"> add-node</span><span style="color:#98C379"> 宿主机IP:6388</span><span style="color:#98C379"> 宿主机IP:6381</span><span style="color:#D19A66"> --cluster-slave</span><span style="color:#D19A66"> --cluster-master-id</span><span style="color:#98C379"> 目标主节点的节点ID</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>其中的 <code>宿主机IP:6381</code> 可以是节点里的任意节点，最后的「目标主节点的节点 ID」就是 <code>6387</code> 节点的 ID。</p>
<p>最后查看集群状态：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> --cluster</span><span style="color:#98C379"> check</span><span style="color:#98C379"> 宿主机IP:6381</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>此时集群中共有 4 台 Redis，新增 <code>6387</code> <code>6388</code> 两台一主一从，<code>6388</code> 作为从节点挂在 <code>6387</code> 下。</p>
<h2 id="3-5-主从缩容"><a class="header-anchor" href="#3-5-主从缩容"></a>3.5 主从缩容</h2>
<p>现在需要贯彻落实开源节流，4 主 4 从的 Redis 集群太奢侈了，3 主 3 从就够用。那么要怎么缩容呢？</p>
<p>假设需要将 <code>6387</code> 和 <code>6388</code> 「干掉」，先进入其他任意不包含这两个 Redis 的容器中：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> exec</span><span style="color:#D19A66"> -it</span><span style="color:#98C379"> redis-node-1</span><span style="color:#98C379"> /bin/bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>查看集群状态：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> --cluster</span><span style="color:#98C379"> check</span><span style="color:#98C379"> 宿主机IP:6381</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>在缩容时，需要先移除从节点。</p>
<p>将 <code>6388</code> 节点从集群中移除：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> --cluster</span><span style="color:#98C379"> del-node</span><span style="color:#98C379"> 宿主机IP:6388</span><span style="color:#98C379"> 6388节点ID</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>root@mofan:/data# redis-cli --cluster del-node 宿主机IP:6388 7b06b67eb4cc8a6f47307a8f065053638c5093c4
&gt;&gt;&gt; Removing node 7b06b67eb4cc8a6f47307a8f065053638c5093c4 from cluster 宿主机IP:6388
&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...
&gt;&gt;&gt; Sending CLUSTER RESET SOFT to the deleted node.
</pre>
<p>再次查看集群状态：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> --cluster</span><span style="color:#98C379"> check</span><span style="color:#98C379"> 宿主机IP:6381</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>此时容器中的配置是 4 主 3 从，<code>6388</code> 已经被移除。</p>
<p>接下来需要移除 <code>6387</code> 主机，但是该主机上还有被分配的槽位，需要先将其槽位分配给其他主节点。</p>
<p>对集群重新分配哈希槽可以像前文扩容那样使用如下命令：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> --cluster</span><span style="color:#98C379"> reshard</span><span style="color:#98C379"> 宿主机IP:6381</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>询问需要移动多少个槽位：</p>
<pre>How many slots do you want to move (from 1 to 16384)?
</pre>
<p><code>6387</code> 上有 <code>4096</code> 个槽，因此输入 <code>4096</code>。</p>
<p>接着询问接受这些槽的节点 ID：</p>
<pre>What is the receiving node ID?
</pre>
<p>先把 <code>6387</code> 的槽移给 <code>6381</code>，这里输入 <code>6381</code> 的节点 ID。</p>
<p>然后询问需要使用哪些节点作为源节点：</p>
<pre>Please enter all the source node IDs.
  Type 'all' to use all the nodes as source nodes for the hash slots.
  Type 'done' once you entered all the source nodes IDs.
Source node #1:
</pre>
<p>要移除 <code>6387</code> 节点，自然是把 <code>6387</code> 的槽分配出来，因此输入 <code>6387</code> 的节点 ID。输入后回车，然后再输入 <code>done</code>：</p>
<pre>Source node #1: 6387节点ID
Source node #2: done
</pre>
<p>最后询问是否继续：</p>
<pre>Do you want to proceed with the proposed reshard plan (yes/no)?
</pre>
<p>输入 <code>yes</code> 即可。</p>
<p>等待分配完成后查看集群状态：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> --cluster</span><span style="color:#98C379"> check</span><span style="color:#98C379"> 宿主机IP:6381</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>此时依旧是 4 主 3 从的配置，但是 <code>6387</code> 节点上已经没有槽，是 <code>0 slots</code>。</p>
<p>尝试移除 <code>6387</code> 节点：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> --cluster</span><span style="color:#98C379"> del-node</span><span style="color:#98C379"> 宿主机IP:6387</span><span style="color:#98C379"> 6387节点ID</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>再次查看集群状态：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> --cluster</span><span style="color:#98C379"> check</span><span style="color:#98C379"> 宿主机IP:6381</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>此时集群的配置变成 3 主 3 从。</p>
<p>由于 <code>6381</code> 从 <code>6387</code> 中获得了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4096</mn></mrow><annotation encoding="application/x-tex">4096</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4096</span></span></span></span> 个槽位，因此它现在有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8192</mn></mrow><annotation encoding="application/x-tex">8192</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8192</span></span></span></span> 个槽位。</p>
<p>可以使用以下命令将当前集群中的槽位再次分配均匀：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> --cluster</span><span style="color:#98C379"> rebalance</span><span style="color:#D19A66"> --cluster-use-empty-masters</span><span style="color:#98C379"> 宿主机IP:6381</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>其中：</p>
<ul>
<li><code>rebalance</code> 表示重新分配集群中的哈希槽，使数据分配更均匀</li>
<li><code>--cluster-use-empty-masters</code> 表示将空节点（未分配任何槽位的节点）也纳入平衡逻辑，就是分配时还会把槽位分配给空节点。当前的场景下这个参数没啥用，不需要填充空节点。</li>
</ul>
<p>最后查看集群状态：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> --cluster</span><span style="color:#98C379"> check</span><span style="color:#98C379"> 宿主机IP:6381</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>集群中 3 个主机拥有的槽位数量大致均匀。</p>
<h1 id="4-Dockerfile"><a class="header-anchor" href="#4-Dockerfile"></a>4. Dockerfile</h1>
<h2 id="4-1-概述"><a class="header-anchor" href="#4-1-概述"></a>4.1 概述</h2>
<p>官方网站：<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/dockerfile/">Dockerfile reference | Docker Docs</a></p>
<p>Dockerfile 是用来构建 Docker 镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/Dockerfile.png" alt="Dockerfile"></p>
<p>构建三步骤：</p>
<ol>
<li>编写 Dockerfile 文件</li>
<li>使用 <code>docker build</code> 命令构建镜像</li>
<li>使用 <code>docker run</code> 命令运行容器实例</li>
</ol>
<h2 id="4-2-构建过程"><a class="header-anchor" href="#4-2-构建过程"></a>4.2 构建过程</h2>
<blockquote>
<p>Dockerfile 内容基础知识</p>
</blockquote>
<ul>
<li>每条保留字指令都 <strong>必须为大写字母</strong> 且后面要跟随至少一个参数</li>
<li>指令按照从上到下，顺序执行</li>
<li><code>#</code> 表示注释</li>
<li>每条指令都会创建一个新的镜像层并对镜像进行提交</li>
</ul>
<blockquote>
<p>Docker 执行 Dockerfile 的大致流程</p>
</blockquote>
<ol>
<li>Docker 从基础镜像运行一个容器</li>
<li>执行一条指令并对容器作出修改</li>
<li>执行类似 <code>docker commit</code> 的操作提交一个新的镜像层</li>
<li>Docker 再基于刚提交的镜像运行一个新容器</li>
<li>执行 Dockerfile 中的下一条指令直到所有指令都执行完成</li>
</ol>
<blockquote>
<p>小总结</p>
</blockquote>
<p>从应用软件的角度来看，Dockerfile、Docker 镜像与 Docker 容器分别代表软件的三个不同阶段：</p>
<ul>
<li>Dockerfile 是软件的原材料</li>
<li>Docker 镜像是软件的交付品</li>
<li>Docker 容器则是软件镜像的运行态，是依照镜像运行的容器实例</li>
</ul>
<p>Dockerfile 面向开发，Docker 镜像成为交付标准，Docker 容器涉及部署与运维，三者缺一不可，合力充当 Docker 体系的基石。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/Dockerfile%E6%80%BB%E7%BB%93.png" alt="Dockerfile总结"></p>
<ol>
<li>Dockerfile 定义了进程需要的一切东西。Dockerfile 涉及的内容包括执行代码、文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程（当应用进程需要和系统服务和内核进程打交道时，需要考虑如何设计 namespace 的权限控制）等等;</li>
<li>Docker 镜像，在用 Dockerfile 定义一个文件之后，执行 <code>docker build</code> 命令时会产生一个 Docker 镜像，运行 Docker 镜像时会真正开始提供服务；</li>
<li>Docker 容器是直接提供服务的。</li>
</ol>
<h2 id="4-3-Dockerfile-保留字"><a class="header-anchor" href="#4-3-Dockerfile-保留字"></a>4.3 Dockerfile 保留字</h2>
<p>参考 Tomcat 的 Dockerfile：<a target="_blank" rel="noopener" href="https://github.com/docker-library/tomcat">docker-library/tomcat</a></p>
<blockquote>
<p>FROM</p>
</blockquote>
<p>基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是 <code>From</code>。</p>
<blockquote>
<p>MAINTAINER</p>
</blockquote>
<p>镜像维护者的姓名和邮箱地址。</p>
<blockquote>
<p>RUN</p>
</blockquote>
<p>容器构建时需要运行的命令。</p>
<p>两种格式：</p>
<figure class="highlight dockerfile line-numbers" data-language="DOCKERFILE">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic"># shell 格式</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># RUN &lt;命令行命令&gt;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># &lt;命令行命令&gt; 等同于在终端操作的 shell 命令</span></span>
<span class="line"><span style="color:#61AFEF">RUN</span><span style="color:#ABB2BF"> yum -y install vim</span></span></code></pre></td></tr></tbody></table>
      </figure>
<figure class="highlight dockerfile line-numbers" data-language="DOCKERFILE">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic"># exec 格式</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 格式：RUN ["可执行文件", "参数1", "参数2"]</span></span>
<span class="line"><span style="color:#61AFEF">RUN</span><span style="color:#ABB2BF"> [</span><span style="color:#98C379">"./test.php"</span><span style="color:#ABB2BF">, </span><span style="color:#98C379">"dev"</span><span style="color:#ABB2BF">, </span><span style="color:#98C379">"offline"</span><span style="color:#ABB2BF">]  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 等价于 RUN ./test.php dev offline</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><code>RUN</code> 是在 <code>docker build</code> 时运行。</p>
<blockquote>
<p>EXPOSE</p>
</blockquote>
<p>当前容器对外暴露出的端口。</p>
<blockquote>
<p>WORKDIR</p>
</blockquote>
<p>一个落脚点。指定在创建容器后，终端默认登陆的进来工作目录。</p>
<blockquote>
<p>USER</p>
</blockquote>
<p>指定该镜像以什么样的用户去执行，如果都不指定，默认 <code>root</code>。</p>
<blockquote>
<p>ENV</p>
</blockquote>
<p>在构建镜像过程中设置环境变量。</p>
<p>比如：</p>
<figure class="highlight dockerfile line-numbers" data-language="DOCKERFILE">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">ENV</span><span style="color:#ABB2BF"> MY_PATH /usr/mytest</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>指定的 <code>MY_PATH</code> 环境变量可以在后续的任何 <code>RUN</code> 指令中使用，也可以在其他指令中直接使用这些环境变量，比如：</p>
<figure class="highlight dockerfile line-numbers" data-language="DOCKERFILE">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">WORKDIR</span><span style="color:#ABB2BF"> $MY_PATH</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>ADD</p>
</blockquote>
<p>将宿主机目录下的文件拷贝进镜像，并自动处理 URL 和解压 tar 压缩包。</p>
<blockquote>
<p>COPY</p>
</blockquote>
<p>类似 <code>ADD</code>，用于拷贝文件和目录到镜像中。</p>
<p>将构建上下文目录中 <code>&lt;源路径&gt; 的文件/目录</code> 复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。</p>
<p>与 <code>RUN</code> 类似，也有两种书写方式：</p>
<figure class="highlight dockerfile line-numbers" data-language="DOCKERFILE">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic"># 1. shell 格式</span></span>
<span class="line"><span style="color:#61AFEF">COPY</span><span style="color:#ABB2BF"> src dest</span></span></code></pre></td></tr></tbody></table>
      </figure>
<figure class="highlight dockerfile line-numbers" data-language="DOCKERFILE">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic"># 2. exec 格式</span></span>
<span class="line"><span style="color:#61AFEF">COPY</span><span style="color:#ABB2BF"> [</span><span style="color:#98C379">"src"</span><span style="color:#ABB2BF">, </span><span style="color:#98C379">"dest"</span><span style="color:#ABB2BF">]</span></span></code></pre></td></tr></tbody></table>
      </figure>
<ul>
<li><code>src</code> 表示源文件或源目录</li>
<li><code>dest</code> 表示容器内的指定路径，如果路径不存在，会自动创建</li>
</ul>
<blockquote>
<p>VOLUME</p>
</blockquote>
<p>容器数据卷，用于数据保存和持久化工作。</p>
<p>作用与 <code>docker run</code> 命令中的 <code>-v</code> 参数类型。</p>
<blockquote>
<p>CMD</p>
</blockquote>
<p>指定容器启动后要做的事。</p>
<p>与 <code>RUN</code> 类似，也有两种书写方式：</p>
<figure class="highlight dockerfile line-numbers" data-language="DOCKERFILE">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic"># 1. shell 格式</span></span>
<span class="line"><span style="color:#61AFEF">CMD</span><span style="color:#ABB2BF"> &lt;命令&gt;</span></span></code></pre></td></tr></tbody></table>
      </figure>
<figure class="highlight dockerfile line-numbers" data-language="DOCKERFILE">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic"># 2. exec 格式</span></span>
<span class="line"><span style="color:#61AFEF">CMD</span><span style="color:#ABB2BF"> [</span><span style="color:#98C379">"可执行文件"</span><span style="color:#ABB2BF">, </span><span style="color:#98C379">"参数1"</span><span style="color:#ABB2BF">, </span><span style="color:#98C379">"参数2"</span><span style="color:#ABB2BF">, ...]</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>Dockerfile 中可以有多个 <code>CMD</code> 指令，但是 <mark>只有最后一个生效，</mark> 并且最后一个 <code>CMD</code> 还会被 <code>docker run</code> 之后的参数替换。</p>
<p>以 Tomcat 的 Dockerfile 最后一行为例：</p>
<figure class="highlight dockerfile line-numbers" data-language="DOCKERFILE">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">CMD</span><span style="color:#ABB2BF"> [</span><span style="color:#98C379">"catalina.sh"</span><span style="color:#ABB2BF">, </span><span style="color:#98C379">"run"</span><span style="color:#ABB2BF">]</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>这表示在容器启动后运行 <code>catalina.sh</code> 文件。</p>
<p>在使用 tomcat 镜像创建容器实例时会使用以下命令：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> -p</span><span style="color:#98C379"> 8080:8080</span><span style="color:#98C379"> tomcat</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>命令执行后，访问 <code>8080</code> 端口能够看到「那只猫」：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/Tomcat%E6%88%91%E4%BB%AC%E8%B5%B0.png" alt="Tomcat我们走"></p>
<p>还记得使用 ubuntu 镜像创建容器实例的命令吗？</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -it</span><span style="color:#98C379"> ubuntu</span><span style="color:#98C379"> /bin/bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>该命令最后在 <code>ubuntu</code> 后追加了 <code>/bin/bash</code>，如果使用 tomcat 镜像创建容器实例时也追加 <code>/bin/bash</code> 呢？</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> -p</span><span style="color:#98C379"> 8080:8080</span><span style="color:#98C379"> tomcat</span><span style="color:#98C379"> /bin/bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>容器实例能够正常创建，但容器状态是 <code>Exited</code>，容器已经停止运行，访问 <code>8080</code> 端口自然也看不到「那只猫」。</p>
<p>这是因为 Dockerfile 最后的 <code>CMD ["catalina.sh", "run"]</code> 指令被 <code>/bin/bash</code> 替换，导致容器没有正常启动。</p>
<p><code>CMD</code> 与 <code>RUN</code> 的区别：</p>
<ul>
<li><code>CMD</code> 在 <code>docker run</code> 时运行</li>
<li><code>RUN</code> 在 <code>docker build</code> 时运行</li>
</ul>
<blockquote>
<p>ENTRYPOINT</p>
</blockquote>
<p><code>ENTRYPOINT</code> 也是用来指定容器启动时需要运行的命令，类似于 <code>CMD</code> 指令。</p>
<p>不同的是，<code>ENTRYPOINT</code> 不会被 <code>docker run</code> 命令后面的参数覆盖，并且这些命令行参数会被当作参数传递给 <code>ENTRYPOINT</code> 指令指定运行的程序。</p>
<p>指令格式：</p>
<figure class="highlight dockerfile line-numbers" data-language="DOCKERFILE">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">ENTRYPOINT</span><span style="color:#ABB2BF"> [</span><span style="color:#98C379">"&lt;executeable&gt;"</span><span style="color:#ABB2BF">, </span><span style="color:#98C379">"&lt;param1&gt;"</span><span style="color:#ABB2BF">, </span><span style="color:#98C379">"&lt;param2&gt;"</span><span style="color:#ABB2BF">, ...]</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><code>ENTRYPOINT</code> 可以和 <code>CMD</code> 一起使用。</p>
<p>当两者一起使用时，<code>CMD</code> 的含义就发生了变化，此时的 <code>CMD</code> 相当于在给 <code>ENTRYPOINT</code> 传参，而不是直接运行其命令。</p>
<p>假设已经通过 Dockerfile 构建了 <code>nginx:test</code> 镜像：</p>
<figure class="highlight dockerfile line-numbers" data-language="DOCKERFILE">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">FROM</span><span style="color:#ABB2BF"> nginx</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 定参</span></span>
<span class="line"><span style="color:#61AFEF">ENTRYPOINT</span><span style="color:#ABB2BF"> [</span><span style="color:#98C379">"nginx"</span><span style="color:#ABB2BF">, </span><span style="color:#98C379">"-c"</span><span style="color:#ABB2BF">]</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 变参</span></span>
<span class="line"><span style="color:#61AFEF">CMD</span><span style="color:#ABB2BF"> [</span><span style="color:#98C379">"/etc/nginx/nginx.conf"</span><span style="color:#ABB2BF">]</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>当执行 <code>docker run nginx:test</code> 后，在容器启动时，相当于又执行了：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">nginx</span><span style="color:#D19A66"> -c</span><span style="color:#98C379"> /etc/nginx/nginx.conf</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>而如果执行的是 <code>docker run nginx:test /etc/nginx/new.conf</code>，在容器启动时，相当于执行了：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">nginx</span><span style="color:#D19A66"> -c</span><span style="color:#98C379"> /etc/nginx/new.conf</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>这是因为 Dockerfile 中的 <code>CMD</code> 指令被 <code>docker run</code> 命令后的 <code>/etc/nginx/new.conf</code> 参数替换了。</p>
<p>综上，在执行 <code>docker run</code> 时可以指定 <code>ENTRYPOINT</code> 运行所需的参数。</p>
<p>但请注意，与 <code>CMD</code> 一样，如果 Dockerfile 中存在多个 <code>ENTRYPOINT</code> 指令，也是只有最后一个生效。</p>
<blockquote>
<p>小总结</p>
</blockquote>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/Dockerfile%E4%B8%80%E5%9B%BE%E6%B5%81.png" alt="Dockerfile一图流"></p>
<h2 id="4-4-案例演示"><a class="header-anchor" href="#4-4-案例演示"></a>4.4 案例演示</h2>
<blockquote>
<p>自定义镜像 <code>mycentosjava8</code></p>
</blockquote>
<p>拉取 centos7 镜像：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> pull</span><span style="color:#98C379"> centos:7</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>使用该镜像创建容器实例：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -it</span><span style="color:#98C379"> 镜像ID</span><span style="color:#98C379"> /bin/bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>尝试在容器中使用各种命令：</p>
<pre>[root@c0652f0b7533 /]# vim a.txt
bash: vim: command not found
[root@c0652f0b7533 /]# ifconfig
bash: ifconfig: command not found
[root@c0652f0b7533 /]# java -version
bash: java: command not found
</pre>
<p>根据运行结果可知，<code>vim</code>、<code>ifconfig</code> 和 <code>java</code> 在当前容器中都不存在。</p>
<p>现在需要在容器里安装这些组件，需要怎么做？</p>
<p>挨个执行 <code>yum</code> 命令进行安装，然后再用 <code>docker commit</code> 命令构建新镜像？</p>
<p>错误的！现在应该使用更「高级」的 Dockerfile 进行构建。</p>
<p>退出当前容器，在根目录下创建 <code>/myfile</code> 目录：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">mkdir</span><span style="color:#98C379"> /myfile</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>在该目录下下载 JDK8，记得下载的是后缀名为 <code>.tar.gz</code> 压缩包：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">wget</span><span style="color:#98C379"> 下载地址</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 例如：wget https://mirrors.yangxingzhen.com/jdk/jdk-8u221-linux-x64.tar.gz</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>可以参考的下载地址：</p>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/downloads/#java8">Java Downloads | Oracle</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://mirrors.yangxingzhen.com/jdk/">小柒博客 | 开源软件镜像站</a></p>
</li>
</ul>
<p>之后执行 <code>vim Dockerfile</code> 命令，开始编写 Dockerfile：</p>
<figure class="highlight dockerfile line-numbers" data-language="DOCKERFILE">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">FROM</span><span style="color:#ABB2BF"> centos:7</span></span>
<span class="line"><span style="color:#61AFEF">MAINTAINER</span><span style="color:#ABB2BF"> mofan&lt;example@example.com&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#61AFEF">ENV</span><span style="color:#ABB2BF"> MYPATH /usr/local</span></span>
<span class="line"><span style="color:#61AFEF">WORKDIR</span><span style="color:#ABB2BF"> $MYPATH</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># CentOS7 仓库已经被归档，当前镜像找不到所需的文件，需要额外配置阿里云镜像源</span></span>
<span class="line"><span style="color:#61AFEF">RUN</span><span style="color:#ABB2BF"> mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup &amp;&amp; \</span></span>
<span class="line"><span style="color:#ABB2BF">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo &amp;&amp; </span><span style="color:#D19A66">\ </span><span style="color:#ABB2BF">yum makecache</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 安装 vim 编辑器</span></span>
<span class="line"><span style="color:#61AFEF">RUN</span><span style="color:#ABB2BF"> yum -y install vim</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 安装 ifconfig 命令查看网络 IP</span></span>
<span class="line"><span style="color:#61AFEF">RUN</span><span style="color:#ABB2BF"> yum -y install net-tools</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 安装 java8 及 lib库</span></span>
<span class="line"><span style="color:#61AFEF">RUN</span><span style="color:#ABB2BF"> yum -y install glibc.i686</span></span>
<span class="line"><span style="color:#61AFEF">RUN</span><span style="color:#ABB2BF"> mkdir /usr/local/java</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># ADD 是相对路径 jar,把 jdk-8u171-linux-x64.tar.gz 添加到容器中，安装包必须要和 Dockerfile 文件在同一位置</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 注意，这里的 jdk 信息需要和前面下载的一致</span></span>
<span class="line"><span style="color:#61AFEF">ADD</span><span style="color:#ABB2BF"> jdk-8u221-linux-x64.tar.gz /usr/local/java/</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 配置 java 环境变量</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 注意修改后面的 jdk 文件名</span></span>
<span class="line"><span style="color:#61AFEF">ENV</span><span style="color:#ABB2BF"> JAVA_HOME /usr/local/java/jdk1.8.0_221</span></span>
<span class="line"><span style="color:#61AFEF">ENV</span><span style="color:#ABB2BF"> JRE_HOME $JAVA_HOME/jre</span></span>
<span class="line"><span style="color:#61AFEF">ENV</span><span style="color:#ABB2BF"> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</span></span>
<span class="line"><span style="color:#61AFEF">ENV</span><span style="color:#ABB2BF"> PATH $JAVA_HOME/bin:$PATH</span></span>
<span class="line"></span>
<span class="line"><span style="color:#61AFEF">EXPOSE</span><span style="color:#ABB2BF"> 80</span></span>
<span class="line"></span>
<span class="line"><span style="color:#61AFEF">CMD</span><span style="color:#ABB2BF"> echo $MYPATH</span></span>
<span class="line"><span style="color:#61AFEF">CMD</span><span style="color:#ABB2BF"> echo </span><span style="color:#98C379">"success--------------ok"</span></span>
<span class="line"><span style="color:#61AFEF">CMD</span><span style="color:#ABB2BF"> /bin/bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>变成完成后，使用 Dockerfile 构建 Docker 镜像：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic"># docker build -t 新镜像名字:TAG .</span></span>
<span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> build</span><span style="color:#D19A66"> -t</span><span style="color:#98C379"> mycentosjava8:1.0</span><span style="color:#98C379"> .</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><mark>注意：</mark> 定义的 <code>TAG</code> 后面有个空格，空格后面还有个 <code>.</code>。</p>
<p>等待镜像构建成功后，执行以下命令创建容器实例：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -it</span><span style="color:#98C379"> mycentosjava8:1.0</span><span style="color:#98C379"> /bin/bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>进入容器后，重新验证 <code>yum</code>、<code>ifconfig</code> 和 <code>java</code> 命令，如果无误，证明镜像构建成功。</p>
<h2 id="4-5-虚悬镜像"><a class="header-anchor" href="#4-5-虚悬镜像"></a>4.5 虚悬镜像</h2>
<p>虚悬镜像，即 dangling image，仓库名、标签都是 <code>&lt;none&gt;</code> 的镜像。</p>
<p>可以使用以下 Dockerfile 构建一个虚悬镜像：</p>
<figure class="highlight dockerfile line-numbers" data-language="DOCKERFILE">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">from</span><span style="color:#ABB2BF"> ubuntu</span></span>
<span class="line"><span style="color:#61AFEF">CMD</span><span style="color:#ABB2BF"> echo </span><span style="color:#98C379">'action is success'</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>基于 Dockerfile 构建镜像：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> build</span><span style="color:#98C379"> .</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>之后查看所有镜像：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> images</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>REPOSITORY                    TAG       IMAGE ID       CREATED        SIZE
mycentosjava8                 1.0       af6045743961   23 hours ago   1.41GB
&lt;none&gt;                        &lt;none&gt;    05e9a6757e02   3 years ago    72.8MB
</pre>
<p>可以看到存在一个 <code>REPOSITORY</code> 和 <code>TAG</code> 都是 <code>&lt;none&gt;</code> 的镜像。</p>
<p>可以单独使用以下命令查看虚悬镜像：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> image</span><span style="color:#98C379"> ls</span><span style="color:#D19A66"> -f</span><span style="color:#98C379"> dangling=</span><span style="color:#D19A66">true</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>针对虚悬镜像，应当尽快删除：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> image</span><span style="color:#98C379"> prune</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>[root@mofan test]# docker image prune
WARNING! This will remove all dangling images.
Are you sure you want to continue? [y/N]
</pre>
<p>键入 <code>y</code> 删除所有虚悬镜像。</p>
<h1 id="5-微服务实战"><a class="header-anchor" href="#5-微服务实战"></a>5. 微服务实战</h1>
<h2 id="5-1-搭建项目"><a class="header-anchor" href="#5-1-搭建项目"></a>5.1 搭建项目</h2>
<p><mark>注意：</mark> 本次搭建的项目将采用当前最新的 SpringBoot 3.4.3 与 JDK21。</p>
<p>本节的主要目的是获取项目打包后对应的 JAR 包，如果不了解 Java、SpringBoot、Maven 的基本操作，可以点击 <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1jdzVXY4fAmK4_rgwllDL2Q?pwd=dqtj">链接</a> 下载所需 JAR 包。</p>
<p>使用 IDEA 创建 SpringBoot 项目，<code>pom.xml</code> 内容如下：</p>
<figure class="highlight xml line-numbers" data-language="XML">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#ABB2BF">&lt;?</span><span style="color:#E06C75">xml</span><span style="color:#D19A66"> version</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">"1.0"</span><span style="color:#D19A66"> encoding</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">"UTF-8"</span><span style="color:#ABB2BF">?&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">&lt;</span><span style="color:#E06C75">project</span><span style="color:#D19A66"> xmlns</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">"http://maven.apache.org/POM/4.0.0"</span><span style="color:#D19A66"> xmlns:xsi</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="line"><span style="color:#D19A66">         xsi:schemaLocation</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">    &lt;</span><span style="color:#E06C75">modelVersion</span><span style="color:#ABB2BF">&gt;4.0.0&lt;/</span><span style="color:#E06C75">modelVersion</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">    &lt;</span><span style="color:#E06C75">parent</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">        &lt;</span><span style="color:#E06C75">groupId</span><span style="color:#ABB2BF">&gt;org.springframework.boot&lt;/</span><span style="color:#E06C75">groupId</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">        &lt;</span><span style="color:#E06C75">artifactId</span><span style="color:#ABB2BF">&gt;spring-boot-starter-parent&lt;/</span><span style="color:#E06C75">artifactId</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">        &lt;</span><span style="color:#E06C75">version</span><span style="color:#ABB2BF">&gt;3.4.3&lt;/</span><span style="color:#E06C75">version</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">        &lt;</span><span style="color:#E06C75">relativePath</span><span style="color:#ABB2BF">/&gt; </span><span style="color:#7F848E;font-style:italic">&lt;!-- lookup parent from repository --&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">    &lt;/</span><span style="color:#E06C75">parent</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">    &lt;</span><span style="color:#E06C75">groupId</span><span style="color:#ABB2BF">&gt;indi.mofan&lt;/</span><span style="color:#E06C75">groupId</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">    &lt;</span><span style="color:#E06C75">artifactId</span><span style="color:#ABB2BF">&gt;docker-boot&lt;/</span><span style="color:#E06C75">artifactId</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">    &lt;</span><span style="color:#E06C75">version</span><span style="color:#ABB2BF">&gt;0.0.1-SNAPSHOT&lt;/</span><span style="color:#E06C75">version</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">    &lt;</span><span style="color:#E06C75">name</span><span style="color:#ABB2BF">&gt;docker-boot&lt;/</span><span style="color:#E06C75">name</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">    &lt;</span><span style="color:#E06C75">properties</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">        &lt;</span><span style="color:#E06C75">java.version</span><span style="color:#ABB2BF">&gt;21&lt;/</span><span style="color:#E06C75">java.version</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">    &lt;/</span><span style="color:#E06C75">properties</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">    &lt;</span><span style="color:#E06C75">dependencies</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">        &lt;</span><span style="color:#E06C75">dependency</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">            &lt;</span><span style="color:#E06C75">groupId</span><span style="color:#ABB2BF">&gt;org.springframework.boot&lt;/</span><span style="color:#E06C75">groupId</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">            &lt;</span><span style="color:#E06C75">artifactId</span><span style="color:#ABB2BF">&gt;spring-boot-starter&lt;/</span><span style="color:#E06C75">artifactId</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">        &lt;/</span><span style="color:#E06C75">dependency</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">        &lt;</span><span style="color:#E06C75">dependency</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">            &lt;</span><span style="color:#E06C75">groupId</span><span style="color:#ABB2BF">&gt;org.springframework.boot&lt;/</span><span style="color:#E06C75">groupId</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">            &lt;</span><span style="color:#E06C75">artifactId</span><span style="color:#ABB2BF">&gt;spring-boot-starter-web&lt;/</span><span style="color:#E06C75">artifactId</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">        &lt;/</span><span style="color:#E06C75">dependency</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">    &lt;/</span><span style="color:#E06C75">dependencies</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF">    &lt;</span><span style="color:#E06C75">build</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">        &lt;</span><span style="color:#E06C75">plugins</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">            &lt;</span><span style="color:#E06C75">plugin</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">                &lt;</span><span style="color:#E06C75">groupId</span><span style="color:#ABB2BF">&gt;org.springframework.boot&lt;/</span><span style="color:#E06C75">groupId</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">                &lt;</span><span style="color:#E06C75">artifactId</span><span style="color:#ABB2BF">&gt;spring-boot-maven-plugin&lt;/</span><span style="color:#E06C75">artifactId</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">            &lt;/</span><span style="color:#E06C75">plugin</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">        &lt;/</span><span style="color:#E06C75">plugins</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"><span style="color:#ABB2BF">    &lt;/</span><span style="color:#E06C75">build</span><span style="color:#ABB2BF">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF">&lt;/</span><span style="color:#E06C75">project</span><span style="color:#ABB2BF">&gt;</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>修改配置文件 <code>application.properties</code>，指定服务端口为 <code>9999</code>：</p>
<figure class="highlight properties line-numbers" data-language="PROPERTIES">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#C678DD">server.port</span><span style="color:#ABB2BF">=</span><span style="color:#98C379">9999</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>SpringBoot 主启动类如下：</p>
<figure class="highlight java line-numbers" data-language="JAVA">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#ABB2BF">@</span><span style="color:#E5C07B">SpringBootApplication</span></span>
<span class="line"><span style="color:#C678DD">public</span><span style="color:#C678DD"> class</span><span style="color:#E5C07B"> DockerBootApplication</span><span style="color:#ABB2BF"> {</span></span>
<span class="line"><span style="color:#C678DD">    public</span><span style="color:#C678DD"> static</span><span style="color:#C678DD"> void</span><span style="color:#61AFEF"> main</span><span style="color:#ABB2BF">(</span><span style="color:#E5C07B">String</span><span style="color:#ABB2BF">[] </span><span style="color:#E06C75;font-style:italic">args</span><span style="color:#ABB2BF">)</span><span style="color:#ABB2BF"> {</span></span>
<span class="line"><span style="color:#E5C07B">        SpringApplication</span><span style="color:#ABB2BF">.</span><span style="color:#61AFEF">run</span><span style="color:#ABB2BF">(</span><span style="color:#E5C07B">DockerBootApplication</span><span style="color:#ABB2BF">.</span><span style="color:#E5C07B">class</span><span style="color:#ABB2BF">, args);</span></span>
<span class="line"><span style="color:#ABB2BF">    }</span></span>
<span class="line"><span style="color:#ABB2BF">}</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>一个简单的 Controller 层：</p>
<figure class="highlight java line-numbers" data-language="JAVA">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#ABB2BF">@</span><span style="color:#E5C07B">RestController</span></span>
<span class="line"><span style="color:#C678DD">public</span><span style="color:#C678DD"> class</span><span style="color:#E5C07B"> MyController</span><span style="color:#ABB2BF"> {</span></span>
<span class="line"><span style="color:#ABB2BF">    @</span><span style="color:#E5C07B">Value</span><span style="color:#E06C75">(</span><span style="color:#98C379">"${server.port}"</span><span style="color:#E06C75">)</span></span>
<span class="line"><span style="color:#C678DD">    private</span><span style="color:#E5C07B"> String</span><span style="color:#E06C75"> port</span><span style="color:#ABB2BF">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF">    @</span><span style="color:#E5C07B">GetMapping</span><span style="color:#E06C75">(</span><span style="color:#98C379">"/order/docker"</span><span style="color:#E06C75">)</span></span>
<span class="line"><span style="color:#C678DD">    public</span><span style="color:#E5C07B"> String</span><span style="color:#61AFEF"> helloDocker</span><span style="color:#ABB2BF">()</span><span style="color:#ABB2BF"> {</span></span>
<span class="line"><span style="color:#C678DD">        return</span><span style="color:#98C379"> "hello world: "</span><span style="color:#56B6C2"> +</span><span style="color:#ABB2BF"> port </span><span style="color:#56B6C2">+</span><span style="color:#98C379"> ", UUID: "</span><span style="color:#56B6C2"> +</span><span style="color:#E5C07B"> UUID</span><span style="color:#ABB2BF">.</span><span style="color:#61AFEF">randomUUID</span><span style="color:#ABB2BF">() </span><span style="color:#56B6C2">+</span><span style="color:#98C379"> "</span><span style="color:#56B6C2">\n</span><span style="color:#98C379">"</span><span style="color:#ABB2BF">;</span></span>
<span class="line"><span style="color:#ABB2BF">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF">    @</span><span style="color:#E5C07B">GetMapping</span><span style="color:#E06C75">(</span><span style="color:#D19A66">value</span><span style="color:#56B6C2"> =</span><span style="color:#98C379"> "/order/index"</span><span style="color:#E06C75">)</span></span>
<span class="line"><span style="color:#C678DD">    public</span><span style="color:#E5C07B"> String</span><span style="color:#61AFEF"> index</span><span style="color:#ABB2BF">()</span><span style="color:#ABB2BF"> {</span></span>
<span class="line"><span style="color:#C678DD">        return</span><span style="color:#98C379"> "服务端口号: "</span><span style="color:#56B6C2"> +</span><span style="color:#ABB2BF"> port </span><span style="color:#56B6C2">+</span><span style="color:#98C379"> ", UUID: "</span><span style="color:#56B6C2"> +</span><span style="color:#E5C07B"> UUID</span><span style="color:#ABB2BF">.</span><span style="color:#61AFEF">randomUUID</span><span style="color:#ABB2BF">() </span><span style="color:#56B6C2">+</span><span style="color:#98C379"> "</span><span style="color:#56B6C2">\n</span><span style="color:#98C379">"</span><span style="color:#ABB2BF">;</span></span>
<span class="line"><span style="color:#ABB2BF">    }</span></span>
<span class="line"><span style="color:#ABB2BF">}</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>使用 Maven 打包项目，在项目的 <code>target</code> 目录下得到名为 <code>docker-boot-0.0.1-SNAPSHOT.jar</code> 的 JAR 包。</p>
<h2 id="5-2-发布到容器"><a class="header-anchor" href="#5-2-发布到容器"></a>5.2 发布到容器</h2>
<p>先尝试拉取 <code>openjdk:21</code> 镜像：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> pull</span><span style="color:#98C379"> openjdk:21</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>配置的 Docker 镜像加速器可能对该镜像的支持较弱，可以在 <code>/etc/docker/daemon.json</code> 文件中追加以下镜像加速器地址：</p>
<figure class="highlight json line-numbers" data-language="JSON">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#ABB2BF">{</span></span>
<span class="line"><span style="color:#E06C75">    "registry-mirrors"</span><span style="color:#ABB2BF">: [</span></span>
<span class="line"><span style="color:#98C379">        "https://docker.1ms.run"</span><span style="color:#ABB2BF">,</span></span>
<span class="line"><span style="color:#98C379">        "https://docker.xuanyuan.me"</span></span>
<span class="line"><span style="color:#ABB2BF">    ]</span></span>
<span class="line"><span style="color:#ABB2BF">}</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>上述镜像加速器来源网址：<a target="_blank" rel="noopener" href="https://docker.xuanyuan.me/">轩辕镜像</a></p>
<p>执行以下命令，在根目录下创建 <code>mydocker</code> 目录：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">mkdir</span><span style="color:#98C379"> /mydocker</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>进入 <code>/mydocker</code> 目录：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#56B6C2">cd</span><span style="color:#98C379"> /mydocker</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>把前一节得到的 <code>docker-boot-0.0.1-SNAPSHOT.jar</code> 文件上传至该目录。</p>
<p>使用 <code>vim Dockerfile</code> 命令创建 Dockerfile 文件，并添加如下内容：</p>
<figure class="highlight dockerfile line-numbers" data-language="DOCKERFILE">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic"># 基础镜像使用 openjdk21</span></span>
<span class="line"><span style="color:#61AFEF">FROM</span><span style="color:#ABB2BF"> openjdk:21</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 作者</span></span>
<span class="line"><span style="color:#61AFEF">MAINTAINER</span><span style="color:#ABB2BF"> mofan</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span></span>
<span class="line"><span style="color:#61AFEF">VOLUME</span><span style="color:#ABB2BF"> /tmp</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 将 jar 包添加到容器中并更名</span></span>
<span class="line"><span style="color:#61AFEF">ADD</span><span style="color:#ABB2BF"> docker-boot-0.0.1-SNAPSHOT.jar mofan_docker.jar</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 运行 jar 包</span></span>
<span class="line"><span style="color:#61AFEF">RUN</span><span style="color:#ABB2BF"> bash -c </span><span style="color:#98C379">'touch /mofan_docker.jar'</span></span>
<span class="line"><span style="color:#61AFEF">ENTRYPOINT</span><span style="color:#ABB2BF"> [</span><span style="color:#98C379">"java"</span><span style="color:#ABB2BF">,</span><span style="color:#98C379">"-jar"</span><span style="color:#ABB2BF">,</span><span style="color:#98C379">"/mofan_docker.jar"</span><span style="color:#ABB2BF">]</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 暴露 9999 端口作为微服务</span></span>
<span class="line"><span style="color:#61AFEF">EXPOSE</span><span style="color:#ABB2BF"> 9999</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>构建 <code>mofan-docker:1.0</code> 镜像：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> build</span><span style="color:#D19A66"> -t</span><span style="color:#98C379"> mofan-docker:1.0</span><span style="color:#98C379"> .</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>使用新构建的 <code>mofan-docker:1.0</code> 镜像创建容器实例：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> -p</span><span style="color:#98C379"> 9999:9999</span><span style="color:#98C379"> mofan-docker:1.0</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>最后尝试能否成功访问对应接口：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">curl</span><span style="color:#98C379"> 127.0.0.1:9999/order/docker</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>[root@mofan mydocker]# curl 127.0.0.1:9999/order/docker
hello world: 9999, UUID: a6e8b395-20ae-424e-bb1a-54456128055d
</pre>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">curl</span><span style="color:#98C379"> 127.0.0.1:9999/order/index</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>[root@mofan mydocker]# curl 127.0.0.1:9999/order/index
服务端口号: 9999, UUID: f7682e19-c565-4d27-b983-b143e564f617
</pre>
<h1 id="6-Docker-网络"><a class="header-anchor" href="#6-Docker-网络"></a>6. Docker 网络</h1>
<h2 id="6-1-启动前后的网络"><a class="header-anchor" href="#6-1-启动前后的网络"></a>6.1 启动前后的网络</h2>
<p>在 <strong>首次</strong> 启动 Docker 服务前，使用 <code>ifconfig</code> 或 <code>ip addr</code> 查看网卡信息，可能出现：</p>
<ul>
<li>
<p><code>ens33</code> 或 <code>eth0</code>：本机网卡</p>
</li>
<li>
<p><code>lo</code>：本机回环网络网卡</p>
</li>
<li>
<p>如果使用的是虚拟机，还可能出现 <code>virbr0</code>。在 CentOS7 的安装过程中如果选择了相关虚拟化的服务（<code>libvirt</code> 服务），启动网卡时会发现有一个以网桥连接的私网地址的 <code>virbr0</code> 网卡，它有一个固定的 IP 地址 <code>192.168.122.1</code>，作为虚拟机网桥使用，为连接其上的虚机网卡提供 NAT 访问外网的功能。如果不需要可以直接将 <code>libvirt</code> 服务卸载，使用 <code>yum remove libvirt-libs.x86_64</code> 命令。</p>
</li>
</ul>
<p>使用 <code>systemctl start docker</code> 命令 <strong>首次</strong> 启动 Docker 服务后，就会多出 <code>docker0</code> 网卡：</p>
<ul>
<li>
<p>容器间的互联、通信以及端口映射</p>
</li>
<li>
<p>容器 IP 变动时候可以通过服务名进行网络通信</p>
</li>
</ul>
<p>Docker 容器的网络隔离是通过 Linux 内核特性 <code>namespace</code> 和 <code>cgroup</code> 实现的。</p>
<h2 id="6-2-网络命令"><a class="header-anchor" href="#6-2-网络命令"></a>6.2 网络命令</h2>
<blockquote>
<p>查看 Docker 网络模式</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> network</span><span style="color:#98C379"> ls</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>默认有以下 3 个网络模式：</p>
<pre>[root@mofan ~]# docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
2bb8b4f40c6a   bridge    bridge    local
56db994e8554   host      host      local
5ccc6a0ec3d0   none      null      local
</pre>
<p>当然，不同设备上的 <code>NETWORK ID</code> 会不一样。</p>
<p>可以看到其中有名为 <code>bridge</code> 的网络模式，即网桥模式。</p>
<p>桥接网络使用软件桥接，它允许连接到同一桥接网络的容器进行通信，同时提供与未连接到该桥接网络的容器的隔离。Docker 网桥驱动程序会自动在主机上安装规则，这样不同网桥网络上的容器就不能直接相互通信。</p>
<blockquote>
<p>网络命令帮助</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> network</span><span style="color:#D19A66"> --help</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>[root@mofan ~]# docker network --help<br>
Usage:  docker network COMMAND<br>
Manage networks<br>
Commands:
  connect     Connect a container to a network
  create      Create a network
  disconnect  Disconnect a container from a network
  inspect     Display detailed information on one or more networks
  ls          List networks
  prune       Remove all unused networks
  rm          Remove one or more networks<br>
Run 'docker network COMMAND --help' for more information on a command.
</pre>
<blockquote>
<p>更多命令</p>
</blockquote>
<p>添加网络：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> network</span><span style="color:#98C379"> add</span><span style="color:#98C379"> 网络名称</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>删除网络：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> network</span><span style="color:#98C379"> rm</span><span style="color:#98C379"> 网络名称</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>查看指定网络信息：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> network</span><span style="color:#98C379"> inspect</span><span style="color:#98C379"> 网络名称</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>删除所有无效的网络：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> network</span><span style="color:#98C379"> prune</span></span></code></pre></td></tr></tbody></table>
      </figure>
<h2 id="6-3-网络模式"><a class="header-anchor" href="#6-3-网络模式"></a>6.3 网络模式</h2>
<table>
<thead>
<tr>
<th style="text-align:center">网络模式</th>
<th style="text-align:center">简介</th>
<th style="text-align:center">使用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bridge</td>
<td style="text-align:center">为每一个容器分配、设置 IP 等，并将容器连接到一个 <code>docker0</code> 虚拟网桥，默认为该模式</td>
<td style="text-align:center"><code>--network bridge</code>，默认使用 <code>docker0</code></td>
</tr>
<tr>
<td style="text-align:center">host</td>
<td style="text-align:center">容器将不会虚拟出自己的网卡、配置自己的 IP 等，而是使用宿主机的 IP 和端口</td>
<td style="text-align:center"><code>--network host</code></td>
</tr>
<tr>
<td style="text-align:center">none</td>
<td style="text-align:center">容器有独立的 Network namespace，但并没有对齐进行任何网络设置，如分配 <code>veth pari</code> 和 网桥连接、IP 等</td>
<td style="text-align:center"><code>--network none</code></td>
</tr>
<tr>
<td style="text-align:center">container</td>
<td style="text-align:center">新创建的容器不会创建自己的网卡和配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等</td>
<td style="text-align:center"><code>--network container:NAME或者容器ID</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>容器实例内默认网络 IP 生成规则</p>
</blockquote>
<p>创建两个 ubuntu 容器实例：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -it</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> u1</span><span style="color:#98C379"> ubuntu</span><span style="color:#98C379"> bash</span></span>
<span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -it</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> u2</span><span style="color:#98C379"> ubuntu</span><span style="color:#98C379"> bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>查看容器运行情况：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> ps</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS          PORTS     NAMES
681e5033f136   ubuntu    "bash"    16 seconds ago   Up 15 seconds             u2
a66712ac8b88   ubuntu    "bash"    31 seconds ago   Up 30 seconds             u1
</pre>
<p>查看 <code>u1</code> 容器的网络信息：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> inspect</span><span style="color:#98C379"> u1</span><span style="color:#ABB2BF"> | </span><span style="color:#61AFEF">tail</span><span style="color:#D19A66"> -n</span><span style="color:#D19A66"> 21</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "MacAddress": "02:42:ac:11:00:02",
                    "NetworkID": "xxx",
                    "EndpointID": "xxx",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "DriverOpts": null,
                    "DNSNames": null
                }
            }
        }
    }
]
</pre>
<p>查看 <code>u1</code> 容器的网络信息：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> inspect</span><span style="color:#98C379"> u2</span><span style="color:#ABB2BF"> | </span><span style="color:#61AFEF">tail</span><span style="color:#D19A66"> -n</span><span style="color:#D19A66"> 21</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "MacAddress": "02:42:ac:11:00:03",
                    "NetworkID": "xxx",
                    "EndpointID": "xxx",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.3",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "DriverOpts": null,
                    "DNSNames": null
                }
            }
        }
    }
]
</pre>
<p><code>u1</code> 和 <code>u2</code> 的网络模式都是 bridge。</p>
<p><code>u1</code> 容器的 <code>IPAddress</code> 是 <code>172.17.0.2</code>，<code>u2</code> 容器的 <code>IPAddress</code> 是 <code>172.17.0.3</code>。</p>
<p>此时关闭 <code>u2</code> 容器实例，新建 <code>u3</code> 容器实例，再查看 <code>u3</code> 的网络信息：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> stop</span><span style="color:#98C379"> u2</span></span>
<span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -it</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> u3</span><span style="color:#98C379"> ubuntu</span><span style="color:#98C379"> bash</span></span>
<span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> inspect</span><span style="color:#98C379"> u3</span><span style="color:#ABB2BF"> | </span><span style="color:#61AFEF">tail</span><span style="color:#D19A66"> -n</span><span style="color:#D19A66"> 21</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><code>u3</code> 的 <code>IPAddress</code> 与先前关闭的 <code>u2</code> 一样，都是 <code>172.17.0.3</code>。</p>
<p>这说明，<strong>Docker 容器内部的 IP 是有可能会发生改变的。</strong></p>
<h2 id="6-4-docker0"><a class="header-anchor" href="#6-4-docker0"></a>6.4 docker0</h2>
<p>Docker 服务默认会创建一个 <code>docker0</code> 网桥（其上有一个 <code>docker0</code> 内部接口），该桥接网络的名称为 <code>docker0</code>，它在 <strong>内核层</strong> 连通了其他的物理或虚拟网卡，将所有容器和本地主机放到 <strong>同一个物理网络</strong>。</p>
<p>Docker 默认指定了 <code>docker0</code> 接口的 IP 地址和子网掩码，<strong>让主机和容器之间可以通过网桥互相通信</strong>。</p>
<p>查看 <code>bridge</code> 网络的详细信息，并通过 <code>grep</code> 获取名称：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> network</span><span style="color:#98C379"> inspect</span><span style="color:#98C379"> bridge</span><span style="color:#ABB2BF"> | </span><span style="color:#61AFEF">grep</span><span style="color:#98C379"> name</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 或者</span></span>
<span class="line"><span style="color:#61AFEF">ifconfig</span><span style="color:#ABB2BF"> | </span><span style="color:#61AFEF">grep</span><span style="color:#98C379"> docker</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>可以看到其名称为 <code>docker0</code>。</p>
<h2 id="6-5-bridge-模式"><a class="header-anchor" href="#6-5-bridge-模式"></a>6.5 bridge 模式</h2>
<p>Docker 使用 Linux 桥接，在宿主机虚拟一个 Docker 容器网桥（即 <code>docker0</code>），Docker 启动一个容器时会根据 <code>Docker</code> 网桥的网段分配给容器一个 IP 地址，称为 <code>Container-IP</code>，同时 Docker 网桥是每个容器的默认网关。在同一个宿主机内的容器接入同一个网桥后，容器之间能够通过容器的 <code>Container-IP</code> 直接通信。</p>
<p>执行 <code>docker run</code> 且没有指定 <code>--network</code> 时，默认使用的网桥模式就是 bridge，使用的是 <code>docker0</code>。在宿主机中使用 <code>ifconfig</code> 命令就可以看到 <code>docker0</code> 和自己创建的网络。</p>
<p>网桥 <code>docker0</code> 创建一对对等虚拟设备接口，一个叫 <code>veth</code>，另一个叫 <code>eth0</code>，它们成对匹配。</p>
<p>整个宿主机的网桥模式都是 <code>docker0</code>，类似一个交换机有一堆接口，每个接口叫 <code>veth</code>，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫做 <code>veth pair</code>）。</p>
<p>每个容器实例内部也有一块网卡，容器内的网卡接口叫做 <code>eth0</code>。</p>
<p><code>docker0</code> 上面的每个 <code>veth</code> 都会匹配某个容器实例内部的<code>eth0</code>。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/Docker%E7%BD%91%E7%BB%9Cbridge%E6%A8%A1%E5%BC%8F.webp" alt="Docker网络bridge模式"></p>
<blockquote>
<p>案例说明</p>
</blockquote>
<p>尝试创建两个 tomcat 容器实例：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> -p</span><span style="color:#98C379"> 8081:8080</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> tomcat1</span><span style="color:#98C379"> tomcat</span></span>
<span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> -p</span><span style="color:#98C379"> 8082:8080</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> tomcat2</span><span style="color:#98C379"> tomcat</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>先查看宿主机的 IP 信息：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">ip</span><span style="color:#98C379"> addr</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>存在以下两个网络信息：</p>
<pre>121: veth642ed91@if120:
123: veth3f66e1c@if122:
</pre>
<pre><code class="highlight mermaid">flowchart LR
subgraph docker0
    121:veth
    123:veth
end
121:veth --&gt; 120
123:veth --&gt; 122</code></pre>
<p>进入 <code>tomcat1</code> 容器实例内部：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> exec</span><span style="color:#D19A66"> -it</span><span style="color:#98C379"> tomcat1</span><span style="color:#98C379"> bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>然后使用 <code>ip addr</code> 查看 IP 信息。如果提示 <code>bash: ip: command not found</code>，就先安装 <code>iproute2</code> 包：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">apt-get</span><span style="color:#98C379"> update</span></span>
<span class="line"><span style="color:#61AFEF">apt-get</span><span style="color:#98C379"> install</span><span style="color:#D19A66"> -y</span><span style="color:#98C379"> iproute2</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>再次使用 <code>ip addr</code> 能够看到以下 IP 信息：</p>
<pre>120: eth0@if121:
</pre>
<pre><code class="highlight mermaid">flowchart LR
subgraph Container:tomcat1
    120:eth0
end
120:eth0 --&gt; 121</code></pre>
<p>再进入 <code>tomcat2</code> 容器实例内部：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> exec</span><span style="color:#D19A66"> -it</span><span style="color:#98C379"> tomcat2</span><span style="color:#98C379"> bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>再使用 <code>ip addr</code> 查看 <code>tomcat2</code> 容器的 IP 信息：</p>
<pre>122: eth0@if123:
</pre>
<pre><code class="highlight mermaid">flowchart LR
subgraph Container:tomcat2
    122:eth0
end
122:eth0 --&gt; 123</code></pre>
<p>可以看到，宿主机的网络信息和容器的网络信息两两匹配。</p>
<h2 id="6-6-host-模式"><a class="header-anchor" href="#6-6-host-模式"></a>6.6 host 模式</h2>
<p>host 模式将直接使用宿主机的 IP 地址与外界进行通信，不再额外进行 NAT 转换。</p>
<p>容器将不会获得一个独立的 Network namespace，而是和宿主机共用一个 Network space。</p>
<p>容器将不会虚拟出自己的网卡，而是直接使用宿主机的 IP 和端口。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/Docker%E7%BD%91%E7%BB%9Chost%E6%A8%A1%E5%BC%8F.webp" alt="Docker网络host模式"></p>
<blockquote>
<p>案例说明</p>
</blockquote>
<p>如果执行 <code>docker run</code> 命令时同时使用了 <code>--network host</code> 以采用 host 网络模式和 <code>-p</code> 指定端口映射，如：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> -p</span><span style="color:#98C379"> 8083:8080</span><span style="color:#D19A66"> --network</span><span style="color:#98C379"> host</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> tomcat3</span><span style="color:#98C379"> tomcat</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>此时容器实例依旧能够启动成功，但是会出现以下警告：</p>
<pre>WARNING: Published ports are discarded when using host network mode
</pre>
<p>这是因为使用 host 网络模式时，将直接使用的宿主机的 IP 和端口，<code>-p</code> 选项指定的端口映射没有任何作用，依旧以主机端口号为主，重复时递增。</p>
<p>解决方法是不使用 <code>-p</code> 选项，或者使用 Docker 的其他网络模式，例如 <code>--network bridge</code>，当然也可以不指定，默认就会使用 bridge 模式。</p>
<p>使用以下命令正确创建 <code>tomcat3</code> 容器实例：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> --network</span><span style="color:#98C379"> host</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> tomcat3</span><span style="color:#98C379"> tomcat</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>查看 <code>tomcat3</code> 容器的网络信息：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> inspect</span><span style="color:#98C379"> tomcat3</span><span style="color:#ABB2BF"> | </span><span style="color:#61AFEF">tail</span><span style="color:#D19A66"> -n</span><span style="color:#D19A66"> 21</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>            "Networks": {
                "host": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "MacAddress": "",
                    "NetworkID": "xxx",
                    "EndpointID": "xxx",
                    "Gateway": "",
                    "IPAddress": "",
                    "IPPrefixLen": 0,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "DriverOpts": null,
                    "DNSNames": null
                }
            }
        }
    }
]
</pre>
<p>可以看到，<code>tomcat3</code> 的网络模式是 host，并且 <code>Gateway</code> 和 <code>IPAddress</code> 信息都是空。</p>
<p>查看宿主机 IP 信息：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">ip</span><span style="color:#98C379"> addr</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>然后进入 <code>tomcat3</code> 容器内部：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> exec</span><span style="color:#D19A66"> -it</span><span style="color:#98C379"> tomcat3</span><span style="color:#98C379"> bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>使用 <code>ip addr</code> 查看容器的 IP 信息，可以发现，容器的 IP 信息与宿主机的 IP 信息一致。</p>
<p>使用 host 模式时，不再使用 <code>-p</code> 设置端口映射，此时容器的 IP 将借用宿主机的，使得外部主机可以直接与容器通信。如果要访问 <code>tomcat3</code> 容器内部的 Tomcat，需要使用 <code>宿主机IP:8080</code> 的形式进行访问。</p>
<h2 id="6-7-none-模式"><a class="header-anchor" href="#6-7-none-模式"></a>6.7 none 模式</h2>
<p>none 模式将禁用网络功能。</p>
<p>在 none 模式下，不为 Docker 容器进行任何网络配置，Docker 容器内没有网卡、IP、路由等信息，需要自行为 Docker 容器添加网卡、配置 IP 等。</p>
<p>进入容器内，使用 <code>ip addr</code> 查看 IP 信息，只能看到 <code>lo</code>（本地回环网络 <code>127.0.0.1</code>）。</p>
<p>使用以下命令创建使用 none 模式的容器实例：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> -p</span><span style="color:#98C379"> 8084:8080</span><span style="color:#D19A66"> --network</span><span style="color:#98C379"> none</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> tomcat4</span><span style="color:#98C379"> tomcat</span></span></code></pre></td></tr></tbody></table>
      </figure>
<h2 id="6-8-container-模式"><a class="header-anchor" href="#6-8-container-模式"></a>6.8 container 模式</h2>
<p>新建的容器和已经存在的一个容器共享网络 IP 配置，而不是和宿主机共享。</p>
<p>新创建的容器不会创建自己的网卡、配置自己的 IP，而是和一个指定的容器共享IP、端口范围等。两个容器除了网络共享，其他的如文件系统、进程列表依然是隔离的。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/Docker%E7%BD%91%E7%BB%9Ccontainer%E6%A8%A1%E5%BC%8F.webp" alt="Docker网络container模式"></p>
<blockquote>
<p>案例说明</p>
</blockquote>
<p>先创建 <code>tomcat5</code> 容器实例：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> -p</span><span style="color:#98C379"> 8085:8080</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> tomcat5</span><span style="color:#98C379"> tomcat</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>再创建 <code>tomcat6</code> 容器实例，并指定网络为 container 模式，沿用 <code>tomcat5</code> 的网络配置：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> -p</span><span style="color:#98C379"> 8086:8080</span><span style="color:#D19A66"> --network</span><span style="color:#98C379"> container:tomcat5</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> tomcat6</span><span style="color:#98C379"> tomcat</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>此时不出意外的话会出现意外，提示以下错误：</p>
<pre>docker: <font style="color:red">Error</font> response from daemon: conflicting options: port publishing and the container type network mode.
</pre>
<p>这相当于 <code>tomcat5</code> 和 <code>tomcat6</code> 共用了同一个 IP 和同一个端口，导致端口冲突，因此这里不适合使用 Tomcat 进行演示。</p>
<blockquote>
<p>正确的案例说明</p>
</blockquote>
<p>这里将使用 alpine 镜像进行演示。</p>
<p>Alpine Linux 是一款独立的、非商业的通用 Linux 发行版，专为追求安全性、简单性和资源效率的用户而设计。 可能很多人没听说过这个 Linux 发行版，但经常用 Docker 的朋友可能都用过，因为它以小、简单、安全而著称，所以作为基础镜像是非常好的一个选择，可谓是麻雀虽小但五脏俱全。其镜像十分小巧，不到 6M 的大小，特别适合容器打包。</p>
<p>运行以下命令，进入 <code>alpine1</code> 容器实例终端：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -it</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> alpine1</span><span style="color:#98C379"> alpine</span><span style="color:#98C379"> /bin/sh</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>再使用以下命令创建 <code>alpine2</code> 容器实例，使其沿用 <code>alpine1</code> 的网络配置：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -it</span><span style="color:#D19A66"> --network</span><span style="color:#98C379"> container:alpine1</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> alpine2</span><span style="color:#98C379"> alpine</span><span style="color:#98C379"> /bin/sh</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>分别使用 <code>ip addr</code> 查看两个容器的 IP 信息，可以发现，它们俩的 IP 信息都一样。</p>
<p>如果此时停止 <code>alpine1</code> 容器的运行，再次查看 <code>alpine2</code> 容器的 IP 信息，会发现其 <code>eth0</code> 网卡不见了。这是因为 <code>alpine2</code> 使用了 <code>alpine1</code> 的网络共享，当后者「下线」时，<code>alpine2</code> 的 <code>eth0</code> 网卡自然也就不见了。</p>
<h2 id="6-9-自定义网络模式"><a class="header-anchor" href="#6-9-自定义网络模式"></a>6.9 自定义网络模式</h2>
<p>Docker 容器内部的 IP 是有可能会发生变化的。</p>
<p>当容器的 IP 发生变化时，希望能够通过容器名进行通信，而不受到影响。</p>
<blockquote>
<p>不使用自定义网络</p>
</blockquote>
<p>使用以下命令创建 <code>tomcat1</code> 和 <code>tomcat2</code> 容器实例：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> -p</span><span style="color:#98C379"> 8081:8080</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> tomcat1</span><span style="color:#98C379"> tomcat</span></span>
<span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> -p</span><span style="color:#98C379"> 8082:8080</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> tomcat2</span><span style="color:#98C379"> tomcat</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>进入 <code>tomcat1</code> 容器内部：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> exec</span><span style="color:#D19A66"> -it</span><span style="color:#98C379"> tomcat1</span><span style="color:#98C379"> bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>使用 <code>ip addr</code> 查看其 IP 信息，其 <code>eth0</code> 下对应的 IP 是 <code>172.17.0.2</code>。</p>
<p>不退出 <code>tomcat1</code> 容器，再进入 <code>tomcat1</code> 容器内部：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> exec</span><span style="color:#D19A66"> -it</span><span style="color:#98C379"> tomcat2</span><span style="color:#98C379"> bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>查看 <code>tomcat2</code> 的 IP 信息，其 <code>eth0</code> 下对应的 IP 是 <code>172.17.0.3</code>。</p>
<p>回到 <code>tomcat1</code> 容器中，ping <code>tomcat2</code> 容器的 IP：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">ping</span><span style="color:#D19A66"> 172.17.0.3</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>能够成功 ping 通。</p>
<p>如果提示 <code>ping: command not found</code>，使用以下命令安装对应工具包：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">apt-get</span><span style="color:#98C379"> update</span></span>
<span class="line"><span style="color:#61AFEF">apt</span><span style="color:#98C379"> install</span><span style="color:#98C379"> iputils-ping</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>然后又去 <code>tomcat2</code> 中 ping <code>tocmat1</code>：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">ping</span><span style="color:#D19A66"> 172.17.0.2</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>也能够 ping 通。</p>
<p>如果换成服务名呢？比如：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">ping</span><span style="color:#98C379"> tomcat1</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># or</span></span>
<span class="line"><span style="color:#61AFEF">ping</span><span style="color:#98C379"> tomcat2</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>都将提示 <code>Name or service not known</code>。</p>
<p>这显然是不行的，Docker 容器的 IP 信息可能会变，只使用对应 IP 通信并不是一个好方案，能够使用服务名进行通信才是最好的。</p>
<blockquote>
<p>自定义网络模式</p>
</blockquote>
<p>默认 bridge 模式不支持直接使用容器名进行通信，可以新建一个自定义网络，它本身就维护好了主机名和 IP 的对应关系，使用自定义网络可以通过容器名进行通信。</p>
<p>新建的自定义网络默认使用的也是桥接网络。</p>
<p>首先删除原先的 tomcat 容器：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> rm</span><span style="color:#D19A66"> -f</span><span style="color:#ABB2BF"> $(</span><span style="color:#61AFEF">docker</span><span style="color:#98C379"> ps</span><span style="color:#D19A66"> -q</span><span style="color:#ABB2BF">)</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>新建自定义网络：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> network</span><span style="color:#98C379"> create</span><span style="color:#98C379"> mofan_network</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>查看网络列表：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> network</span><span style="color:#98C379"> ls</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>[root@mofan ~]# docker network ls
NETWORK ID     NAME            DRIVER    SCOPE
2bb8b4f40c6a   bridge          bridge    local
56db994e8554   host            host      local
8fd083e40a4a   mofan_network   bridge    local
5ccc6a0ec3d0   none            null      local
</pre>
<p>创建容器实例时，使用自定义网络：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> -p</span><span style="color:#98C379"> 8081:8080</span><span style="color:#D19A66"> --network</span><span style="color:#98C379"> mofan_network</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> tomcat1</span><span style="color:#98C379"> tomcat</span></span>
<span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> -p</span><span style="color:#98C379"> 8082:8080</span><span style="color:#D19A66"> --network</span><span style="color:#98C379"> mofan_network</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> tomcat2</span><span style="color:#98C379"> tomcat</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>之后再尝试利用容器名互相 ping：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">ping</span><span style="color:#98C379"> tomcat1</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># or</span></span>
<span class="line"><span style="color:#61AFEF">ping</span><span style="color:#98C379"> tomcat2</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>现在都能 ping 通了。</p>
<h1 id="7-Docker-Compose"><a class="header-anchor" href="#7-Docker-Compose"></a>7. Docker Compose</h1>
<h2 id="7-1-概述"><a class="header-anchor" href="#7-1-概述"></a>7.1 概述</h2>
<p>由于 Docker 本身占用资源极少，Docker 官方建议每个容器中只运行一个服务，将每个服务单独的分割开来。如果需要同时部署多个服务，单独构建镜像、容器就比较麻烦，因此 Docker 官方推出了 Docker Compose 来部署多服务。</p>
<p>比如要实现一个 Web 微服务项目，除了 Web 服务容器本身，还需要加上 MySQL、Redis 等一大批服务，此时单独部署就显得十分费劲。</p>
<p>Docker Compose 是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排，管理多个 Docker 容器组成一个应用。</p>
<p>定义一个 <code>compose.yaml</code> （新版写法，<code>docker-compose.yml</code> 是过去写法）配置文件，内部包含多个容器之间的调用关系，然后只需要一个命令就能同时启动或关闭这些容器。</p>
<h2 id="7-2-安装"><a class="header-anchor" href="#7-2-安装"></a>7.2 安装</h2>
<p>Docker Compose 安装文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/install/linux/#install-using-the-repository">Install using the repository</a></p>
<p>查看 Docker 版本：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> version</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>Version:           26.1.4
</pre>
<p>在当前版本中，安装 Docker Engine 时已经一并安装了 Docker Compose。</p>
<p>执行以下命令查看 Docker Compose 版本：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#98C379"> version</span></span></code></pre></td></tr></tbody></table>
      </figure>
<pre>[root@mofan ~]# docker compose version
Docker Compose version v2.27.1
</pre>
<h2 id="7-3-核心概念"><a class="header-anchor" href="#7-3-核心概念"></a>7.3 核心概念</h2>
<p>一文件，即 <code>compose.yaml</code>。</p>
<p>两要素：</p>
<ol>
<li>服务（<code>service</code>）：一个个应用容器实例</li>
<li>工程（<code>project</code>）：由一组关联的应用容器组成的一个 <strong>完整业务单元</strong>，在 <code>compose.yaml</code> 中定义</li>
</ol>
<h2 id="7-4-使用步骤"><a class="header-anchor" href="#7-4-使用步骤"></a>7.4 使用步骤</h2>
<ol>
<li>编写 Dockerfile 定义各个应用容器，并构建出对应的镜像文件；</li>
<li>编写 <code>compose.yaml</code>，定义一个完整的业务单元，安排好应用中的各个容器服务；</li>
<li>执行 <code>docker compose up</code> 命令，创建并运行整个应用程序，完成一键部署上线。</li>
</ol>
<h2 id="7-5-常用命令"><a class="header-anchor" href="#7-5-常用命令"></a>7.5 常用命令</h2>
<p>执行命令时，需要在 <code>compose.yaml</code> （<code>docker-compose.yaml</code> 或 <code>docker-compose.yml</code>）文件所在目录下执行。</p>
<p><mark>注意：</mark> 在最新的 Docker 中，Docker Compose 的命令不再是 <code>docker-compose</code>，不需要其中的连字号（Hyphen），而是使用 <code>docker compose</code>，甚至使用旧命令还会提示 <code>docker-compose: command not found</code>。</p>
<blockquote>
<p>查看帮助</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#D19A66"> -h</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>启动所有 Docker Compose 服务（类比 <code>docker run</code>）</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#98C379"> up</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 后台运行</span></span>
<span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#98C379"> up</span><span style="color:#D19A66"> -d</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>停止并删除容器、网络、卷、镜像（类比 <code>docker stop</code> +  <code>docker rm</code>）</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#98C379"> down</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>进入容器实例内部</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#98C379"> exec</span><span style="color:#ABB2BF"> &lt;</span><span style="color:#98C379">yml里面的服务i</span><span style="color:#ABB2BF">d&gt; </span><span style="color:#98C379">/bin/bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>展示当前 Docker Compose 编排过的运行的所有容器</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#98C379"> ps</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>展示当前 Docker Compose 编排过的容器进程</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#98C379"> top</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>查看容器输出日志</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#98C379"> log</span><span style="color:#ABB2BF"> &lt;</span><span style="color:#98C379">yml里面的服务i</span><span style="color:#ABB2BF">d&gt;</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>检查配置</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#98C379"> config</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 有问题才输出</span></span>
<span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#98C379"> config</span><span style="color:#D19A66"> -q</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>重启服务</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#98C379"> restart</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>启动服务</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#98C379"> start</span></span></code></pre></td></tr></tbody></table>
      </figure>
<blockquote>
<p>停止服务</p>
</blockquote>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#98C379"> stop</span></span></code></pre></td></tr></tbody></table>
      </figure>
<h2 id="7-6-编排微服务"><a class="header-anchor" href="#7-6-编排微服务"></a>7.6 编排微服务</h2>
<p>Compose file 官网：<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/compose-file/">Compose file reference</a></p>
<p>不必聚焦微服务项目代码的编写，只看 Docker Compose 的使用。</p>
<p><code>compose.yaml</code> 文件内容：</p>
<figure class="highlight yaml line-numbers" data-language="YAML">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic"># 文件版本号（已过时）</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># version: "3"</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 配置各个容器服务</span></span>
<span class="line"><span style="color:#E06C75">services</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">  # docker run -d -p 9999:9999 -v /app/microService:/data --network mofan_network --name ms01 mofan_docker:1.0</span></span>
<span class="line"><span style="color:#E06C75">  microService</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#E06C75">    image</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">mofan_docker:1.0</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">    # 容器名称，如果不指定，会生成一个服务名加上前缀的容器名</span></span>
<span class="line"><span style="color:#E06C75">    container_name</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">ms01</span><span style="color:#ABB2BF">  </span></span>
<span class="line"><span style="color:#E06C75">    ports</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">"9999:9999"</span></span>
<span class="line"><span style="color:#E06C75">    volumes</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">/app/microService:/data</span></span>
<span class="line"><span style="color:#E06C75">    networks</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">mofan_network</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">    # 配置该容器服务所依赖的容器服务  </span></span>
<span class="line"><span style="color:#E06C75">    depends_on</span><span style="color:#ABB2BF">:  </span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">redis</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">mysql</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E06C75">  redis</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#E06C75">    image</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">redis:6.0.8</span></span>
<span class="line"><span style="color:#E06C75">    ports</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">"6379:6379"</span></span>
<span class="line"><span style="color:#E06C75">    volumes</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">/app/redis/redis.conf:/etc/redis/redis.conf</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">/app/redis/data:data</span></span>
<span class="line"><span style="color:#E06C75">    networks</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">mofan_network</span></span>
<span class="line"><span style="color:#E06C75">    command</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">redis-server /etc/redis/redis.conf</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E06C75">  mysql</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#E06C75">    image</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">mysql:5.7</span></span>
<span class="line"><span style="color:#E06C75">    environment</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#E06C75">      MYSQL_ROOT_PASSWORD</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">'123456'</span></span>
<span class="line"><span style="color:#E06C75">      MYSQL_ALLOW_EMPTY_PASSWORD</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">'no'</span></span>
<span class="line"><span style="color:#E06C75">      MYSQL_DATABASE</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">'db01'</span></span>
<span class="line"><span style="color:#E06C75">      MYSQL_USER</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">'mofan'</span></span>
<span class="line"><span style="color:#E06C75">      MYSQL_PASSWORD</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">'mofan'</span></span>
<span class="line"><span style="color:#E06C75">    ports</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">"3306:3306"</span></span>
<span class="line"><span style="color:#E06C75">    volumes</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">/app/mysql/db:/var/lib/mysql</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">/app/mysql/conf/my.cnf:/etc/my.cnf</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">/app/mysql/init:/docker-entrypoint-initdb.d</span></span>
<span class="line"><span style="color:#E06C75">    networks</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">mofan_network</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">    # 解决外部无法访问</span></span>
<span class="line"><span style="color:#E06C75">    command</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">--default-authentication-plugin=mysql_native_password</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E06C75">networks</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">  # 创建 mofan_network 网络</span></span>
<span class="line"><span style="color:#E06C75">  mofan_network</span><span style="color:#ABB2BF">:</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>建议编写完 <code>compose.yaml</code> 文件后进行语法检查：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#98C379"> config</span><span style="color:#D19A66"> -q</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>如果没有输出错误，进行构建、启动：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#98C379"> up</span><span style="color:#D19A66"> -d</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><mark>注意：</mark> 在使用 Docker Compose 后，容器间的通信不再使用容器名，而是使用 <code>compose.yaml</code> 文件里指定的服务名。</p>
<p>本节的主要目标是熟悉 <code>compose.yaml</code> 文件的简单书写方式并打开思维，实际生产中多半会更加复杂，一切以官方文档为准。</p>
<h1 id="8-Portainer"><a class="header-anchor" href="#8-Portainer"></a>8. Portainer</h1>
<p>官网：<a target="_blank" rel="noopener" href="https://www.portainer.io/">Kubernetes and Docker Container Management Software</a></p>
<p>Portainer 是一款轻量级的应用，提供了图形化界面用于管理 Docker 环境，包括单机环境和集群环境。</p>
<p>Portainer 分为开源社区版（CE版）和商用版（BE版/EE版）。</p>
<blockquote>
<p>下载</p>
</blockquote>
<p>Portainer 也被制作成了一个 Docker 镜像，可以直接使用 Docker 运行：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> run</span><span style="color:#D19A66"> -d</span><span style="color:#D19A66"> -p</span><span style="color:#98C379"> 8000:8000</span><span style="color:#D19A66"> -p</span><span style="color:#98C379"> 9000:9000</span><span style="color:#D19A66"> --name</span><span style="color:#98C379"> portainer</span><span style="color:#D19A66"> --restart=always</span><span style="color:#D19A66"> -v</span><span style="color:#98C379"> /var/run/docker.sock:/var/run/docker.sock</span><span style="color:#D19A66"> -v</span><span style="color:#98C379"> portainer_data:/data</span><span style="color:#98C379"> portainer/portainer-ce:alpine</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>此处使用的镜像是 <code>portainer/portainer-ce:alpine</code>，相比于 <code>portainer/portainer-ce</code> 镜像体积更小，而 <code>portainer/portainer</code> 作为旧镜像名称，已被标记为过期。</p>
<p>命令中的 <code>--restart=always</code> 参数表示如果 Docker 引擎重启了，该容器实例也会在 Docker 引擎重启后重启，类似开机自启。</p>
<blockquote>
<p>访问页面</p>
</blockquote>
<p>安装成功后访问 <code>宿主机IP:9000</code> 进入 Portainer 首页，创建 <code>admin</code>。</p>
<p>如果使用的是云服务器，其中的宿主机 IP 就是云服务器的公网 IP，记得把 <code>9000</code> 端口添加到安全组，方便外网访问。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E9%A6%96%E6%AC%A1%E7%99%BB%E5%85%A5Portainer.png" alt="首次登入Portainer"></p>
<p><code>Username</code> 不动，设置 <code>Password</code>，值至少是 8 位字符，设置完毕后点击 Create user 登入。</p>
<p>首次登录后点击 <code>Local</code>，用于管理本地 Docker 环境：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/Portainer%E7%9A%84Home%E9%A1%B5.png" alt="Portainer的Home页"></p>
<p>选择 <code>local</code> 选项卡后展示本地 Docker 详细信息（相当于于 <code>docker system df</code> 命令）：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E6%9C%AC%E5%9C%B0Docker%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.png" alt="本地Docker详细信息"></p>
<p>其中的 <code>Stacks</code> 表示当前环境下有几个使用 Docker Compose 编排的容器应用。</p>
<blockquote>
<p>使用案例 —— 安装 Nginx</p>
</blockquote>
<p>创建 Nginx 容器实例：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/Add-container.png" alt="Add-container"></p>
<p>填写容器实例信息并部署：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E5%A1%AB%E5%86%99Nginx%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B%E4%BF%A1%E6%81%AF%E5%B9%B6%E9%83%A8%E7%BD%B2.png" alt="填写Nginx容器实例信息并部署"></p>
<p>等待部署完成后，按照与访问 Portainer 类似的方式，访问 <code>宿主机IP:80</code> 访问 Nginx 首页：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E8%AE%BF%E9%97%AEPortainer%E9%83%A8%E7%BD%B2%E7%9A%84Nginx%E9%A6%96%E9%A1%B5.png" alt="访问Portainer部署的Nginx首页"></p>
<h1 id="9-CIG-容器监控"><a class="header-anchor" href="#9-CIG-容器监控"></a>9. CIG 容器监控</h1>
<h2 id="9-1-背景"><a class="header-anchor" href="#9-1-背景"></a>9.1 背景</h2>
<p>可以使用以下命令查看 Docker 容器的运行状态：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> stats</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>注意命令是 <code>stats</code> 而不是 <code>status</code>。</p>
<p>该命令能够很方便地查看当前宿主机下上所有 CPU 的占用情况、内存使用以及网络流量等数据，但并没有地方存储、健康指标过线预警等功能。</p>
<p>此时可以使用 CIG 容器监控，即 CAdvisor（监控收集） + InfluxDB（存储数据） + Granfana（展示图表）。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/CIG.svg" alt="CIG"></p>
<h2 id="9-2-组成部分"><a class="header-anchor" href="#9-2-组成部分"></a>9.2 组成部分</h2>
<blockquote>
<p>CAdvisor</p>
</blockquote>
<p>CAdvisor 是一个容器资源监控工具，能够对容器的内存、CPU、网络 IO、磁盘 IO 等信息进行监控，同时提供了一个 Web 页面用于查看容器的实时运行状态。</p>
<p>CAdvisor 默认存储 2 分钟的数据，而且只是针对单物理机。不过 CAdvisor 提供了很多数据集成接口，支持  InfluxDB、Redis、Kafka、Elasticsearch 等集成，可以添加对应配置将监控数据发往到这些数据库存储起来。</p>
<p>CAdvisor 主要功能有两点：</p>
<ol>
<li>展示 Host 和容器两个层次的监控数据</li>
<li>展示历史变化数据</li>
</ol>
<blockquote>
<p>InfluxDB</p>
</blockquote>
<p>InfluxDB 是用 Go 语言（已用 Rust 语言改写）编写的一个开源分布式时序、事件和指标数据库，无需外部依赖。</p>
<p>由于 CAdvisor 默认只在本机保存 2 分钟的数据，为了持久化存储数据和统一收集展示监控数据，就可以将数据存储到 InfluxDB 中。InfluxDB 是一个时序数据库，专门用于存储时序相关数据，很适合存储 CAdvisor 的数据。</p>
<p>CAdvisor 本身已经提供了集成 InfluxDB 的方法，在启动容器时指定配置即可。</p>
<p>InfluxDB 主要功能：</p>
<ul>
<li>
<p>基于时间序列，支持与时间有关的相关函数（如最大、最小、求和等）</p>
</li>
<li>
<p>可度量性，可以实时对大量数据进行计算</p>
</li>
<li>
<p>基于事件，支持任意的事件数据</p>
</li>
</ul>
<blockquote>
<p>Granfana</p>
</blockquote>
<p>Grafana 是一个开源的数据监控分析可视化平台，支持多种数据源配置（包括 InfluxDB、MySQL、Elasticsearch、OpenTSDB、Graphite 等）和丰富的插件及模板功能，支持图表权限控制和报警。</p>
<p>Granfana 主要功能：</p>
<ul>
<li>
<p>灵活丰富的图形化选项</p>
</li>
<li>
<p>可以混合多种风格</p>
</li>
<li>
<p>支持白天和夜间模式</p>
</li>
<li>
<p>多数据源</p>
</li>
</ul>
<h2 id="9-3-安装部署"><a class="header-anchor" href="#9-3-安装部署"></a>9.3 安装部署</h2>
<p>新建 <code>/mydocker/cig</code> 目录：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">mkdir</span><span style="color:#98C379"> /mydocker/cig</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>进入 <code>cig</code> 目录：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#56B6C2">cd</span><span style="color:#98C379"> /mydocker/cig</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>在该目录下编写 <code>compose.yaml</code>，使用 Docker Compose 一套带走。</p>
<p>截止本文首次发布时，CAdvisor 并不支持最新的 InfluxDB V2，见 <a target="_blank" rel="noopener" href="https://github.com/google/cadvisor/issues/2843">Issue #2843 · google/cadvisor</a>，因此务必保证使用的镜像版本与下文一致，以免出现各种问题。</p>
<figure class="highlight yaml line-numbers" data-language="YAML">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#E06C75">services</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#E06C75">  influxdb</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#E06C75">    image</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">tutum/influxdb:latest</span></span>
<span class="line"><span style="color:#E06C75">    restart</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">always</span></span>
<span class="line"><span style="color:#E06C75">    environment</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">PRE_CREATE_DB=cadvisor</span></span>
<span class="line"><span style="color:#E06C75">    ports</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">      # 数据库web可视化页面端口</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">"8083:8083"</span><span style="color:#ABB2BF">      </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">      # 数据库端口</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">"8086:8086"</span><span style="color:#ABB2BF">        </span></span>
<span class="line"><span style="color:#E06C75">    volumes</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">./data/influxdb:/data</span></span>
<span class="line"><span style="color:#E06C75">    networks</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">monitoring</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E06C75">  cadvisor</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#E06C75">    image</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">google/cadvisor:v0.32.0</span></span>
<span class="line"><span style="color:#E06C75">    command</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">-storage_driver=influxdb</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">-storage_driver_db=cadvisor</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">-storage_driver_host=influxdb:8086</span></span>
<span class="line"><span style="color:#E06C75">    restart</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">always</span></span>
<span class="line"><span style="color:#E06C75">    privileged</span><span style="color:#ABB2BF">: </span><span style="color:#D19A66">true</span></span>
<span class="line"><span style="color:#E06C75">    ports</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">"8080:8080"</span></span>
<span class="line"><span style="color:#E06C75">    volumes</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">/:/rootfs:ro</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">/var/run:/var/run:rw</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">/sys:/sys:ro</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">/var/lib/docker/:/var/lib/docker:ro</span></span>
<span class="line"><span style="color:#E06C75">    networks</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">monitoring</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">    # 显式声明启动顺序依赖  </span></span>
<span class="line"><span style="color:#E06C75">    depends_on</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">influxdb</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E06C75">  grafana</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#E06C75">    image</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">grafana/grafana:8.5.2</span></span>
<span class="line"><span style="color:#E06C75">    user</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">'104'</span></span>
<span class="line"><span style="color:#E06C75">    restart</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">always</span></span>
<span class="line"><span style="color:#E06C75">    ports</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">"3000:3000"</span></span>
<span class="line"><span style="color:#E06C75">    volumes</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic">      # 注意，grafana_data 前不能有 /，添加后会导致容器一直处于 Restarting</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">grafana_data:/var/lib/grafana</span></span>
<span class="line"><span style="color:#E06C75">    environment</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">HTTP_USER=admin</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">HTTP_PASS=admin</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">INFLUXDB_HOST=influxdb</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">INFLUXDB_PORT=8086</span></span>
<span class="line"><span style="color:#E06C75">    networks</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">monitoring</span></span>
<span class="line"><span style="color:#E06C75">    depends_on</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#ABB2BF">      - </span><span style="color:#98C379">influxdb</span></span>
<span class="line"><span style="color:#ABB2BF">      </span></span>
<span class="line"><span style="color:#E06C75">volumes</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#E06C75">  grafana_data</span><span style="color:#ABB2BF">: {}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic"># 显式定义自定义网络</span></span>
<span class="line"><span style="color:#E06C75">networks</span><span style="color:#ABB2BF">:  </span></span>
<span class="line"><span style="color:#E06C75">  monitoring</span><span style="color:#ABB2BF">:</span></span>
<span class="line"><span style="color:#E06C75">    driver</span><span style="color:#ABB2BF">: </span><span style="color:#98C379">bridge</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>检查 <code>compose.yaml</code> 文件的正确性：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#98C379"> config</span><span style="color:#D19A66"> -q</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>创建并运行容器：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> compose</span><span style="color:#98C379"> up</span><span style="color:#D19A66"> -d</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>查看三个容器是否启动成功：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">docker</span><span style="color:#98C379"> ps</span></span></code></pre></td></tr></tbody></table>
      </figure>
<h2 id="9-4-配置-Grafana"><a class="header-anchor" href="#9-4-配置-Grafana"></a>9.4 配置 Grafana</h2>
<p>在浏览器中以 <code>宿主机IP:3000</code> 的方式访问 Grafana，默认用户名和密码都是 <code>admin</code>。</p>
<p>如果使用的是云服务器，其中的宿主机 IP 就是云服务器的公网 IP，记得把 <code>3000</code> 端口添加到安全组，方便外网访问。</p>
<p>首次进入登录页时可能比较慢，请耐心等待。</p>
<p>登录成功后，进行数据源配置：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E9%85%8D%E7%BD%AEGrafana%E6%95%B0%E6%8D%AE%E6%BA%90.png" alt="配置Grafana数据源"></p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E6%B7%BB%E5%8A%A0Grafana%E6%95%B0%E6%8D%AE%E6%BA%90.png" alt="添加Grafana数据源"></p>
<p>搜索 <code>InfluxDB</code>，选择 InfluxDB 作为数据源：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E9%80%89%E6%8B%A9InfluxDB%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90.png" alt="选择InfluxDB作为数据源"></p>
<p>点击 Select 后配置 InfluxDB 数据源：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/Grafana%E9%85%8D%E7%BD%AEInfluxDB%E6%95%B0%E6%8D%AE%E6%BA%90-1.png" alt="Grafana配置InfluxDB数据源-1"></p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/Grafana%E9%85%8D%E7%BD%AEInfluxDB%E6%95%B0%E6%8D%AE%E6%BA%90-2.png" alt="Grafana配置InfluxDB数据源-2"></p>
<p>如果出现上图中的提示，证明 InfluxDB 数据源配置成功。</p>
<p>接下来创建 Dashboard：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E6%96%B0%E5%BB%BAGrafana%E7%9A%84Dashboard.png" alt="新建Grafana的Dashboard"></p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/Add-a-new-panel.png" alt="Add-a-new-panel"></p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/CloudNativeImages/%E5%AE%8C%E6%88%90cig01-Dashboard%E9%85%8D%E7%BD%AE.png" alt="完成cig01-Dashboard配置"></p>
</body></html></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mofan212.github.io">默烦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mofan212.github.io/posts/Docker-Advanced/">https://mofan212.github.io/posts/Docker-Advanced/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://mofan212.github.io" target="_blank">Mofan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post-share"><div class="social-share" data-image="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/158.png" data-sites="wechat,qq,weibo,facebook,x"></div><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" target="_blank"><img class="post-qr-code-img" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" target="_blank"><img class="post-qr-code-img" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/Docker-Basics/" title="Docker 基础篇"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/157.png" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Docker 基础篇</div></div><div class="info-2"><div class="info-item-1">Develop faster. Run anywhere.</div></div></div></a><a class="pagination-related" href="/posts/Java-Lambda-In-Action/" title="Java Lambda In Action"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/159.png" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java Lambda In Action</div></div><div class="info-2"><div class="info-item-1">讲解不一样的 Lambda 表达式用法，希望能给你带来一些启发。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/Docker-Desktop/" title="Docker Desktop"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/164.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-26</div><div class="info-item-2">Docker Desktop</div></div><div class="info-2"><div class="info-item-1">开发者和团队首选的容器化软件，利用 Docker Desktop 的容器工具简化开发过程。</div></div></div></a><a class="pagination-related" href="/posts/Docker-Basics/" title="Docker 基础篇"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/157.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-15</div><div class="info-item-2">Docker 基础篇</div></div><div class="info-2"><div class="info-item-1">Develop faster. Run anywhere.</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">默烦</div><div class="author-info-description">彩笔的打怪升级之路...</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">174</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mofan212"><i class="fab fa-github"></i><span>follow me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:cy.mofan@foxmail.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站所有博文均是博主的学习笔记与个人理解。<strong><font style="color:red">除特别注明外，</font>如需转载，请在文章头部醒目处附带原文链接并<a href="./mine/" style="color:#49B1F5;text-decoration:underline">告知我</a></strong>你将转载。😊</br><strong><font style="color:red">严禁未遵循规范的转载。</font></strong>😡</br><strong>死去的评论系统复活啦！欢迎到留言板畅所欲言！</strong>当然也可以使用更高效的<a target="_blank" href="https://space.bilibili.com/23658864/dynamic" style="color:#49B1F5;text-decoration:underline"> 哔哩哔哩私信 </a>或<a href="mailto:cy.mofan@foxmail.com" style="color:#49B1F5;text-decoration:underline" target="_blank">邮箱</a>。 😉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%AE%89%E8%A3%85-MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">1. 安装 MySQL 主从复制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-text">2. 分布式数据分区算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%93%88%E5%B8%8C%E5%8F%96%E4%BD%99%E7%AE%97%E6%B3%95"><span class="toc-text">2.1 哈希取余算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-text">2.2 一致性哈希算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%93%88%E5%B8%8C%E6%A7%BD%E7%AE%97%E6%B3%95"><span class="toc-text">2.3 哈希槽算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%AE%89%E8%A3%85-Redis-%E9%9B%86%E7%BE%A4"><span class="toc-text">3. 安装 Redis 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%B8%89%E4%B8%BB%E4%B8%89%E4%BB%8E-Redis-%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE"><span class="toc-text">3.1 三主三从 Redis 集群配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%B8%BB%E4%BB%8E%E5%AE%B9%E9%94%99%E5%88%87%E6%8D%A2%E8%BF%81%E7%A7%BB"><span class="toc-text">3.2 主从容错切换迁移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E4%B8%BB%E4%BB%8E%E5%AE%B9%E9%94%99%E5%88%87%E6%8D%A2%E8%BF%81%E7%A7%BB"><span class="toc-text">3.3 主从容错切换迁移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E4%B8%BB%E4%BB%8E%E6%89%A9%E5%AE%B9"><span class="toc-text">3.4 主从扩容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E4%B8%BB%E4%BB%8E%E7%BC%A9%E5%AE%B9"><span class="toc-text">3.5 主从缩容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Dockerfile"><span class="toc-text">4. Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">4.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">4.2 构建过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Dockerfile-%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-text">4.3 Dockerfile 保留字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-text">4.4 案例演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E8%99%9A%E6%82%AC%E9%95%9C%E5%83%8F"><span class="toc-text">4.5 虚悬镜像</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98"><span class="toc-text">5. 微服务实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-text">5.1 搭建项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%8F%91%E5%B8%83%E5%88%B0%E5%AE%B9%E5%99%A8"><span class="toc-text">5.2 发布到容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Docker-%E7%BD%91%E7%BB%9C"><span class="toc-text">6. Docker 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%90%AF%E5%8A%A8%E5%89%8D%E5%90%8E%E7%9A%84%E7%BD%91%E7%BB%9C"><span class="toc-text">6.1 启动前后的网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">6.2 网络命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">6.3 网络模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-docker0"><span class="toc-text">6.4 docker0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-bridge-%E6%A8%A1%E5%BC%8F"><span class="toc-text">6.5 bridge 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-host-%E6%A8%A1%E5%BC%8F"><span class="toc-text">6.6 host 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-none-%E6%A8%A1%E5%BC%8F"><span class="toc-text">6.7 none 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-container-%E6%A8%A1%E5%BC%8F"><span class="toc-text">6.8 container 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">6.9 自定义网络模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Docker-Compose"><span class="toc-text">7. Docker Compose</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">7.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E5%AE%89%E8%A3%85"><span class="toc-text">7.2 安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">7.3 核心概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-text">7.4 使用步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">7.5 常用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E7%BC%96%E6%8E%92%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-text">7.6 编排微服务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Portainer"><span class="toc-text">8. Portainer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-CIG-%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7"><span class="toc-text">9. CIG 容器监控</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E8%83%8C%E6%99%AF"><span class="toc-text">9.1 背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">9.2 组成部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2"><span class="toc-text">9.3 安装部署</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E9%85%8D%E7%BD%AE-Grafana"><span class="toc-text">9.4 配置 Grafana</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Git/" title="Git理论与使用"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/3.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Git理论与使用"/></a><div class="content"><a class="title" href="/posts/Git/" title="Git理论与使用">Git理论与使用</a><time datetime="2026-01-26T16:00:00.000Z" title="更新于 2026-01-27 00:00:00">2026-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Something-About-Blog/" title="博客搭建与维护"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/42.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="博客搭建与维护"/></a><div class="content"><a class="title" href="/posts/Something-About-Blog/" title="博客搭建与维护">博客搭建与维护</a><time datetime="2026-01-24T16:00:00.000Z" title="更新于 2026-01-25 00:00:00">2026-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Memory-Model/" title="Java 内存模型"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/174.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Java 内存模型"/></a><div class="content"><a class="title" href="/posts/Java-Memory-Model/" title="Java 内存模型">Java 内存模型</a><time datetime="2026-01-02T16:00:00.000Z" title="更新于 2026-01-03 00:00:00">2026-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Bytecode-And-Class-Loading/" title="字节码与类加载"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/173.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="字节码与类加载"/></a><div class="content"><a class="title" href="/posts/Java-Bytecode-And-Class-Loading/" title="字节码与类加载">字节码与类加载</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Class-Resource-Loading-In-Java/" title="Java 的类资源加载"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/103.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Java 的类资源加载"/></a><div class="content"><a class="title" href="/posts/Class-Resource-Loading-In-Java/" title="Java 的类资源加载">Java 的类资源加载</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Annotation-And-Reflection/" title="注解、类的加载、反射"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/20.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="注解、类的加载、反射"/></a><div class="content"><a class="title" href="/posts/Annotation-And-Reflection/" title="注解、类的加载、反射">注解、类的加载、反射</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2020 - 2026 By 默烦</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://testingcf.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://testingcf.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://testingcf.jsdelivr.net/npm/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://testingcf.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://testingcf.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://testingcf.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://gcore.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources@master/js/mine.min.js"></script><script src="/js/tip_portal.js"></script><script defer="defer" id="ribbon" src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-show-text" src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Azathoth,Yog-Sothoth,Shub-Niggurath,Nyarlathotep,Cthulhu,Hastur,Abhoth,Ghroth,Tsathoggua,Cthugha,Deep Ones,Dagon,Chaugnar Faugn,Mordiggian,Shoggoth,Old One,Mi-Go,Great Race of Yith,Flying Polyp,Hounds of Tindalos,Dhole" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://testingcf.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'BAFEL7A6K1',
    apiKey: '89fcb5961984c5c054bf04149f345f38',
    indexName: 'mofan212io',
    container: '#docsearch',
    placeholder: '输入关键字进行搜索',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>
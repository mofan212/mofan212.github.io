<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【MySQL 高级篇七】InnoDB 的数据存储结构 | Mofan</title><meta name="author" content="默烦,cy.mofan@foxmail.com"><meta name="copyright" content="默烦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文介绍了 MySQL 中 InnoDB 存储引擎的数据存储结构，包括页的内部结构、行格式等。">
<meta property="og:type" content="article">
<meta property="og:title" content="【MySQL 高级篇七】InnoDB 的数据存储结构">
<meta property="og:url" content="https://mofan212.github.io/posts/MySQL-Advanced-Seventh-Data-Storage-Structure-Of-InnoDB/">
<meta property="og:site_name" content="Mofan">
<meta property="og:description" content="本文介绍了 MySQL 中 InnoDB 存储引擎的数据存储结构，包括页的内部结构、行格式等。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/146.jpg">
<meta property="article:published_time" content="2024-01-13T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-13T16:00:00.000Z">
<meta property="article:author" content="默烦">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/146.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【MySQL 高级篇七】InnoDB 的数据存储结构",
  "url": "https://mofan212.github.io/posts/MySQL-Advanced-Seventh-Data-Storage-Structure-Of-InnoDB/",
  "image": "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/146.jpg",
  "datePublished": "2024-01-13T16:00:00.000Z",
  "dateModified": "2024-01-13T16:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "默烦",
      "url": "https://mofan212.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/favicon.png"><link rel="canonical" href="https://mofan212.github.io/posts/MySQL-Advanced-Seventh-Data-Storage-Structure-Of-InnoDB/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 默烦","link":"链接: ","source":"来源: Mofan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://testingcf.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【MySQL 高级篇七】InnoDB 的数据存储结构',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><link rel="stylesheet" href="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources@master/css/myStyle.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css" /><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" /><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Mofan" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources/css/minimal.min.css"/><script src="https://testingcf.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">174</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/reward/"><i class="fa-fw fa-solid fa-coins"></i><span> 赞助</span></a></li><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/post_top_img.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Mofan</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/reward/"><i class="fa-fw fa-solid fa-coins"></i><span> 赞助</span></a></li><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【MySQL 高级篇七】InnoDB 的数据存储结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-13T16:00:00.000Z" title="发表于 2024-01-14 00:00:00">2024-01-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-13T16:00:00.000Z" title="更新于 2024-01-14 00:00:00">2024-01-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;距离本文上次更新已经过去&quot;,&quot;messageNext&quot;:&quot;天，请注意时效性。&quot;,&quot;postUpdate&quot;:&quot;2024-01-14 00:00:00&quot;}" hidden></div><p>封面来源：由博主个人绘制，如需使用请联系博主。</p>
<p>本文参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iq4y1u7vj/?p=121">MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！</a></p>
<h1 id="1-数据库的存储结构"><a class="header-anchor" href="#1-数据库的存储结构"></a>1. 数据库的存储结构</h1>
<p>索引结构提供了高效的索引方式，索引信息和数据记录都是保存在文件上的，确切说是存储在页结构中的。</p>
<p>索引是在存储引擎中实现的，不同存储引擎中存放的格式一般是不同的，甚至有的存储引警比如 Memory 甚至都不用磁盘来存储数据。</p>
<p>由于 InnoDB 是 MySQL 的默认存储引擎，所以本章剖析 InnoDB 存储引擎的数据存储结构。</p>
<h2 id="1-1-磁盘与内存交互的基本单位"><a class="header-anchor" href="#1-1-磁盘与内存交互的基本单位"></a>1.1 磁盘与内存交互的基本单位</h2>
<p>页是磁盘与内存交互的基本单位。</p>
<p>InnoDB 将数据划分为若干个页，InnoDB 中页的大小默认为 16KB。</p>
<p>以页作为磁盘和内存之间交互的基本单位，也就是一次至少从磁盘中读取 16KB 大小的内容到内存中，或者一次至少把内存中 16KB 的内容刷新到磁盘中。使用 InnoDB 不论读一行，还是读多行，都会加载这些行所在的页。</p>
<p>记录是按行来存储的，但读取并不以行为单位，否则一次读取（一次 IO 操作）只能处理一行数据，效率非常低。</p>
<p>使用 InnoDB 管理存储空间的基本单位是页（Page），数据库 IO 操作的最小单位是页。一个页可以存储多个行记录。</p>
<h2 id="1-2-页结构概述"><a class="header-anchor" href="#1-2-页结构概述"></a>1.2 页结构概述</h2>
<p>多个页可以不在物理结构上相连，只通过双向链表相关联即可。</p>
<p>每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里边的记录生成一个页目录。</p>
<p>通过主键查找某条记录时可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可。</p>
<h2 id="1-3-页的大小"><a class="header-anchor" href="#1-3-页的大小"></a>1.3 页的大小</h2>
<p>不同数据库管理系统中的页大小通常不同。MySQL 的 InnoDB 存储引擎中，默认的页大小是 16KB，可以通过以下命令查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%innodb_page_size%&#x27;;</span><br></pre></td></tr></table></figure>
<pre>
mysql> SHOW VARIABLES LIKE '%innodb_page_size%';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| innodb_page_size | 16384 |
+------------------+-------+
</pre>
<p>SQL Server 中页的大小是 8KB，Oracle 中使用 <em>块(Block)</em> 来代表页，它支持的块大小有 2KB、4KB、8KB、16KB、32KB 和 64KB。</p>
<h2 id="1-4-页的上层结构"><a class="header-anchor" href="#1-4-页的上层结构"></a>1.4 页的上层结构</h2>
<p>在数据库中，还存在着区（Extent）、段（Segment）和表空间（Tablespace）的概念。它们之间的关系如下图所示：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E9%A1%B5%E7%9A%84%E4%B8%8A%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="页的上层结构"></p>
<p><em>区(Extent)</em> 是比页大一级的存储结构，在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。InnoDB 中页大小默认是 16KB，因此一个区的大小是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn><mo>×</mo><mn>16</mn><mi>K</mi><mi>B</mi><mo>=</mo><mn>1</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">64 \times 16KB= 1MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">64</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">16</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span></span></span></span>。</p>
<p><em>段(Segment)</em> 由一个或多个区组成，区在文件系统是一个连续分配的空间（在 InnoDB 中是连续的 64 个页），但段中的区不一定是相邻的。 段是数据库中的分配单位 ，不同类型的数据库对象以不同的段形式存在。在创建数据表、索引时，就会创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p>
<p><em>表空间(Tablespace)</em> 是一个逻辑容器，表空间中存储了段，在一个表空间中可以有若干个段，但一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理层面上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。</p>
<h1 id="2-页的内部结构"><a class="header-anchor" href="#2-页的内部结构"></a>2. 页的内部结构</h1>
<p>按类型对页划分，常见的有：</p>
<ul>
<li>数据页（保存 B+Tree 节点)</li>
<li>系统页</li>
<li>Undo 页</li>
<li>事务数据页</li>
</ul>
<p>数据页是最常使用的页。</p>
<p>16KB 的数据页被划分为七个部分：</p>
<ol>
<li>文件头（File Header）</li>
<li>页头（Page Header）</li>
<li>最大最小记录（Infimum + Supremum）</li>
<li>用户记录（User Records）</li>
<li>空闲空间（Free Space）</li>
<li>页目录（Page Directory）</li>
<li>文件尾（File Tailer）</li>
</ol>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="数据页结构示意图"></p>
<p>7 个部分的作用如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">占用大小</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">File Header</td>
<td style="text-align:center">38 字节</td>
<td style="text-align:center">文件头，描述页的信息</td>
</tr>
<tr>
<td style="text-align:center">Page Header</td>
<td style="text-align:center">56 字节</td>
<td style="text-align:center">页头，页的状态信息</td>
</tr>
<tr>
<td style="text-align:center">Infimum + Supremum</td>
<td style="text-align:center">26 字节</td>
<td style="text-align:center">最大和最小记录，两个虚拟的行记录</td>
</tr>
<tr>
<td style="text-align:center">User Records</td>
<td style="text-align:center">不确定</td>
<td style="text-align:center">用户记录，存储的行记录内容</td>
</tr>
<tr>
<td style="text-align:center">Free Space</td>
<td style="text-align:center">不确定</td>
<td style="text-align:center">空闲记录，页中还没有被使用的空间</td>
</tr>
<tr>
<td style="text-align:center">Page Directory</td>
<td style="text-align:center">不确定</td>
<td style="text-align:center">页目录，存储用户记录的相对位置</td>
</tr>
<tr>
<td style="text-align:center">File Trailer</td>
<td style="text-align:center">8 字节</td>
<td style="text-align:center">文件尾，校验页是否完整</td>
</tr>
</tbody>
</table>
<p>这七个部分又可以分成三类，分别是：</p>
<ol>
<li>File Header 和 File Trailer</li>
<li>User Records、Infimum + Supremum 和 Free Space</li>
<li>Page Directory 和 Page Header</li>
</ol>
<p>页的主要作用是存储记录，所以 User Records 和 Infimum + Supremum 占了页结构的主要空间：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E4%B8%8D%E6%96%AD%E6%8F%92%E5%85%A5%E8%AE%B0%E5%BD%95%E5%90%8E%E9%A1%B5%E7%BB%93%E6%9E%84%E7%9A%84%E5%8F%98%E5%8C%96.png" alt="不断插入记录后页结构的变化"></p>
<p>随着页中用户记录的不断增加，空闲空间不断减少。</p>
<h2 id="2-1-File-Header"><a class="header-anchor" href="#2-1-File-Header"></a>2.1 File Header</h2>
<p>File Header，即文件头部，描述各种页的通用信息（比如页的编号、其上一页、下一页是谁等）。</p>
<p>大小：38 字节。</p>
<p>构成：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">占用空间大小</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>FIL_PAGE_SPACE_OR_CHKSUM</code></td>
<td style="text-align:center">4 字节</td>
<td style="text-align:center">页的校验和（checksum 值）</td>
</tr>
<tr>
<td style="text-align:center"><code>FIL_PAGE_OFFSET</code></td>
<td style="text-align:center">4 字节</td>
<td style="text-align:center">页号</td>
</tr>
<tr>
<td style="text-align:center"><code>FIL_PAGE_PREV</code></td>
<td style="text-align:center">4 字节</td>
<td style="text-align:center">上一个页的页号</td>
</tr>
<tr>
<td style="text-align:center"><code>FIL_PAGE_NEXT</code></td>
<td style="text-align:center">4 字节</td>
<td style="text-align:center">下一个页的页号</td>
</tr>
<tr>
<td style="text-align:center">FIL_PAGE_LSN</td>
<td style="text-align:center">8 字节</td>
<td style="text-align:center">页面被最后修改时对应的日志序列位置（Log Sequence Number）</td>
</tr>
<tr>
<td style="text-align:center"><code>FIL_PAGE_TYPE</code></td>
<td style="text-align:center">2 字节</td>
<td style="text-align:center">页的类型</td>
</tr>
<tr>
<td style="text-align:center">FIL_PAGE_FILE_FLUSH_LSN</td>
<td style="text-align:center">8 字节</td>
<td style="text-align:center">仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的 LSN 值</td>
</tr>
<tr>
<td style="text-align:center"><code>FIL_PAGE_ARCH_LOG_ON_OR_SPACE_ID</code></td>
<td style="text-align:center">4 字节</td>
<td style="text-align:center">页属于哪个表空间</td>
</tr>
</tbody>
</table>
<blockquote>
<p>FIL_PAGE_OFFSET（4字节）</p>
</blockquote>
<p>每一个页都有一个单独的页号，就像身份证号码一样，InnoDB 通过页号可以定位到唯一页。</p>
<blockquote>
<p>FIL_PAGE_TYPE（2字节）</p>
</blockquote>
<p>当前页的类型。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型名称</th>
<th style="text-align:center">十六进制</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FIL_PAGE_TYPE_ALLOCATED</td>
<td style="text-align:center">0x0000</td>
<td style="text-align:center">最新分配，还未使用</td>
</tr>
<tr>
<td style="text-align:center"><code>FIL_PAGE_UNDO_LOG</code></td>
<td style="text-align:center">0x0002</td>
<td style="text-align:center">Undo 日志页</td>
</tr>
<tr>
<td style="text-align:center">FIL_PAGE_INODE</td>
<td style="text-align:center">0x0003</td>
<td style="text-align:center">段信息节点</td>
</tr>
<tr>
<td style="text-align:center">FIL_PAGE_IBUF_FREE_LIST</td>
<td style="text-align:center">0x0004</td>
<td style="text-align:center">Insert Buffer 空闲列表</td>
</tr>
<tr>
<td style="text-align:center">FIL_PAGE_IBUF_BITMAP</td>
<td style="text-align:center">0x0005</td>
<td style="text-align:center">Insert Buffer 位图</td>
</tr>
<tr>
<td style="text-align:center"><code>FIL_PAGE_TYPE_SYS</code></td>
<td style="text-align:center">0x0006</td>
<td style="text-align:center">系统页</td>
</tr>
<tr>
<td style="text-align:center">FIL_PAGE_TYPE_TRX_SYS</td>
<td style="text-align:center">0x0007</td>
<td style="text-align:center">事务系统数据</td>
</tr>
<tr>
<td style="text-align:center">FIL_PAGE_TYPE_FSP_HDR</td>
<td style="text-align:center">0x0008</td>
<td style="text-align:center">表空间头部信息</td>
</tr>
<tr>
<td style="text-align:center">FIL_PAGE_TYPE_XDES</td>
<td style="text-align:center">0x0009</td>
<td style="text-align:center">扩展描述页</td>
</tr>
<tr>
<td style="text-align:center">FIL_PAGE_TYPE_BLOB</td>
<td style="text-align:center">0x000A</td>
<td style="text-align:center">溢出页</td>
</tr>
<tr>
<td style="text-align:center"><code>FIL_PAGE_INDEX</code></td>
<td style="text-align:center">0x45BF</td>
<td style="text-align:center">索引页，即数据页</td>
</tr>
</tbody>
</table>
<blockquote>
<p>FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）</p>
</blockquote>
<p>InnoDB 是以页为单位存放数据的，如果数据分散到多个不连续的页中进行存储，则需要把这些页关联起来，<code>FIL_PAGE_PREV</code> 和 <code>FIL_PAGE_NEXT</code> 分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把众多页都串联起来，保证这些页之间无需物理上的连续，而达到逻辑上的连续。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%BB%84%E6%88%90%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%A4%BA%E4%BE%8B%E4%B8%80.png" alt="数据页之间组成的双向链表示例一"></p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%BB%84%E6%88%90%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%A4%BA%E4%BE%8B%E4%BA%8C.png" alt="数据页之间组成的双向链表示例二"></p>
<blockquote>
<p>FIL_PAGE_SPACE_OR_CHKSUM（4字节）</p>
</blockquote>
<p>当前页面的校验和（checksum）。</p>
<p><strong>什么是校验和？</strong></p>
<p>对于一个很长的字节串来说，会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就被称为校验和。</p>
<p>在比较两个很长的字节串之前，先比较这两个长字节串的校验和，如果校验和都不一样，那么两个长字节串肯定是不同的，这能够省去直接比较两个比较长的字节串的时间损耗。</p>
<p>文件头部和文件尾部都有 <code>FIL_PAGE_SPACE_OR_CHKSUM</code> 属性。</p>
<p><strong><code>FIL_PAGE_SPACE_OR_CHKSUM</code> 的作用：</strong></p>
<p>InnoDB 存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。假设在同步一半时突然断电，导致该页传输得不完整。可以通过比较文件尾的校验和（checksum 值）与文件头的校验和来检测一个页是否完整（也就是在同步的时候有没有发生只同步部分的情况），如果两个值不相等，则证明页的传输有问题，需要重新传输，否则认为页的传输已经完成。</p>
<p><strong>具体过程：</strong></p>
<p>当一个页在内存中被修改后，在同步之前会把它的校验和算出来，由于 File Header 在页的前边，所以 File Header 的校验和会先被同步到磁盘，当完全写完时，File Trailer 的校验和会被写到页的尾部。如果完全同步成功，则页的首、尾部校验和是一致的；如果写到一半突然断电，File Header 的校验和代表已经修改过的页，File Trailer 的校验和代表原先的页，二者不同则意味着同步中间出了错。这里的校验方式采用了 Hash 算法。</p>
<blockquote>
<p>FIL_PAGE_LSN（8字节）</p>
</blockquote>
<p>页面被最后修改时对应的日志序列位置（Log Sequence Number）。</p>
<h2 id="2-2-File-Trailer"><a class="header-anchor" href="#2-2-File-Trailer"></a>2.2 File Trailer</h2>
<p>File Trailer，即文件尾部。</p>
<p>大小：8 字节。</p>
<p>前 4 个字节代表页的校验和，与 File Header 中的校验和相对应。</p>
<p>后 4 个字节代表页面被最后修改时对应的日志序列位置（LSN），这部分也是为了校验页的完整性，如果首、尾部的 LSN 值校验失败，说明在同步过程出现了问题。</p>
<h2 id="2-3-Free-Space"><a class="header-anchor" href="#2-3-Free-Space"></a>2.3 Free Space</h2>
<p>Free Space，即空闲空间。</p>
<p>存储的记录会按照指定的行格式存储到 User Records 部分。在最开始生成页的时候，并没有 User Records，每当插入一条记录，都会从 Free Space，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records。当 Free Space 的空间都被 User Records 替代之后，就意味着这个页使用完了，此时再插入新记录，就需要申请新的页。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E4%B8%8D%E6%96%AD%E6%8F%92%E5%85%A5%E8%AE%B0%E5%BD%95%E5%90%8E%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8F%98%E5%8C%96.png" alt="不断插入记录后空闲空间的变化"></p>
<h2 id="2-4-User-Records"><a class="header-anchor" href="#2-4-User-Records"></a>2.4 User Records</h2>
<p>User Records，即用户记录。</p>
<p>用户记录中的记录按照 <strong>指定的行格式</strong> 一条一条地摆放，相互之间形成单链表。</p>
<p>那其中的每条记录又是怎么记录的呢？或者说单链表又是怎么形成的？</p>
<p>这就需要说到 <strong>行格式</strong> 中的 <strong>记录头信息</strong> 了。</p>
<blockquote>
<p>记录头信息</p>
</blockquote>
<p>记录头信息占了 5 字节。</p>
<p>执行以下语句创建 <code>page_demo</code> 表，指定字符集为 <code>ascii</code>，指定行格式为 <code>Compact</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> page_demo (</span><br><span class="line">    c1 <span class="type">INT</span>,</span><br><span class="line">    c2 <span class="type">INT</span>,</span><br><span class="line">    c3 <span class="type">VARCHAR</span>(<span class="number">10000</span>),</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (c1)</span><br><span class="line">) CHARSET <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>
<p>一条记录的行格式如下图所示：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E8%A1%A8%E4%B8%AD%E8%AE%B0%E5%BD%95%E7%9A%84%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="表中记录的行格式示意图"></p>
<p>可以看到，除了记录的真实数据外，一条记录还包括一些额外信息：</p>
<ul>
<li>变长字段长度列表</li>
<li><code>NULL</code> 值列表</li>
<li>记录头信息</li>
</ul>
<p>此处主要讲述 <em>记录头信息</em>，在记录头信息中，又包含了多个属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">大小（单位 bit）</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">预留位 1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">未使用</td>
</tr>
<tr>
<td style="text-align:center">预留位 2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">未使用</td>
</tr>
<tr>
<td style="text-align:center">delete_mask</td>
<td style="text-align:center">1</td>
<td style="text-align:center">标记当前记录是否被删除</td>
</tr>
<tr>
<td style="text-align:center">min_rec_mask</td>
<td style="text-align:center">1</td>
<td style="text-align:center">B+Tree 的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td style="text-align:center">n_owned</td>
<td style="text-align:center">4</td>
<td style="text-align:center">当前记录拥有的记录数</td>
</tr>
<tr>
<td style="text-align:center">heap_no</td>
<td style="text-align:center">13</td>
<td style="text-align:center">当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td style="text-align:center">record_type</td>
<td style="text-align:center">3</td>
<td style="text-align:center">当前记录的类型</td>
</tr>
<tr>
<td style="text-align:center">next_record</td>
<td style="text-align:center">16</td>
<td style="text-align:center">下一条记录的相对位置</td>
</tr>
</tbody>
</table>
<p>移除两个预留位后，行格式的简化图：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%AE%80%E5%8C%96%E5%9B%BE.png" alt="行格式简化图"></p>
<p>向表中插入 4 条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> page_demo <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">100</span>, <span class="string">&#x27;song&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;tong&#x27;</span>), </span><br><span class="line">(<span class="number">3</span>, <span class="number">300</span>, <span class="string">&#x27;zhan&#x27;</span>), </span><br><span class="line">(<span class="number">4</span>, <span class="number">400</span>, <span class="string">&#x27;lisi&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>此时用户记录的示意图如下：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E6%8F%92%E5%85%A54%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%90%8E%E7%9A%84%E7%94%A8%E6%88%B7%E8%AE%B0%E5%BD%95.png" alt="插入4条数据后的用户记录"></p>
<p>后续将围绕这 4 条数据介绍 <em>记录头信息</em> 中各个属性的作用。</p>
<blockquote>
<p>记录头信息：delete_mask</p>
</blockquote>
<p>标记当前记录是否被删除，占用 1 个二进制位：</p>
<ul>
<li>0：记录未被删除</li>
<li>1：记录已被删除</li>
</ul>
<p>当某条记录被删除后，不会立即从磁盘上移除。如果立即移除，之后的记录需要在磁盘上重新排列，造成性能消耗。所有被删掉的记录会组成一个所谓的垃圾链表，这个链表中的记录占用的空间被称为 <em>可重用空间</em>，当有新记录插入时，可以覆盖这些被删除的记录。</p>
<blockquote>
<p>记录头信息：min_rec_mask</p>
</blockquote>
<p>B+Tree 的每层 <strong>非叶子节点</strong> 中的最小记录都会添加该标记，值为1。</p>
<p>前面插入的四条记录的 <code>min_rec_mask</code> 值都是0，意味它们都不是 B+Tree 的非叶子节点中的最小记录（因为它们根本就不是非叶子节点，都是叶子节点）。</p>
<blockquote>
<p>记录头信息：record_type</p>
</blockquote>
<p>当前记录的类型，共有 4 种类型：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型值</th>
<th style="text-align:center">对应的记录类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">普通记录</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">B+Tree 非叶节点记录</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">最小记录</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">最大记录</td>
</tr>
</tbody>
</table>
<p>前面插入的四条记录都是普通记录，因此它们的 <code>record_type</code> 都是 0。</p>
<blockquote>
<p>记录头信息：heap_no</p>
</blockquote>
<p>当前记录在本页中的位置。</p>
<p>前面插入的四条记录在本页中的位置分别是 2、3、4、5，怎么没有 0 或 1 的记录呢？</p>
<p>MySQL 会自动为每个页添加两条记录，由于这两条记录并不是用户插入的，所以也称为 <em>伪记录</em> 或 <em>虚拟记录</em>。这两个伪记录一个代表 <strong>最小记录</strong>，一个代表 <strong>最大记录</strong>。最小记录和最大记录的 <code>heap_no</code> 值分别是 <code>0</code> 和 <code>1</code>，也就是说它们俩在页中的位置最靠前。</p>
<p>什么是最大记录，什么是最小记录？参看【2.5 Infimum + Supremum】。</p>
<blockquote>
<p>记录头信息：n_owned</p>
</blockquote>
<p>页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，存储所用的字段就是 <code>n_owned</code>。</p>
<p>页目录的详细信息可以参看【2.6 Page Directory】。</p>
<blockquote>
<p>记录头信息：next_record</p>
</blockquote>
<p><code>next_record</code> 在记录头信息中十分重要，它表示从当前记录的真实数据到 <strong>下一条</strong> 记录的真实数据的 <strong>地址偏移量</strong>。</p>
<p>比如第一条记录的 <code>next_record</code> 值为 <code>32</code>，意味着从第一条记录的真实数据的地址处向后找 32 个字节就是  <strong>下一条</strong> 记录的真实数据。</p>
<p>这里的 <em>下一条</em> 记录并不是按照插入顺序插入的下一条记录，而是按照主键值由小到大排列的下一条记录，同时规定 <code>Infimum</code> 记录（即最小记录）的下一条记录是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录是 <code>Supremum</code> 记录（即最大记录）。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%AE%B0%E5%BD%95%E4%B8%8E%E7%94%A8%E6%88%B7%E8%AE%B0%E5%BD%95%E7%9A%84%E9%93%BE%E6%8E%A5%E5%85%B3%E7%B3%BB.png" alt="最大最小记录与用户记录的链接关系"></p>
<p>如果从表中删除一条记录，这个单链表也会发生变化：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> page_demo <span class="keyword">WHERE</span> c1 <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E5%88%A0%E9%99%A4c1%E4%B8%BA2%E7%9A%84%E8%AE%B0%E5%BD%95%E5%90%8E%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%AE%B0%E5%BD%95%E4%B8%8E%E7%94%A8%E6%88%B7%E8%AE%B0%E5%BD%95%E7%9A%84%E9%93%BE%E6%8E%A5%E5%85%B3%E7%B3%BB.png" alt="删除c1为2的记录后最大最小记录与用户记录的链接关系"></p>
<p>删除 <code>c1</code> 为 <code>2</code> 的记录后：</p>
<ul>
<li>被删除记录并没有立即从存储空间中移除，而是把该记录的 <code>delete_mask</code> 值设置为 1；</li>
<li>被删除记录的 <code>next_record</code> 值为 0，表示该记录没有下一条记录；</li>
<li>被删除记录的前一条记录的 <code>next_record</code> 指向了被删除记录的下一条记录；</li>
<li>最大记录的 <code>n_owned</code> 值从 5 变成了 4。</li>
</ul>
<p>不论怎么对页中的记录做增删改操作，InnoDB 始终会维护一条记录的单链表，链表中的各个节点按照主键值由小到大的顺序进行连接。</p>
<p>如果又添加一条 <code>c1</code> 为 <code>2</code> 的记录呢？</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E5%8F%88%E6%B7%BB%E5%8A%A0c1%E4%B8%BA2%E7%9A%84%E8%AE%B0%E5%BD%95%E5%90%8E%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%AE%B0%E5%BD%95%E4%B8%8E%E7%94%A8%E6%88%B7%E8%AE%B0%E5%BD%95%E7%9A%84%E9%93%BE%E6%8E%A5%E5%85%B3%E7%B3%BB.png" alt="又添加c1为2的记录后最大最小记录与用户记录的链接关系"></p>
<p>直接复用了被删除记录的存储空间。</p>
<p>如果数据页中存在多条被删除掉的记录，这些记录的 <code>next_record</code> 会链接起来，并组成一个垃圾链表，以便后续重用这些存储空间。</p>
<h2 id="2-5-Infimum-Supremum"><a class="header-anchor" href="#2-5-Infimum-Supremum"></a>2.5 Infimum + Supremum</h2>
<p>Infimum，即最小记录；Supremum，即最大记录。</p>
<p>记录也可以比大小。对于一条完整的记录来说，比较记录的大小就是比较主键的大小。比如插入的 4 条记录的主键值分别是 1、2、3、4，这意味着这 4 条记录是从小到大依次递增。</p>
<p>InnoDB 规定的最小记录与最大记录的构造十分简单，都由 5 字节的记录头信息和 8 字节大小的一个固定的部分组成（一条占 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>+</mo><mn>8</mn><mo>=</mo><mn>13</mn></mrow><annotation encoding="application/x-tex">5 + 8 = 13</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">13</span></span></span></span> 字节，俩一起就 26 字节）：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E6%9C%80%E5%A4%A7%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%9C%80%E5%B0%8F%E8%AE%B0%E5%BD%95%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="最大记录与最小记录的结构"></p>
<p>这两条记录不是用户定义的记录，它们并不存放在页的 User Records 中，而是被单独放在一个称为 Infimum + Supremum 的部分：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%AE%B0%E5%BD%95%E4%B8%8E%E7%94%A8%E6%88%B7%E8%AE%B0%E5%BD%95%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="最大最小记录与用户记录的区别"></p>
<h2 id="2-6-Page-Directory"><a class="header-anchor" href="#2-6-Page-Directory"></a>2.6 Page Directory</h2>
<p>Page Directory，即页目录。</p>
<p>在页中，记录以单向链表的形式进行存储的。单向链表的插入、删除效率高，但检索效率不高，最坏情况需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，使得能够通过二分查找法的方式对记录进行检索。</p>
<p>现在需要查找 <code>page_demo</code> 表中 <code>c1</code> 为 <code>3</code> 的记录，如果使用页目录进行二分查找：</p>
<ol>
<li>将所有记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li>
<li>第 1 组中 <strong>只有</strong> 最小记录；最后一组是最大记录所在的分组，内部会有 1~8 条记录；其余组中记录的数量在 4~8 条之间。这样使得除第 1 组（最小记录所在组）外，其余组的记录数会尽量平分。</li>
<li>每个组中最后一条记录的头信息（其中的 <code>n_owned</code>）中会存储该组一共有多少条记录；</li>
<li>页目录会存储每组最后一条记录的地址偏移量，这些地址偏移量按照先后顺序排列，每组的地址偏移量也被称为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。</li>
</ol>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E9%A1%B5%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E6%A7%BD%E4%B8%8E%E5%88%86%E7%BB%84.png" alt="页目录中的槽与分组"></p>
<p>比如 <code>page_demo</code> 表中共有 6 条记录，InnoDB 会把它们分成两组，第一组中只有一条最小记录，第二组中含有剩余的 5 条记录：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E5%AF%B9page_demo%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%AE%B0%E5%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84.png" alt="对page_demo表中的记录进行分组"></p>
<p>由上图可知：</p>
<ul>
<li>页目录中只有两个槽，也就是说记录被分为了两组，槽 1 中的值是 112，表示最大记录的地址偏移量（从页面的 0 字节开始数，数 112 个字节）；槽 0 中的值是 99，代表最小记录的地址偏移量。</li>
<li>最小记录的 <code>n_owned</code> 值为1，表示以最小记录结尾的这个分组中只有 1 条记录，即最小记录本身。</li>
<li>最大记录的 <code>n_owned</code> 值为 5，表示以最大记录结尾的这个分组中有 5 条记录，除最大记录外，还有用户插入的 4 条记录。</li>
</ul>
<p>如果将槽与记录链接起来：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E5%B0%86%E6%A7%BD%E4%B8%8E%E8%AE%B0%E5%BD%95%E9%93%BE%E6%8E%A5%E8%B5%B7%E6%9D%A5.png" alt="将槽与记录链接起来"></p>
<p>将记录的分组也体现出来：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E4%BD%93%E7%8E%B0%E8%AE%B0%E5%BD%95%E7%9A%84%E5%88%86%E7%BB%84.png" alt="体现记录的分组"></p>
<blockquote>
<p>页目录的分组个数是如何确定的？</p>
</blockquote>
<p>InnoDB 规定：对于最小记录所在的分组 <strong>只能</strong> 有 1 条记录，最大记录所在的分组拥有的记录条数 <strong>只能</strong> 在 1~8 条之间，剩下分组中记录的条数范围 <strong>只能</strong> 在是 4~8 条之间。</p>
<p>分组过程将按照：</p>
<ul>
<li>
<p>初始情况下一个数据页中只有最小记录和最大记录，它们分属于两个分组；</p>
</li>
<li>
<p>每插入一条用户记录，都会从页目录中找到主键值比插入记录的主键值大且差值最小的槽，然后把该槽中最后一条记录的 <code>n_owned</code> 值加 1，表示本组内添加了一条记录，直到该组中的记录数等于 8；</p>
</li>
<li>
<p>当一个组中的记录数为 8 时再插入一条记录，会将组中的记录拆分为两个组，一个组 4 条，另一个 5 条，并在页目录中新增一个槽来记录新增分组中最大记录的地址偏移量。</p>
</li>
</ul>
<blockquote>
<p>如何使用页目录进行快速查找到目标记录</p>
</blockquote>
<p>向 <code>page_demo</code> 表中再增加 12 条记录，现在共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mo>+</mo><mn>12</mn><mo>=</mo><mn>18</mn></mrow><annotation encoding="application/x-tex">6 + 12 = 18</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">18</span></span></span></span> 条记录（包括最大、最小记录），这些记录被分为 5 个组：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E6%96%B0%E5%A2%9E12%E6%9D%A1%E8%AE%B0%E5%BD%95%E5%90%8E%E7%9A%84%E5%88%86%E7%BB%84%E6%83%85%E5%86%B5.png" alt="新增12条记录后的分组情况"></p>
<p>各个槽中代表的记录的主键值按照从小到大排序，所以才可以使用二分法来快速查找。5 个槽的编号分别是 0、1、2、3、4，所以初始情况下最低的槽是 low = 0，最高的槽是 high = 4。如果想查找主键值为 6 的记录：</p>
<ol>
<li>计算中间槽的位置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>+</mo><mn>4</mn><mo stretchy="false">)</mo><mo>÷</mo><mn>2</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">(0 + 4) \div 2 = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，槽 2 对应记录的主键值为 8，又因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>&gt;</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">8 &gt; 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span>，设置 high 为 2，low 保持不变；</li>
<li>重新计算中间槽的位置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>÷</mo><mn>2</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(0 + 2) \div 2 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，槽 1 对应的主键值为 4，又因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>&lt;</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">4 &lt; 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span>，设置 low 为 1，high 保持不变；</li>
<li>由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">high - low = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，确定主键值为 6 的记录在槽 2 对应的组中，接下来需要找到槽 2 中主键值最小的那条记录，然后沿着单向链表遍历槽 2 中的记录。</li>
</ol>
<p>每个槽对应该组中主键值最大的记录，槽 2 对应主键值为 8 的记录，怎么定位一个组中最小的记录呢？</p>
<p>各个槽都是挨着的，可以很轻易的拿到槽 1 对应的记录（主键值为 4），该条记录的下一条记录就是槽 2 中主键值最小的记录，该记录的主键值为 5。可以从主键值为 5 的记录出发，遍历槽 2 中的各条记录，直到找到主键值为 6 的记录。</p>
<p>因为一个组中包含的记录条数范围是 1~8，所以遍历一个组中的记录的代价是很小的。</p>
<h2 id="2-7-Page-Header"><a class="header-anchor" href="#2-7-Page-Header"></a>2.7 Page Header</h2>
<p>Page Header，即页面头部。</p>
<p>为了得到数据页中记录的状态信息，比如已经存储了多少条记录、第一条记录的地址是什么、页目录中存储了多少个槽等等，特意在页中定义了名为 Page Header 的部分，Page Header 固定占用 56 个字节，专门存储各种状态信息。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">大小（单位 bit）</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PAGE_N_DIR_SLOTS</td>
<td style="text-align:center">2</td>
<td style="text-align:center">当前页目录中的槽数</td>
</tr>
<tr>
<td style="text-align:center">PAGE_HEAP_TOP</td>
<td style="text-align:center">2</td>
<td style="text-align:center">还未使用的空间最小地址，该地址之后就是 Free Space</td>
</tr>
<tr>
<td style="text-align:center">PAGE_N_HEAP</td>
<td style="text-align:center">2</td>
<td style="text-align:center">当前页中记录的数量（包括最大、最小、被删除的记录）</td>
</tr>
<tr>
<td style="text-align:center">PAGE_FREE</td>
<td style="text-align:center">2</td>
<td style="text-align:center">第一个已经标记为删除的记录的地址（多个被删除的记录会通过 <code>next_record</code> 组成垃圾链表）</td>
</tr>
<tr>
<td style="text-align:center">PAGE_GARBAGE</td>
<td style="text-align:center">2</td>
<td style="text-align:center">已删除记录占用的字节数</td>
</tr>
<tr>
<td style="text-align:center">PAGE_LAST_INSERT</td>
<td style="text-align:center">2</td>
<td style="text-align:center">最后插入记录的位置</td>
</tr>
<tr>
<td style="text-align:center"><code>PAGE_DIRECTION</code></td>
<td style="text-align:center">2</td>
<td style="text-align:center">记录插入的方向</td>
</tr>
<tr>
<td style="text-align:center"><code>PAGE_N_DIRECTION</code></td>
<td style="text-align:center">2</td>
<td style="text-align:center">一个方向连续插入的记录数量</td>
</tr>
<tr>
<td style="text-align:center">PAGE_N_RECS</td>
<td style="text-align:center">2</td>
<td style="text-align:center">当前页中记录的数量（不包括最大、最小、被删除的记录）</td>
</tr>
<tr>
<td style="text-align:center">PAGE_MAX_TRX_ID</td>
<td style="text-align:center">8</td>
<td style="text-align:center">修改当前页的最大事务 ID，仅在二级索引中定义</td>
</tr>
<tr>
<td style="text-align:center">PAGE_LEVEL</td>
<td style="text-align:center">2</td>
<td style="text-align:center">当前页在 B+Tree 中所处的层级</td>
</tr>
<tr>
<td style="text-align:center">PAGE_INDEX_ID</td>
<td style="text-align:center">8</td>
<td style="text-align:center">索引 ID，表示当前页属于哪个索引</td>
</tr>
<tr>
<td style="text-align:center">PAGE_BTR_SEG_LEAF</td>
<td style="text-align:center">10</td>
<td style="text-align:center">B+Tree 叶子段的头部信息，仅在 B+Tree 的 Root 页中定义</td>
</tr>
<tr>
<td style="text-align:center">PAGE_BTR_SEG_TOP</td>
<td style="text-align:center">10</td>
<td style="text-align:center">B+Tree 非叶子段的头部信息，仅在 B+Tree 的 Root 页中定义</td>
</tr>
</tbody>
</table>
<blockquote>
<p>PAGE_DIRECTION</p>
</blockquote>
<p>如果新插入记录的主键值比上一条记录的主键值大，就说这条记录的插入方向是向右，反之向左。用来表示最后一条记录插入方向的状态就是 <code>PAGE_DIRECTION</code>。</p>
<blockquote>
<p>PAGE_N_DIRECTION</p>
</blockquote>
<p>如果连续几次插入的新记录的方向都是一致的，InnoDB 会把沿着同一个方向插入记录的条数记下来，并用 <code>PAGE_N_DIRECTION</code> 表示。如果最后一条记录的插入方向发生了改变，这个值会被清零并重新统计。</p>
<h2 id="2-8-从数据页的角度看-B-Tree-的查询"><a class="header-anchor" href="#2-8-从数据页的角度看-B-Tree-的查询"></a>2.8 从数据页的角度看 B+Tree 的查询</h2>
<p>一棵 B+Tree 按照节点类型可以分成两部分：</p>
<ul>
<li>叶子节点，B+Tree 最底层的节点，节点的高度为 0，存储行记录；</li>
<li>非叶子节点，节点高度大于 0，存储索引键和页面指针，并不存储行记录本身</li>
</ul>
<blockquote>
<p>B+Tree 如何进行记录检索的？</p>
</blockquote>
<p>先从 B+Tree 的根开始，逐层检索，直到找到叶子节点，也就是找到对应的数据页为止，然后将数据页加载到内存中，页目录中的槽（slot）采用二分查找的方式先找到一个粗略的记录分组，最后在分组中通过链表遍历的方式查找到记录。</p>
<blockquote>
<p>普通索引和唯一索引在查询效率上有什么不同？</p>
</blockquote>
<p>唯一索引是在普通索引的基础上增加了约束性，即关键字唯一，找到了关键字就会停止检索。</p>
<p>使用普通索引时，用户记录中可能会存在多个关键字相同的情况，根据页结构，在读取一条记录时，不会单独从磁盘中读一条记录出去，而是将这个记录所在的页都加载到内存中进行读取。InnoDB 存储引擎的页大小为  16KB，一个页中可能存储着许多记录，因此在使用普通索引进行查找时，也只是在内存中多几次“判断下一条记录”的操作，对 CPU 来说，这些操作消耗的时间是忽略不计的。</p>
<p>所以对一个索引字段进行检索，无论采用普通索引还是唯一索引，在检索效率上几乎没有区别。</p>
<h1 id="3-InnoDB-行格式"><a class="header-anchor" href="#3-InnoDB-行格式"></a>3. InnoDB 行格式</h1>
<p>向表中插入记录时，都是以行为单位的，这些记录在磁盘上的存放方式也被称为 <em>行格式</em> 或 <em>记录格式</em>。InnoDB 存储引擎设计了 4 种不同类型的行格式：</p>
<ul>
<li>Compact</li>
<li>Redundant</li>
<li>Dynamic 和 Compressed</li>
</ul>
<p>在 MySQL 8.0 中可以使用以下语句查看默认的行格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@innodb_default_row_format;</span><br></pre></td></tr></table></figure>
<pre>
mysql> SELECT @@innodb_default_row_format;
+-----------------------------+
| @@innodb_default_row_format |
+-----------------------------+
| dynamic                     |
+-----------------------------+
</pre>
<p>还可以使用如下语句查看某个具体表使用的行格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLE STATUS like &#x27;表名&#x27;\G</span><br></pre></td></tr></table></figure>
<p>在创建表时，也可以指定行格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(列的信息) ROW_FORMAT = 行格式名称</span><br></pre></td></tr></table></figure>
<p>也能修改某个表的行格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ROW_FORMAT = 行格式名称</span><br></pre></td></tr></table></figure>
<h2 id="3-1-COMPACT"><a class="header-anchor" href="#3-1-COMPACT"></a>3.1 COMPACT</h2>
<p>在 MySQL 5.1 中，默认行格式为 <code>Compact</code>。</p>
<p>一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/compact%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="compact行格式示意图"></p>
<p>由上图可知，Compact 行格式分为四个部分：</p>
<ul>
<li>变长字段长度列表</li>
<li>NULL 值列表</li>
<li>记录头信息</li>
<li>真实记录数据</li>
</ul>
<p>其中的 <em>记录头信息</em> 在前文已经介绍过，本节不再赘述。</p>
<blockquote>
<p>变长字段长度列表</p>
</blockquote>
<p>MySQL 支持一些变长的数据类型，比如 <code>VARCHAR(M)</code>、<code>VARBINARY(M)</code>、<code>TEXT</code>、<code>BLOB</code> 等类型，这些数据类型修饰列被称为变长字段，变长字段存储的字节数是不固定的，所以在存储真实数据时需要顺便把这些数据占用的字节数也存起来。在 Compact 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。</p>
<p><mark>注意：</mark> 存储的变长长度和字段顺序是反过来的。比如两个 <code>CARCHAR</code> 字段在表结构的顺序是 <code>a(10)</code> 和 <code>b(15)</code>，那么在变长字段长度列表中存储的顺序是 15 和 10。</p>
<p>假设 <code>record_test_table</code> 表中的 <code>col1</code>、<code>col2</code> 和 <code>col4</code> 列的类型都是 <code>VARCHAR(8)</code>，并且均能为 <code>NULL</code>，所以这三个列的值的长度都需要保存在 <em>变长字段长度列表</em> 中。再假设这三列的内容长度以十六进制表示如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字段名</th>
<th style="text-align:center">内容长度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">col1</td>
<td style="text-align:center">0x08</td>
</tr>
<tr>
<td style="text-align:center">col2</td>
<td style="text-align:center">0x04</td>
</tr>
<tr>
<td style="text-align:center">col3</td>
<td style="text-align:center">0x06</td>
</tr>
</tbody>
</table>
<p>这些长度值需要按照列顺序的 <strong>逆序</strong> 存放，最终该记录的 <em>变长字段长度列表</em> 值为 <code>060408</code>。</p>
<blockquote>
<p>NULL 值列表</p>
</blockquote>
<p>Compact 行格式会把可以为 <code>NULL</code> 的列统一管理起来，并存放在 <em>NULL值列表</em> 中。如果表中的列都要求 <code>NOT NULL</code>，那么 <em>NULL 值列表</em> 也不存在了。</p>
<p>为什么要定义 NULL 值列表？</p>
<p>因为数据都需要对齐，如果没有标注出 <code>NULL</code> 值的位置，就有可能在查询数据时出现混乱。如果使用一个特定的符号放到相应的数据位表示 <code>NULL</code>，虽能达到效果，但会浪费空间。所以不如开辟出一块空间专门用来记录该行的哪些列是非空数据，哪些是空数据：</p>
<ul>
<li>二进制位值为 1 时，代表该列为 <code>NULL</code></li>
<li>二进制位值为 0 时，代表该列不为 <code>NULL</code></li>
</ul>
<p>假设有字段 a、b、c，其中 a 是主键，在某一行中存储的数依次是 <code>(1, null, 2)</code>。Compact 行格式中的 NULL 值列表中将会存放 <code>01</code>，第一个 0 表示列 c 不为 <code>NULL</code>，第二个 1 表示列 b 的值为 <code>NULL</code>。因为列 a 是主键，肯定是非 <code>NULL</code> 且唯一的，因此 NULL 值列表会自动跳过主键。</p>
<p>因为 NULL 值列表的存在，在 Compact 行格式下，无论是定长的 <code>CHAR</code>，还是变长的 <code>VARCHAR</code>，<code>NULL</code> 值都不会占用任何存储空间。</p>
<blockquote>
<p>记录的真实数据</p>
</blockquote>
<p>记录的真实数据除了用户定义的数据以外，还会有三个隐藏列：</p>
<table>
<thead>
<tr>
<th style="text-align:center">列名</th>
<th style="text-align:center">是否必须</th>
<th style="text-align:center">占用空间</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DB_ROW_ID</td>
<td style="text-align:center">否</td>
<td style="text-align:center">6 字节</td>
<td style="text-align:center">行 ID，唯一标识</td>
</tr>
<tr>
<td style="text-align:center">DB_TRX_ID</td>
<td style="text-align:center">是</td>
<td style="text-align:center">6 字节</td>
<td style="text-align:center">事务 ID</td>
</tr>
<tr>
<td style="text-align:center">DB_ROLL_PTR</td>
<td style="text-align:center">是</td>
<td style="text-align:center">7 字节</td>
<td style="text-align:center">回滚指针</td>
</tr>
</tbody>
</table>
<p>如果一个表没有手动定义主键列，会选取一个唯一列作为主键列；如果没有唯一列，则会为表默认添加一个名为 DB_ROW_ID 的隐藏列作为主键列。也就是说，DB_ROW_ID 隐藏列是在既没有主键列也唯一列时才会存在的。</p>
<p>DB_TRX_ID 和 DB_ROLL_PTR 与 MySQL 的事务日志有关，此处暂不介绍。</p>
<h2 id="3-2-行溢出"><a class="header-anchor" href="#3-2-行溢出"></a>3.2 行溢出</h2>
<p><strong>InnoDB 存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。</strong></p>
<p><code>VARCHAR(M)</code> 类型最多可以存放 65535 个字节，那可以创建仅包含一个 <code>VARCHAR(65535)</code> 列的表吗？比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE  TABLE  varchar_size_demo(</span><br><span class="line">    c  VARCHAR(65535)</span><br><span class="line">)  CHARSET=ascii  ROW_FORMAT=Compact;</span><br></pre></td></tr></table></figure>
<pre>
ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs
</pre>
<p>创建失败了，这是因为：MySQL 对一条记录占用的最大存储空间是有限制的，除 <code>BLOB</code> 或 <code>TEXT</code> 类型的列外， 其他所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。</p>
<p>变长字段长度列表要占用 2 个字节，且 <code>c</code> 列未被标记为 <code>NOT NULL</code>，因此 NULL 值列表还会占用 1 个字节，最终自能创建出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>65535</mn><mo>−</mo><mn>2</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>65532</mn></mrow><annotation encoding="application/x-tex">65535 - 2 - 1 = 65532</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">65535</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">65532</span></span></span></span> 个字节的 <code>VARCHAR</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE  TABLE  varchar_size_demo(</span><br><span class="line">    c  VARCHAR(65532)</span><br><span class="line">)  CHARSET=ascii  ROW_FORMAT=Compact;</span><br></pre></td></tr></table></figure>
<p><mark>注意：</mark> 此处的 <code>65532</code> 还和表使用的字符集有关，创建的表使用的字符集是 <code>ascii</code>，在这种字符集下，一个字符恰好占用 1 个字节，如果换用其他字符集，比如 <code>utf8mf4</code>，在这种字符集下，一个字符不再只占用 1 个字节，此时需要额外的计算才能求出 <code>VARCHAR(M)</code> 中 <code>M</code> 的最大值。</p>
<p>一个页的大小一般是 16KB，即 <code>16384</code> 字节，而一个 <code>VARCHAR(M)</code> 类型的列可以存储远超这个值的字节数，这导致一个页可能都存放不了一条记录，这种现象被称为 <em>行溢出</em>。</p>
<p>使用 Compact 或 Reduntant 行格式时，对于占用存储空间非常大的列，在记录的真实数据处 <strong>只会</strong> 存储该列的一部分数据，而把剩余数据分散存储到其他的几个页中，并在记录的真实数据处用 20 个字节指向这些页的地址（这 20 个字节中还包括这些分散在其他页面中的数据所占用的字节数），以便找到剩余数据所在的页，这被称为 <em>页的拓展</em>。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E9%A1%B5%E7%9A%84%E6%8B%93%E5%B1%95.png" alt="页的拓展"></p>
<h2 id="3-3-Dynamic-和-Compressed"><a class="header-anchor" href="#3-3-Dynamic-和-Compressed"></a>3.3 Dynamic 和 Compressed</h2>
<p>在 MySQL 8.0 中，默认行格式是 Dynamic。Dynamic、Compressed 行格式和 Compact 行格式很类似，只不过在处理行溢出数据时有差别：</p>
<ul>
<li>
<p>Compressed 和 Dynamic 两种行格式对于存放在 <code>BLOB</code> 中的数据采用了 <em>完全的行溢出</em>。在数据页中只存放 20 个字节的指针（溢出页的地址），实际的数据都存放在 Off Page（溢出页）中。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/%E5%AE%8C%E5%85%A8%E7%9A%84%E8%A1%8C%E6%BA%A2%E5%87%BA.png" alt="完全的行溢出"></p>
</li>
<li>
<p>Compact 和 Redundant 两种格式会在记录的真实数据处存储一部分数据（存放 768 个前缀字节）。</p>
</li>
</ul>
<p>对于 Compressed 行格式来说，存储在其中的行数据会以 <code>zlib</code> 的算法进行压缩，因此对于 <code>BLOB</code>、<code>TEXT</code>、<code>VARCHAR</code> 这类大长度类型的数据能够进行非常有效的存储。</p>
<h2 id="3-4-Redundant"><a class="header-anchor" href="#3-4-Redundant"></a>3.4 Redundant</h2>
<p>Redundant 是 MySQL 5.0 之前 InnoDB 的行记录存储方式，MySQL 8.0 也支持这种行格式。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SQLImages/Redundant%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Redundant行格式示意图"></p>
<p>不同于 Compact 行记录格式，Redundant 行格式的首部存在一个 <em>字段长度偏移列表</em>，它同样是按照列的顺序 <strong>逆序</strong> 摆放的。</p>
<blockquote>
<p>字段长度偏移列表</p>
</blockquote>
<p>Compact 行格式开头是 <em>变长字段长度列表</em>，而 Redundant 行格式的开头是 <em>字段长度偏移列表</em>，它们相比有以下差异：</p>
<ul>
<li>少了“变长”两个字。Redundant 行格式会把该条记录中所有列（包括隐藏列）的长度信息 <strong>都</strong> 逆序存储到字段长度偏移列表。</li>
<li>多了“偏移”两个字。这意味着计算列值长度的方式不像 Compact 行格式那么直观，它采用两个相邻数值的差值来计算出各个列值的长度。</li>
</ul>
<p>比如某条记录的字段长度偏移列表是：</p>
<pre>
2B 25 1F 1B 13 0C 06
</pre>
<p>由于采用逆序摆放，因此 <em>字段长度偏移列表</em> 中的值是：</p>
<pre>
06 0C 13 17 1A 24 25
</pre>
<p>而按照两个相邻数值的差值来计算各个列值的长度的意思是：</p>
<ul>
<li>
<p>第一列 DB_ROW_ID 的长度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>06</mn></mrow><annotation encoding="application/x-tex">0x06</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">06</span></span></span></span> 个字节，也就是 6 个字节。</p>
</li>
<li>
<p>第二列 DB_TRX_ID 的长度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>0</mn><mi>C</mi><mo>−</mo><mn>0</mn><mi>x</mi><mn>06</mn></mrow><annotation encoding="application/x-tex">0x0C - 0x06</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">06</span></span></span></span> 个字节，也就是 6 个字节。</p>
</li>
<li>
<p>第三列 DB_ROLL_PTR 的长度就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>13</mn><mo>−</mo><mn>0</mn><mi>x</mi><mn>0</mn><mi>C</mi></mrow><annotation encoding="application/x-tex">0x13 - 0x0C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">13</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 个字节，也就是 7 个字节。</p>
</li>
<li>
<p>第四列 col1 的长度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>1</mn><mi>B</mi><mo>−</mo><mn>0</mn><mi>x</mi><mn>13</mn></mrow><annotation encoding="application/x-tex">0x1B - 0x13</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">13</span></span></span></span> 个字节，也就是 8 个字节。</p>
</li>
<li>
<p>第五列 col2 的长度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>1</mn><mi>F</mi><mo>−</mo><mn>0</mn><mi>x</mi><mn>1</mn><mi>B</mi></mrow><annotation encoding="application/x-tex">0x1F - 0x1B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 个字节，也就是 4 个字节。</p>
</li>
<li>
<p>第六列 col3 的长度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>25</mn><mo>−</mo><mn>0</mn><mi>x</mi><mn>1</mn><mi>F</mi></mrow><annotation encoding="application/x-tex">0x25 - 0x1F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">25</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 个字节，也就是 6 个字节。</p>
</li>
<li>
<p>第七列 col4 的长度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>2</mn><mi>B</mi><mo>−</mo><mn>0</mn><mi>x</mi><mn>25</mn></mrow><annotation encoding="application/x-tex">0x2B - 0x25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">25</span></span></span></span> 个字节，也就是 6 个字节。</p>
</li>
</ul>
<blockquote>
<p>记录头信息</p>
</blockquote>
<p>不同于 Compact 行格式，Redundant 行格式中的记录头信息固定占用 6 个字节（即 48 位）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">大小（bit）</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">()</td>
<td style="text-align:center">1</td>
<td style="text-align:center">预留位，未使用</td>
</tr>
<tr>
<td style="text-align:center">()</td>
<td style="text-align:center">1</td>
<td style="text-align:center">预留位，未使用</td>
</tr>
<tr>
<td style="text-align:center">deleted_mask</td>
<td style="text-align:center">1</td>
<td style="text-align:center">该行是否被删除</td>
</tr>
<tr>
<td style="text-align:center">min_rec_mask</td>
<td style="text-align:center">1</td>
<td style="text-align:center">B+Tree 的每层非叶子节点中的最小记录会添加此标记</td>
</tr>
<tr>
<td style="text-align:center">n_owned</td>
<td style="text-align:center">4</td>
<td style="text-align:center">当前记录拥有的记录数</td>
</tr>
<tr>
<td style="text-align:center">heap_no</td>
<td style="text-align:center">13</td>
<td style="text-align:center">索引堆中该记录的位置信息</td>
</tr>
<tr>
<td style="text-align:center"><code>n_fileds</code></td>
<td style="text-align:center">10</td>
<td style="text-align:center">记录中列的数量</td>
</tr>
<tr>
<td style="text-align:center"><code>1byte_offs_flag</code></td>
<td style="text-align:center">1</td>
<td style="text-align:center">字段长度偏移列表中每个列对应的偏移量</td>
</tr>
<tr>
<td style="text-align:center">next_record</td>
<td style="text-align:center">16</td>
<td style="text-align:center">页中下一条记录的绝对位置</td>
</tr>
</tbody>
</table>
<p>与 Compact 行格式的记录头信息相比，有两处不同：</p>
<ol>
<li>Redundant 行格式多了 <code>n_field</code> 和 <code>1byte_offs_flag</code> 两个属性</li>
<li>Redundant 行格式中没有 <code>record_type</code> 属性</li>
</ol>
<h1 id="4-区、段、碎片区"><a class="header-anchor" href="#4-区、段、碎片区"></a>4. 区、段、碎片区</h1>
<h2 id="4-1-为什么要有区？"><a class="header-anchor" href="#4-1-为什么要有区？"></a>4.1 为什么要有区？</h2>
<p>B+Tree 的每一层中的页都会形成一个双向链表，如果是以页为单位来分配存储空间，双向链表相邻的两个页之间的物理位置可能相距非常远。</p>
<p>B+Tree 索引的范围查询只需要定位到最左边和最右边的记录，然后沿着双向链表一直扫描就可以了，如果链表中相邻的两个页的物理位置相距非常远，范围查询时将使用随机 IO。磁盘的速度和内存的速度差了好几个数量级，随机 IO 是非常慢的，所以应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询时才可以使用所谓的顺序 IO。</p>
<p>一个区是在物理位置上连续的 64个页。因为 InnoDB 中页的大小默认为 16KB，所以一个区的大小是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn><mo>×</mo><mn>16</mn><mi>K</mi><mi>B</mi><mo>=</mo><mn>1</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">64 \times 16KB = 1MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">64</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">16</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span></span></span></span>。</p>
<p>如果表中的数据量较大，为某个索引分配空间时将不再以页为单位进行分配，而是按照区为单位，如果表中的数据特别多，甚至可以一次性分配多个连续的区。虽然这可能造成空间的浪费（数据不足以填充满整个区），但从性能的角度看，这可以消除很多随机 IO，功大于过。</p>
<h2 id="4-2-为什么要有段？"><a class="header-anchor" href="#4-2-为什么要有段？"></a>4.2 为什么要有段？</h2>
<p>范围查询其实是对 B+Tree 叶子节点中的记录进行顺序扫描，如果不区分叶子节点和非叶子节点，把节点代表的页面都放到申请到的区中的话，范围扫描的效果就大打折扣了（还会扫描非叶子节点）。所以 InnoDB 对 B+Tree 的叶子节点和非叶子节点进行了区别对待，叶子节点有自己独有的区，非叶子节点也有自己独有的区，存放叶子节点的区的集合就是一个 <em>段</em>（segment），存放非叶子节点的区的集合也是一个段，也就是说一个索引会生成 2 个段，一个时叶子节点段，另一个非叶子节点段。</p>
<p>除了索引的叶子节点段和非叶子节点段之外，InnoDB 中还有为存储一些特殊的数据而定义的段，比如回滚段，常见的段有数据段、索引段和回滚段。数据段即 B+Tree 的叶子节点，索引段即 B+Tree 的非叶子节点。</p>
<p>在 InnoDB 存储引警中，段的管理都是由引擎自身所完成，DBA 不能、也没有必要对其进行控制，某种意义上简化了 DBA 的管理。</p>
<p>段其实不对应表空间中某个连续的物理区域，而是一个逻辑上的概率，由若干个零散的页面以及一些完整的区组成。</p>
<h2 id="4-3-为什么要有碎片区？"><a class="header-anchor" href="#4-3-为什么要有碎片区？"></a>4.3 为什么要有碎片区？</h2>
<p>默认情况下，一个使用 InnoDB 存储引擎的表只有一个聚簇索引，一个索引会生成 2 个段，段以区为单位申请存储空间，一个区默认占 1M 的存储空间，因此默认情况下一个只存了几条记录的小表也需要 2M 的存储空间吗？以后每次添加一个索引都要多申请 2M 的存储空间吗？显然不是这样的。</p>
<p>目前为止介绍的区都是纯粹的，一个区被整个分配到某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在，即使段中的数据填不满区中所有的页面，余下的页面也不会挪作他用。</p>
<p>为了考虑上述情况，InnoDB 提出了 <em>碎片区(fragment)</em> 的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，碎片区中的页可以用于不同的目的，比如某些页用于段 A，某些页用于段 B，甚至可能不属于任何段。</p>
<p><strong>碎片区直属于表空间，不属于任何段。</strong></p>
<p>为某个段分配存储空间的策略应该是：</p>
<ul>
<li>在刚向表中插入数据时，段从某个碎片区以单个页面为单位进行存储空间的分配</li>
<li>当某个段已经占用了 32 个碎片区页面后，申请以完整的区为单位来分配存储空间</li>
</ul>
<p><strong>段不能仅定义为某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。</strong></p>
<h2 id="4-4-区的分类"><a class="header-anchor" href="#4-4-区的分类"></a>4.4 区的分类</h2>
<p>区大体上可以分为 4 种类型：</p>
<ol>
<li>空闲的区（FREE）：现在还没有用到这个区中的任何页面</li>
<li>有剩余空间的碎片区（FREE_FRAG）：碎片区中还有可用的页面</li>
<li>没有剩余空间的碎片区（FULL_FRAG）：碎片区中的所有页面都被使用，没有空闲页面</li>
<li>附属于某个段的区（FSEG）：每一个索引都可以分为叶子节点段和非叶子节点段</li>
</ol>
<p>处于 FREE、FREE_FRAG 以及 FULL_FRAG 这三种状态的区都是独立的，直属于表空间；而处于 FSEG 状态的区是附属于某个段的。</p>
<p>如果把表空间比作成一个集团军，段就相当于师，区相当于团。一般的团都隶属于某个师，就像是处于 FSEG 的区全都隶属于某个段，而处于 FREE、FREE_FRAG 以及 FULL_FRAG 这三种状态的区却直接隶属于表空间，类似独立团直接听命于军部。</p>
<h1 id="5-表空间"><a class="header-anchor" href="#5-表空间"></a>5. 表空间</h1>
<p>表空间可以看做是 InnoDB 存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。</p>
<p>表空间是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库由一个或多个表空间组成，表空间从管理上可以划分为：</p>
<ul>
<li>
<p>系统表空间（System Tablespace）</p>
</li>
<li>
<p>独立表空间（File-per-table Tablespace）</p>
</li>
<li>
<p>撤销表空间（Undo Tablespace）</p>
</li>
<li>
<p>临时表空间（Temporary Tablespace）等</p>
</li>
</ul>
<h2 id="5-1-独立表空间"><a class="header-anchor" href="#5-1-独立表空间"></a>5.1 独立表空间</h2>
<p>独立表空间，即每张表都有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间（即单表）可以在不同的数据库之间进行迁移。</p>
<p>空间可以回收（<code>DROP TABLE</code> 操作可自动回收表空间；其他情况，表空间不能自己回收）。如果对于统计分析或日志表，删除大量数据后可以通过 <code>ALTER TABLE table_name ENGINE=InnoDB;</code> 回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片都不会太严重影响性能，且还有机会处理。</p>
<p>独立表空间由段、区、页组成。</p>
<blockquote>
<p>真实表空间对应的文件大小</p>
</blockquote>
<p>到数据目录里看，会发现一个新建的表对应的 <code>.ibd</code> 文件只占用了 96K（仅在 MySQL 5.7 中，因为 MySQL 8.0 中还保存了表结构，<code>.frm</code> 文件也融入到 <code>.idb</code> 文件中了），仅 6 个页面大小，这是因为一开始表里边都没有数据。<code>.ibd</code> 文件是自扩展的，随着表中数据的增多，表空间对应的文件也会逐渐增大。</p>
<blockquote>
<p>查看 InnoDB 的表空间类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_file_per_table&#x27;;</span><br></pre></td></tr></table></figure>
<pre>
mysql> SHOW VARIABLES LIKE 'innodb_file_per_table';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| innodb_file_per_table | ON    |
+-----------------------+-------+
</pre>
<p>Value 为 <code>ON</code>，这意味着每张表都会单独保存为一个 <code>.idb</code> 文件。</p>
<h2 id="5-2-系统表空间"><a class="header-anchor" href="#5-2-系统表空间"></a>5.2 系统表空间</h2>
<p>系统表空间的结构和独立表空间基本类似，只不过整个 MySQL 进程只有一个系统表空间，相比于独立表空间，在系统表空间中会额外记录一些有关整个系统信息的页面。</p>
<p>每向一个表中插入一条记录，MySQL 还会有如下的校验过程：</p>
<ul>
<li>
<p>校验插入语句对应的表是否存在、插入的列和表中的列是否相符合等语法</p>
</li>
<li>
<p>判断插入表的聚族索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的 B+Tree 中</p>
</li>
</ul>
<p>所以说，MySQL 除了保存着插入的用户数据之外，还需要保存许多额外的信息，比如：</p>
<ul>
<li>某个表属于哪个表空间，表内有多少个列</li>
<li>表中的每个列是什么类型</li>
<li>表中有多少个索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面</li>
<li>表中有多少个外键，外键都对应了哪些列</li>
<li>某个表空间对应文件系统上的文件路径是什么</li>
<li>…</li>
</ul>
<p>上述这些数据并不是用户使用 <code>INSERT</code> 语句插入的用户数据，实是为了更好地管理用户数据而不得不引入的额外数据，这些数据也被称为 <em>元数据</em>。InnoDB 存储引擎特意定义了一些列的内部系统表（Internal System Table）来记录这些元数据：</p>
<table>
<thead>
<tr>
<th style="text-align:center">表名</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>SYS_TABLES</code></td>
<td style="text-align:center">整个 InnoDB 存储引擎中所有的 <strong>表</strong> 的信息</td>
</tr>
<tr>
<td style="text-align:center"><code>SYS_COLUMNS</code></td>
<td style="text-align:center">整个 InnoDB 存储引擎中所有的 <strong>列</strong> 的信息</td>
</tr>
<tr>
<td style="text-align:center"><code>SYS_INDEXES</code></td>
<td style="text-align:center">整个 InnoDB 存储引擎中所有的 <strong>索引</strong> 的信息</td>
</tr>
<tr>
<td style="text-align:center"><code>SYS_FIELDS</code></td>
<td style="text-align:center">整个 InnoDB 存储引擎中所有的 <strong>索引对应的列</strong> 的信息</td>
</tr>
<tr>
<td style="text-align:center">SYS_FOREIGN</td>
<td style="text-align:center">整个 InnoDB 存储引擎中所有的 <strong>外键</strong> 的信息</td>
</tr>
<tr>
<td style="text-align:center">SYS_FOREIGN_COLS</td>
<td style="text-align:center">整个 InnoDB 存储引擎中所有的 <strong>外键对应的列</strong> 的信息</td>
</tr>
<tr>
<td style="text-align:center">SYS_TABLESPACES</td>
<td style="text-align:center">整个 InnoDB 存储引擎中所有的 <strong>表空间</strong> 信息</td>
</tr>
<tr>
<td style="text-align:center">SYS_DATAFILES</td>
<td style="text-align:center">整个 InnoDB 存储引擎中所有的 <strong>表空间对应文件系统的文件路径</strong> 信息</td>
</tr>
<tr>
<td style="text-align:center">SYS_VIRTUAL</td>
<td style="text-align:center">整个 InnoDB 存储引擎中所有的 <strong>虚拟生成的列</strong> 信息</td>
</tr>
</tbody>
</table>
<p>这些系统表也被称为 <em>数据字典</em>，它们都以 B+Tree 的形式保存在系统表空间的某些页面中，其中 <code>SYS_TABLES</code>、<code>SYS_COLUMNS</code>、<code>SYS_INDEXES</code> 和 <code>SYS_FIELDS</code> 这四个表尤为重要，称之为 <em>基本系统表</em>（Basic System Tables）。</p>
<p><mark>注意：</mark> 用户不能直接访问 InnoDB 的内部系统表，除非直接去解析系统表空间对应文件系统上的文件。不过考虑到查看这些表的内容可能有助于分析问题，所以在系统数据库 <code>information_schema</code> 中提供了一些以 <code>INNODB_SYS</code> 开头的表：</p>
<pre>
mysql> USE information_schema;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A <br />
Database changed
mysql> SHOW TABLES LIKE 'INNODB_SYS%';
Empty set (0.00 sec) <br />
mysql> SHOW TABLES LIKE 'INNODB%';
+----------------------------------------+
| Tables_in_information_schema (INNODB%) |
+----------------------------------------+
| INNODB_BUFFER_PAGE                     |
| INNODB_BUFFER_PAGE_LRU                 |
| INNODB_BUFFER_POOL_STATS               |
| INNODB_CACHED_INDEXES                  |
| INNODB_CMP                             |
| INNODB_CMPMEM                          |
| INNODB_CMPMEM_RESET                    |
| INNODB_CMP_PER_INDEX                   |
| INNODB_CMP_PER_INDEX_RESET             |
| INNODB_CMP_RESET                       |
| INNODB_COLUMNS                         |
| INNODB_DATAFILES                       |
| INNODB_FIELDS                          |
| INNODB_FOREIGN                         |
| INNODB_FOREIGN_COLS                    |
| INNODB_FT_BEING_DELETED                |
| INNODB_FT_CONFIG                       |
| INNODB_FT_DEFAULT_STOPWORD             |
| INNODB_FT_DELETED                      |
| INNODB_FT_INDEX_CACHE                  |
| INNODB_FT_INDEX_TABLE                  |
| INNODB_INDEXES                         |
| INNODB_METRICS                         |
| INNODB_SESSION_TEMP_TABLESPACES        |
| INNODB_TABLES                          |
| INNODB_TABLESPACES                     |
| INNODB_TABLESPACES_BRIEF               |
| INNODB_TABLESTATS                      |
| INNODB_TEMP_TABLE_INFO                 |
| INNODB_TRX                             |
| INNODB_VIRTUAL                         |
+----------------------------------------+
31 rows in set (0.01 sec)
</pre>
<p><mark>注意：</mark> MySQL 8.0 中无需末尾的 <code>SYS</code>，否则查不出数据。</p>
<p>在 <code>information_schema</code> 数据库中的以 <code>INNODB_SYS</code> 开头的表并不是真正的内部系统表，而是在存储引警启动时读取这些以 <code>SYS</code> 开头的系统表后填充到这些表中的。它们中的字段并不完全一样，但供日常参考已经足矣。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mofan212.github.io">默烦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mofan212.github.io/posts/MySQL-Advanced-Seventh-Data-Storage-Structure-Of-InnoDB/">https://mofan212.github.io/posts/MySQL-Advanced-Seventh-Data-Storage-Structure-Of-InnoDB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://mofan212.github.io" target="_blank">Mofan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post-share"><div class="social-share" data-image="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/146.jpg" data-sites="wechat,qq,weibo,facebook,x"></div><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" target="_blank"><img class="post-qr-code-img" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" target="_blank"><img class="post-qr-code-img" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/MySQL-Advanced-Sixth-Data-Structure-Of-Index/" title="【MySQL 高级篇六】索引的数据结构"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/145.jpg" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">【MySQL 高级篇六】索引的数据结构</div></div><div class="info-2"><div class="info-item-1">本文介绍了 MySQL 中 InnoDB 存储引擎的索引的数据结构。</div></div></div></a><a class="pagination-related" href="/posts/Goodbye-2023-Hello-2024/" title="再见癸卯，你好甲辰"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/147.jpg" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">再见癸卯，你好甲辰</div></div><div class="info-2"><div class="info-item-1">人生若只如初见，何事秋风悲画扇。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/Constraint-Of-MySQL/" title="【MySQL 四】约束"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/108.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-18</div><div class="info-item-2">【MySQL 四】约束</div></div><div class="info-2"><div class="info-item-1">本文介绍了 MySQL 中约束的使用，并给出添加、删除约束的方式。</div></div></div></a><a class="pagination-related" href="/posts/Installing-MySQL-Under-Windows/" title="【MySQL 补充】Windows 下 MySQL 的安装"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/136.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="info-item-2">【MySQL 补充】Windows 下 MySQL 的安装</div></div><div class="info-2"><div class="info-item-1">本文介绍了 MySQL 在 Windows 下的安装与卸载，以及常见问题的解决。</div></div></div></a><a class="pagination-related" href="/posts/DDL-And-DML-Of-MySQL/" title="【MySQL 二】DDL 与 DML"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/106.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-11</div><div class="info-item-2">【MySQL 二】DDL 与 DML</div></div><div class="info-2"><div class="info-item-1">本文介绍了 MySQL 中的 DDL 与 DML，并对其进行拓展。</div></div></div></a><a class="pagination-related" href="/posts/MySQL-Advanced-First-Use-Of-MySQL-Under-Linux/" title="【MySQL 高级篇一】Linux 下 MySQL 的使用"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/128.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-26</div><div class="info-item-2">【MySQL 高级篇一】Linux 下 MySQL 的使用</div></div><div class="info-2"><div class="info-item-1">本文介绍了 Linux 下 MySQL 的使用以及 MySQL 的字符集、SQL 大小写规范和 sql_mode 的合理设置。</div></div></div></a><a class="pagination-related" href="/posts/MySQL-Advanced-Second-Data-Directory-Of-MySQL/" title="【MySQL 高级篇二】MySQL 的数据目录"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/129.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="info-item-2">【MySQL 高级篇二】MySQL 的数据目录</div></div><div class="info-2"><div class="info-item-1">本文介绍了 MySQL 8.0 的主要目录结构、数据库和文件系统的关系。</div></div></div></a><a class="pagination-related" href="/posts/Data-Type-Of-MySQL/" title="【MySQL 三】数据类型"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/107.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="info-item-2">【MySQL 三】数据类型</div></div><div class="info-2"><div class="info-item-1">本文介绍了 MySQL 中的十一种数据类型，并在每种数据类型的讲解中给出使用示例。</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">默烦</div><div class="author-info-description">彩笔的打怪升级之路...</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">174</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mofan212"><i class="fab fa-github"></i><span>follow me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:cy.mofan@foxmail.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站所有博文均是博主的学习笔记与个人理解。<strong><font style="color:red">除特别注明外，</font>如需转载，请在文章头部醒目处附带原文链接并<a href="./mine/" style="color:#49B1F5;text-decoration:underline">告知我</a></strong>你将转载。😊</br><strong><font style="color:red">严禁未遵循规范的转载。</font></strong>😡</br><strong>死去的评论系统复活啦！欢迎到留言板畅所欲言！</strong>当然也可以使用更高效的<a target="_blank" href="https://space.bilibili.com/23658864/dynamic" style="color:#49B1F5;text-decoration:underline"> 哔哩哔哩私信 </a>或<a href="mailto:cy.mofan@foxmail.com" style="color:#49B1F5;text-decoration:underline" target="_blank">邮箱</a>。 😉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">1. 数据库的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%A3%81%E7%9B%98%E4%B8%8E%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D"><span class="toc-text">1.1 磁盘与内存交互的基本单位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E9%A1%B5%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-text">1.2 页结构概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E9%A1%B5%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">1.3 页的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E9%A1%B5%E7%9A%84%E4%B8%8A%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-text">1.4 页的上层结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E9%A1%B5%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">2. 页的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-File-Header"><span class="toc-text">2.1 File Header</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-File-Trailer"><span class="toc-text">2.2 File Trailer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Free-Space"><span class="toc-text">2.3 Free Space</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-User-Records"><span class="toc-text">2.4 User Records</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-Infimum-Supremum"><span class="toc-text">2.5 Infimum + Supremum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-Page-Directory"><span class="toc-text">2.6 Page Directory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-Page-Header"><span class="toc-text">2.7 Page Header</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E4%BB%8E%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B-B-Tree-%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="toc-text">2.8 从数据页的角度看 B+Tree 的查询</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-InnoDB-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">3. InnoDB 行格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-COMPACT"><span class="toc-text">3.1 COMPACT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%A1%8C%E6%BA%A2%E5%87%BA"><span class="toc-text">3.2 行溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Dynamic-%E5%92%8C-Compressed"><span class="toc-text">3.3 Dynamic 和 Compressed</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Redundant"><span class="toc-text">3.4 Redundant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%8C%BA%E3%80%81%E6%AE%B5%E3%80%81%E7%A2%8E%E7%89%87%E5%8C%BA"><span class="toc-text">4. 区、段、碎片区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8C%BA%EF%BC%9F"><span class="toc-text">4.1 为什么要有区？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E6%AE%B5%EF%BC%9F"><span class="toc-text">4.2 为什么要有段？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%A2%8E%E7%89%87%E5%8C%BA%EF%BC%9F"><span class="toc-text">4.3 为什么要有碎片区？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%8C%BA%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">4.4 区的分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">5. 表空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%8B%AC%E7%AB%8B%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">5.1 独立表空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">5.2 系统表空间</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Something-About-Blog/" title="博客搭建与维护"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/42.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="博客搭建与维护"/></a><div class="content"><a class="title" href="/posts/Something-About-Blog/" title="博客搭建与维护">博客搭建与维护</a><time datetime="2026-01-24T16:00:00.000Z" title="更新于 2026-01-25 00:00:00">2026-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Memory-Model/" title="Java 内存模型"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/174.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Java 内存模型"/></a><div class="content"><a class="title" href="/posts/Java-Memory-Model/" title="Java 内存模型">Java 内存模型</a><time datetime="2026-01-02T16:00:00.000Z" title="更新于 2026-01-03 00:00:00">2026-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Bytecode-And-Class-Loading/" title="字节码与类加载"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/173.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="字节码与类加载"/></a><div class="content"><a class="title" href="/posts/Java-Bytecode-And-Class-Loading/" title="字节码与类加载">字节码与类加载</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Class-Resource-Loading-In-Java/" title="Java 的类资源加载"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/103.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Java 的类资源加载"/></a><div class="content"><a class="title" href="/posts/Class-Resource-Loading-In-Java/" title="Java 的类资源加载">Java 的类资源加载</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Annotation-And-Reflection/" title="注解、类的加载、反射"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/20.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="注解、类的加载、反射"/></a><div class="content"><a class="title" href="/posts/Annotation-And-Reflection/" title="注解、类的加载、反射">注解、类的加载、反射</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ren-zhi-jue-xing/" title="认知觉醒"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/172.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="认知觉醒"/></a><div class="content"><a class="title" href="/posts/ren-zhi-jue-xing/" title="认知觉醒">认知觉醒</a><time datetime="2025-12-28T16:00:00.000Z" title="更新于 2025-12-29 00:00:00">2025-12-29</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2020 - 2026 By 默烦</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://testingcf.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://testingcf.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://testingcf.jsdelivr.net/npm/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://testingcf.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://testingcf.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://testingcf.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://gcore.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources@master/js/mine.min.js"></script><script src="/js/tip_portal.js"></script><script defer="defer" id="ribbon" src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-show-text" src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Azathoth,Yog-Sothoth,Shub-Niggurath,Nyarlathotep,Cthulhu,Hastur,Abhoth,Ghroth,Tsathoggua,Cthugha,Deep Ones,Dagon,Chaugnar Faugn,Mordiggian,Shoggoth,Old One,Mi-Go,Great Race of Yith,Flying Polyp,Hounds of Tindalos,Dhole" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://testingcf.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'BAFEL7A6K1',
    apiKey: '89fcb5961984c5c054bf04149f345f38',
    indexName: 'mofan212io',
    container: '#docsearch',
    placeholder: '输入关键字进行搜索',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【算法】图的最短路径 | Mofan</title><meta name="author" content="默烦,cy.mofan@foxmail.com"><meta name="copyright" content="默烦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文基于数据结构——图，介绍了最短路径的基本概念和求解最短路径的三个经典算法：Dijkstra、Bellman-Ford和Floyd。">
<meta property="og:type" content="article">
<meta property="og:title" content="【算法】图的最短路径">
<meta property="og:url" content="https://mofan212.github.io/posts/Algorithm-Shortest-Path/index.html">
<meta property="og:site_name" content="Mofan">
<meta property="og:description" content="本文基于数据结构——图，介绍了最短路径的基本概念和求解最短路径的三个经典算法：Dijkstra、Bellman-Ford和Floyd。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/53.jpg">
<meta property="article:published_time" content="2020-08-30T16:00:00.000Z">
<meta property="article:modified_time" content="2020-08-31T16:00:00.000Z">
<meta property="article:author" content="默烦">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/53.jpg"><link rel="shortcut icon" href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/favicon.png"><link rel="canonical" href="https://mofan212.github.io/posts/Algorithm-Shortest-Path/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://jsd.proxy.aks.moe/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://jsd.proxy.aks.moe/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://jsd.proxy.aks.moe/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"距离本文上次更新已经过去","messageNext":"天，请注意时效性。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 默烦","link":"链接: ","source":"来源: Mofan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【算法】图的最短路径',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-09-01 00:00:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="referrer" content="no-referrer-when-downgrade" /><link rel="stylesheet" href="https://jsd.proxy.aks.moe/gh/mofan212/blog-static-resources@master/css/myStyle.min.css"><link rel="stylesheet" href="https://cdn.staticfile.net/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><link rel="stylesheet" href="https://jsd.proxy.aks.moe/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css" /><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Mofan" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://jsd.proxy.aks.moe/gh/mofan212/blog-static-resources/css/fill-left.min.css"/><script src="https://jsd.proxy.aks.moe/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">151</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/post_top_img.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Mofan"><span class="site-name">Mofan</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【算法】图的最短路径</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-30T16:00:00.000Z" title="发表于 2020-08-31 00:00:00">2020-08-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-08-31T16:00:00.000Z" title="更新于 2020-09-01 00:00:00">2020-09-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Algorithm/">Algorithm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【算法】图的最短路径"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>封面画师：Nengoro(ネんごろぅ)     封面ID：66360374</p>
<p>本文参考视频：小马哥教育(SEEMYGO) 2019年 恋上数据结构与算法（第二季）</p>
<p>源码仓库：<a target="_blank" rel="noopener" href="https://github.com/mofan212/data-structure-and-algorithm">mofan212/data-structure-and-algorithm (github.com)</a></p>
<p>辅助学习网址：<a target="_blank" rel="noopener" href="https://visualgo.net/zh">数据结构和算法动态可视化</a>     <a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a></p>
<h1 id="1-最短路径"><a class="header-anchor" href="#1-最短路径"></a>1.最短路径</h1>
<h2 id="1-1-基本含义"><a class="header-anchor" href="#1-1-基本含义"></a>1.1 基本含义</h2>
<p>最短路径是指两个顶点之间权值之和最小的路径（有向图、无向图均使用，不能有<span style="color:red">负权环</span>）。</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/AlgorithmImages/最短路径.png" alt="最短路径" style="zoom: 50%;" />
<p>对于无权图来说也有最短路径的概念，可以认为无权图相当于是全部边权值为 1 的有权图。</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/AlgorithmImages/无权图的最短路径.png" alt="无权图的最短路径" style="zoom:50%;" />
<p>如果图中<span style="color:darkorange ">存在负权边</span>，但是<mark>没有负权环</mark>的时候，这个图也有最短路径。</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/AlgorithmImages/存在负权边的图.png" alt="存在负权边的图" style="zoom:67%;" />
<p>比如对于上图给出的存在负权边的图来说，A 到 E 的最短路径是： A – B – E</p>
<p>但是如果图中<mark>存在负权环</mark> ，那么这个图不存在最短路径。</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/AlgorithmImages/存在负权环的图.png" alt="存在负权环的图" style="zoom:67%;" />
<p>通过负权环， A 到 E 的路径可以无限短。</p>
<h2 id="1-2-求解算法"><a class="header-anchor" href="#1-2-求解算法"></a>1.2 求解算法</h2>
<p>最短路径的典型应用之一： 路径规划问题。</p>
<p>求解最短路径的三个经典算法：</p>
<ul>
<li>单源最短路径算法
<ul>
<li>Dijkstra （迪杰斯特拉算法）</li>
<li>Bellman-Ford （贝尔曼-福特算法）</li>
</ul>
</li>
<li>多源最短路径算法
<ul>
<li>Floyd（弗洛伊德算法）</li>
</ul>
</li>
</ul>
<h1 id="2-Dijkstra"><a class="header-anchor" href="#2-Dijkstra"></a>2. Dijkstra</h1>
<h2 id="2-1-基本概念"><a class="header-anchor" href="#2-1-基本概念"></a>2.1 基本概念</h2>
<p>Dijkstra 属于单源最短路径算法，用于计算一个顶点到其他所有顶点的最短路径。</p>
<p>使用前提： 图中不能有<mark>负权边</mark></p>
<p>时间复杂度： <strong>可优化</strong>至<code>O(ElogV)</code> ，E 是边数量， V 是节点数量。我们待会实现的 Dijkstra 的时间复杂度并不是<code>O(ElogV)</code>，因为我们没有用到堆。</p>
<p>该算法由荷兰科学家 Edsger Wybe Dijkstra 发明，曾在 1972 年获得图灵奖， “goto有害论” 也是他提出来的。2002 年，与癌症抗争多年后，Dijkstra 去世，这一年的 PODC 奖颁给了他，获奖论文是他 1974 年关于自稳定系统的论文。<strong>为了纪念他，PODC 决定从 2003 年把这个奖项改名为 Dijkstra 奖。所以 Dijkstra 是少数获得过以自己的名字命名的奖项的人之一。</strong></p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/AlgorithmImages/Dijkstra.jpg" alt="Dijkstra" style="zoom:33%;" />
<h2 id="2-2-等价思考"><a class="header-anchor" href="#2-2-等价思考"></a>2.2 等价思考</h2>
<p>Dijkstra 算法的原理其实跟生活中的一些自然现象完全一样。</p>
<p>把图上每一个顶点都想象成一块小石头，每一条边都想象成一条绳子，每一条绳子都连接着两块小石头，边的权值就是绳子的长度。将小石头和绳子平放在桌子上（下图是一张俯视图，图中黄色表示桌子）：</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/AlgorithmImages/Dijkstra等价思考_1.png" alt="Dijkstra等价思考_1" style="zoom:50%;" />
<p>接下来想象一下，手拽这小石头 A ，慢慢地向上提起来，远离桌面。</p>
<p>那么， B、D、C、E 会依次离开桌面：</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/AlgorithmImages/Dijkstra等价思考_2.png" alt="Dijkstra等价思考_2" style="zoom: 50%;" />
<p>在提起小石头 A 后，桌面上的小石头会依次离开桌面，当最后一块小石头离开桌面后，一些绳子会绷直，而有些绳子会耷拉着，那么这些绷直的绳子就是 A 到其他小石头的最短路径。</p>
<p>依次离开的顺序取决于： 小石头 A 到其他石头的最短路径。</p>
<p>在这一顿操作中，有一个很关键的信息： <strong>后离开桌面的小石头，都是被先离开桌面的小石头拉起来的</strong> 。</p>
<h2 id="2-3-执行过程"><a class="header-anchor" href="#2-3-执行过程"></a>2.3 执行过程</h2>
<p>图中黑色顶点表示“源头”，指最先被拽起来的石头。</p>
<p>图中红色顶点表示直接连着被拽起来的石头的顶点，指下一步就可能被拽起来的石头。</p>
<p>而对于右边的表格来说，绿色表示已经“离开桌面”，已经确定了最终的最短路径；红色表示更新了最短路径信息。</p>
<ul>
<li>步骤一： 以顶点 A 为源点，求出 A 与能够直接到达的顶点之间的距离，最终确定 A 到 B 之间的最短路径；</li>
</ul>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/AlgorithmImages/Dijkstra%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B1.png" alt="Dijkstra执行流程1"></p>
<ul>
<li>步骤二： 继续求得 A 到 D 之间的最短路径；</li>
</ul>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/AlgorithmImages/Dijkstra%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B2.png" alt="Dijkstra执行流程2"></p>
<p>松弛操作（Relaxation）：更新2个顶点之间的最短路径。</p>
<p>这里一般是指：更新源点到另一个点的最短路径。</p>
<p>如何理解更新两个顶点之间最短路径的操作叫松弛操作呢？ 😕 可以把原来两个顶点之间的最短路径看成一根绳子，在没有更新最短路径前，这根绳子是绷直的，但是等到更新了新的最短路径后，新的路径相比于原来的路径更短，那么<strong>原来的绳子就会变得松弛</strong> ，新的最短路径的 “绳子” 就会被绷直。</p>
<p>松弛操作的意义：  <strong>尝试</strong>找出更短的路径长度，以便求出最短路径。需要注意的是，并不是每一次松弛操作都是有效的，就是说可能最先的路径就是最短的，那么后面进行的松弛操作就是无效的。</p>
<ul>
<li>步骤三：确定 A 到 D 的最短路径后，对 DC 、 DE 边进行松弛操作，更新了 A 到 C 、 A 到 E 的最短路径，这样就求出了源点 A 到其他顶点之间的最短路径。</li>
</ul>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/AlgorithmImages/Dijkstra%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B3.png" alt="Dijkstra执行流程3"></p>
<hr>
<p>如果源头是 A ，要求得 A 到其他顶点的最短路径，就要对 A 的 outedges 进行松弛操作，就可以算出 A 到这些顶点可能存在的最短路径。然后从这些路径长度中找出最短的路径，这个最短的路径就是 A 到那个顶点的最短路径，这样就确认了一条最短路径。确认后，对那个顶点的 outedges 进行松弛操作，更新路径长度，又找出其中最小的，确认第二条最短路径，以此类推直到求出 A 到其他顶点的所有最短路径。</p>
<h2 id="2-4-编码实现"><a class="header-anchor" href="#2-4-编码实现"></a>2.4 编码实现</h2>
<p>在实现 Dijkstra 算法之前，需要先在接口<code>Graph</code>中添加方法，假设命名为<code>shortestPath(V begin)</code>，表示求得从 begin 出发到其他顶点的最短路径。</p>
<p>那么问题来了，返回值是什么？ 😨</p>
<p>对于返回值来说，最短路径长度是必要的（最短的权值之和），那么还有其他需要返回吗？ 😰</p>
<p>有的！ 如果可以，最好将最短路径连同最短路径长度一起返回出去。</p>
<p>我们先初步实现 Dijkstra 算法，将返回值设置为 Map ，Map 中的 key 是其他顶点的 value，Map 中的 value 就是源点到其他顶点之间最短路径长度。即： <code>Graph</code>接口中完整的方法是<code>Map&lt;V, E&gt; shortestPath(V begin)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Map&lt;V, E&gt; <span class="title function_">shortestPath</span><span class="params">(V begin)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>初步实现</p>
</blockquote>
<p>还是惯例，先说说思路：</p>
<p>1、获取源点（通过方法传递的参数获取），并判断是否非空</p>
<p>2、初始化两个 HashMap ，一个命名为<code>selectPaths</code>表示已经确定了的最短路径，一个命名为<code>paths</code>表示待确定的最短路径 “ 们 ”</p>
<p>3、从源点出发，初始化<code>paths</code></p>
<p>4、重复执行以下操作，直到<code>paths</code>为空，<code>paths</code>为空时，方法返回<code>selectPaths</code>：</p>
<ul>
<li>获取<code>paths</code>中最短的一条路径<code>minVertex</code></li>
<li>将<code>minVertex</code>加入到<code>selectPaths</code>中，将<code>minVertex</code>从<code>paths</code>中删除</li>
<li>然后对<code>minVertex</code>的 outEdges 进行松弛操作</li>
</ul>
<hr>
<p>在上述的思路整理中，涉及到两个要点：一个是从<code>paths</code>中获取最短的路径，另一个是对<code>minVertex</code>的 outEdges 进行松弛操作。</p>
<p>从<code>paths</code>中获取最短的路径时，<code>paths</code>的类型是 HashMap ，我们可以采用最小堆来实现，但是使用最小堆实现有很多要点和技巧。我们选择最简单的实现方式，采用遍历方式一个个进行比较最后选出路径最小的。要对 HashMap 中的数据进行遍历，可以使用<code>entrySet()</code>方法，这个方法可以返回一个包含了原 Map 中数据的 Set 集合。</p>
<p>在获取<code>paths</code>中的最短路径时，由于 Set 中数据是无序的，无法直接获得第一个元素。因此我们可以设置一个临时变量，这个临时变量用来存储最短的路径，等到将所有路径都比较完后，就直接返回这个临时变量即可。</p>
<p>这个临时变量在最开始时会将其设置为<code>null</code>，在遍历 Set 时将遍历到的第一个元素赋值给这个临时变量，然后再使用这个临时变量和 Set 中其他元素进行比较，求出<code>paths</code>中的最短路径。为了减少临时变量的非空判断次数，我们可以使用迭代器，让这个临时变量的初始值设置成迭代器中 0 位置的元素。✌️</p>
<p>对<code>minVertex</code>的 outEdges 进行松弛操作时，就是将新的可选择的最短路径<code>newWeight</code>和以前的最短路径<code>oldWeight</code>进行比较，选出其中最短的路径。如果最短的路径是新的可选择的最短路径，就用该路径覆盖以前的最短路径，反之则不用覆盖。</p>
<p>新的可选择的最短路径指的是源点到<code>minVertex</code>的 outEdges的遍历结果 edge.from 的最短路径加上 edge.weight； 以前的最短路径指的是源点到<code>minVertex</code>的 outEdges的遍历结果 edge.to 的最短路径。</p>
<p>进行松弛操作有一些注意要点，如果<code>minVertex</code>的 outEdges的遍历结果 edge.to 已经存入<code>selectPaths</code>或者 edge.to <code>equals</code> 源点，那么就没必要进行松弛操作。同时<code>oldWeight</code>为null时，可以理解为距离无穷，那么直接设置将<code>newWeight</code>放进<code>paths</code>即可。👊</p>
<hr>
<p>那么，初步实现 Dijkstra 算法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;V, E&gt; <span class="title function_">shortestPath</span><span class="params">(V begin)</span> &#123;</span><br><span class="line">    Vertex&lt;V, E&gt; beginVertex = vertices.get(begin);</span><br><span class="line">    <span class="keyword">if</span> (beginVertex == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;V, E&gt; selectPaths = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Vertex&lt;V, E&gt;, E&gt; paths = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化 paths</span></span><br><span class="line">    <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : beginVertex.outEdges) &#123;</span><br><span class="line">        paths.put(edge.to, edge.weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!paths.isEmpty()) &#123;</span><br><span class="line">        Map.Entry&lt;Vertex&lt;V, E&gt;, E&gt; minEntry = getMinPath(paths);</span><br><span class="line">        <span class="comment">// minEntry 离开桌面</span></span><br><span class="line">        Vertex&lt;V, E&gt; minVertex = minEntry.getKey();</span><br><span class="line">        selectPaths.put(minVertex.value, minEntry.getValue());</span><br><span class="line">        paths.remove(minVertex);</span><br><span class="line">        <span class="comment">// 对它的 minEntry 的 outEdges 进行松弛操作</span></span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : minVertex.outEdges) &#123;</span><br><span class="line">            <span class="comment">// 如果 edge.to 已经离开桌面，那么就没必要进行松弛操作</span></span><br><span class="line">            <span class="keyword">if</span> (selectPaths.containsKey(edge.to.value) </span><br><span class="line">                <span class="comment">/* || edge.to.equals(beginVertex)*/</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 新的可选择的最短路径： beginVertex 到 edge.from 的最短路径 + edge.weight</span></span><br><span class="line">            <span class="type">E</span> <span class="variable">newWeight</span> <span class="operator">=</span> weightManager.add(minEntry.getValue(), edge.weight);</span><br><span class="line">            <span class="comment">// 以前的最短路径： beginVertex 到 edge.to 的最短路径</span></span><br><span class="line">            <span class="type">E</span> <span class="variable">oldWeight</span> <span class="operator">=</span> paths.get(edge.to);</span><br><span class="line">            <span class="comment">// oldWeight为null时，表示距离无穷，直接设置将newWeight放进paths即可</span></span><br><span class="line">            <span class="keyword">if</span> (oldWeight == <span class="literal">null</span> || weightManager.compare(newWeight, oldWeight) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                paths.put(edge.to, newWeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果第 23 行代码不进行源点判断时</span></span><br><span class="line">    selectPaths.remove(begin);</span><br><span class="line">    <span class="keyword">return</span> selectPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从 paths 中挑选一个最短的路径</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> paths 路径集合</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 顶点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Map.Entry&lt;Vertex&lt;V, E&gt;, E&gt; <span class="title function_">getMinPath</span><span class="params">(Map&lt;Vertex&lt;V, E&gt;, E&gt; paths)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用迭代器从 Set 的第一个元素开始遍历比较</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;Vertex&lt;V, E&gt;, E&gt;&gt; iterator = paths.entrySet().iterator();</span><br><span class="line">    Map.Entry&lt;Vertex&lt;V, E&gt;, E&gt; minEntry = iterator.next();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;Vertex&lt;V, E&gt;, E&gt; entry = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (weightManager.compare(entry.getValue(), minEntry.getValue()) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            minEntry = entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minEntry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是 Dijkstra 算法初步实现的代码，以经过初步测试，可放心 “食用”！😃</p>
<blockquote>
<p>算法完善</p>
</blockquote>
<p>在初步实现中，我们给其返回值设置为<code>Map&lt;V, E&gt;</code>，其中  V 表示源点到达的顶点， E 表示最短路径的权值之和。</p>
<p>但是我们真正想要的，并不是直接返回到达的顶点而是返回路径，当然也要返回最终到达的点和最短路径的权值之和。</p>
<p>因此需要更改接口<code>Graph</code>中的<code>shortestPath()</code>方法的返回值，使其返回值能够包含最短路径信息，路径信息其实就是边信息，只不过是有顺序的边信息，因此我们可以使用线性表来存储多个边信息，达到存储路径的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Map&lt;V, PathInfo&lt;V, E&gt;&gt; <span class="title function_">shortestPath</span><span class="params">(V begin)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PathInfo</span>&lt;V, E&gt;&#123;</span><br><span class="line">    <span class="keyword">protected</span> E weight;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(E weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;EdgeInfo&lt;V, E&gt;&gt; <span class="title function_">getEdgeInfos</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edgeInfos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEdgeInfos</span><span class="params">(List&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.edgeInfos = edgeInfos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PathInfo&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;weight=&quot;</span> + weight +</span><br><span class="line">            <span class="string">&quot;, edgeInfos=&quot;</span> + edgeInfos +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口更改后，前往<code>ListGraph</code>类中更改实现的<code>shortestPath()</code>方法。</p>
<p>在修改<code>shortestPath()</code>时，将与返回值相关的 HashMap 的 value 类型修改为 <code>PathInfo&lt;V, E&gt;</code>。</p>
<p>同时<code>getMinPath()</code>方法的返回值类型和参数类型也要进行修改，方法内的临时变量类型也要进行修改。</p>
<p>为了后续方便实现 <em><strong>Bellman-Ford</strong></em> 算法，在这里将松弛操作的代码抽取出来，单独写成一个方法<code>relaxForDijkstra()</code>。抽取代码时，内部部分代码逻辑相比于初步实现的代码逻辑也发生了些许改变，注意理解。💢</p>
<p>PS：透露一下，<em><strong>Bellman-Ford</strong></em>算法中用不到这里抽取的松弛操作代码，因此将其命名为<code>relaxForDijkstra()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;V, PathInfo&lt;V, E&gt;&gt; <span class="title function_">shortestPath</span><span class="params">(V begin)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dijkstra(begin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Map&lt;V, PathInfo&lt;V, E&gt;&gt; <span class="title function_">dijkstra</span><span class="params">(V begin)</span> &#123;</span><br><span class="line">    Vertex&lt;V, E&gt; beginVertex = vertices.get(begin);</span><br><span class="line">    <span class="keyword">if</span> (beginVertex == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;V, PathInfo&lt;V, E&gt;&gt; selectPaths = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化 Paths</span></span><br><span class="line">    <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : beginVertex.outEdges) &#123;</span><br><span class="line">        <span class="comment">// 修改</span></span><br><span class="line">        PathInfo&lt;V, E&gt; path = <span class="keyword">new</span> <span class="title class_">PathInfo</span>&lt;&gt;();</span><br><span class="line">        path.weight = edge.weight;</span><br><span class="line">        path.edgeInfos.add(edge.info());</span><br><span class="line">        paths.put(edge.to, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!paths.isEmpty()) &#123;</span><br><span class="line">        Map.Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; minEntry = getMinPath(paths);</span><br><span class="line">        <span class="comment">// minEntry 离开桌面</span></span><br><span class="line">        Vertex&lt;V, E&gt; minVertex = minEntry.getKey();</span><br><span class="line">        PathInfo&lt;V, E&gt; minPath = minEntry.getValue();</span><br><span class="line">        selectPaths.put(minVertex.value, minPath);</span><br><span class="line">        paths.remove(minVertex);</span><br><span class="line">        <span class="comment">// 对它的 minEntry 的 outEdges 进行松弛操作</span></span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : minVertex.outEdges) &#123;</span><br><span class="line">            <span class="comment">// 如果 edge.to 已经离开桌面，那么就没必要进行松弛操作</span></span><br><span class="line">            <span class="keyword">if</span> (selectPaths.containsKey(edge.to.value)) <span class="keyword">continue</span>;</span><br><span class="line">            relaxForDijkstra(edge, minPath, paths);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    selectPaths.remove(begin);</span><br><span class="line">    <span class="keyword">return</span> selectPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Dijkstra 的松弛操作</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> edge     需要松弛的边</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> fromPath edge 的 from 的最短路径信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> paths    存放着其它点可能存在的最短路径信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">relaxForDijkstra</span><span class="params">(Edge&lt;V, E&gt; edge, PathInfo&lt;V, E&gt; fromPath, Map&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths)</span> &#123;</span><br><span class="line">    <span class="comment">// 新的可选择的最短路径： beginVertex 到 edge.from 的最短路径 + edge.weight</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">newWeight</span> <span class="operator">=</span> weightManager.add(fromPath.weight, edge.weight);</span><br><span class="line">    <span class="comment">// 以前的最短路径： beginVertex 到 edge.to 的最短路径</span></span><br><span class="line">    PathInfo&lt;V, E&gt; oldPath = paths.get(edge.to);</span><br><span class="line">    <span class="keyword">if</span> (oldPath != <span class="literal">null</span> &amp;&amp; weightManager.compare(newWeight, oldPath.weight) &gt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldPath == <span class="literal">null</span>) &#123;</span><br><span class="line">        oldPath = <span class="keyword">new</span> <span class="title class_">PathInfo</span>&lt;&gt;();</span><br><span class="line">        paths.put(edge.to, oldPath);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldPath.edgeInfos.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    oldPath.weight = newWeight;</span><br><span class="line">    oldPath.edgeInfos.addAll(fromPath.edgeInfos);</span><br><span class="line">    oldPath.edgeInfos.add(edge.info());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 paths 中挑选一个最短的路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paths 路径集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 顶点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map.Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; <span class="title function_">getMinPath</span><span class="params">(Map&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用迭代器从 Set 的第一个元素开始遍历比较</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt;&gt; iterator = paths.entrySet().iterator();</span><br><span class="line">    Map.Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; minEntry = iterator.next();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; entry = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (weightManager.compare(entry.getValue().weight, minEntry.getValue().weight) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            minEntry = entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minEntry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是 Dijkstra 算法完善后的代码，以经过初步测试，可放心 “食用”！👏</p>
<p>上述代码其实还可以进行优化修改，<code>getMinPath()</code>方法是从 paths 中选取一条最短的路径，根据以前学过的数据结构，可以使用最小堆来实现，但这里的最小堆结构会发生变化，进而产生一些问题，有兴趣可以尝试一下。</p>
<hr>
<p>在 Dijkstra 算法中，要求图中不能够存在 <mark>负权边</mark>，注意这里是负权边。虽然在最开始时，我们说过没有<strong>负权环</strong>的图有最短路径，但是对于 Dijkstra 算法来说，<mark>负权边</mark> 都不能有，更不要说 负权环了。</p>
<p>那么问题来说，有没有一种算法也是单源最短路径算法，而且图中有负权边也能够计算呢？</p>
<p>那当然是有的， <em><strong>Bellman-Ford</strong></em> 就是这样的一种算法！</p>
<h1 id="3-Bellman-Ford"><a class="header-anchor" href="#3-Bellman-Ford"></a>3. Bellman-Ford</h1>
<h2 id="3-1-基本概念"><a class="header-anchor" href="#3-1-基本概念"></a>3.1 基本概念</h2>
<p>Bellman-Ford 也属于单源最短路径算法，支持负权边，还<strong>能够检测出是否含有负权环</strong>  。</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/meme/%E6%B5%81%E5%BC%8A.jpg" alt="流弊" style="zoom:67%;" />
<p><strong>算法原理：</strong> 对<strong>所有的边</strong>进行 V - 1 次松弛操作（V 是节点数量），得到所有可能的最短路径</p>
<p><strong>时间复杂度：</strong> <code>O(EV)</code>， E 是边数量， V 是节点数量</p>
<p>下图的最好情况是恰好按<strong>从左到右</strong>的顺序对边进行松弛操作：</p>
<p>对<strong>所有边</strong>仅需进行 1 次松弛操作就能计算出 A 到达其他所有顶点的最短路径。</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/AlgorithmImages/最好的情况从左到右松弛操作.png" alt="最好的情况从左到右松弛操作" style="zoom:50%;" />
<p>最坏情况是恰好每次都是<strong>从右到左</strong>的顺序对边进行松弛操作：</p>
<p>对<strong>所有边</strong>需进行 V - 1 次松弛操作才能计算出 A 到达其他所有顶点的最短路径。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/AlgorithmImages/%E6%9C%80%E5%A5%BD%E7%9A%84%E6%83%85%E5%86%B5%E4%BB%8E%E5%8F%B3%E5%88%B0%E5%B7%A6%E6%9D%BE%E5%BC%9B%E6%93%8D%E4%BD%9C.png" alt="最好的情况从右到左松弛操作"></p>
<h2 id="3-2-实际案例"><a class="header-anchor" href="#3-2-实际案例"></a>3.2 实际案例</h2>
<p>假设一个图有八条边、六个顶点，然后使用 Bellman-Ford 进行松弛操作，其过程如下：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/AlgorithmImages/Bellman-Ford%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B1.png" alt="Bellman-Ford实际案例1"></p>
<p><mark>对上图</mark>某一条进行松弛操作时，判断能否松弛成功，就看这条边的起始顶点的最短路径是否已经确认或起始顶点是否是源点，如果已经确认或者是源点，那么就可以松弛成功，反之则不可以松弛成功。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/AlgorithmImages/Bellman-Ford%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B2.png" alt="Bellman-Ford实际案例2"></p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/AlgorithmImages/Bellman-Ford%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B3.png" alt="Bellman-Ford实际案例3"></p>
<p>不难分析出，经过 4 次松弛操作之后，已经计算出了 A 到其他所有顶点的最短路径。</p>
<blockquote>
<p>概述一下</p>
</blockquote>
<p>就是从求最短路径的图中选取所有的边，对这些边进行<code>V - 1</code>次松弛操作（V 指节点数量），直到确认最短路径。</p>
<p>当然，也有可能没有进行<code>V -1 </code>次就松弛操作已经求得了最短路径，但是最多进行<code>V - 1</code>次松弛操作一定可以求得最短路径（除非图中有<strong>负权环</strong>）。</p>
<h2 id="3-3-编码实现"><a class="header-anchor" href="#3-3-编码实现"></a>3.3 编码实现</h2>
<p>设置一个临时变量<code>count</code>，这个临时变量的值等于图中的顶点数减一。</p>
<p>设置一个循环，在这个循环内遍历当前图的所有边，对这些边进行松弛操作，循环次数为<code>count</code>次。</p>
<p>与 <em><strong>Dijkstra</strong></em> 相同的是，<em><strong>Bellman-Ford</strong></em> 一开始也要获取源点（通过方法传递的参数获取），并判断是否非空。但是也有不相同的地方，比如 <em><strong>Dijkstra</strong></em> 需要初始化两个 HashMap ，一个命名为<code>selectPaths</code>表示已经确定了的最短路径，还有一个命名为<code>paths</code>表示待确定的最短路径 “ 们 ”，但是对于 <em><strong>Bellman-Ford</strong></em> 来说后者并不需要，而且在 <em><strong>Bellman-Ford</strong></em> 中，<code>selectPaths</code> 的类型修改为<code>Map&lt;V, PathInfo&lt;V, E&gt;&gt;</code>。</p>
<p>同时，我们在进行松弛操作时，需要获取<code>selectPaths</code>中的边信息。在一开始时，<code>selectPaths</code>中没有任何边信息，获取到的边信息是空，在这里需要进行判断。如果获取到的边信息是空，直接<code>continue</code>即可。</p>
<p>但是这样又会出现一个问题，一开始时<code>selectPaths</code>是空的，无法获取到边信息，这个时候又直接<code>continue</code>了，那么就会一直无法进行松弛操作，因此我们需要在初始化<code>selectPaths</code>时，在这个 HashMap 中添加源点自身到自身的路径信息，最后在方法返回前删除添加的源点路径信息。添加的路径信息中不能设置边信息，因为图中自身到自身是没有边的，这只是我们假想的，但是需要添加路径权值。路径权值应该是零，这个零对于不同的类型可能不一样，比如对于整型来说，零就是<code>0</code>；对于双浮点数来说，零就是<code>0.0</code>；对于自定义类型来说，零就有可能是该类型中某个属性值为零。</p>
<p>这个零值应该是由用户决定的，用户使用了什么类型，这个零值就应该跟着变化，那么可以在<code>Graph</code>接口中的<code>WeightManager</code>接口添加一个方法<code>zero()</code>，这个方法让用户可以自行编写对象的零值，将零值的变化交给用户控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WeightManager</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(E w1, E w2)</span>;</span><br><span class="line">    E <span class="title function_">add</span><span class="params">(E w1, E w2)</span>;</span><br><span class="line">    <span class="comment">// 用户自行编写的对象的零值</span></span><br><span class="line">    E <span class="title function_">zero</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这样的方法，我们还可以对 Dijkstra 进行修改，修改源点的初始化。在修改之前给<code>Graph</code>接口中的<code>PathInfo</code>内部类添加两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PathInfo</span>&lt;V, E&gt;&#123;</span><br><span class="line">    <span class="keyword">protected</span> E weight;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PathInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PathInfo</span><span class="params">(E weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 get/set 方法、toString() 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改 Dijkstra 的源点初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;V, PathInfo&lt;V, E&gt;&gt; <span class="title function_">dijkstra</span><span class="params">(V begin)</span> &#123;</span><br><span class="line">    Vertex&lt;V, E&gt; beginVertex = vertices.get(begin);</span><br><span class="line">    <span class="keyword">if</span> (beginVertex == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;V, PathInfo&lt;V, E&gt;&gt; selectPaths = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    paths.put(beginVertex, <span class="keyword">new</span> <span class="title class_">PathInfo</span>&lt;&gt;(weightManager.zero()));</span><br><span class="line">        <span class="comment">// 初始化 Paths</span></span><br><span class="line"><span class="comment">//        for (Edge&lt;V, E&gt; edge : beginVertex.outEdges) &#123;</span></span><br><span class="line"><span class="comment">//            PathInfo&lt;V, E&gt; path = new PathInfo&lt;&gt;();</span></span><br><span class="line"><span class="comment">//            path.weight = edge.weight;</span></span><br><span class="line"><span class="comment">//            path.edgeInfos.add(edge.info());</span></span><br><span class="line"><span class="comment">//            paths.put(edge.to, path);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略最短路径的选取与松弛操作 </span></span><br><span class="line">    </span><br><span class="line">    selectPaths.remove(begin);</span><br><span class="line">    <span class="keyword">return</span> selectPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>在最开始介绍 <em><strong>Bellman-Ford</strong></em> 时，这个算法<strong>可以检测出是否含有负权环</strong> ，那么应该怎么检测呢？</p>
<p><em><strong>Bellman-Ford</strong></em> 最多对每条边进行 <code>V - 1</code> 次松弛操作，如果图中含有负权环的话，就可以进行超过最多次的松弛操作。那么我们就可以在方法最后再进行一次松弛操作，看看这一次松弛操作能否成功进行。</p>
<p>那么问题又来了，怎么判断松弛操作是否成功进行呢？</p>
<p>我们可以将松弛操作的返回值设置成布尔类型的就可以了，成功进行了松弛操作就返回<code>true</code>，反之就返回<code>false</code>。</p>
<p>那么最终 Bellman-Ford 的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;V, PathInfo&lt;V, E&gt;&gt; <span class="title function_">shortestPath</span><span class="params">(V begin)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bellmanFord(begin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;V, PathInfo&lt;V, E&gt;&gt; <span class="title function_">bellmanFord</span><span class="params">(V begin)</span> &#123;</span><br><span class="line">    Vertex&lt;V, E&gt; beginVertex = vertices.get(begin);</span><br><span class="line">    <span class="keyword">if</span> (beginVertex == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;V, PathInfo&lt;V, E&gt;&gt; selectPaths = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 添加源点自身到自身的路径信息</span></span><br><span class="line">    PathInfo&lt;V, E&gt; beginPath = <span class="keyword">new</span> <span class="title class_">PathInfo</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 设置源点的零值</span></span><br><span class="line">    beginPath.weight = weightManager.zero();</span><br><span class="line">    <span class="comment">// 将源点添加至selectPaths中</span></span><br><span class="line">    selectPaths.put(begin, beginPath);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> vertices.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : edges) &#123;</span><br><span class="line">            PathInfo&lt;V, E&gt; fromPath = selectPaths.get(edge.from.value);</span><br><span class="line">            <span class="keyword">if</span> (fromPath == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            relax(edge, fromPath, selectPaths);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : edges) &#123;</span><br><span class="line">        PathInfo&lt;V, E&gt; fromPath = selectPaths.get(edge.from.value);</span><br><span class="line">        <span class="keyword">if</span> (fromPath == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (relax(edge, fromPath, selectPaths)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前图内存在负权环&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 从selectPaths中删除源点</span></span><br><span class="line">    selectPaths.remove(begin);</span><br><span class="line">    <span class="keyword">return</span> selectPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bellman-Ford 的松弛操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> edge     需要松弛的边</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromPath edge 的 from 的最短路径信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paths    存放着其它点可能存在的最短路径信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">relax</span><span class="params">(Edge&lt;V, E&gt; edge, PathInfo&lt;V, E&gt; fromPath, Map&lt;V, PathInfo&lt;V, E&gt;&gt; paths)</span> &#123;</span><br><span class="line">    <span class="comment">// 新的可选择的最短路径： beginVertex 到 edge.from 的最短路径 + edge.weight</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">newWeight</span> <span class="operator">=</span> weightManager.add(fromPath.weight, edge.weight);</span><br><span class="line">    <span class="comment">// 以前的最短路径： beginVertex 到 edge.to 的最短路径</span></span><br><span class="line">    PathInfo&lt;V, E&gt; oldPath = paths.get(edge.to.value);</span><br><span class="line">    <span class="keyword">if</span> (oldPath != <span class="literal">null</span> &amp;&amp; weightManager.compare(newWeight, oldPath.weight) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldPath == <span class="literal">null</span>) &#123;</span><br><span class="line">        oldPath = <span class="keyword">new</span> <span class="title class_">PathInfo</span>&lt;&gt;();</span><br><span class="line">        paths.put(edge.to.value, oldPath);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldPath.edgeInfos.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    oldPath.weight = newWeight;</span><br><span class="line">    oldPath.edgeInfos.addAll(fromPath.edgeInfos);</span><br><span class="line">    oldPath.edgeInfos.add(edge.info());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是 Bellman-Ford 的代码，以经过初步测试，可放心 “食用”！💪</p>
<h1 id="4-Floyd"><a class="header-anchor" href="#4-Floyd"></a>4. Floyd</h1>
<h2 id="4-1-概念与原理"><a class="header-anchor" href="#4-1-概念与原理"></a>4.1 概念与原理</h2>
<p>Floyd 属于<strong>多源最短路径算法</strong> ，能够求出任意 2 个顶点之间的最短路径，支持负权边。</p>
<p>要实现求出任意 2 个顶点之间的最短路径，也可以多次使用 Dijkstra 来求得最短路径。</p>
<p>时间复杂度： <strong>O(V<sup>3</sup>)</strong> ，效率比执行 V 次 Dijkstra 算法要好（V 是顶点数量）</p>
<blockquote>
<p>算法原理</p>
</blockquote>
<p>从任意顶点 i 到任意顶点 j 的最短路径不外乎有两种可能：</p>
<p>①、直接从 i 到 j</p>
<p>②、从 i 经过若干个顶点到 j</p>
<p>假设 dist(i, j) 为顶点 i 到顶点 j 的最短路径的距离</p>
<p>对于每一个顶点 k ，检查 dist(i, k) + dist(k, j) &lt; dist(i, j) 是否成立</p>
<ul>
<li>如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到 j 的路径短，设置 dist(i, j) = dist(i, k) + dist(k, j)</li>
<li>当我们遍历完所有节点 k ，dist(i, j) 中记录的便是 i 到 j 的最短路径的距离</li>
</ul>
<p><strong>伪代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; V; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; V; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dist(i, k) + dist(k, j) &lt; dist(i, j)) &#123;</span><br><span class="line">                dist(i, j) = dist(i, k) + dist(k, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-编码实现"><a class="header-anchor" href="#4-2-编码实现"></a>4.2 编码实现</h2>
<p>在编码实现之前，首先得明白什么叫做 “ 多源最短路径算法 ” ，理解了这个概念后，才可以编写正确的接口。</p>
<p>所谓 “ 多源最短路径算法 ” 指的就说从图中的每一个顶点出发，到其他顶点的最短路径的算法。</p>
<p>在 “ 单源最短路径算法 ” 中，我们的接口方法是<code>Map&lt;V, PathInfo&lt;V, E&gt;&gt; shortestPath(V begin)</code>，表示源点 begin 到 value 为 V 的顶点的最短路径信息是 PathInfo&lt;V, E&gt; 类型的。</p>
<p>但是对于 “ 多源最短路径算法 ” 来说，源点是有多个的，并不是只有一个，因此接口方法就可以不用传递参数。既然源点不止一个，那么如何返回不同源点的最短路径信息呢？</p>
<p>初看似乎很难，实则很简单。<strong>不同的源点到达不同的顶点对应了不同的最短路径信息</strong> ，因此可以在单源最短路径算法接口返回值类型的基础上套一层 Map ，最终得到在<code>Graph</code>接口下的 “ 多源最短路径算法 ”  接口方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多源最短路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; <span class="title function_">shortestPath</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>接口方法编写完成后，前往<code>ListGraph</code>类实现刚编写的接口方法。</p>
<hr>
<p>在实现接口时需要先实例一个返回值类型的 HashMap ，最后的返回数据就是实例化的这个 HashMap。</p>
<p>初始化后，这个 Map 内是没有任何数据的，我们待会需要从这个 Map 中提取数据，因此还需要对这个 Map 进行初始化，初始化 Map 就是将图中每一条边都放到这个 Map 中。</p>
<p>初始化完成后，使用伪代码一样的逻辑将真正的代码编写出来，<strong>注意空值判断</strong> 。</p>
<p>伪代码逻辑遍历图中的顶点，需要进行三层遍历，每次遍历可以拿到一个顶点，总共三个顶点。这三个顶点可以确定三条边，需要注意的是这三个顶点任意两个不能相同，如果存在相同，确定的边就只有一条，为了避免这种情况，需要在<strong>遍历内部加上顶点相同判断</strong> 。</p>
<p>这三个顶点的任意两个顶点之间可能不存在直接相连的边，因此还<strong>需要注意空边的情况</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; <span class="title function_">shortestPath</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (Edge&lt;V, E&gt; edge : edges) &#123;</span><br><span class="line">        <span class="comment">// edge.from.value 作为起点到 V 之间的路径信息</span></span><br><span class="line">        Map&lt;V, PathInfo&lt;V, E&gt;&gt; map = paths.get(edge.from.value);</span><br><span class="line">        <span class="keyword">if</span> (map == <span class="literal">null</span>) &#123;</span><br><span class="line">            map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            paths.put(edge.from.value, map);</span><br><span class="line">        &#125;</span><br><span class="line">        PathInfo&lt;V, E&gt; pathInfo = <span class="keyword">new</span> <span class="title class_">PathInfo</span>&lt;&gt;(edge.weight);</span><br><span class="line">        pathInfo.edgeInfos.add(edge.info());</span><br><span class="line">        map.put(edge.to.value, pathInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vertices.forEach((V v2, Vertex&lt;V, E&gt; vertex2) -&gt; &#123;</span><br><span class="line">        vertices.forEach((V v1, Vertex&lt;V, E&gt; vertex1) -&gt; &#123;</span><br><span class="line">            vertices.forEach((V v3, Vertex&lt;V, E&gt; vertex3) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1.equals(v2) || v1.equals(v3) || v2.equals(v3)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// v1 -&gt; v2</span></span><br><span class="line">                PathInfo&lt;V, E&gt; path12 = getPathInfo(v1, v2, paths);</span><br><span class="line">                <span class="keyword">if</span> (path12 == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// v2 -&gt; v3</span></span><br><span class="line">                PathInfo&lt;V, E&gt; path23 = getPathInfo(v2, v3, paths);</span><br><span class="line">                <span class="keyword">if</span> (path23 == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// v1 -&gt; v3</span></span><br><span class="line">                PathInfo&lt;V, E&gt; path13 = getPathInfo(v1, v3, paths);</span><br><span class="line"></span><br><span class="line">                <span class="type">E</span> <span class="variable">newWeight</span> <span class="operator">=</span> weightManager.add(path12.weight, path23.weight);</span><br><span class="line">                <span class="keyword">if</span> (path13 != <span class="literal">null</span> &amp;&amp; weightManager.compare(newWeight, path13.weight) &gt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (path13 == <span class="literal">null</span>) &#123;</span><br><span class="line">                    path13 = <span class="keyword">new</span> <span class="title class_">PathInfo</span>&lt;&gt;();</span><br><span class="line">                    paths.get(v1).put(v3, path13);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    path13.edgeInfos.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新数据</span></span><br><span class="line">                path13.weight = newWeight;</span><br><span class="line">                path13.edgeInfos.addAll(path12.edgeInfos);</span><br><span class="line">                path13.edgeInfos.addAll(path23.edgeInfos);</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多源最短路径算法中获取路径信息</span></span><br><span class="line"><span class="keyword">private</span> PathInfo&lt;V, E&gt; <span class="title function_">getPathInfo</span><span class="params">(V from, V to, Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; paths)</span> &#123;</span><br><span class="line">    Map&lt;V, PathInfo&lt;V, E&gt;&gt; map = paths.get(from);</span><br><span class="line">    <span class="keyword">return</span> map == <span class="literal">null</span> ? <span class="literal">null</span> : map.get(to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是 Floyd 的代码，以经过初步测试，可放心 “食用”！😊</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mofan212.github.io">默烦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mofan212.github.io/posts/Algorithm-Shortest-Path/">https://mofan212.github.io/posts/Algorithm-Shortest-Path/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mofan212.github.io" target="_blank">Mofan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm</a></div><div class="post_share"><div class="social-share" data-image="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/53.jpg" data-sites="wechat,qq,weibo,facebook,twitter"></div><link rel="stylesheet" href="https://jsd.proxy.aks.moe/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://jsd.proxy.aks.moe/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" target="_blank"><img class="post-qr-code-img" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" target="_blank"><img class="post-qr-code-img" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/Algorithm-Recursion/" title="【编程技巧】递归"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/54.jpg" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【编程技巧】递归</div></div></a></div><div class="next-post pull-right"><a href="/posts/Algorithm-Topological-Sort-And-MST/" title="【算法】拓扑排序与最小生成树"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/52.jpg" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【算法】拓扑排序与最小生成树</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/Algorithm-Non-Comparative-Sort/" title="【排序算法】三种非比较排序"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/49.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-18</div><div class="title">【排序算法】三种非比较排序</div></div></a></div><div><a href="/posts/Algorithm-Merge-Sort/" title="【排序算法】归并排序"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/47.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-15</div><div class="title">【排序算法】归并排序</div></div></a></div><div><a href="/posts/Algorithm-Insertion-Sort/" title="【排序算法】插入排序和二分搜索"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/46.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-13</div><div class="title">【排序算法】插入排序和二分搜索</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">默烦</div><div class="author-info__description">彩笔的打怪升级之路...</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">151</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/23658864/dynamic"><i class="fas fa-running"></i><span>关注我的B站</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mofan212" target="_blank" title="GitHub"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:cy.mofan@foxmail.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站所有博文均是博主的学习笔记与个人理解。<strong><font style="color:red">除特别注明外，</font>如需转载，请在文章头部醒目处附带原文链接并<a target="_blank" rel="noopener" href="https://mofan212.gitee.io/mine/" style="color:#49B1F5;text-decoration:underline">告知我</a></strong>你将转载。😊</br><strong><font style="color:red">严禁未遵循规范的转载。</font></strong>😡</br><strong>死去的评论系统复活啦！欢迎到留言板畅所欲言！</strong>当然也可以使用更高效的<a target="_blank" href="https://space.bilibili.com/23658864/dynamic" style="color:#49B1F5;text-decoration:underline"> 哔哩哔哩私信 </a>或<a href="mailto:cy.mofan@foxmail.com" style="color:#49B1F5;text-decoration:underline" target="_blank">邮箱</a>。 😉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">1.最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89"><span class="toc-text">1.1 基本含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%B1%82%E8%A7%A3%E7%AE%97%E6%B3%95"><span class="toc-text">1.2 求解算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Dijkstra"><span class="toc-text">2. Dijkstra</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">2.1 基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%AD%89%E4%BB%B7%E6%80%9D%E8%80%83"><span class="toc-text">2.2 等价思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">2.3 执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.4 编码实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Bellman-Ford"><span class="toc-text">3. Bellman-Ford</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1 基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B"><span class="toc-text">3.2 实际案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.3 编码实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Floyd"><span class="toc-text">4. Floyd</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-text">4.1 概念与原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.2 编码实现</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Lambda-Expression-And-Functional-Programming/" title="Lambda 表达式与函数式编程"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/152.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Lambda 表达式与函数式编程"/></a><div class="content"><a class="title" href="/posts/Java-Lambda-Expression-And-Functional-Programming/" title="Lambda 表达式与函数式编程">Lambda 表达式与函数式编程</a><time datetime="2024-07-19T16:00:00.000Z" title="更新于 2024-07-20 00:00:00">2024-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Lambda-And-Serialization/" title="Lambda 与序列化"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/104.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Lambda 与序列化"/></a><div class="content"><a class="title" href="/posts/Lambda-And-Serialization/" title="Lambda 与序列化">Lambda 与序列化</a><time datetime="2024-07-19T16:00:00.000Z" title="更新于 2024-07-20 00:00:00">2024-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/The-Basis-Of-Java-Multithreading/" title="学毛线（Thread）的 Java"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/57.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="学毛线（Thread）的 Java"/></a><div class="content"><a class="title" href="/posts/The-Basis-Of-Java-Multithreading/" title="学毛线（Thread）的 Java">学毛线（Thread）的 Java</a><time datetime="2024-07-10T16:00:00.000Z" title="更新于 2024-07-11 00:00:00">2024-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/SpringBoot-Shutdown-Hook/" title="SpringBoot Shutdown Hook"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/141.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="SpringBoot Shutdown Hook"/></a><div class="content"><a class="title" href="/posts/SpringBoot-Shutdown-Hook/" title="SpringBoot Shutdown Hook">SpringBoot Shutdown Hook</a><time datetime="2024-07-10T16:00:00.000Z" title="更新于 2024-07-11 00:00:00">2024-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/LinkedHashMap-In-JDK21/" title="JDK21 中的 LinkedHashMap"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/150.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="JDK21 中的 LinkedHashMap"/></a><div class="content"><a class="title" href="/posts/LinkedHashMap-In-JDK21/" title="JDK21 中的 LinkedHashMap">JDK21 中的 LinkedHashMap</a><time datetime="2024-07-06T16:00:00.000Z" title="更新于 2024-07-07 00:00:00">2024-07-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/The-Basics-Of-Linux-Part-One/" title="【上篇】Linux 基础"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/96.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="【上篇】Linux 基础"/></a><div class="content"><a class="title" href="/posts/The-Basics-Of-Linux-Part-One/" title="【上篇】Linux 基础">【上篇】Linux 基础</a><time datetime="2024-07-04T16:00:00.000Z" title="更新于 2024-07-05 00:00:00">2024-07-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 默烦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://jsd.proxy.aks.moe/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://jsd.proxy.aks.moe/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://jsd.proxy.aks.moe/npm/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://jsd.proxy.aks.moe/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://jsd.proxy.aks.moe/npm/mermaid@10.9.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://jsd.proxy.aks.moe/gh/mofan212/blog-static-resources@master/js/mine.min.js"></script><script src="https://npm.elemecdn.com/mermaid/dist/mermaid.min.js"></script><script defer="defer" id="ribbon" src="https://jsd.proxy.aks.moe/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://jsd.proxy.aks.moe/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Azathoth,Yog-Sothoth,Shub-Niggurath,Nyarlathotep,Cthulhu,Hastur,Abhoth,Ghroth,Tsathoggua,Cthugha,Deep Ones,Dagon,Chaugnar Faugn,Mordiggian,Shoggoth,Old One,Mi-Go,Great Race of Yith,Flying Polyp,Hounds of Tindalos,Dhole" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://jsd.proxy.aks.moe/npm/@docsearch/css/dist/style.min.css"/><script src="https://jsd.proxy.aks.moe/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'BAFEL7A6K1',
    apiKey: '89fcb5961984c5c054bf04149f345f38',
    indexName: 'mofan212io',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>
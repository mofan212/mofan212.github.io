<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 泛型 | Mofan</title><meta name="author" content="默烦,cy.mofan@foxmail.com"><meta name="copyright" content="默烦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文介绍了 JDK 1.5 引入的新特性——泛型，并对协变、逆变、自限定类型和捕获转换进行了说明。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 泛型">
<meta property="og:url" content="https://mofan212.github.io/posts/Java-Genericity/index.html">
<meta property="og:site_name" content="Mofan">
<meta property="og:description" content="本文介绍了 JDK 1.5 引入的新特性——泛型，并对协变、逆变、自限定类型和捕获转换进行了说明。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/58.jpg">
<meta property="article:published_time" content="2020-10-09T16:00:00.000Z">
<meta property="article:modified_time" content="2024-04-16T16:00:00.000Z">
<meta property="article:author" content="默烦">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/58.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mofan212.github.io/posts/Java-Genericity/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"距离本文上次更新已经过去","messageNext":"天，请注意时效性。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 默烦","link":"链接: ","source":"来源: Mofan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 泛型',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-17 00:00:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="referrer" content="no-referrer-when-downgrade" /><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/gh/mofan212/blog-static-resources@master/css/myStyle.min.css"><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/lxgw-wenkai-screen-webfont@1.7.0/style.css" /><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css" /><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Mofan" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/gh/mofan212/blog-static-resources/css/fill-left.min.css"/><script src="https://jsd.onmicrosoft.cn/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">149</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/post_top_img.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Mofan"><span class="site-name">Mofan</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java 泛型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-09T16:00:00.000Z" title="发表于 2020-10-10 00:00:00">2020-10-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-16T16:00:00.000Z" title="更新于 2024-04-17 00:00:00">2024-04-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java 泛型"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>封面来源：碧蓝航线 铁血、音符 &amp; 誓言 活动CG</p>
<p>本文参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kb411W75N?p=565">尚硅谷 宋红康 Java 零基础教程 P565-P576</a></p>
<p>其他参考链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2bf15c5265c5">Java泛型（二） 协变与逆变</a></p>
<h1 id="1-为什么要使用泛型？"><a class="header-anchor" href="#1-为什么要使用泛型？"></a>1. 为什么要使用泛型？</h1>
<h2 id="1-1-为什么要使用泛型"><a class="header-anchor" href="#1-1-为什么要使用泛型"></a>1.1 为什么要使用泛型</h2>
<p>学习一个知识，得先明白这玩意能干嘛，为什么要用它。如果连这都不清楚，学习后又有什么用呢？</p>
<p>集合容器类在设计阶段 / 声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以 <strong>在 JDK 1.5 之前只能把元素类型设计为 Object，JDK 1.5 之后使用泛型来解决这个问题。</strong> 因为这个时候除了元素的类型是不确定的，其他部分都是确定的，例如关于这个元素如何保存，如何管理等都是确定的，因此此时<mark>把元素的类型设计成一个参数，这个类型参数叫做范型。</mark></p>
<p><code>Collection&lt;E&gt;</code>，<code>List&lt;E&gt;</code>，<code>ArrayList&lt;E&gt; </code>其中 <code>&lt;E&gt;</code> 就是类型参数，即泛型。</p>
<h2 id="1-2-泛型的概念"><a class="header-anchor" href="#1-2-泛型的概念"></a>1.2 泛型的概念</h2>
<p><strong>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。</strong> 这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量创建对象时）确定（即传入实际的类型参数，也称为类型实参）。</p>
<p>从 JDK 1.5 以后，Java引入了“参数化类型（ Parameterized type）”的概念，允许我们在创建集合时再指定集合元素的类型，正如：<code>List&lt;String&gt;</code>， 这表明该 List 只能保存字符串类型的对象。</p>
<p>JDK 1.5 改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参。</p>
<h2 id="1-3-泛型有无的区别"><a class="header-anchor" href="#1-3-泛型有无的区别"></a>1.3 泛型有无的区别</h2>
<p>说了这个多，还是没说为啥要有泛型，直接 <code>Object</code> 不是也可以存数据吗？</p>
<p>主要原因有两点：</p>
<p>1、解决元素存储的安全性问题，就好比商品、药品是不同的类型，就不会弄错</p>
<p>2、解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别</p>
<p>在 JDK 1.5 以前使用集合时，由于没有引入泛型，则会：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/JavaImages/%E5%BD%93%E9%9B%86%E5%90%88%E4%B8%AD%E6%B2%A1%E6%9C%89%E6%B3%9B%E5%9E%8B%E6%97%B6.png" alt="当集合中没有泛型时"></p>
<blockquote>
<p>测试代码</p>
</blockquote>
<p>在集合中没有使用泛型时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在集合中未使用泛型时</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">// 需求：存放学生的成绩</span></span><br><span class="line">    list.add(<span class="number">78</span>);</span><br><span class="line">    list.add(<span class="number">76</span>);</span><br><span class="line">    list.add(<span class="number">89</span>);</span><br><span class="line">    list.add(<span class="number">88</span>);</span><br><span class="line">    <span class="comment">// 问题一 类型不安全</span></span><br><span class="line">    list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object score : list) &#123;</span><br><span class="line">        <span class="comment">// 问题二 强转时，可能出现 ClassCastException</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> ((Integer) score);</span><br><span class="line">        System.out.println(stuScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在集合中使用泛型，且使用迭代器进行遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在集合中使用泛型</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">78</span>);</span><br><span class="line">        list.add(<span class="number">76</span>);</span><br><span class="line">        list.add(<span class="number">89</span>);</span><br><span class="line">        list.add(<span class="number">88</span>);</span><br><span class="line">        <span class="comment">// 编译时就会进行类型检查，保证数据的安全</span></span><br><span class="line"><span class="comment">//        list.add(&quot;tom&quot;);</span></span><br><span class="line">        <span class="comment">// 方式一</span></span><br><span class="line">        <span class="keyword">for</span> (Integer score : list) &#123;</span><br><span class="line">            <span class="comment">// 避免了强制类型转换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> score;</span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二 迭代器</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">stuScore</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 HashMap 中使用泛型 迭代器进行遍历</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();</span></span><br><span class="line">        <span class="comment">// JDK 7 新特性：类型推断</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;Tom&quot;</span>, <span class="number">87</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Jerry&quot;</span>, <span class="number">87</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Jack&quot;</span>, <span class="number">67</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entries.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; next = iterator.next();</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> next.getKey();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> next.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot; ----&gt; &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><mark>需要注意的是：</mark> 泛型的类型必须是类，不能是基本数据类型，需要用到基本数据类型的位置，应该使用那个基本数据类型的包装类。</p>
<p>总的来说，使用泛型后有以下两个优点：</p>
<p>1、编译时就会进行类型检查，保证数据的安全</p>
<p>2、避免了强制类型转换</p>
<h1 id="2-自定义泛型"><a class="header-anchor" href="#2-自定义泛型"></a>2. 自定义泛型</h1>
<h2 id="2-1-自定义泛型类"><a class="header-anchor" href="#2-1-自定义泛型类"></a>2.1 自定义泛型类</h2>
<p>自定义泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.generic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 自定义泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    String orderName;</span><br><span class="line">    <span class="type">int</span> orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的内部结构就可以使用类的泛型</span></span><br><span class="line"></span><br><span class="line">    T orderT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(String orderName, <span class="type">int</span> orderId, T orderT)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderName = orderName;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">        <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getOrderT</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderT</span><span class="params">(T orderT)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;orderName=&#x27;&quot;</span> + orderName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, orderId=&quot;</span> + orderId +</span><br><span class="line">                <span class="string">&quot;, orderT=&quot;</span> + orderT +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承了自定义泛型类的两个子类。</p>
<p>不再是一个泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/9</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不再是一个泛型类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubOrder</span> <span class="keyword">extends</span> <span class="title class_">Order</span>&lt;Integer&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仍然是一个泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/9</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 仍然是一个泛型类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubOrder1</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Order</span>&lt;T&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/9</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 自定义泛型类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTest1</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果定义了泛型类，实例化没有指明类的范型，则认为泛型类型为 Object 类型</span></span><br><span class="line">        <span class="comment">// 要求：如果自定义了范型类，实例化时需要指明类的泛型</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order.setOrderT(<span class="number">123</span>);</span><br><span class="line">        order.setOrderT(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化时指明类的泛型</span></span><br><span class="line">        Order&lt;String&gt; order1 = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;&gt;(<span class="string">&quot;orderAA&quot;</span>, <span class="number">1001</span>, <span class="string">&quot;order:AA&quot;</span>);</span><br><span class="line">        order1.setOrderT(<span class="string">&quot;AA:hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SubOrder</span> <span class="variable">subOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubOrder</span>();</span><br><span class="line">        <span class="comment">// 由于子类在继承带泛型的父类时，指明了范型类型，则实例化子类对象时，不需要再指明泛型</span></span><br><span class="line">        subOrder.setOrderT(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        SubOrder1&lt;String&gt; subOrder1 = <span class="keyword">new</span> <span class="title class_">SubOrder1</span>&lt;&gt;();</span><br><span class="line">        subOrder1.setOrderT(<span class="string">&quot;subOrder1...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果子类在继承带泛型的父类时，指明了范型类型，则实例化子类对象时，不需要再指明泛型。</p>
<h2 id="2-2-要点重点"><a class="header-anchor" href="#2-2-要点重点"></a>2.2 要点重点</h2>
<p>1、泛型类可能有多个参数，此时应当将多个参数一起放在尖括号里。比如：<code>&lt;E1, E2, E3&gt;</code>。</p>
<p>2、泛型类的构造器如下：<code>public GenericClass()&#123;&#125;</code> ，而不是 <code>public GenericClass&lt;E&gt;()&#123;&#125;</code>。</p>
<p>3、实例化后，操作原来泛型的位置的结构必须与指定的泛型类型一致。</p>
<p>4、泛型不同的应用不能相互赋值，道理很简单，类型都不一样，赋值个 🔨 。</p>
<ul>
<li>尽管在编译时 <code>ArrayList&lt;String&gt;</code> 和 <code>ArrayList&lt;Integer&gt;</code> 是两种类型，但是在运行时只有一个 <code>ArrayList</code> 被加载到 JVM中。</li>
</ul>
<p>5、泛型如果不指定，将被擦除，泛型对应的类型均按照 <code>Object</code> 处理，但不等价于 <code>Object</code>。</p>
<ul>
<li><strong>经验之谈：</strong> 泛型要使用就一路使用，不使用就一直别使用。</li>
</ul>
<p>6、如果泛型类是一个接口或抽象类，则不可创建泛型类的对象。</p>
<p>7、JDK 1.7 后，有一个泛型简化操作：<code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</code></p>
<p>8、泛型的指定中不能使用基本数据类型，需要使用对应的包装类进行替代。</p>
<p>9、在类 / 接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。注意： <mark>在静态方法中不能使用类的泛型。</mark></p>
<p>10、异常类不能是泛型的。</p>
<p>11、不能使用 <code>new E[]</code> ，原因也很简单，此时的 E 还是相当于一个变量，而使用 new 关键字时，需要保证类是指明的，但是可以：<code>E[] elements = (E[])new Object[capacity];</code></p>
<ul>
<li>参考：ArrayList 源码中 声明：<code>Object[] elementData</code>，而非泛型参数类型数组。</li>
</ul>
<p>12、父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：</p>
<ul>
<li>
<p>子类不保留父类的泛型：按需实现</p>
<ul>
<li>没有类型，擦除</li>
<li>具体类型</li>
</ul>
</li>
<li>
<p>子类保留父类的泛型：泛型子类</p>
<ul>
<li>全部保留</li>
<li>部分保留</li>
</ul>
</li>
</ul>
<p>结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型。</p>
<h2 id="2-3-自定义泛型方法"><a class="header-anchor" href="#2-3-自定义泛型方法"></a>2.3 自定义泛型方法</h2>
<p>不是说方法中使用了类的泛型就叫做泛型方法，以下方法都不是泛型方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span>&lt;T&gt; &#123;</span><br><span class="line">    T orderT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下方法都不是泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getOrderT</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderT</span><span class="params">(T orderT)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。换句话说，泛型方法所属的类是不是泛型类没有关系。</p>
<p>泛型方法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">copyFromArrayToList</span><span class="params">(E[] array)</span> &#123;</span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (E e : array) &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型方法测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    Order&lt;String&gt; order = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;&gt;();</span><br><span class="line">    Integer[] array = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// 泛型方法在调用时，指明泛型参数的类型</span></span><br><span class="line">    List&lt;Integer&gt; list = order.copyFromArrayToList(array);</span><br><span class="line"></span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是： <mark>在静态方法中不能使用类的泛型，但泛型方法是可以声明为静态的。</mark> 原因也很简单，泛型参数是在调用方法时确定的，并非在实例化类时确定。</p>
<h2 id="2-4-使用场景"><a class="header-anchor" href="#2-4-使用场景"></a>2.4 使用场景</h2>
<p>在实际业务的数据访问层中，会涉及到大量的增删改查，我们可以将一些简单的增删改查提取出来，并将其设置成泛型类，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DAO</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 添加方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些简单的增删改查是可以复用的，基本上每个 DAO 中都有这些方法，因此将它们提取出来，后续使用的时候直接继承这个类就可以了。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudenDao</span> <span class="keyword">extends</span> <span class="title class_">DAO</span>&lt;Student&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-继承与泛型"><a class="header-anchor" href="#3-继承与泛型"></a>3. 继承与泛型</h1>
<p>假设 类A 是类 B 的父类，那么 <code>G&lt;A&gt;</code> 与 <code>G&lt;B&gt;</code> 有什么关系？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类 A 是类 B 的父类，G&lt;A&gt; 与 G&lt;B&gt; 无子父类关系，二者是并列关系</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    obj = str;</span><br><span class="line"></span><br><span class="line">    Object[] arr1 = <span class="literal">null</span>;</span><br><span class="line">    String[] arr2 = <span class="literal">null</span>;</span><br><span class="line">    arr1 = arr2;</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 此时 list1 与 list2 的类型不具备子父类关系</span></span><br><span class="line">    list1 = list2; <span class="comment">// 报错，编译不通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码在编译器中直接报错，编译不通过，证明是不能那么写的。</p>
<p>但是现在又有另外一种情况，类 A 是类 B 的父类，<code>A&lt;G&gt;</code> 与 <code>B&lt;G&gt;</code> 又有什么关系呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类 A 是类 B 的父类，A&lt;G&gt; 是 B&lt;G&gt; 的父类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    AbstractList&lt;String&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">    ArrayList&lt;String&gt; list3 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下情况并不会报错</span></span><br><span class="line">    list1 = list3;</span><br><span class="line">    list2 = list3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单！👍</p>
<h1 id="4-通配符"><a class="header-anchor" href="#4-通配符"></a>4. 通配符</h1>
<h2 id="4-1-简单使用"><a class="header-anchor" href="#4-1-简单使用"></a>4.1 简单使用</h2>
<p>上文说到：类A 是类 B 的父类， <code>G&lt;A&gt;</code> 与 <code>G&lt;B&gt;</code> 是没有子父类关系的，但是它俩还是有一点关系的。这里涉及到通配符 <code>?</code> 的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通配符 ? 的使用</span></span><br><span class="line"><span class="comment">// 类 A 是类 B 的父类，G&lt;A&gt; 与 G&lt;B&gt; 是没有关系的，两者共同的父类是 G&lt;?&gt;</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下代码不会报错</span></span><br><span class="line">    list = list1;</span><br><span class="line">    list = list2;</span><br><span class="line"></span><br><span class="line">    print(list1);</span><br><span class="line">    print(list2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-写入与读取"><a class="header-anchor" href="#4-2-写入与读取"></a>4.2 写入与读取</h2>
<p>在使用了通配符 <code>?</code> 后，可以进行写入和读取数据吗？</p>
<p>在 4.1 的测试代码中进行修改，最终得到以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">        List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        list = list1;</span><br><span class="line">        list = list2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        print(list1);</span></span><br><span class="line"><span class="comment">//        print(list2);</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list3.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        list3.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">        list3.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">        list = list3;</span><br><span class="line">        <span class="comment">// 添加：对于 List&lt;?&gt; 就不能向其内部添加数据了</span></span><br><span class="line">        <span class="comment">// 除了添加 null</span></span><br><span class="line">        list.add(<span class="string">&quot;DD&quot;</span>); <span class="comment">// 报错</span></span><br><span class="line">        list.add(<span class="literal">null</span>); <span class="comment">// 这不会报错</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取（读取）：允许读取，读取的数据类型是 Object</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(o); <span class="comment">// 输出 AA</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>总结一下，对于 <code>List&lt;?&gt;</code> 不能向其内部添加数据（除了 <code>null</code>，但是并没有什么用，谁没事添加这玩意），但可以读取其中的数据，读取的数据类型是 <code>Object</code> 。</p>
<h2 id="4-3-存在限制条件"><a class="header-anchor" href="#4-3-存在限制条件"></a>4.3 存在限制条件</h2>
<p>在有些代码中，我们可以看到以下类似的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list1 = <span class="literal">null</span>; </span><br><span class="line">List&lt;? <span class="built_in">super</span> Person&gt; list2 = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure>
<p>这种写法就是一种存在限制条件的泛型写法。那么这种写法与原来的写法有什么区别呢？</p>
<p>现有以下两个类，其中 Student 类是 Person 类的子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以编写一个测试代码来测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 有限制条件的通配符的使用</span></span><br><span class="line"><span class="comment">*  ? extends A :</span></span><br><span class="line"><span class="comment">*       G&lt;? extends A&gt; 可以作为 G&lt;A&gt; 和 G&lt;B&gt; 的父类，其中 B 是 A 的子类</span></span><br><span class="line"><span class="comment">*  ? super B :</span></span><br><span class="line"><span class="comment">*       G&lt;? super A&gt; 可以作为 G&lt;A&gt; 和 G&lt;B&gt; 的父类，其中 B 是 A 的父类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list1 = <span class="literal">null</span>; <span class="comment">// 类型范围小于等于 Person</span></span><br><span class="line">    List&lt;? <span class="built_in">super</span> Person&gt; list2 = <span class="literal">null</span>; <span class="comment">// 类型范围大于等于 Person</span></span><br><span class="line"></span><br><span class="line">    List&lt;Student&gt; list3 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;Person&gt; list4 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;Object&gt; list5 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    list1 = list3;</span><br><span class="line">    list1 = list4;</span><br><span class="line">    <span class="comment">//        list1 = list5; // 报错</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//        list2 = list3; // 报错</span></span><br><span class="line">    list2 = list4;</span><br><span class="line">    list2 = list5;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    list1 = list4;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> list1.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//        Student student = list1.get(0); // 报错</span></span><br><span class="line">    list2 = list4;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> list2.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//        Person p = list2.get(0); // 报错</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    <span class="comment">//        list1.add(new Student()); // 报错</span></span><br><span class="line"></span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些地方会报错的原因听我细细道来：</p>
<p>1、<code>list1 = list5</code> 会报错，是因为：list1 的范围应当小于等于 Person，而 list5 的范围是 Object</p>
<p>2、<code>list2 = list3</code> 会报错，是因为：list2 的范围应当大于等于 Person，而 list3 的范围是 Student</p>
<p>3、<code>Student student = list1.get(0);</code> 会报错，是因为：list1 的范围应当小于等于 Person，但也有可能比 Student 的范围更小</p>
<p>4、<code>Person p = list2.get(0);</code> 会报错，是因为：list2 的范围应当大于等于 Person，但也有可能比 Person 更大</p>
<p>5、<code>list1.add(new Student());</code> 会报错，是因为：list1 的范围应当小于等于 Person，但也有可能比 Student 的范围更小</p>
<p>6、<code>list2.add(new Student());</code> <strong>不会</strong>报错，是因为：list2 的范围应当大于等于 Person，写 Person 类及其子类当然是可以的，但是不能写范围比 Person 大的类（不能写 Person 的父类）。如果我初始化的类型是 A（A 是 Person 的父类），但是又 <code>add</code> 了 B（B 也是 Person 的父类），两个类型不一样，肯定是不能 <code>add</code> Person 的父类。</p>
<h1 id="5-协变与逆变"><a class="header-anchor" href="#5-协变与逆变"></a>5. 协变与逆变</h1>
<h2 id="5-1-泛型是不变的"><a class="header-anchor" href="#5-1-泛型是不变的"></a>5.1 泛型是不变的</h2>
<p>一个问题，下面的代码会编译报错吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p><strong>会编译报错！</strong></p>
<p>为什么呢？</p>
<p>假设不会编译报错，那么我们就可以进行以下操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>很显然，这是不对的。像上述代码一样，无法保证 <code>get</code> 出来的数据一定是 <code>String</code> 类型的，因此 <strong>Java 将泛型设置为不变的。</strong></p>
<p>也就是说，<code>List&lt;Object&gt;</code> 和 <code>ArrayList&lt;String&gt;</code> 之间是没有关系的，他们并不等价。</p>
<p>从上述示例也可以看出，Java 的泛型没有 <strong>内建的协变类型</strong>，无法将 <code>List&lt;Object&gt;</code> 和 <code>ArrayList&lt;String&gt;</code> 关联起来。当然了，也没有 <strong>内建的逆变类型</strong>。</p>
<p>需要额外提一句，Java 中数组是有内建的协变类型，比如下面这样是不会编译报错的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number[] array = &#123;<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">1.2</span>), <span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">1.23</span>)&#125;;</span><br><span class="line"><span class="comment">// 当然拆下箱更好</span></span><br><span class="line">Number[] array = &#123;<span class="number">1</span>, <span class="number">1.2</span>, (<span class="type">float</span>) <span class="number">1.23</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>假设又有这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number[] array = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">10</span>];</span><br><span class="line">array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">array[<span class="number">1</span>] = <span class="number">1.2</span>; <span class="comment">// java.lang.ArrayStoreException: java.lang.Double</span></span><br></pre></td></tr></table></figure>
<p>尽管编译时不会报错，但在运行时处理的是 <code>Integer[]</code>，因此在向数组中放置异构类型时会抛出异常。</p>
<p>但有些情况下可能需要将一个 <code>new ArrayList&lt;String&gt;</code> 转换为 <code>List&lt;Object&gt;</code>，应该咋办呢？</p>
<h2 id="5-2-泛型的协变"><a class="header-anchor" href="#5-2-泛型的协变"></a>5.2 泛型的协变</h2>
<p>从【4. 通配符】中可知，在泛型中可以使用 <code>?</code> 通配符，并且可以搭配 <code>extends</code> 和 <code>super</code> 使用，利用通配符就可以实现协变和逆变。</p>
<blockquote>
<p>协变与逆变的定义</p>
</blockquote>
<p>逆变与协变用来描述类型转换（type transformation）后的继承关系，其定义：如果 A、B 表示类型，<code>f(⋅)</code>表示类型转换，<code>≤</code> 表示继承关系（比如，<code>A≤B</code> 表示 AA 是由 BB 派生出来的子类）；</p>
<ul>
<li><code>f(⋅)</code> 是逆变（contravariant）的，当 <code>A≤B</code> 时有 <code>f(B)≤f(A)</code> 成立；</li>
<li><code>f(⋅)</code> 是协变（covariant）的，当 <code>A≤B</code> 时有 <code>f(A)≤f(B)</code>成立；</li>
<li><code>f(⋅)</code> 是不变（invariant）的，当 <code>A≤B</code> 时上述两个式子均不成立，即 <code>f(A)</code> 与 <code>f(B)</code> 之间没有继承关系。</li>
</ul>
<blockquote>
<p>协变</p>
</blockquote>
<p>先看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title function_">sum</span><span class="params">(List&lt;Number&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Number number : list) &#123;</span><br><span class="line">        sum += number.doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，这是对一个数字列表进行求和。现在我想这么去调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Double&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1.2</span>);</span><br><span class="line">list.add(<span class="number">1.8</span>);</span><br><span class="line"><span class="type">Double</span> <span class="variable">sum</span> <span class="operator">=</span> sum(list);</span><br></pre></td></tr></table></figure>
<p>乍眼一看，没啥问题。但由于 <strong>泛型是不变的</strong>，因此这里调用 <code>sum(list)</code> 会编译报错。</p>
<p>我们希望传入 <code>sum()</code> 方法的参数是一个 <code>List</code> 列表，并且其内部的元素是 <code>Number</code> 的子类。说到子类，难免会想到 <code>extends</code> 关键词，因此这里可以使用通配符 <code>? </code> 和 <code>extends</code> 结合，实现 <strong>协变</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title function_">sum</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">	<span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似 <code>&lt;? extends T&gt;</code> 被称为 <strong>子类通配符</strong>，意味着这个泛型可以匹配 <code>T</code> 及其子类。</p>
<p>这样做也会带来一定的代价：<strong>无法向集合中再添加元素了。</strong></p>
<p>以 <code>List&lt;? extends Number&gt;</code> 为例，它可以合法地指向 <code>List&lt;Double&gt;</code>，这时向集合内添加诸如 <code>Integer</code>、<code>Float</code> 等类型的数据显然是不合法的。除此之外，<code>List&lt;? extends Number&gt;</code> 还可以合法地指向 <code>List&lt;Integer&gt;</code>、<code>List&lt;Float&gt;</code> 等集合，具体指向什么只有在调用方法的时候才知道，也就是说编译器不知道 <code>List&lt;? extends Number&gt;</code> 的具体类型是什么，因此一旦使用了这种向上转型，将丢失向集合内添加元素的能力。</p>
<p>假设 <code>Number</code> 是非抽象类型的父类，针对 <code>List&lt;? extends Number&gt;</code> 而言，向这个集合中添加 <code>Number</code> 类型的元素也是不行的，因为编译器不知道指向的具体类型是什么，同时泛型还是不变的。</p>
<p>简单来说，使用 <code>&lt;? extends T&gt;</code> 后，编译器 <strong>只知道类型的上界</strong> 是 <code>T</code>，而无法知道下界是什么，因此也就无法向集合内添加元素了。</p>
<p>也不是说不能添加任何元素，<code>null</code> 还是可以的，只不过没人会那么做。</p>
<h2 id="5-3-泛型的逆变"><a class="header-anchor" href="#5-3-泛型的逆变"></a>5.3 泛型的逆变</h2>
<p>前面已经说过，下面这段代码是会编译报错的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>利用 <strong>协变</strong>，可以只调用 <code>get()</code> 方法，而不能调用 <code>add()</code> 方法。</p>
<p>那我就想调用 <code>add()</code> 方法怎么办呢？</p>
<p>先看 JDK8 <code>ArrayList</code> 中新增的一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span> &#123;</span><br><span class="line">	<span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法表示传入一个过滤器 <code>Predicate</code>，删除当前集合中符合过滤器条件的数据。</p>
<p>过滤器 <code>Predicate</code> 的泛型是 <code>&lt;? super E&gt;</code>，类似 <code>&lt;? super E&gt;</code> 被称为 <strong>超类通配符</strong>，利用超类通配符实现了范型的 <strong>逆变</strong>。假设这个方法没有使用逆变，而是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;E&gt; filter)</span> &#123;</span><br><span class="line">	<span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设当我们需要删除 <code>Double</code> 类型的集合中大于 0 的元素时，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Double&gt; doubleList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Predicate&lt;Double&gt; doublePredicate = <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Double&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Double num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">doubleList.removeIf(doublePredicate);</span><br></pre></td></tr></table></figure>
<p>又假设需要删除 <code>Integer</code> 类型的集合中大于 0 的元素，就要这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Predicate&lt;Integer&gt; integerPredicate = <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> integer &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">integerList.removeIf(integerPredicate);</span><br></pre></td></tr></table></figure>
<p>由于泛型是不变的，如果想要复用 <code>doublePredicate</code> 也是不行的，像下面这样就会编译报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Double&gt; doublePredicate = <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Double&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Double num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">integerList.removeIf(doublePredicate); <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure>
<p>我们知道 <code>Double</code> 和 <code>Integer</code> 都是 <code>Number</code> 的子类，如果可以将 <code>Predicate</code> 的泛型设置为 <code>Number</code> 类型，那不就可以对 <code>Double</code> 和 <code>Integer</code> 类型的集合复用了。</p>
<p>想法是很好的，同样由于泛型是不变的，在没有使用逆变的情况下，直接传入 <code>Number</code> 类型的 <code>Predicate</code> 也还是会报错。正因如此，<code>removeIf()</code> 方法的参数使用泛型的逆变，被设计为 <code>Predicate&lt;? super E&gt;</code>，而不是 <code>Predicate&lt;E&gt;</code>。</p>
<p>在使用了逆变的情况下，就可以这样操作 <code>Double</code> 和 <code>Integer</code> 类型的集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Number&gt; predicate = <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Number&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Number number)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number.doubleValue() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ArrayList&lt;Double&gt; doubleList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">doubleList.removeIf(predicate);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">integerList.removeIf(predicate);</span><br></pre></td></tr></table></figure>
<p>逆变也是有代价的，使用了逆变可以 <strong>确定类型的下界</strong>，而无法确定上界（与协变相反），因此使用了逆变将丧失获取该类型的能力。道理很简单，编译器不知道给定下界和 <code>Object</code>（所有类型都是 <code>Object</code> 类型的子类）类型之间到底有怎样的继承关系，为了防止由于“泛型是不变的”带来的编译报错，编译器干脆就不允许在使用逆变后再获取该类型。</p>
<p>假设有一 <code>Student</code> 类，其父类为 <code>Person</code>。利用这两个类型来看看使用了逆变后的得与失：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(List&lt;? <span class="built_in">super</span> Student&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 没问题</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 编译报错</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 编译报错</span></span><br><span class="line"></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>()); <span class="comment">// 编译报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到使用逆变后，就无法从集合中再获取原类型了。当然，可以获取 <code>Object</code> 类。</p>
<p>除此之外，使用逆变后可以消费泛型。以上述为例，就是可以向集合内添加元素，但并不是任何元素都是可行的，只能添加给定类型及其子类的元素。原因同样是只确定了下界而没有确定上界。</p>
<h2 id="5-4-PECS-原则"><a class="header-anchor" href="#5-4-PECS-原则"></a>5.4 PECS 原则</h2>
<p>那什么时候使用协变，什么时候使用逆变呢？</p>
<p>《Effective Java》给出了一个原则：<strong>producer-extends, consumer-super（PECS）</strong>。</p>
<p>当需要生产一个泛型时（从泛型类获取指定类型的数据，并且不需要写入），可以使用 <code>extends</code>，即协变。比如从集合中获取指定下标的元素。</p>
<p>当需要消费一个泛型时（需要向泛型类写入指定类型的数据，但不需要获取这种类型），可以使用 <code>super</code>，即逆变。比如在集合中按照指定条件删除元素。</p>
<p>但如果又要写入数据，又要获取数据，就不能使用通配符 <code>?</code>，而是指定具体的泛型。</p>
<p>在 <code>java.util.Collections</code> 中有一个 <code>copy()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;</span><br><span class="line">	<span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>copy()</code> 方法是将源列表中的元素拷贝到目标列表中，并且目标列表中每个复制元素的索引将与其在源列表中的索引相同。因此，目标列表必须至少与源列表一样长，如果更长，则目标列表中的其余元素不受影响。</p>
<p>显然是需要从 <code>src</code> 中获取需要拷贝的元素，即生产泛型，然后将获取到的元素放到 <code>dest</code> 中指定的下标位置，即消费泛型。因此 <code>src</code> 使用 <code>extends</code>，而 <code>dest</code> 使用 <code>super</code>。</p>
<h1 id="6-自限定类型"><a class="header-anchor" href="#6-自限定类型"></a>6. 自限定类型</h1>
<h2 id="6-1-普通泛型类构成自限定"><a class="header-anchor" href="#6-1-普通泛型类构成自限定"></a>6.1 普通泛型类构成自限定</h2>
<p>在使用 Java 泛型时经常会看到下述这样的“迷惑”写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelfBound</span>&lt;T <span class="keyword">extends</span> <span class="title class_">SelfBound</span>&lt;T&gt;&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>
<p><code>SelfBound</code> 类的类型参数是 <code>T</code>，<code>T</code> 由一个边界类限定，这个边界恰好又是参数类型为 <code>T</code> 的 <code>SelfBound</code>，似乎变成了无限循环。这种写法被称为自限定类型（Self-Bound Types）。</p>
<p>看一个例子，<strong>使用普通泛型类构成自限定</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicHolder</span>&lt;T&gt; &#123;</span><br><span class="line">    T element;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T arg)</span> &#123;</span><br><span class="line">        element = arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subtype</span> <span class="keyword">extends</span> <span class="title class_">BasicHolder</span>&lt;Subtype&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Subtype</span> <span class="variable">st1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subtype</span>(), st2 = <span class="keyword">new</span> <span class="title class_">Subtype</span>(), st3 = <span class="keyword">new</span> <span class="title class_">Subtype</span>();</span><br><span class="line">        st2.set(st3);</span><br><span class="line">        st1.set(st2);</span><br><span class="line">        <span class="type">Subtype</span> <span class="variable">st4</span> <span class="operator">=</span> st1.get();</span><br><span class="line">        st4.f(); <span class="comment">// Subtype</span></span><br><span class="line">        <span class="type">Subtype</span> <span class="variable">st5</span> <span class="operator">=</span> st1.get().get(); <span class="comment">// 链式调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Subtype</code> 类继承了 <code>BasicHolder</code> 类的属性与方法，<code>element</code> 属性的类型具有 <code>Subtype</code> 类型，而不仅仅是 <code>BasicHolder</code>。</p>
<p>上述示例代码中，<code>BasicHolder</code> 类变成了其所有子类的公共模板，对于子类所继承的属性与方法将使用准确的类型而不是基类。</p>
<p>像 <code>class Subtype extends BasicHolder&lt;Subtype&gt;</code> 这样就构成了 <strong>自限定</strong>，<code>Subtype</code> 从 <code>BasicHolder</code> 所继承来的 <code>element</code> 属性、<code>set()</code>  方法的参数、<code>get()</code> 方法的返回值都是 <code>Subtype</code>，而不是 <code>BasicHolder</code>，这样 <code>Subtype</code> 对象只允许与 <code>SubType</code> 对象进行交互，不允许其与 <code>BasicHolder</code> 的其他子类对象进行交互。</p>
<p>也就是说，自限定类型定义了一个基类，这个基类能够使用子类作为其参数、返回值类型、属性类型。</p>
<h2 id="6-2-自限定与协变"><a class="header-anchor" href="#6-2-自限定与协变"></a>6.2 自限定与协变</h2>
<p>使用自限定类型可以产生 <strong>协变参数类型</strong>，即：方法参数类型跟随子类而变化。当然，也可以产生 <strong>协变返回类型</strong>。</p>
<blockquote>
<p>协变返回类型</p>
</blockquote>
<p>不使用泛型时，子类重写基类的方法，返回更确切的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">OrdinaryGetter</span> &#123; </span><br><span class="line">    Base <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DerivedGetter</span> <span class="keyword">extends</span> <span class="title class_">OrdinaryGetter</span> &#123;</span><br><span class="line">    Derived <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CovariantReturnTypes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(DerivedGetter derivedGetter)</span> &#123;</span><br><span class="line">        <span class="type">Derived</span> <span class="variable">derived</span> <span class="operator">=</span> derivedGetter.get();</span><br><span class="line">        <span class="comment">// 当然这样也是可以的</span></span><br><span class="line">        <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> derivedGetter.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用泛型后，子类继承具有自定义类型的基类，子类所继承的方法将返回更确切的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericsGetter</span>&lt;T <span class="keyword">extends</span> <span class="title class_">GenericsGetter</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Getter</span> <span class="keyword">extends</span> <span class="title class_">GenericsGetter</span>&lt;Getter&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsAndReturnTypes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(Getter g)</span> &#123;</span><br><span class="line">        <span class="type">Getter</span> <span class="variable">result</span> <span class="operator">=</span> g.get();</span><br><span class="line">        <span class="comment">// 这样也是可以的</span></span><br><span class="line">        GenericsGetter&lt;Getter&gt; genericsGetter = g.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>协变参数类型</p>
</blockquote>
<p>在不使用泛型时，基类方法参数不能随着子类的类型发生变化。 <strong>方法只能重载不能重写。</strong></p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrdinarySetter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Base base)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OrdinarySetter.set(Base)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedSetter</span> <span class="keyword">extends</span> <span class="title class_">OrdinarySetter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Derived derived)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DerivedSetter.set(Derived)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrdinaryArguments</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line">        <span class="type">Derived</span> <span class="variable">derived</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line">        <span class="type">DerivedSetter</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DerivedSetter</span>();</span><br><span class="line">        <span class="comment">// DerivedSetter.set(Derived)</span></span><br><span class="line">        ds.set(derived);</span><br><span class="line">        <span class="comment">// OrdinarySetter.set(Base)</span></span><br><span class="line">        ds.set(base);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DerivedSetter</code> 子类使用 <code>base</code> 和 <code>derived</code> 作为参数调用 <code>set()</code> 方法后，并不是只调用重写的方法，也调用了其基类的方法，从这里也可以论证方法只能重载而不能重写。</p>
<p>但在使用自定义限定类型后，子类所继承的方法不再以基类类型为参数，而是接受其本身作为参数。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SelfBoundSetter</span>&lt;T <span class="keyword">extends</span> <span class="title class_">SelfBoundSetter</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T args)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Setter</span> <span class="keyword">extends</span> <span class="title class_">SelfBoundSetter</span>&lt;Setter&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelfBoundAndCovariantArguments</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testA</span><span class="params">(Setter s1, Setter s2, SelfBoundSetter sbs)</span> &#123;</span><br><span class="line">        s1.set(s2);</span><br><span class="line"><span class="comment">//        s1.set(sbs);  // 编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-自限定类型的应用"><a class="header-anchor" href="#6-3-自限定类型的应用"></a>6.3 自限定类型的应用</h2>
<p>我们知道在 JDK5 中引入了枚举，使用 <code>enum</code> 关键词就可以创建枚举类。这其实是一个语法糖，使用 <code>enum</code> 关键词后就相当于继承了 <code>java.lang.Enum</code> 基类。</p>
<p>JDK 中 <code>Enum</code> 是这样定义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Enum</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt;, Serializable &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>很明显，<code>Enum</code> 的定义使用了自限定类型。</p>
<p>那为什么要这么声明呢？像这样不行吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Enum</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt;, Serializable &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>Enum</code> 是一个抽象类，我们使用的都是它的子类，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Month</span> <span class="keyword">extends</span> <span class="title class_">Enum</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Week</span> <span class="keyword">extends</span> <span class="title class_">Enum</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>我们会在 <code>Month</code> 中定义从一月到十二月共十二个枚举，在 <code>Week</code> 中定义从星期一到星期天共七个枚举。</p>
<p><code>Enum</code> 实现了 <code>Comparable</code> 接口，因此枚举都是可比较的。比如可以在 <code>Month</code> 中比较一月和二月哪个大，也可以在 <code>Week</code> 中比较星期一和星期天哪个大，但是能比较 <code>Month</code> 中的一月和 <code>Week</code> 中的星期一哪个大吗？</p>
<p>如果使用自定义的 <code>Enum</code> 抽象类，那么这是可以比较的，但这显然不是我们所期望的。我们期望是：同一个 <code>Enum</code> 子类的实例进行比较，而不是两个不同的 <code>Enum</code> 子类实例进行比较，因为这是没有意义的。</p>
<p>因此 JDK 中 <code>Enum</code> 的定义使用了自限定类型，保证其子类所继承的 <code>compareTo()</code> 方法的参数是其本身。</p>
<blockquote>
<p>总结下 JDK Enum 的设计思路</p>
</blockquote>
<p>1、首先枚举是可以比较的，因此 <code>Enum</code> 没有定义成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Enum</span> <span class="keyword">extends</span> <span class="title class_">Object</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>2、我们希望枚举在比较时只能和枚举进行比较，而不是和任何类型，因此 <code>Enum</code> 没有定义成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Enum</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt;, Serializable &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>3、我们还希望只有同一个枚举类之间才能比较，而不是随便两个枚举类之间就可以比较，因此在 <code>Enum</code> 的定义中使用自类型限定。最终，<code>Enum</code> 就长这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Enum</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt;, Serializable &#123; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-4-为什么没有编译报错？"><a class="header-anchor" href="#6-4-为什么没有编译报错？"></a>6.4 为什么没有编译报错？</h2>
<p>现有如下类和方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T, U, R&gt; <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(T obj,</span></span><br><span class="line"><span class="params">                            Function&lt;T, U&gt; fun1,</span></span><br><span class="line"><span class="params">                            Function&lt;R, U&gt; fun2)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下使用方式不会编译报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Obj</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Obj</span>();</span><br><span class="line">func(obj, Object::hashCode, Obj::hashCode);</span><br><span class="line">func(obj, Obj::toString, Object::toString);</span><br></pre></td></tr></table></figure>
<p>那么这样的使用会编译报错吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(obj, Obj::hashCode, Obj::toString);</span><br></pre></td></tr></table></figure>
<p>答案是也不会。</p>
<p><code>hashCode()</code> 方法的返回值类型是 <code>int</code>，<code>toString()</code> 方法的返回值类型是 <code>String</code>，<code>func()</code> 方法的第二个和第三个 <code>Function</code> 类型的参数的第二个泛型参数都是 <code>U</code>，表示方法的出参类型应该一致，但一个是 <code>int</code>，一个是 <code>String</code>，显然不一样，为什么不会编译报错呢？</p>
<p>这是因为在泛型推断时，将 <code>U</code> 推断为 <code>Integer</code> 和 <code>String</code> 的相同父类 <code>Comparable</code>，因此不会编译报错。</p>
<p>由于所有类的“祖宗类”都是 <code>Object</code>，因此在不加任何限定的情况下，<code>func()</code> 方法的第二个和第三个参数可以任意填写，比如一个返回 <code>HashMap</code>，一个返回 <code>HashSet</code> 都不会编译报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(obj, obj1 -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), o -&gt; <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br></pre></td></tr></table></figure>
<p>再回到最开始，如何使 <code>func(obj, Obj::hashCode, Obj::toString);</code> 的写法产生编译报错呢？</p>
<p>也就是说，<code>int</code> 类型只能和 <code>int</code> 类型比较，<code>String</code> 类型只能和 <code>String</code> 类型比较，根据本节的知识，很容易想到让泛型参数 <code>U</code> 构成自限定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T, U <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;U&gt;, R&gt; <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(T obj,</span></span><br><span class="line"><span class="params">                                                  Function&lt;T, U&gt; fun1,</span></span><br><span class="line"><span class="params">                                                  Function&lt;R, U&gt; fun2)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-捕获转换"><a class="header-anchor" href="#7-捕获转换"></a>7. 捕获转换</h1>
<h2 id="7-1-无界通配符"><a class="header-anchor" href="#7-1-无界通配符"></a>7.1 无界通配符</h2>
<p><code>&lt;? extends T&gt;</code> 被称为 <strong>子类通配符</strong>，它确定了类型的上界；<code>&lt;? super E&gt;</code> 被称为 <strong>超类通配符</strong>，它确定了类型的下界；而 <code>&lt;?&gt;</code> 被称为 <strong>无界通配符</strong>，它并没有确定类型的上界和下界。</p>
<p>可以在下面这两种场景下使用无界通配符：</p>
<ol>
<li>正在编写一个可以使用 <code>Object</code> 类中提供的功能来实现的方法（所有类的父类都是 <code>Object</code>）；</li>
<li>代码在泛型中使用不依赖类型参数的方法。比如经常使用 <code>Class&lt;?&gt;</code> 就是因为类 <code>Class&lt;T&gt;</code> 中的大多数方法不依赖并不于 <code>T</code>。</li>
</ol>
<p>注意 <code>List&lt;?&gt;</code> 和 <code>List&lt;Object&gt;</code> 是不一样的。可以将 <code>Object</code> 类型或及其子类对象插入到 <code>List&lt;Object&gt;</code>，但是对于 <code>List&lt;?&gt;</code> 就只能插入 <code>null</code>。在调用 <code>get()</code> 获取元素时，它们调用 <code>get()</code> 方法的返回值都是 <code>Object</code>。</p>
<p><code>List&lt;?&gt;</code> 表示的是“具有某种特定类型的 <code>List</code>，但这个类型是未知的”，因此可以将任何类型的 <code>List</code> 赋值给 <code>List&lt;?&gt;</code>，对于 <code>List&lt;Object&gt;</code> 则不是这样。</p>
<h2 id="7-2-捕获转换"><a class="header-anchor" href="#7-2-捕获转换"></a>7.2 捕获转换</h2>
<p>通常情况下，使用原生类型和 <code>&lt;?&gt;</code> 没什么区别，但是使用 <code>&lt;?&gt;</code> 可以实现捕获转换。</p>
<p><strong>捕获转换</strong>（Capture conversion）允许编译器为已捕获的通配符产生一个占位符类型名，以便对它进行类型推断。</p>
<p>直接上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Holder</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Holder</span><span class="params">(T val)</span> &#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T val)</span> &#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaptureConversion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(Holder&lt;T&gt; holder)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> holder.get();</span><br><span class="line">        System.out.println(t.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(Holder&lt;?&gt; holder)</span> &#123;</span><br><span class="line">        f1(holder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Holder</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>&lt;Integer&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Unchecked assignment: &#x27;Holder&#x27; to &#x27;Holder&lt;java.lang.Object&gt;&#x27;</span></span><br><span class="line">        f1(raw);</span><br><span class="line">        f2(raw);</span><br><span class="line"></span><br><span class="line">        <span class="type">Holder</span> <span class="variable">rawBasic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>();</span><br><span class="line">        <span class="comment">// Unchecked call to &#x27;set(T)&#x27; as a member of raw type &#x27;Holder&#x27;</span></span><br><span class="line">        rawBasic.set(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        f2(rawBasic);</span><br><span class="line"></span><br><span class="line">        Holder&lt;?&gt; wildcards = <span class="keyword">new</span> <span class="title class_">Holder</span>&lt;Double&gt;(<span class="number">1.0</span>);</span><br><span class="line">        f2(wildcards);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码中调用 <code>f1()</code> 时 IDEA 会进行警告，而调用 <code>f2()</code> 时却没有，这是因为 <code>f2()</code> 的 holder 参数可以捕获到原生类型中的参数类型，但自己却不知道，捕获到的参数类型可以转换成 <code>f1()</code> 中的确切类型。</p>
<p>捕获转换只适用在方法内部，并且需要传入确切的类型。需要注意的是，不能从 <code>f2()</code> 中返回 T，因为 T 对于 <code>f2()</code> 来说是未知的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mofan212.github.io">默烦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mofan212.github.io/posts/Java-Genericity/">https://mofan212.github.io/posts/Java-Genericity/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mofan212.github.io" target="_blank">Mofan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/58.jpg" data-sites="wechat,qq,weibo,facebook,twitter"></div><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://jsd.onmicrosoft.cn/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/AliPay.png" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/img/AliPay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="/img/WeChatPay.png" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/img/WeChatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/Java-IO-Stream/" title="Java IO 流基础"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/59.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java IO 流基础</div></div></a></div><div class="next-post pull-right"><a href="/posts/The-Basis-Of-Java-Multithreading/" title="学毛线（Thread）的 Java"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/57.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">学毛线（Thread）的 Java</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/Combinator-Pattern/" title="Combinator Pattern"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/149.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-28</div><div class="title">Combinator Pattern</div></div></a></div><div><a href="/posts/Design-Pattern-Proxy-Pattern/" title="【设计模式】代理模式"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/19.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-28</div><div class="title">【设计模式】代理模式</div></div></a></div><div><a href="/posts/Design-Pattern-Mediator-Pattern/" title="【设计模式】中介者模式"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/148.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-03</div><div class="title">【设计模式】中介者模式</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">默烦</div><div class="author-info__description">彩笔的打怪升级之路...</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">149</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/23658864/dynamic"><i class="fas fa-running"></i><span>关注我的B站</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mofan212" target="_blank" title="GitHub"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:cy.mofan@foxmail.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站所有博文均是博主的学习笔记与个人理解。<strong><font style="color:red">除特别注明外，</font>如需转载，请在文章头部醒目处附带原文链接并<a target="_blank" rel="noopener" href="https://mofan212.gitee.io/mine/" style="color:#49B1F5;text-decoration:underline">告知我</a></strong>你将转载。😊</br><strong><font style="color:red">严禁未遵循规范的转载。</font></strong>😡</br><strong>死去的评论系统复活啦！欢迎到留言板畅所欲言！</strong>当然也可以使用更高效的<a target="_blank" href="https://space.bilibili.com/23658864/dynamic" style="color:#49B1F5;text-decoration:underline"> 哔哩哔哩私信 </a>或<a href="mailto:cy.mofan@foxmail.com" style="color:#49B1F5;text-decoration:underline" target="_blank">邮箱</a>。 😉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-text">1. 为什么要使用泛型？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="toc-text">1.1 为什么要使用泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1.2 泛型的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%B3%9B%E5%9E%8B%E6%9C%89%E6%97%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.3 泛型有无的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-text">2. 自定义泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-text">2.1 自定义泛型类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E8%A6%81%E7%82%B9%E9%87%8D%E7%82%B9"><span class="toc-text">2.2 要点重点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">2.3 自定义泛型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.4 使用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B"><span class="toc-text">3. 继承与泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">4. 通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-text">4.1 简单使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%86%99%E5%85%A5%E4%B8%8E%E8%AF%BB%E5%8F%96"><span class="toc-text">4.2 写入与读取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%AD%98%E5%9C%A8%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6"><span class="toc-text">4.3 存在限制条件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98"><span class="toc-text">5. 协变与逆变</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%B3%9B%E5%9E%8B%E6%98%AF%E4%B8%8D%E5%8F%98%E7%9A%84"><span class="toc-text">5.1 泛型是不变的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%8D%8F%E5%8F%98"><span class="toc-text">5.2 泛型的协变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%80%86%E5%8F%98"><span class="toc-text">5.3 泛型的逆变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-PECS-%E5%8E%9F%E5%88%99"><span class="toc-text">5.4 PECS 原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E8%87%AA%E9%99%90%E5%AE%9A%E7%B1%BB%E5%9E%8B"><span class="toc-text">6. 自限定类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%99%AE%E9%80%9A%E6%B3%9B%E5%9E%8B%E7%B1%BB%E6%9E%84%E6%88%90%E8%87%AA%E9%99%90%E5%AE%9A"><span class="toc-text">6.1 普通泛型类构成自限定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E8%87%AA%E9%99%90%E5%AE%9A%E4%B8%8E%E5%8D%8F%E5%8F%98"><span class="toc-text">6.2 自限定与协变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E8%87%AA%E9%99%90%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">6.3 自限定类型的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99%EF%BC%9F"><span class="toc-text">6.4 为什么没有编译报错？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%8D%95%E8%8E%B7%E8%BD%AC%E6%8D%A2"><span class="toc-text">7. 捕获转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%97%A0%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">7.1 无界通配符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%8D%95%E8%8E%B7%E8%BD%AC%E6%8D%A2"><span class="toc-text">7.2 捕获转换</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Something-About-Blog/" title="博客搭建与维护"><img src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/42.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="博客搭建与维护"/></a><div class="content"><a class="title" href="/posts/Something-About-Blog/" title="博客搭建与维护">博客搭建与维护</a><time datetime="2024-05-10T16:00:00.000Z" title="更新于 2024-05-11 00:00:00">2024-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/The-Basics-Of-Linux-Part-One/" title="【上篇】Linux 基础"><img src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/96.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【上篇】Linux 基础"/></a><div class="content"><a class="title" href="/posts/The-Basics-Of-Linux-Part-One/" title="【上篇】Linux 基础">【上篇】Linux 基础</a><time datetime="2024-04-16T16:00:00.000Z" title="更新于 2024-04-17 00:00:00">2024-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Genericity/" title="Java 泛型"><img src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/58.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java 泛型"/></a><div class="content"><a class="title" href="/posts/Java-Genericity/" title="Java 泛型">Java 泛型</a><time datetime="2024-04-16T16:00:00.000Z" title="更新于 2024-04-17 00:00:00">2024-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/How-to-use-IDEA/" title="帅气地使用 IDEA"><img src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/37.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="帅气地使用 IDEA"/></a><div class="content"><a class="title" href="/posts/How-to-use-IDEA/" title="帅气地使用 IDEA">帅气地使用 IDEA</a><time datetime="2024-04-11T16:00:00.000Z" title="更新于 2024-04-12 00:00:00">2024-04-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/The-Basics-Of-Linux-Part-Two/" title="【下篇】Linux 基础"><img src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/97.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【下篇】Linux 基础"/></a><div class="content"><a class="title" href="/posts/The-Basics-Of-Linux-Part-Two/" title="【下篇】Linux 基础">【下篇】Linux 基础</a><time datetime="2024-04-10T16:00:00.000Z" title="更新于 2024-04-11 00:00:00">2024-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Combinator-Pattern/" title="Combinator Pattern"><img src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/149.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Combinator Pattern"/></a><div class="content"><a class="title" href="/posts/Combinator-Pattern/" title="Combinator Pattern">Combinator Pattern</a><time datetime="2024-04-02T16:00:00.000Z" title="更新于 2024-04-03 00:00:00">2024-04-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 默烦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://jsd.onmicrosoft.cn/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://jsd.onmicrosoft.cn/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://jsd.onmicrosoft.cn/npm/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://jsd.onmicrosoft.cn/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://jsd.onmicrosoft.cn/npm/mermaid@10.9.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://jsd.onmicrosoft.cn/gh/mofan212/blog-static-resources@master/js/mine.min.js"></script><script src="https://npm.elemecdn.com/mermaid/dist/mermaid.min.js"></script><script defer="defer" id="ribbon" src="https://jsd.onmicrosoft.cn/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://jsd.onmicrosoft.cn/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Azathoth,Yog-Sothoth,Shub-Niggurath,Nyarlathotep,Cthulhu,Hastur,Abhoth,Ghroth,Tsathoggua,Cthugha,Deep Ones,Dagon,Chaugnar Faugn,Mordiggian,Shoggoth,Old One,Mi-Go,Great Race of Yith,Flying Polyp,Hounds of Tindalos,Dhole" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/@docsearch/css/dist/style.min.css"/><script src="https://jsd.onmicrosoft.cn/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'BAFEL7A6K1',
    apiKey: '89fcb5961984c5c054bf04149f345f38',
    indexName: 'mofan212io',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【下篇】Redis 基础篇 | Mofan</title><meta name="author" content="默烦,cy.mofan@foxmail.com"><meta name="copyright" content="默烦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文为 Redis 基础篇下篇，主要介绍了 Redis事务、发布订阅、Redis 的复制、Jedis、三种特殊的数据类型，缓存穿透和雪崩以及整合 SpringBoot。">
<meta property="og:type" content="article">
<meta property="og:title" content="【下篇】Redis 基础篇">
<meta property="og:url" content="https://mofan212.github.io/posts/The-Basics-Of-Redis-Part-Two/index.html">
<meta property="og:site_name" content="Mofan">
<meta property="og:description" content="本文为 Redis 基础篇下篇，主要介绍了 Redis事务、发布订阅、Redis 的复制、Jedis、三种特殊的数据类型，缓存穿透和雪崩以及整合 SpringBoot。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/73.png">
<meta property="article:published_time" content="2020-12-07T16:00:00.000Z">
<meta property="article:modified_time" content="2022-03-26T16:00:00.000Z">
<meta property="article:author" content="默烦">
<meta property="article:tag" content="Middleware">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/73.png"><link rel="shortcut icon" href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/favicon.png"><link rel="canonical" href="https://mofan212.github.io/posts/The-Basics-Of-Redis-Part-Two/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"距离本文上次更新已经过去","messageNext":"天，请注意时效性。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 默烦","link":"链接: ","source":"来源: Mofan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【下篇】Redis 基础篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-27 00:00:00'
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/mofan212/blog-static-resources@master/css/myStyle.min.css"><link rel="stylesheet" href="https://cdn.staticfile.net/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css" /><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Mofan" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/mofan212/blog-static-resources/css/fill-left.min.css"/><script src="https://fastly.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">153</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/post_top_img.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Mofan</span></a><a class="nav-page-title" href="/"><span class="site-name">【下篇】Redis 基础篇</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【下篇】Redis 基础篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-07T16:00:00.000Z" title="发表于 2020-12-08 00:00:00">2020-12-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-26T16:00:00.000Z" title="更新于 2022-03-27 00:00:00">2022-03-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Middleware/">Middleware</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">21.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>87分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>封面来源：碧蓝航线 永夜幻光 活动CG</p>
<p>Redis 命令参考：<a target="_blank" rel="noopener" href="http://doc.redisfans.com/">Redis 命令参考</a></p>
<p>本文参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1oW411u75R">尚硅谷超经典Redis教程,redis实战,阳哥版从入门到精通</a></p>
<h1 id="1-Redis-事务"><a class="header-anchor" href="#1-Redis-事务"></a>1. Redis 事务</h1>
<h2 id="1-1-事务概述"><a class="header-anchor" href="#1-1-事务概述"></a>1.1 事务概述</h2>
<blockquote>
<p>什么是事务</p>
</blockquote>
<p>可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞。</p>
<p>Redis 支持事务，但只部分支持，并不像常见关系型数据库那样强一致性。</p>
<blockquote>
<p>事务可以干嘛</p>
</blockquote>
<p>一个队列中，一次性、顺序性、排他性的执行一系列命令。</p>
<h2 id="1-2-怎么使用"><a class="header-anchor" href="#1-2-怎么使用"></a>1.2 怎么使用</h2>
<p>在官网上 <a target="_blank" rel="noopener" href="https://redis.io/topics/transactions">Transactions</a> 内有这样一段话：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/Redis%E4%BA%8B%E5%8A%A1Usage.png" alt="Redis事务Usage"></p>
<blockquote>
<p>常用命令</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DISCARD</td>
<td style="text-align:center">取消事务，放弃执行事务块内的所有命令。</td>
</tr>
<tr>
<td style="text-align:center">EXEC</td>
<td style="text-align:center">执行所有事务块内的命令。</td>
</tr>
<tr>
<td style="text-align:center">MULTI</td>
<td style="text-align:center">标记一个事务块的开始。</td>
</tr>
<tr>
<td style="text-align:center">UNWATCH</td>
<td style="text-align:center">取消 WATCH 命令对所有 key 的监视。</td>
</tr>
<tr>
<td style="text-align:center">WATCH key [key …]</td>
<td style="text-align:center">监视一个（或多个）key ，如果在事务执行之前这个（或这些）key 被其他命令所改动，那么事务将被打断。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>正常执行</p>
</blockquote>
<pre>[root@cheny bin]# redis-server /Redis/redis_aof.conf
[root@cheny bin]# redis-cli -p 6379
127.0.0.1:6379&gt; ping
PONG
127.0.0.1:6379&gt; MULTI
OK
127.0.0.1:6379&gt; set k1 v1
QUEUED
127.0.0.1:6379&gt; set k2 v2
QUEUED
127.0.0.1:6379&gt; get k2
QUEUED
127.0.0.1:6379&gt; set k3 v3
QUEUED
127.0.0.1:6379&gt; EXEC
1) OK
2) OK
3) &quot;v2&quot;
4) OK
</pre>
<blockquote>
<p>放弃事务</p>
</blockquote>
<pre>127.0.0.1:6379&gt; MULTI
OK
127.0.0.1:6379&gt; set k1 v11
QUEUED
127.0.0.1:6379&gt; set k2 v22
QUEUED
127.0.0.1:6379&gt; set k3 v33
QUEUED
127.0.0.1:6379&gt; DISCARD
OK
127.0.0.1:6379&gt; mget k1 k2 k3
1) &quot;v1&quot;
2) &quot;v2&quot;
3) &quot;v3&quot;
</pre>
<blockquote>
<p>全体连坐</p>
</blockquote>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/Redis%E4%BA%8B%E5%8A%A1%E5%85%A8%E4%BD%93%E8%BF%9E%E5%9D%90.png" alt="Redis事务全体连坐"></p>
<p>这里的命令就错了，类似 Java 的编译异常，所以都不会执行。</p>
<blockquote>
<p>冤头债主</p>
</blockquote>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/Redis%E4%BA%8B%E5%8A%A1%E5%86%A4%E5%A4%B4%E5%80%BA%E4%B8%BB.png" alt="Redis事务冤头债主"></p>
<p>这里的命令没错，过程中没有报错，都入队了，但 k1 是 “aa”，不是数字不能加一，因此针对 k1 的错误不执行，但其他的操作会执行。类似 Java 的运行异常。</p>
<p>在 Redis 事务中还有 watch 监控，这部分内容较多且重要，单独提出来编写。</p>
<h2 id="1-3-watch-监控"><a class="header-anchor" href="#1-3-watch-监控"></a>1.3 watch 监控</h2>
<blockquote>
<p>知识回顾</p>
</blockquote>
<p>回顾一下行锁和表锁：</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52678870">深入理解数据库行锁与表锁</a></p>
<p>行锁：顾名思义，行锁就是一锁锁一行或者多行记录，MySQL 的 <strong>行锁是基于索引加载的</strong>，所以行锁是要加在索引响应的行上，即命中索引。行锁锁冲突概率低，并发性高，但是会有死锁的情况出现。</p>
<p>表锁：顾名思义，表锁就是一锁锁一整张表，在表被锁定期间，其他事务不能对该表进行操作，必须等当前表的锁被释放后才能进行操作。<strong>表锁响应的是非索引字段，即全表扫描</strong>，全表扫描时锁定整张表，SQL 语句可以通过执行计划看出扫描了多少条记录。表锁的锁冲突几率特别高，表锁不会出现死锁的情况。</p>
<p>再回顾一下悲观锁和乐观锁：</p>
<p>悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁、表锁等，读锁、写锁等，都是在做操作之前先上锁。</p>
<p>乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。</p>
<p>乐观锁策略：提交版本必须大于记录当前版本才能执行更新。</p>
<p>CAS，即：Check And Set，意为检查并设置，运用了乐观锁的机制。</p>
<blockquote>
<p>信用卡可用余额和欠款</p>
</blockquote>
<p>初始化信用卡可用余额和欠款：</p>
<pre>127.0.0.1:6379&gt; set balance 100
OK
127.0.0.1:6379&gt; set debt 0
OK
127.0.0.1:6379&gt; KEYS *
1) &quot;debt&quot;
2) &quot;balance&quot;
127.0.0.1:6379&gt; MGET balance debt
1) &quot;100&quot;
2) &quot;0&quot;
</pre>
<p>无加塞篡改，先监控再开启 MULTI，保证两笔金额变动在同一个事务内</p>
<pre>127.0.0.1:6379&gt; WATCH balance
OK
127.0.0.1:6379&gt; MULTI
OK
127.0.0.1:6379&gt; DECRBY balance 20
QUEUED
127.0.0.1:6379&gt; INCRBY debt 20
QUEUED
127.0.0.1:6379&gt; EXEC
1) (integer) 80
2) (integer) 20
</pre>
<p>有加塞篡改，监控了 key，<strong>如果 key 被修改</strong>，后面一个事务的执行将会失败</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/watch%E6%9C%89%E7%AF%A1%E6%94%B9%E5%8A%A0%E5%A1%9E.png" alt="watch有篡改加塞"></p>
<p>unwatch：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/unwatch.png" alt="unwatch"></p>
<p>一旦执行了 <code>EXEC</code> 之前加的监控锁都会被取消掉了（一次性）</p>
<blockquote>
<p>小结</p>
</blockquote>
<p><code>WATCH</code> 指令，类似乐观锁，事务提交时，如果看 key 的值已被别的客户端改变，比如某个 list 已被别的客户端 push / pop 过了，整个事务队列都不会被执行。</p>
<p>通过 <code>WATCH</code> 命令在事务执行之前监控了多个 keys，倘若在 <code>WATCH</code> 之后有任何 key 的值发生了变化， <code>EXEC</code> 命令执行的事务都将被放弃，同时返回 Nullmulti-bulk 应答以通知调用者事务执行失败。</p>
<h2 id="1-4-三阶段和三特性"><a class="header-anchor" href="#1-4-三阶段和三特性"></a>1.4 三阶段和三特性</h2>
<blockquote>
<p>三阶段</p>
</blockquote>
<p>1、开启：以 <code>MULTI</code> 开始一个事务</p>
<p>2、入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面</p>
<p>3、执行：由 <code>EXEC</code> 命令触发事务</p>
<blockquote>
<p>三特性</p>
</blockquote>
<p>1、<strong>单独的隔离操作</strong>：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>2、<strong>没有隔离级别的概念</strong>：队列中的命令在没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行， 也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题</p>
<p>3、<strong>不保证原子性</strong>：Redis 同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</p>
<p>不遵循传统的 ACID 中的 AI（原子性和隔离性）。</p>
<h1 id="2-发布订阅"><a class="header-anchor" href="#2-发布订阅"></a>2. 发布订阅</h1>
<h2 id="2-1-什么是发布订阅"><a class="header-anchor" href="#2-1-什么是发布订阅"></a>2.1 什么是发布订阅</h2>
<p>进程间的一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息。</p>
<p>Redis 有发布订阅的功能，但是在实际企业开发的时候并不会使用 Redis 作为消息中间件，本节做个了解即可。</p>
<blockquote>
<p>订阅 / 发布消息图</p>
</blockquote>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、client5 和 client1 之间的关系：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E8%AE%A2%E9%98%85channel1.png" alt="订阅channel1"></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/channel1%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF.png" alt="channel1发布消息"></p>
<h2 id="2-2-常用命令"><a class="header-anchor" href="#2-2-常用命令"></a>2.2 常用命令</h2>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PSUBSCRIBE pattern [pattern …]</td>
<td style="text-align:center">订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td style="text-align:center">PUBSUB subcommand [argument [argument …]]</td>
<td style="text-align:center">查看订阅与发布系统状态。</td>
</tr>
<tr>
<td style="text-align:center">PUBLISH channel message</td>
<td style="text-align:center">将信息发送到指定的频道。</td>
</tr>
<tr>
<td style="text-align:center">PUNSUBSCRIBE [pattern [pattern …]]</td>
<td style="text-align:center">退订所有给定模式的频道。</td>
</tr>
<tr>
<td style="text-align:center">SUBSCRIBE channel [channel …]</td>
<td style="text-align:center">订阅给定的一个或多个频道的信息。</td>
</tr>
<tr>
<td style="text-align:center">UNSUBSCRIBE [channel [channel …]]</td>
<td style="text-align:center">指退订给定的频道。</td>
</tr>
</tbody>
</table>
<h2 id="2-3-相关案例"><a class="header-anchor" href="#2-3-相关案例"></a>2.3 相关案例</h2>
<blockquote>
<p>依次订阅多个频道</p>
</blockquote>
<p>要模拟 Redis 的发布和订阅，需要在 Linux 上开启两个终端，并在两个终端上都启动 Redis 服务，打开 Redis 客户端。其中一个终端用于订阅并接收消息，另一个终端用于发送消息。</p>
<p>首先使一个终端订阅三个频道：</p>
<pre>127.0.0.1:6379&gt; SUBSCRIBE c1 c2 c3
Reading messages... (press Ctrl-C to quit)
1) &quot;subscribe&quot;
2) &quot;c1&quot;
3) (integer) 1
1) &quot;subscribe&quot;
2) &quot;c2&quot;
3) (integer) 2
1) &quot;subscribe&quot;
2) &quot;c3&quot;
3) (integer) 3
1) &quot;message&quot;</pre>
<p>然后我们在另外一个终端发布消息：</p>
<pre>127.0.0.1:6379&gt; PUBLISH c2 hello-redis
(integer) 1
</pre>
<p>成功发布消息后，在订阅频道的终端就会收到消息，会出现如下显示：</p>
<pre>127.0.0.1:6379&gt; SUBSCRIBE c1 c2 c3
Reading messages... (press Ctrl-C to quit)
1) &quot;subscribe&quot;
2) &quot;c1&quot;
3) (integer) 1
1) &quot;subscribe&quot;
2) &quot;c2&quot;
3) (integer) 2
1) &quot;subscribe&quot;
2) &quot;c3&quot;
3) (integer) 3
1) &quot;message&quot;
2) &quot;c2&quot;
3) &quot;hello-redis&quot;
</pre>
<blockquote>
<p>通配符订阅多个频道</p>
</blockquote>
<p>Redis 还支持通配符 <code>*</code> 的方式订阅多个频道。还是和前面一样，打开两个终端，都启动 Redis 的客户端。</p>
<p>首先让一个终端使用通配符的方式订阅多个频道：</p>
<pre>127.0.0.1:6379&gt; PSUBSCRIBE new*
Reading messages... (press Ctrl-C to quit)
1) &quot;psubscribe&quot;
2) &quot;new*&quot;
3) (integer) 1
</pre>
<p>然后在另一个终端发送消息：</p>
<pre>127.0.0.1:6379&gt; PUBLISH new1 I-am-mofan
(integer) 1
127.0.0.1:6379&gt; PUBLISH new666 mofan212.github.io
(integer) 1</pre>
<p>回到订阅频道的终端，可以成功接收消息：</p>
<pre>127.0.0.1:6379&gt; PSUBSCRIBE new*
Reading messages... (press Ctrl-C to quit)
1) &quot;psubscribe&quot;
2) &quot;new*&quot;
3) (integer) 1
1) &quot;pmessage&quot;
2) &quot;new*&quot;
3) &quot;new1&quot;
4) &quot;I-am-mofan&quot;
1) &quot;pmessage&quot;
2) &quot;new*&quot;
3) &quot;new666&quot;
4) &quot;mofan212.getee.io&quot;</pre>
<h1 id="3-Redis-的复制"><a class="header-anchor" href="#3-Redis-的复制"></a>3. Redis 的复制</h1>
<h2 id="3-1-什么是主从复制"><a class="header-anchor" href="#3-1-什么是主从复制"></a>3.1 什么是主从复制</h2>
<p>Redis 官网介绍：<a target="_blank" rel="noopener" href="https://redis.io/topics/replication">Replication</a></p>
<p>主从复制（Master / Slaver），主机数据更新后根据配置和策略， 自动同步到备机的 master / slaver 机制。简单来说就是将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为主节点（master / leader），后者称为从节点（slave / follower）。</p>
<p>数据的复制是单向的，只能由主节点到从节点。Master 以写为主，Slave 以读为主。</p>
<p>那这能做什么呢？</p>
<ul>
<li>读写分离</li>
<li>容灾恢复</li>
<li>负载均衡</li>
<li>高可用基石</li>
</ul>
<p>一般来说，在工程项目中不会仅仅只使用一台 Redis，因为：</p>
<p>1、一台 Redis 会发生单点故障，而且一台服务器处理所有的请求压力会很大</p>
<p>2、单个 Redis 服务器的容量有限，一般来说，单台 Redis 最大使用内存不应该超过 20G。</p>
<h2 id="3-2-环境配置"><a class="header-anchor" href="#3-2-环境配置"></a>3.2 环境配置</h2>
<p>1、配从（库）不配主（库）</p>
<p>2、从库配置命令：<code>slaveof 主库IP 主库端口</code></p>
<ul>
<li>每次与 Master 断开之后，都需要重新连接，除非你配置进 Redis 的配置文件 redis.conf （具体位置：redis.conf 文件内搜索 <code>REPLICATION</code>，这也是在【Redis 基础 上篇】中没讲到的配置）</li>
<li>如果需要查看信息，可以使用命令：<code>info replication</code></li>
</ul>
<blockquote>
<p>修改配置文件细节操作</p>
</blockquote>
<p>1、拷贝多个 redis.conf 文件，按 “redis[port].conf” 进行重命名。</p>
<p>进入【Redis 基础 上篇】中存放 Redis 配置文件的地方，对这份配置文件复制三份：</p>
<pre>[root@cheny Redis]# cp redis.conf redis6379.conf
[root@cheny Redis]# cp redis.conf redis6380.conf
[root@cheny Redis]# cp redis.conf redis6381.conf
[root@cheny Redis]# ls -l
总用量 2616
-rw------- 1 mofan mofan 2247528 12月  3 21:40 <font color="#EF2929">redis-6.0.8.tar.gz</font>
-rw-r--r-- 1 root  root    84643 12月  6 14:15 redis6379.conf
-rw-r--r-- 1 root  root    84643 12月  6 14:15 redis6380.conf
-rw-r--r-- 1 root  root    84643 12月  6 14:15 redis6381.conf
-rw-r--r-- 1 root  root    84644 12月  5 22:16 redis_aof.conf
-rw-r--r-- 1 root  root    84643 12月  5 22:19 redis.conf
</pre>
<p>2、然后对每个配置文件进行如下修改：</p>
<ul>
<li>开启 <code>daemonize yes</code></li>
<li>pid 文件名字</li>
<li>指定端口（Redis 6.0.8 版本中该项位于 NETWORK 中）</li>
<li>log 文件名字</li>
<li>dump.rdb 名字（Redis 6.0.8 版本中该项位于 SNAPSHOTTING 中）</li>
</ul>
<p>其他配置项位于 GENERAL 中。</p>
<p>比如针对 redis6379.conf 文件，我们对这些配置项进行修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">port 6379</span><br><span class="line">logfile &quot;6379.log&quot;</span><br><span class="line">dbfilename dump6379.rdb</span><br></pre></td></tr></table></figure>
<p>对于 redis6380.conf 和 redis6381.conf 来说，也是按照这种方式进行修改，把和端口号相关的配置按照文件名进行修改即可。</p>
<p>最后通过三个配置文件启动三个 Redis 服务，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /Redis/redis6379.conf</span><br></pre></td></tr></table></figure>
<p>然后使用命令 <code>ps -ef|grep redis</code> 查看服务进程情况：</p>
<pre>[root@cheny Redis]# ps -ef|grep redis
root      20815      1  0 14:46 ?        00:00:00 <font color="#EF2929"><b>redis</b></font>-server 127.0.0.1:6379
root      20992      1  0 14:47 ?        00:00:00 <font color="#EF2929"><b>redis</b></font>-server 127.0.0.1:6380
root      21069      1  0 14:48 ?        00:00:00 <font color="#EF2929"><b>redis</b></font>-server 127.0.0.1:6381
root      21084  20502  0 14:48 pts/0    00:00:00 grep --color=auto <font color="#EF2929"><b>redis</b></font></pre>
<p>启动三个服务后，会在路径（我这里的路径是 <code>/usr/local/bin</code>）下生成对应的日志文件。</p>
<h2 id="3-3-一主二仆"><a class="header-anchor" href="#3-3-一主二仆"></a>3.3 一主二仆</h2>
<p>启动 Redis 服务后，在 <strong>三个终端</strong> 里打开 Redis 客户端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个终端</span></span><br><span class="line">redis-cli -p 6379</span><br><span class="line"><span class="comment"># 第二个终端</span></span><br><span class="line">redis-cli -p 6380</span><br><span class="line"><span class="comment"># 第三个终端</span></span><br><span class="line">redis-cli -p 6381</span><br></pre></td></tr></table></figure>
<p>启动客户端后，在三个终端内使用命令 <code>KEYS *</code> 查看 0 库是否为空，如果不为空，将其设置为空，执行命令 <code>FLUSHDB</code>。</p>
<p>在三个终端内执行命令 <code>INFO replication</code> 查看角色信息，可以发现三个客户端的角色都是 Master 主节点，比如 6380 端口下：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E9%BB%98%E8%AE%A4%E8%A7%92%E8%89%B2%E4%BF%A1%E6%81%AF.png" alt="默认角色信息"></p>
<p>我们需要将 6379 设置为 Master 主机（默认），将 6380 和 6381 设置为 Slave 从机。</p>
<p>先向 6379 中插入一些数据：</p>
<pre>27.0.0.1:6379&gt; set k1 v1
OK
127.0.0.1:6379&gt; set k2 v2
OK
127.0.0.1:6379&gt; set k3 v3
OK
127.0.0.1:6379&gt; KEYS *
1) &quot;k3&quot;
2) &quot;k2&quot;
3) &quot;k1&quot;
</pre>
<p>将 6380 设置为从机（跟着 6379 混）：</p>
<pre>127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379
OK
</pre>
<p>将 6381 设置为从机（跟着 6379 混）：</p>
<pre>127.0.0.1:6381&gt; SLAVEOF 127.0.0.1 6379
OK</pre>
<p>在 6379 主机中执行命令 <code>SET k4 v4</code> 再插入一条数据。</p>
<p>在 6380 和 6381 从机中执行命令 <code>GET k4</code> 尝试获取数据，看看能够获取数据。</p>
<p>6380 获取数据：</p>
<pre>127.0.0.1:6380&gt; get k4
&quot;v4&quot;
</pre>
<p>6381 获取数据：</p>
<pre>127.0.0.1:6381&gt; get k4
&quot;v4&quot;
</pre>
<p>可以看到，两个从机都获取到了数据。</p>
<blockquote>
<p>问题一</p>
</blockquote>
<p>那么问题来了，我们是在插入了 k1、k2 和 k3 后，才让 6380 和 6381 跟着主机 6379 混，两个从机都能获得到最后插入的数据 k4，那么从机能够获取到 k1、k2 和 k3 吗？我们来尝试一下。</p>
<p>从机 6380 获取 k1：</p>
<pre>127.0.0.1:6380&gt; get k1
&quot;v1&quot;
</pre>
<p>从机 6381 获取 k3：</p>
<pre>127.0.0.1:6381&gt; get k3
&quot;v3&quot;
</pre>
<p>可以看到从机能够获取到所有数据，也就是说从机会将主机的数据从头撸到尾。</p>
<blockquote>
<p>问题二</p>
</blockquote>
<p>在主机 6379 中再添加一个值 <code>SET k5 v5</code>，在从机 6380 和 6381 中对值进行修改，能够成功吗？</p>
<p>主机添加数据：</p>
<pre>127.0.0.1:6379&gt; SET k5 v5
OK
</pre>
<p>从机 6380 修改值：</p>
<pre>127.0.0.1:6380&gt; set k5 55
(error) READONLY You can&apos;t write against a read only replica.</pre>
<p>从机 6381 修改值：</p>
<pre>127.0.0.1:6381&gt; set k5 555
(error) READONLY You can&apos;t write against a read only replica.</pre>
<p>可以看到从机 <strong>默认</strong> 是无法添加或修改值的。</p>
<p>主机可以设置值，从机可以读取到，但是从机 <strong>默认</strong> 不能写值。</p>
<blockquote>
<p>问题三</p>
</blockquote>
<p>如果主机 6379 宕掉，从机数据会受影响吗？从机会上位变成主机吗？</p>
<p>看到主机 6379 数据，并手动模拟其宕掉：</p>
<pre>127.0.0.1:6379&gt; KEYS *
1) &quot;k4&quot;
2) &quot;k1&quot;
3) &quot;k2&quot;
4) &quot;k5&quot;
5) &quot;k3&quot;
127.0.0.1:6379&gt; SHUTDOWN
not connected&gt; exit
</pre>
<p>从机 6380 查看数据信息，并使用命令 <code>INFO replication</code> 查看从机信息：</p>
<pre>127.0.0.1:6380&gt; KEYS *
1) &quot;k3&quot;
2) &quot;k1&quot;
3) &quot;k4&quot;
4) &quot;k2&quot;
5) &quot;k5&quot;
127.0.0.1:6380&gt; INFO replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
master_link_status:down
master_last_io_seconds_ago:-1
master_sync_in_progress:0
slave_repl_offset:1775
master_link_down_since_seconds:59
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:01acd6b70486c8c3c9ccf15713b8568b625cb872
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:1775
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:1775</pre>
<p>对从机 6381 来说，也是上面一样的结果。</p>
<p>可以看到从机数据不会受到影响，并且从机也不会上位变成主机。</p>
<p>那么问题又来了，这时候主机又活了，并执行命令 <code>SET k6 v6</code>，从机能够获取到 k6 吗？</p>
<p>主机活过来，并添加数据：</p>
<pre>[root@cheny bin]# redis-server /Redis/redis6379.conf 
[root@cheny bin]# redis-cli -p 6379
127.0.0.1:6379&gt; SET k6 v6
OK
</pre>
<p>从机 6380 获取 k6：</p>
<pre>27.0.0.1:6380&gt; get k6
&quot;v6&quot;
</pre>
<p>从机 6381 获取 k6：</p>
<pre>127.0.0.1:6381&gt; get k6
&quot;v6&quot;</pre>
<p>可以看到，主机宕掉后，从机不会上位变成主机。主机又活了后，主从又连接上，如果主机添加数据，从机还能够获取到。</p>
<blockquote>
<p>问题四</p>
</blockquote>
<p>那如果一个从机宕掉了，会影响另外一个从机吗？</p>
<p>模拟 6380 从机宕掉：</p>
<pre>127.0.0.1:6380&gt; SHUTDOWN
not connected&gt; exit
</pre>
<p>主机 6379 添加数据：</p>
<pre>127.0.0.1:6379&gt; SET k7 v7
OK
</pre>
<p>从机 6381 获取 k7：</p>
<pre>127.0.0.1:6381&gt; GET k7
&quot;v7&quot;</pre>
<p>可以看到一个从机死了，不会影响另外一个从机。</p>
<p>那如果死了的从机又活了，它是继续连接主机，还是不会呢？</p>
<pre>[root@cheny bin]# redis-server /Redis/redis6380.conf 
[root@cheny bin]# redis-cli -p 6380
127.0.0.1:6380&gt; INFO replication
# Replication
role:master
connected_slaves:0
master_replid:329f88c3d94aee96c3fe66b9eae2cfc14848a6e6
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
</pre>
<p>可以看到 6380 活了后，不会连接上主机，自己默认的角色是 Master。</p>
<p>这也验证了我们最开始说的：从机与 Master 断开之后，都需要重新连接，除非你配置进 Redis 的配置文件 redis.conf（配置角色为从机和连接主机的信息）。</p>
<p>尝试 6380 从机获取 k7：</p>
<pre>127.0.0.1:6380&gt; GET k7
(nil)
</pre>
<p>很显然，无法获取到数据。让 6380 再次作为从机，连接主机为 6379，再看看能够获取到 k7：</p>
<pre>127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379
OK
127.0.0.1:6380&gt; GET k7
&quot;v7&quot;
</pre>
<p>重新连接主机后，从机 6380 又能获取到 k7 了。</p>
<h2 id="3-4-薪火相传"><a class="header-anchor" href="#3-4-薪火相传"></a>3.4 薪火相传</h2>
<p>在一主二仆中，Master 带了两个仆，当然还可以有多仆的情况，这个时候，Master 的压力就很大，带了很多仆。</p>
<p>那么我们可以使用“薪火相传”以去中心化，简单来说就是一个 Master 带几个仆，这些仆又来了几个仆，比如：</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/薪火相传.png" alt="薪火相传" style="zoom: 50%;" />
<p>上一个 Slave 可以是下一个 Slave 的 Master，Slave 同样可以接收其他 Slaves 的连接和同步请求，那么该 Slave 作为了链条中下一个的 Master, 可以有效减轻 Master 的写压力（记住：奴隶的奴隶还是奴隶）。</p>
<p>中途变更转向：会清除之前的数据，重新建立拷贝最新的。</p>
<p>使用命令：<code>slaveof 新主库IP 新主库端口</code></p>
<blockquote>
<p>基本测试</p>
</blockquote>
<p>让 6379 作为 Master，6380 作为从机，6381 作为 6380 的从机。</p>
<p>在一主二仆中，满足前两个，但 6381 是 6379 的从机，我们修改一下：</p>
<pre>127.0.0.1:6381&gt; SLAVEOF 127.0.0.1 6380
OK
</pre>
<p>使用 <code>INFO replication</code> 查看主机 6379 的信息：</p>
<pre>127.0.0.1:6379&gt; INFO replication
# Replication
role:master
connected_slaves:1
slave0:ip=127.0.0.1,port=6380,state=online,offset=2979,lag=0
master_replid:5743c894b43bcd99c2bed3b261d4d854f99d365c
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:2993
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:2993
</pre>
<p>可以看到 6379 的仆只有 6380 了。</p>
<p>在主机中使用命令 <code>SET k8 v8</code> 添加数据：</p>
<pre>127.0.0.1:6379&gt; KEYS *
1) &quot;k3&quot;
2) &quot;k6&quot;
3) &quot;k2&quot;
4) &quot;k4&quot;
5) &quot;k5&quot;
6) &quot;k7&quot;
7) &quot;k1&quot;
127.0.0.1:6379&gt; SET k8 v8
OK
</pre>
<p>不用想，6380 从机是可以获取到 k8 的：</p>
<pre>127.0.0.1:6380&gt; get k8
&quot;v8&quot;
</pre>
<p>那么 6381 从机可以获取到吗？</p>
<pre>127.0.0.1:6381&gt; get k8
&quot;v8&quot;
</pre>
<p>可以看到从机 6381 也是可以获取到 k8。</p>
<p>这个时候从机 6380 的角色是什么呢？对主机 6379 来说，它是从机，但是对 6381 来说，它又是主机。执行命令 <code>INFO replication</code> 看看：</p>
<pre>127.0.0.1:6380&gt; INFO replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
master_link_status:up
master_last_io_seconds_ago:5
master_sync_in_progress:0
slave_repl_offset:3731
slave_priority:100
slave_read_only:1
connected_slaves:1
slave0:ip=127.0.0.1,port=6381,state=online,offset=3731,lag=1
master_replid:5743c894b43bcd99c2bed3b261d4d854f99d365c
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:3731
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1790
repl_backlog_histlen:1942</pre>
<p>6380 的角色还是从机，翻身？不可能的！只不过可以从信息看到 6380 从机还连接了一个从机 6381。</p>
<h2 id="3-5-反客为主"><a class="header-anchor" href="#3-5-反客为主"></a>3.5 反客为主</h2>
<blockquote>
<p>介绍前的准备</p>
</blockquote>
<p>在介绍“反客为主”之前，我们先将 6381 设置成 6379 的从机：</p>
<pre>127.0.0.1:6381&gt; SLAVEOF 127.0.0.1 6379
OK
</pre>
<p>查看 6379 主机的信息：</p>
<pre>127.0.0.1:6379&gt; INFO replication
# Replication
role:master
connected_slaves:2
slave0:ip=127.0.0.1,port=6380,state=online,offset=3885,lag=0
slave1:ip=127.0.0.1,port=6381,state=online,offset=3885,lag=0
master_replid:5743c894b43bcd99c2bed3b261d4d854f99d365c
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:3885
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:3885
</pre>
<p>嗯！没问题，我们继续。</p>
<blockquote>
<p>反客为主</p>
</blockquote>
<p>什么叫反客为主？</p>
<p>使当前数据库停止与其他数据库的同步，转成主数据库。</p>
<p>在一主二仆中我们知道，如果主机宕机，两个仆还是原地待命，主机活过来，两个仆重新连上。如果主机活不过来了，我们可以让一个从机变成主机，这个时候其余的从机链接到这台机器。</p>
<p>在没有主机的情况下，对某一个从机使用命令 <code>SLAVEOF NO ONE</code>，就可以让这个从机变成主机。</p>
<p>对一个从属服务器执行命令 <code>SLAVEOF NO ONE</code> 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集不会被丢弃。</p>
<p>让主机 6379 宕机：</p>
<pre>127.0.0.1:6379&gt; SHUTDOWN
not connected&gt; exit
</pre>
<p>从机 6380 谋权篡位：</p>
<pre>127.0.0.1:6380&gt; SLAVEOF no one
OK
127.0.0.1:6380&gt; INFO replication
# Replication
role:master
connected_slaves:0
master_replid:9fbaa89cfb388bf036b4cd489023cfeb0e8a5fb9
master_replid2:5743c894b43bcd99c2bed3b261d4d854f99d365c
master_repl_offset:4627
second_repl_offset:4628
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1790
repl_backlog_histlen:2838</pre>
<p>可以看到 6380 变成了主机。</p>
<p>看看 6381 的信息：</p>
<pre>127.0.0.1:6381&gt; INFO replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
master_link_status:down
master_last_io_seconds_ago:-1
master_sync_in_progress:0
slave_repl_offset:4627
master_link_down_since_seconds:204
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:5743c894b43bcd99c2bed3b261d4d854f99d365c
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:4627
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:4627
</pre>
<p>我们在 6380 中添加新数据：</p>
<pre>127.0.0.1:6380&gt; SET k9 v9
OK
</pre>
<p>那 6381 能够获取到 k9 吗？</p>
<pre>127.0.0.1:6381&gt; GET k9
(nil)
</pre>
<p>看样子没有连接是不行的，6381 是不能获取到数据的。</p>
<p>让 6381 作为 6380 的从机，然后再获取 k9 试试：</p>
<pre>127.0.0.1:6381&gt; SLAVEOF 127.0.0.1 6380
OK
127.0.0.1:6381&gt; GET k9
&quot;v9&quot;
</pre>
<p>成功获取到数据！</p>
<p>那这时候原来的主机 6379 诈尸了，又活过来了呢？</p>
<pre>[root@cheny bin]# redis-server /Redis/redis6379.conf 
[root@cheny bin]# redis-cli -p 6379
127.0.0.1:6379&gt; get k9
(nil)
127.0.0.1:6379&gt; INFO replication
# Replication
role:master
connected_slaves:0
master_replid:1729c5bcd52e700756dc2389081be3ea776a489c
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
</pre>
<p>就算 6379 又活过来也不行了，6379 已经是光杆司令了。6380 和 6381 是一套体系，6379 又是另外一套体系（果然只是诈尸）。</p>
<p>如果将 6380 又设置成 6379 的主机，这时候在 6379 中可以获取到 6380 中的数据，这个时候就相当于是“薪火相传”的情况。</p>
<h2 id="3-6-复制原理"><a class="header-anchor" href="#3-6-复制原理"></a>3.6 复制原理</h2>
<p>Slave 启动成功连接到 Master 后会发送一个 sync 命令</p>
<p>Master 接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，Master 将传送整个数据文件到Slave，以完成一次完全同步</p>
<p>全量复制：Slave 服务在接收到数据库文件数据后，会将其存盘并加载到内存中。</p>
<p>增量复制：Master 继续将新的所有收集到的修改命令依次传给 Slave，完成同步</p>
<p>但是只要是重新连接 Master，一次完全同步（全量复制）将被自动执行</p>
<h2 id="3-7-哨兵模式"><a class="header-anchor" href="#3-7-哨兵模式"></a>3.7 哨兵模式</h2>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/06ab9daf921d">Redis哨兵（Sentinel）模式</a></p>
<p><strong>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。</strong> 这不是一种推荐的方式，更多时候，我们优先考虑 <strong>哨兵模式</strong>。Redis 从 2.8 开始正式提供了Sentinel（哨兵） 架构来解决这个问题。</p>
<blockquote>
<p>哨兵模式概述</p>
</blockquote>
<p>哨兵模式是一种特殊的模式，首先 Redis 提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是 <strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个 Redis 实例。</strong></p>
<p>可以理解成反客为主的自动版，能够在后台监控主机是否发生了故障，如果故障了会根据投票数自动将从库转换为主库。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/Redis%E5%93%A8%E5%85%B5.png" alt="Redis哨兵"></p>
<p>这里的哨兵有两个作用</p>
<ul>
<li>通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器。</li>
<li>当哨兵监测到 Master 宕机，会自动将 Slave 切换成 Master，然后通过 <strong>发布订阅模式</strong> 通知其他的从服务器，修改配置文件，让它们切换主机。</li>
</ul>
<p>然而一个哨兵进程对 Redis 服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E5%A4%9A%E5%93%A8%E5%85%B5%E7%9B%91%E6%8E%A7Redis.png" alt="多哨兵监控Redis"></p>
<p>用文字描述一下 <strong>故障切换（failover）</strong> 的过程。假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵 1 主观的认为主服务器不可用，这个现象成为 <strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为 <strong>客观下线</strong>。这样对于客户端而言，一切都是透明的。</p>
<blockquote>
<p>使用步骤</p>
</blockquote>
<p>1、在前面的配置上调整结构，使6379 带着6380、6381</p>
<p>2、在 Linux 的 /Redis 目录下新建  <code>sentinel.conf</code> 文件，<strong>名字绝不能错！</strong></p>
<pre>[root@cheny Redis]# touch sentinel.conf
[root@cheny Redis]# ls -l
总用量 2616
-rw------- 1 mofan mofan 2247528 12月  3 21:40 <font color="#EF2929">redis-6.0.8.tar.gz</font>
-rw-r--r-- 1 root  root    84655 12月  6 14:35 redis6379.conf
-rw-r--r-- 1 root  root    84655 12月  6 14:41 redis6380.conf
-rw-r--r-- 1 root  root    84655 12月  6 14:43 redis6381.conf
-rw-r--r-- 1 root  root    84644 12月  5 22:16 redis_aof.conf
-rw-r--r-- 1 root  root    84643 12月  5 22:19 redis.conf
-rw-r--r-- 1 root  root        0 12月  6 16:57 sentinel.conf
</pre>
<p>3、配置哨兵，在 sentinel.conf 文件内填写内容，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;master-group-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>sentinel monitor 被监控主机名字(自己起名字) 127.0.0.1 6379 1</code></p>
</li>
<li>
<p>上面最后一个数字 1，表示主机挂掉后 Salve 投票看让谁接替成为主机，得票数多少后成为主机</p>
</li>
</ul>
<p>比如：</p>
<pre>sentinel monitor host6379 127.0.0.1 6379 1
</pre>
<p>4、启动哨兵，使用命令 <code>redis-sentinel /Redis/sentinel.conf</code> （上述目录依照各自的实际情况配置，可能目录不同）。比如：</p>
<pre>[root@cheny Redis]# cd /usr/local/bin
[root@cheny bin]# ls -l
总用量 36032
-rw-r--r-- 1 root root   15041 12月  6 16:39 6379.log
-rw-r--r-- 1 root root   70376 12月  6 16:39 6380.log
-rw-r--r-- 1 root root  145855 12月  6 16:39 6381.log
-rw-r--r-- 1 root root    1017 12月  6 00:01 appendonly.aof
-rw-r--r-- 1 root root     236 12月  6 16:39 dump6379.rdb
-rw-r--r-- 1 root root     236 12月  6 16:39 dump6380.rdb
-rw-r--r-- 1 root root     236 12月  6 16:39 dump6381.rdb
-rw-r--r-- 1 root root     116 12月  6 14:14 dump.rdb
-rwxr-xr-x 1 root root 4719848 12月  4 12:51 <font color="#00AF00">redis-benchmark</font>
-rwxr-xr-x 1 root root 8976960 12月  4 12:51 <font color="#00AF00">redis-check-aof</font>
-rwxr-xr-x 1 root root 8976960 12月  4 12:51 <font color="#00AF00">redis-check-rdb</font>
-rwxr-xr-x 1 root root 4976648 12月  4 12:51 <font color="#00AF00">redis-cli</font>
lrwxrwxrwx 1 root root      12 12月  4 12:51 <font color="#00FFFF">redis-sentinel</font> -&gt; <font color="#00AF00">redis-server</font>
-rwxr-xr-x 1 root root 8976960 12月  4 12:51 <font color="#00AF00">redis-server</font>
[root@cheny bin]# redis-sentinel /Redis/sentinel.conf
</pre>
<p>启动成功后截图：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F%E5%90%8E%E7%A4%BA%E4%BE%8B.png" alt="哨兵模式启动成功后示例"></p>
<p>5、正常主从演示</p>
<p>6、原有的 Master 挂了</p>
<p>7、投票新选</p>
<p>8、重新主从继续开工，<code>info replication</code> 查看信息</p>
<p>查看一下 6379、6380 和 6381 中的数据，三个客户端的数据是一样的，假设以 6379 为例：</p>
<pre>127.0.0.1:6379&gt; KEYS *
1) &quot;k3&quot;
2) &quot;k1&quot;
3) &quot;k8&quot;
4) &quot;k5&quot;
5) &quot;k2&quot;
6) &quot;k6&quot;
7) &quot;k7&quot;
8) &quot;k4&quot;
</pre>
<p>这个时候 6379 是主机，模拟 6379 挂掉：</p>
<pre>127.0.0.1:6379&gt; SHUTDOWN
not connected&gt; exit</pre>
<p>这时候哨兵会监控到 6379 挂了，然后对从机进行投票，选出一个新的主机。票选截图：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E5%93%A8%E5%85%B5%E7%A5%A8%E9%80%89%E6%88%AA%E5%9B%BE.png" alt="哨兵票选截图"></p>
<p>可以看懂，6380 变成了主机，如果不信，执行命令查看一下：</p>
<pre>127.0.0.1:6380&gt; INFO replication
# Replication
role:master
connected_slaves:1
slave0:ip=127.0.0.1,port=6381,state=online,offset=40415,lag=1
master_replid:767f5c305d52ffe479b4a1154874e59532934f0e
master_replid2:4f1f8029918698d3d197168e34bfb0c66e01d04a
master_repl_offset:40415
second_repl_offset:28850
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:40415
</pre>
<p>从上述信息也可以看出，6380 变成了主机，6381 成为了 6381 的从机。</p>
<p>那么问题又来了，如果之前挂了的 Master 重启回来，会不会双 Master 冲突？尝试一下：</p>
<pre>[root@cheny bin]# redis-server /Redis/redis6379.conf 
[root@cheny bin]# redis-cli -p 6379
127.0.0.1:6379&gt; INFO replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6380
master_link_status:up
master_last_io_seconds_ago:1
master_sync_in_progress:0
slave_repl_offset:51848
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:767f5c305d52ffe479b4a1154874e59532934f0e
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:51848
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:51693
repl_backlog_histlen:156
</pre>
<p>6379 变成了 Salve，再看看 6380：</p>
<pre>127.0.0.1:6380&gt; INFO replication
# Replication
role:master
connected_slaves:2
slave0:ip=127.0.0.1,port=6381,state=online,offset=59450,lag=1
slave1:ip=127.0.0.1,port=6379,state=online,offset=59450,lag=1
master_replid:767f5c305d52ffe479b4a1154874e59532934f0e
master_replid2:4f1f8029918698d3d197168e34bfb0c66e01d04a
master_repl_offset:59450
second_repl_offset:28850
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:59450</pre>
<p>不难得出结论，原 Master 活过来后，会变成 Salve 依附新的 Master，所以也就不会产生冲突。</p>
<p>其实从前面截取的哨兵票选截图也可以看到 6379 变成了 6380 的 Salve。</p>
<blockquote>
<p>哨兵模式配置介绍</p>
</blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011784767/article/details/77994046">Redis高可用方案哨兵机制------ 配置文件sentinel.conf详解</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># Example sentinel.conf</span><br><span class="line"> </span><br><span class="line"># 哨兵sentinel实例运行的端口 默认26379</span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"># 哨兵sentinel的工作目录</span><br><span class="line">dir /tmp</span><br><span class="line"> </span><br><span class="line"># 哨兵sentinel监控的redis主节点的 ip port </span><br><span class="line"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span><br><span class="line"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span><br><span class="line"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line">  sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"> </span><br><span class="line"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span><br><span class="line"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><br><span class="line"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><br><span class="line"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span><br><span class="line">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><br><span class="line">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span><br><span class="line">#3.当想要取消一个正在进行的failover所需要的时间。  </span><br><span class="line">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><br><span class="line"># 默认三分钟</span><br><span class="line"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"> </span><br><span class="line"># SCRIPTS EXECUTION</span><br><span class="line"> </span><br><span class="line">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><br><span class="line">#对于脚本的运行结果有以下规则：</span><br><span class="line">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><br><span class="line">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><br><span class="line">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><br><span class="line">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><br><span class="line"> </span><br><span class="line">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span><br><span class="line">这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span><br><span class="line">一个是事件的类型，</span><br><span class="line">一个是事件的描述。</span><br><span class="line">如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><br><span class="line">#通知脚本</span><br><span class="line"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="line">  sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"> </span><br><span class="line"># 客户端重新配置主节点参数脚本</span><br><span class="line"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><br><span class="line"># 以下参数将会在调用脚本时传给脚本:</span><br><span class="line"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="line"># 目前&lt;state&gt;总是“failover”,</span><br><span class="line"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span><br><span class="line"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span><br><span class="line"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span><br><span class="line"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="line"> sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>哨兵模式的优缺点</p>
</blockquote>
<p><strong>优点：</strong></p>
<p>1、哨兵集群模式是基于主从模式的，所有主从的优点，哨兵模式同样具有</p>
<p>2、主从可以切换，故障可以转移，系统可用性更好。</p>
<p>3、哨兵模式是主从模式的升级，系统更健壮，可用性更高。</p>
<p><strong>缺点：</strong></p>
<p>1、Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂</p>
<p>2、实现哨兵模式的配置也不简单，甚至可以说有些繁琐</p>
<h2 id="3-8-复制的缺点"><a class="header-anchor" href="#3-8-复制的缺点"></a>3.8 复制的缺点</h2>
<p><strong>复制延时</strong></p>
<p>由于所有的写操作都是先在 Master 上操作，然后同步更新到 Slave 上，所以从 Master 同步到 Slave 机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave 机器数量的增加也会使这个问题更加严重。</p>
<h1 id="4-Jedis"><a class="header-anchor" href="#4-Jedis"></a>4. Jedis</h1>
<h2 id="4-1-测试连通"><a class="header-anchor" href="#4-1-测试连通"></a>4.1 测试连通</h2>
<p>Jedis 是 Redis 官方推荐的 Java 连接开发工具。要在 Java 开发中使用好 Redis 中间件，必须对 Jedis 熟悉才能写成漂亮的代码。</p>
<p>在使用 IDEA 连接虚拟机的 Redis 时，需要先修改配置文件 redis.conf。因为我是使用的是拷贝的配置文件 redis_aof.conf，所以需要修改这个配置文件，使用命令 <code>vi redis_aof.conf</code>。</p>
<p>在 Redis 6.0.8 中，修改 NETWORK 栏中的配置：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/Jedis%E8%BF%9E%E6%8E%A5%E5%89%8D%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="Jedis连接前修改配置文件"></p>
<p>然后在虚拟机中重启 Redis 客户端。</p>
<p>咱们用 IDEA 创建一个 Maven 项目，然后导入 jedis 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan 2020/12/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个参数为 Redis 服务器的 ip 地址，我在此处修改了开发机的 host 文件</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;redis&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后运行代码，可以在控制台看到打印出来的 PONG，证明我们连接成功。</p>
<h2 id="4-2-常用-API"><a class="header-anchor" href="#4-2-常用-API"></a>4.2 常用 API</h2>
<blockquote>
<p>数据添加和获取</p>
</blockquote>
<p>现在 Linux 中看看 Redis 里有没有数据：</p>
<pre>127.0.0.1:6379&gt; KEYS *
(empty array)
</pre>
<p>可以，没有数据。</p>
<p>返回 Windows，编写代码，向里面添加数据，并获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testSetAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;redis&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    jedis.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">    jedis.set(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">    jedis.set(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;k2&quot;</span>)); <span class="comment">// v2</span></span><br><span class="line">    Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    System.out.println(keys.size()); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，控制台打印成功，返回 Linux 下的 Redis，查看数据：</p>
<pre>127.0.0.1:6379&gt; KEYS *
1) &quot;k3&quot;
2) &quot;k2&quot;
3) &quot;k1&quot;
</pre>
<p>数据添加成功！API 使用成功。</p>
<p>Jedis 的操作方法就和我们在 Linux 中书写命令是一样的，只要命令熟悉了，没什么操作不能一个点不能点出来的，因此就不再赘述了。</p>
<blockquote>
<p>List 列表排序</p>
</blockquote>
<p>讲一下 Jedis 实现列表排序。</p>
<p>使用排序， 首先需要生成一个排序对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SortingParams</span>  <span class="variable">sortingParams</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">SortingParams</span>();</span><br></pre></td></tr></table></figure>
<p>三个排序 API 如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">语法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">jedis.sort(String key, sortingParams.alpha())</td>
<td style="text-align:center">队列按首字母 a-z  排序</td>
</tr>
<tr>
<td style="text-align:center">jedis.sort(String key,  sortingParams.asc())</td>
<td style="text-align:center">队列按数字升序排列</td>
</tr>
<tr>
<td style="text-align:center">jedis.sort(String key, sortingParams.desc())</td>
<td style="text-align:center">队列按数字降序排列</td>
</tr>
</tbody>
</table>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testSortedList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;redis&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    jedis.lpush(<span class="string">&quot;list01&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(jedis.lrange(<span class="string">&quot;list01&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    <span class="type">SortingParams</span> <span class="variable">sortingParams</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SortingParams</span>();</span><br><span class="line"></span><br><span class="line">    System.out.println(jedis.sort(<span class="string">&quot;list01&quot;</span>, sortingParams.alpha()));</span><br><span class="line">    System.out.println(jedis.sort(<span class="string">&quot;list01&quot;</span>, sortingParams.asc()));</span><br><span class="line">    System.out.println(jedis.sort(<span class="string">&quot;list01&quot;</span>, sortingParams.desc()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<pre>
[c, b, a, 3, 2, 1]
[1, 2, 3, a, b, c]
[1, 2, 3, a, b, c]
[c, b, a, 3, 2, 1]
</pre>
<h2 id="4-3-事务"><a class="header-anchor" href="#4-3-事务"></a>4.3 事务</h2>
<blockquote>
<p>日常 API 使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;redis&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">transaction</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line"></span><br><span class="line">    transaction.set(<span class="string">&quot;k4&quot;</span>, <span class="string">&quot;v4&quot;</span>);</span><br><span class="line">    transaction.set(<span class="string">&quot;k5&quot;</span>, <span class="string">&quot;v5&quot;</span>);</span><br><span class="line"></span><br><span class="line">    transaction.exec();</span><br><span class="line">    <span class="comment">// 出现异常，回滚 一般放在 catch 块中</span></span><br><span class="line">    <span class="comment">// transaction.discard();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// v4</span></span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;k4&quot;</span>));</span><br><span class="line">    <span class="comment">// v5</span></span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;k5&quot;</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>加锁</p>
</blockquote>
<p>在测试加锁之前，先在 Linux 的 Redis 中插入两条数据。</p>
<pre>127.0.0.1:6379&gt; set balance 100
OK
127.0.0.1:6379&gt; set debt 0
OK
127.0.0.1:6379&gt; get balance
&quot;100&quot;
127.0.0.1:6379&gt; get debt
&quot;0&quot;
</pre>
<p>然后编写程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;redis&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="type">int</span> balance; <span class="comment">// 可用余额</span></span><br><span class="line">    <span class="type">int</span> debt; <span class="comment">// 欠额</span></span><br><span class="line">    <span class="comment">// 实刷额度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">amtToSubtract</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    jedis.watch(<span class="string">&quot;balance&quot;</span>);</span><br><span class="line">    <span class="comment">// 模拟其他程序已经修改了该条目</span></span><br><span class="line">    jedis.set(<span class="string">&quot;balance&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">7000</span>);</span><br><span class="line">    balance = Integer.parseInt(jedis.get(<span class="string">&quot;balance&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (balance &lt; amtToSubtract) &#123;</span><br><span class="line">        jedis.unwatch();</span><br><span class="line">        System.out.println(<span class="string">&quot;modify&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;***********transaction&quot;</span>);</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">transaction</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line">        transaction.decrBy(<span class="string">&quot;balance&quot;</span>, amtToSubtract);</span><br><span class="line">        transaction.incrBy(<span class="string">&quot;debt&quot;</span>, amtToSubtract);</span><br><span class="line">        transaction.exec();</span><br><span class="line">        balance = Integer.parseInt(jedis.get(<span class="string">&quot;balance&quot;</span>));</span><br><span class="line">        debt = Integer.parseInt(jedis.get(<span class="string">&quot;debt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******&quot;</span> + balance);</span><br><span class="line">        System.out.println(<span class="string">&quot;*******&quot;</span> + debt);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通俗点讲，watch命令就是标记一个键，如果标记了一个键，</span></span><br><span class="line"><span class="comment"> * 在提交事务前如果该键被别人修改过，那事务就会失败，这种情况通常可以在程序中 重新再尝试一次。</span></span><br><span class="line"><span class="comment"> * 首先标记了键balance，然后检查余额是否足够，不足就取消标记，并不做扣减；</span></span><br><span class="line"><span class="comment"> * 足够的话，就启动事务进行更新操作，</span></span><br><span class="line"><span class="comment"> * 如果在此期间键balance被其它人修改， 那在提交事务（执行exec）时就会报错，</span></span><br><span class="line"><span class="comment"> * 程序中通常可以捕获这类错误再重新执行一次，直到成功。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">TestMulti</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestMulti</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">retValue</span> <span class="operator">=</span> test.transMethod();</span><br><span class="line">    System.out.println(<span class="string">&quot;main retValue-------: &quot;</span> + retValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终控制台打印：</p>
<pre>
modify
main retValue-------: false
</pre>
<h2 id="4-4-主从复制"><a class="header-anchor" href="#4-4-主从复制"></a>4.4 主从复制</h2>
<p>在 Linux 上让 6379 和 6380 启动，并让各自先独立，即：两个客户端的角色都是 Master，同时清空数据（如果使用了其他配置文件，记得按照最开始那样修改配置文件）。</p>
<p>然后编写代码，实现主机写，从机读：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedisM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;redis&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedisS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;redis&quot;</span>, <span class="number">6380</span>);</span><br><span class="line"></span><br><span class="line">    jedisS.slaveof(<span class="string">&quot;redis&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    jedisM.set(<span class="string">&quot;mofan&quot;</span>, <span class="string">&quot;212&quot;</span>);</span><br><span class="line">    <span class="comment">// 添加速度很快，可能有延迟，可以去 Redis 中查看或者再次执行</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedisS.get(<span class="string">&quot;mofan&quot;</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-5-JedisPool"><a class="header-anchor" href="#4-5-JedisPool"></a>4.5 JedisPool</h2>
<blockquote>
<p>JedisPoolUtil</p>
</blockquote>
<p>一个工具类，并且是单例的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan 2020/12/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisPoolUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">JedisPoolUtil</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title function_">getJedisPoolInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == jedisPool) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (JedisPoolUtil.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == jedisPool) &#123;</span><br><span class="line">                    <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">                    poolConfig.setMaxTotal(<span class="number">1000</span>);</span><br><span class="line">                    poolConfig.setMaxIdle(<span class="number">32</span>);</span><br><span class="line">                    poolConfig.setMaxWaitMillis(<span class="number">100</span> * <span class="number">1000</span>);</span><br><span class="line">                    poolConfig.setTestOnBorrow(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig, <span class="string">&quot;redis&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(JedisPool jedisPool, Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != jedis) &#123;</span><br><span class="line">            jedisPool.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试连接池的使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cheny 2020/12/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line">        <span class="type">JedisPool</span> <span class="variable">jedisPool2</span> <span class="operator">=</span> JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(jedisPool == jedisPool2);</span><br><span class="line"></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            jedis.set(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>);</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;aa&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JedisPoolUtil.release(jedisPool, jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后，控制台会输出 <code>true</code> 和 <code>bb</code>。</p>
<p>控制台可能会出现一下问题，但是不影响运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span><br></pre></td></tr></table></figure>
<p>其实就是缺少 SLF4J，在 pom.xml 中导入就行了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置总结</p>
</blockquote>
<p>JedisPool 的配置参数大部分是由 JedisPoolConfig 的对应项来赋值的。</p>
<ul>
<li><strong>maxActive</strong>：控制一个 pool 可分配多少个 jedis 实例，通过 pool.getResource() 来获取。如果赋值为 -1，则表示不限制；如果 pool 已经分配了maxActive 个 jedis 实例，则此时 pool 的状态为 exhausted。</li>
<li><strong>maxIdle</strong>：控制一个 pool 最多有多少个状态为 idle(空闲) 的 jedis 实例；</li>
<li>whenExhaustedAction：表示当 pool 中的 jedis 实例都被 allocated 完时，pool 要采取的操作；默认有三种。
<ul>
<li>WHEN_EXHAUSTED_FAIL：表示无jedis实例时，直接抛出NoSuchElementException；</li>
<li>WHEN_EXHAUSTED_BLOCK：则表示阻塞住，或者达到 maxWait 时抛出 JedisConnectionException；</li>
<li>WHEN_EXHAUSTED_GROW：则表示新建一个 jedis 实例，也就说设置的 maxActive 无用；</li>
</ul>
</li>
<li><strong>maxWait</strong>：表示当 borrow 一个 jedis 实例时，最大的等待时间，如果超过等待时间，则直接抛 JedisConnectionException；</li>
<li><strong>testOnBorrow</strong>：获得一个 jedis 实例的时候是否检查连接可用性（ping()）；如果为 true，则得到的jedis实例均是可用的；</li>
<li><strong>testOnReturn</strong>：return 一个 jedis 实例给 pool 时，是否检查连接可用性（ping()）；</li>
<li><strong>testWhileIdle</strong>：如果为 true，表示有一个 idle object evitor 线程对 idle object 进行扫描，如果 validate 失败，此 object 会被从 pool 中 drop 掉；这一项只有在 timeBetweenEvictionRunsMillis 大于 0 时才有意义；</li>
<li><strong>timeBetweenEvictionRunsMillis</strong>：表示 idle object evitor 两次扫描之间要 sleep 的毫秒数；</li>
<li><strong>numTestsPerEvictionRun</strong>：表示 idle object evitor 每次扫描的最多的对象数；</li>
<li><strong>minEvictableIdleTimeMillis</strong>：表示一个对象至少停留在idle状态的最短时间，然后才能被 idle object evitor 扫描并驱逐；这一项只有在 timeBetweenEvictionRunsMillis 大于 0 时才有意义；</li>
<li><strong>softMinEvictableIdleTimeMillis</strong>：在 minEvictableIdleTimeMillis 基础上，加入了至少 minIdle 个对象已经在 pool 里面了。如果为 -1，evicted 不会根据 idle time 驱逐任何对象。如果 minEvictableIdleTimeMillis &gt; 0，则此项设置无意义，且只有在 timeBetweenEvictionRunsMillis 大于 0 时才有意义；</li>
<li><strong>lifo</strong>：borrowObject 返回对象时，是采用 DEFAULT_LIFO（last in first out，即类似 cache 的最频繁使用队列），如果为 false，则表示 FIFO 队列；</li>
</ul>
<hr>
<p>其中JedisPoolConfig对一些参数的默认设置如下：</p>
<ul>
<li>testWhileIdle = true</li>
<li>minEvictableIdleTimeMills = 60000</li>
<li>timeBetweenEvictionRunsMillis = 30000</li>
<li>numTestsPerEvictionRun = -1</li>
</ul>
<p>注意：以上部分配置在高版本的 Jedis 中已被启用，导致编写代码时无法使用，官方也提供了代替的方法，因此上述配置仅供参考。</p>
<h1 id="5-三种特殊数据类型"><a class="header-anchor" href="#5-三种特殊数据类型"></a>5. 三种特殊数据类型</h1>
<h2 id="5-1-Geospatial-地理位置"><a class="header-anchor" href="#5-1-Geospatial-地理位置"></a>5.1 Geospatial 地理位置</h2>
<p>Geospatial 在 Redis 3.2 版本中推出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作，来实现一些依赖于地理位置信息的功能，比如：附近的人。</p>
<p>GEO 的数据类型为 Zset。</p>
<p>GEO 的数据结构总共有六个常用命令：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/GEO%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.png" alt="GEO常用命令"></p>
<p>具体操作可以参考这个链接：https://www.redis.net.cn/order/3685.html</p>
<p>如果想要强制输出中文，可以重新连接 redis-cli，增加参数  <code>--raw</code>，而不然会乱码。</p>
<blockquote>
<p>geoadd</p>
</blockquote>
<p>使用这个命令可以将给定的空间元素（纬度、经度、名字）添加到指定的键里面。</p>
<p>语法介绍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude member ...</span><br></pre></td></tr></table></figure>
<p>这些数据会以有序集合的形式被储存在键里面。</p>
<p>geoadd 命令以标准的 <code>x , y</code> 格式接受参数，所以用户必须先输入经度，然后再输入纬度。</p>
<p>geoadd 能够记录的坐标是有限的：非常接近两极的区域无法被索引。</p>
<p>有效的经度介 -180 到 180 度之间，有效的纬度介于 -85.05112878 度至 85.05112878 度之间。当用户尝试输入一个超出范围的经度或者纬度，geoadd 命令将返回一个错误。</p>
<p>手动添加一些数据，用于后续测试：</p>
<pre>127.0.0.1:6379&gt; GEOADD china:city 116.23 40.22 beijing
(integer) 1
127.0.0.1:6379&gt; GEOADD china:city 121.48 31.40 shanghai 113.88 22.55 shenzhen 120.21 30.20 hangzhou
(integer) 3
127.0.0.1:6379&gt; GEOADD china:city 106.54 29.40 chongqing 102.54 30.05 chengdu 108.93 34.23 sian
(integer) 3
</pre>
<blockquote>
<p>geopos</p>
</blockquote>
<p>语法介绍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geopos key member [member...]</span><br></pre></td></tr></table></figure>
<p>使用这个命令从 key 里返回所有给定位置元素的位置（经度和纬度）。</p>
<pre>127.0.0.1:6379&gt; GEOPOS china:city beijing
1) 1) &quot;116.23000055551528931&quot;
   2) &quot;40.2200010338739844&quot;
127.0.0.1:6379&gt; GEOPOS china:city shanghai chengdu
1) 1) &quot;121.48000091314315796&quot;
   2) &quot;31.40000025319353938&quot;
2) 1) &quot;102.54000037908554077&quot;
   2) &quot;30.05000015956613169&quot;
127.0.0.1:6379&gt; GEOPOS china:city wuhan
1) (nil)
</pre>
<blockquote>
<p>geodist</p>
</blockquote>
<p>语法介绍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geodist key member1 member2 [unit]</span><br></pre></td></tr></table></figure>
<p>使用这个命令可以返回两个给定位置之间的距离，如果两个位置之间的其中一个不存在，那么返回空值。</p>
<p>指定单位的参数 unit 必须是以下单位的其中一个：</p>
<ul>
<li>
<p>m 表示单位为米</p>
</li>
<li>
<p>km 表示单位为千米</p>
</li>
<li>
<p>mi 表示单位为英里</p>
</li>
<li>
<p>ft 表示单位为英尺</p>
</li>
</ul>
<p>如果用户没有显式地指定单位参数，那么 <code>geodist</code> <strong>默认</strong> 使用米作为单位。</p>
<p><code>geodist</code> 命令在计算距离时会假设地球为完美的球形，因此在极限情况下，这一假设最大会造成 0.5% 的误差。</p>
<pre>127.0.0.1:6379&gt; GEODIST china:city beijing shanghai
&quot;1088785.4302&quot;
127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km
&quot;1088.7854&quot;
127.0.0.1:6379&gt; GEODIST china:city chongqing chengdu km
&quot;393.0455&quot;
</pre>
<blockquote>
<p>georadius</p>
</blockquote>
<p>语法解析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">georadius key longitude latitude radius m|km|ft|mi [withcoord][withdist] [withhash][asc|desc][count count]</span><br></pre></td></tr></table></figure>
<p>使用这个命令可以以给定的经纬度为中心， 找出某一半径内的元素。（类似“附近的人”功能）</p>
<p>在 key 中寻找坐标 longitude latitude 半径为 radius 的城市，withcoord 显示经纬度，withdist 显示中心距离，[count count1] 可以限定个数为 count1 个。</p>
<pre>127.0.0.1:6379&gt; GEORADIUS china:city 100 30 1000 km
1) &quot;chengdu&quot;
2) &quot;chongqing&quot;
3) &quot;sian&quot;
127.0.0.1:6379&gt; GEORADIUS china:city 100 30 1000 km withdist
1) 1) &quot;chengdu&quot;
   2) &quot;244.6616&quot;
2) 1) &quot;chongqing&quot;
   2) &quot;635.2850&quot;
3) 1) &quot;sian&quot;
   2) &quot;963.3171&quot;
127.0.0.1:6379&gt; GEORADIUS china:city 100 30 1000 km withcoord
1) 1) &quot;chengdu&quot;
   2) 1) &quot;102.54000037908554077&quot;
      2) &quot;30.05000015956613169&quot;
2) 1) &quot;chongqing&quot;
   2) 1) &quot;106.54000014066696167&quot;
      2) &quot;29.39999880018641676&quot;
3) 1) &quot;sian&quot;
   2) 1) &quot;108.92999857664108276&quot;
      2) &quot;34.23000121926852302&quot;
127.0.0.1:6379&gt; GEORADIUS china:city 100 30 1000 km withcoord withdist count 1
1) 1) &quot;chengdu&quot;
   2) &quot;244.6616&quot;
   3) 1) &quot;102.54000037908554077&quot;
      2) &quot;30.05000015956613169&quot;
127.0.0.1:6379&gt; GEORADIUS china:city 100 30 1000 km withcoord withdist count 2
1) 1) &quot;chengdu&quot;
   2) &quot;244.6616&quot;
   3) 1) &quot;102.54000037908554077&quot;
      2) &quot;30.05000015956613169&quot;
2) 1) &quot;chongqing&quot;
   2) &quot;635.2850&quot;
   3) 1) &quot;106.54000014066696167&quot;
      2) &quot;29.39999880018641676&quot;
</pre>
<blockquote>
<p>georadiusbymember</p>
</blockquote>
<p>语法解析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">georadiusbymember key member radius m|km|ft|mi [withcoord][withdist] [withhash][asc|desc][count count]</span><br></pre></td></tr></table></figure>
<p>这个命令可以找出位于指定范围内的元素，中心点是由给定的位置元素决定，而不是经纬度。（这才是正儿八经的“附近的人”）</p>
<pre>127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city chengdu 1000 km
1) &quot;chengdu&quot;
2) &quot;chongqing&quot;
3) &quot;sian&quot;
127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city chengdu 100 km
1) &quot;chengdu&quot;
127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city chengdu 400 km
1) &quot;chengdu&quot;
2) &quot;chongqing&quot;
</pre>
<blockquote>
<p>geohash</p>
</blockquote>
<p>语法解析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geohash key member [member...]</span><br></pre></td></tr></table></figure>
<p>这个命令可以将二维经纬度转换为一维字符串，字符串越长表示位置更精确,两个字符串越相似表示距离越近。</p>
<pre>127.0.0.1:6379&gt; GEOHASH china:city chengdu chongqing
1) &quot;wm2fvq7mgn0&quot;
2) &quot;wm5z22h53v0&quot;
127.0.0.1:6379&gt; GEOHASH china:city chengdu sian
1) &quot;wm2fvq7mgn0&quot;
2) &quot;wqj6wz2khy0&quot;</pre>
<blockquote>
<p>zrem</p>
</blockquote>
<p>GEO 没有提供删除的功能，但GEO 的底层实现是 Zset，所以可以借用 <code>zrem</code> 命令实现对地理位置信息的删除，也可以使用其他 Zset 的命令。</p>
<pre>127.0.0.1:6379&gt; GEOADD china:city 116.23 40.22 Peiking
(integer) 1
127.0.0.1:6379&gt; ZRANGE china:city 0 -1
1) &quot;chengdu&quot;
2) &quot;chongqing&quot;
3) &quot;sian&quot;
4) &quot;shenzhen&quot;
5) &quot;hangzhou&quot;
6) &quot;shanghai&quot;
7) &quot;Peiking&quot;
8) &quot;beijing&quot;
127.0.0.1:6379&gt; ZREM china:city Peiking
(integer) 1
127.0.0.1:6379&gt; ZREM china:city beijing
(integer) 1
127.0.0.1:6379&gt; ZRANGE china:city 0 -1
1) &quot;chengdu&quot;
2) &quot;chongqing&quot;
3) &quot;sian&quot;
4) &quot;shenzhen&quot;
5) &quot;hangzhou&quot;
6) &quot;shanghai&quot;</pre>
<h2 id="5-2-HyperLogLog"><a class="header-anchor" href="#5-2-HyperLogLog"></a>5.2 HyperLogLog</h2>
<blockquote>
<p>HyperLogLog 概述</p>
</blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-hyperloglog.html">Redis HyperLogLog</a></p>
<p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2<sup>64</sup> 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p>那这有什么用呢？</p>
<p>比如我们想实现网站的浏览用户数量（UV），一个人多次访问这个网站，还是算作一个人，就可以使用 HyperLogLog 来实现。</p>
<p>如果不使用 HyperLogLog，就需要使用 Set 来保存用户的信息，这就比较麻烦，毕竟我们只是为了计数，而不是为了获取用户信息。但是这种方式有 0.81% 的错误率，但对于统计 UV 这种不需要很精确的数据是可以忽略不计的。</p>
<p>那什么是基数呢？</p>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<blockquote>
<p>基本命令</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PFADD key element [element …]</td>
<td style="text-align:center">添加指定元素到 HyperLogLog 中。</td>
</tr>
<tr>
<td style="text-align:center">PFCOUNT key [key …]</td>
<td style="text-align:center">返回给定 HyperLogLog 的基数估算值。</td>
</tr>
<tr>
<td style="text-align:center">PFMERGE destkey sourcekey [sourcekey …]</td>
<td style="text-align:center">将多个 HyperLogLog 合并为一个 HyperLogLog</td>
</tr>
</tbody>
</table>
<blockquote>
<p>具体使用</p>
</blockquote>
<pre>127.0.0.1:6379&gt; PFADD hyll1 a a b b c c d d
(integer) 1
127.0.0.1:6379&gt; PFCOUNT hyll1
(integer) 4
127.0.0.1:6379&gt; PFADD hyll2 e e e  f f g g g z
(integer) 1
127.0.0.1:6379&gt; PFCOUNT hyll2
(integer) 4
127.0.0.1:6379&gt; PFMERGE hyll1 hyll2
OK
127.0.0.1:6379&gt; PFCOUNT hyll1
(integer) 8
127.0.0.1:6379&gt; PFCOUNT hyll2
(integer) 4
</pre>
<h2 id="5-3-Bitmaps"><a class="header-anchor" href="#5-3-Bitmaps"></a>5.3 Bitmaps</h2>
<blockquote>
<p>概述</p>
</blockquote>
<p>Bitmaps（位图），Bitmaps 本身不是一种数据结构，实际上就是字符串，但是它可以对字符串的位进行操作，是定义在String类型上的一个面向字节操作的集合。</p>
<p>可以把 Bitmaps 想象成一个以位为单位数组，数组中的每个单元只能存 0 或者 1，数组的下标在 Bitmaps 中叫做偏移量。因为字符串是二进制安全的块，他们的最大长度是 512M，最适合设置成2^32个不同字节。单个 Bitmaps 的最大长度是 512MB，即 2<sup>32</sup> 个比特位。</p>
<p>Bitmaps 的最大优势之一在存储信息时极其节约空间。例如，在一个以增量用户 ID 来标识不同用户的系统中，记录用户的四十亿的一个单独 bit 信息（例如，要知道用户是否想要接收最新的来信）仅仅使用 512M 内存。</p>
<blockquote>
<p>具体使用</p>
</blockquote>
<p>比如，我们可以使用 Bitmaps 来统计某一员工在一周内的打开次数，打卡了设置成 1，没打开设置成  0。</p>
<p>可以使用 <code>SETBIT key offset value</code> 来 key 的第 offset 位为 value （1或0）。比如添加打卡信息：</p>
<pre>127.0.0.1:6379&gt; SETBIT mofan 0 1
(integer) 0
127.0.0.1:6379&gt; SETBIT mofan 1 1
(integer) 0
127.0.0.1:6379&gt; SETBIT mofan 2 1
(integer) 0
127.0.0.1:6379&gt; SETBIT mofan 3 0
(integer) 0
127.0.0.1:6379&gt; SETBIT mofan 4 0
(integer) 0
127.0.0.1:6379&gt; SETBIT mofan 5 0
(integer) 0
127.0.0.1:6379&gt; SETBIT mofan 6 1
(integer) 0
</pre>
<p>上图就表示 mofan 的打卡情况（真迷的打卡情况，997 警告）。</p>
<p>可以使用 <code>GETBIT key offset</code>  来获取 offset 设置的值，未设置过默认返回 0。比如获取某一天的打卡情况：</p>
<pre>127.0.0.1:6379&gt; GETBIT mofan 1
(integer) 1
127.0.0.1:6379&gt; GETBIT mofan 4
(integer) 0
127.0.0.1:6379&gt; GETBIT mofan 2
(integer) 1</pre>
<p>可以使用 <code>bitcount key [start, end]</code> 统计 key 中位为 1 的个数，还可以指定范围。比如获取一周的打卡次数：</p>
<pre>127.0.0.1:6379&gt; BITCOUNT mofan
(integer) 4
</pre>
<blockquote>
<p><code>BITOP</code> 命令</p>
</blockquote>
<p>语法解析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITOP operation destkey key [key ...]</span><br></pre></td></tr></table></figure>
<p><code>BITOP</code> 命令用于对一个或多个保存二进制位的字符串 <code>key</code> 进行 <strong>位元</strong> 操作，并将结果保存到 <code>destkey</code> 上。</p>
<p><code>operation</code> 可以是 <code>AND</code> 、 <code>OR</code> 、 <code>NOT</code> 、 <code>XOR</code> 这四种操作中的任意一种：</p>
<ul>
<li><code>BITOP AND destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑并，并将结果保存到 <code>destkey</code> 。</li>
<li><code>BITOP OR destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑或，并将结果保存到 <code>destkey</code> 。</li>
<li><code>BITOP XOR destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑异或，并将结果保存到 <code>destkey</code> 。</li>
<li><code>BITOP NOT destkey key</code> ，对给定 <code>key</code> 求逻辑非，并将结果保存到 <code>destkey</code> 。</li>
</ul>
<p>除了 <code>NOT</code> 操作之外，其他操作都可以接受一个或多个 <code>key</code> 作为输入。</p>
<p>当 <code>BITOP</code> 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <code>0</code> 。空的 <code>key</code> 也被看作是包含 <code>0</code> 的字符串序列。</p>
<p><code>BITOP</code> 命令的返回值是保存到 <code>destkey</code> 中的字符串的长度，和输入 <code>key</code> 中最长的字符串长度相等。</p>
<pre>127.0.0.1:6379&gt; SETBIT bits-1 0 1        # bits-1 = 1001
(integer) 0
127.0.0.1:6379&gt; SETBIT bits-1 3 1
(integer) 0
127.0.0.1:6379&gt; SETBIT bits-2 0 1        # bits-2 = 1011
(integer) 0
127.0.0.1:6379&gt; SETBIT bits-2 1 1
(integer) 0
127.0.0.1:6379&gt; SETBIT bits-2 3 1
(integer) 0
127.0.0.1:6379&gt; BITOP AND and-result bits-1 bits-2
(integer) 1
127.0.0.1:6379&gt; GETBIT and-result 0      # and-result = 1001
(integer) 1
127.0.0.1:6379&gt; GETBIT and-result 1
(integer) 0
127.0.0.1:6379&gt; GETBIT and-result 2
(integer) 0
127.0.0.1:6379&gt; GETBIT and-result 3
(integer) 1
</pre>
<h1 id="6-缓存穿透、击穿、雪崩"><a class="header-anchor" href="#6-缓存穿透、击穿、雪崩"></a>6. 缓存穿透、击穿、雪崩</h1>
<p>Redis 缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。</p>
<p>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</p>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1655304940308056733">帮你解读什么是Redis缓存穿透和缓存雪崩（包含解决方案）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fei33423/article/details/79027790">最佳实践 缓存穿透,瞬间并发,缓存雪崩的解决方法</a></p>
<h2 id="6-1-缓存穿透"><a class="header-anchor" href="#6-1-缓存穿透"></a>6.1 缓存穿透</h2>
<p>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p>
<p>简单来说就是：用户想要查询一个数据，发现 Redis 内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<blockquote>
<p>解决方法</p>
</blockquote>
<p><strong>1、布隆过滤器</strong></p>
<p>布隆过滤器是一种数据结构，垃圾网站和正常网站加起来全世界据统计也有几十亿个。网警要过滤这些垃圾网站，总不能到数据库里面一个一个去比较吧，这就可以使用布隆过滤器。假设我们存储一亿个垃圾网站地址。</p>
<p>可以先有一亿个二进制比特，然后网警用八个不同的随机数产生器（F1, F2,  …, F8） 产生八个信息指纹（f1, f2, …, f8）。接下来用一个随机数产生器 G 把这八个信息指纹映射到 1 到1亿中的八个自然数 g1, g2, …, g8。最后把这八个位置的二进制全部设置为一。过程如下：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%BB%93%E6%9E%84.png" alt="布隆过滤器结构"></p>
<p>有一天网警查到了一个可疑的网站，想判断一下是否是 XX 网站，首先将可疑网站通过哈希映射到 1 亿个比特数组上的 8 个点。如果 8 个点的其中有一个点不为 1，则可以判断该元素一定不存在集合中。</p>
<p>那这个布隆过滤器是如何解决 Redis 中的缓存穿透呢？很简单首先也是对所有可能查询的参数以 Hash 形式存储，当用户想要查询的时候，使用布隆过滤器发现不在集合中，就直接丢弃，不再对持久层查询。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.jpg" alt="布隆过滤器"></p>
<p><strong>2、缓存空对象</strong></p>
<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1.jpg" alt="缓存空对象"></p>
<p>但是这种方法会存在两个问题：</p>
<ul>
<li>
<p>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；</p>
</li>
<li>
<p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p>
</li>
</ul>
<h2 id="6-2-缓存击穿"><a class="header-anchor" href="#6-2-缓存击穿"></a>6.2 缓存击穿</h2>
<p><strong>这里需要注意和缓存击穿的区别，缓存击穿，是指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</strong></p>
<p>当某个 key 在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p>
<p>简单来说，缓存穿透是查询缓存和数据库中都没有的数据，而缓存击穿是查询缓存中没有（一般是缓存时间到期）但数据库中有的数据。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>1、设置热点数据永不过期</strong></p>
<p>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。</p>
<p><strong>2、加互斥锁</strong><br>
分布式锁：使用分布式锁，保证对于每个 key 同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p>
<h2 id="6-3-缓存雪崩"><a class="header-anchor" href="#6-3-缓存雪崩"></a>6.3 缓存雪崩</h2>
<p>如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。</p>
<p>或者说缓存层出现了错误，不能正常工作了，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<p>这个没有完美解决办法，但可以分析用户行为，尽量让失效时间点均匀分布。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。</p>
<p>雪崩的时候，每一片雪花都在勇闯天涯！❄️</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.jpg" alt="缓存雪崩"></p>
<blockquote>
<p>解决方法</p>
</blockquote>
<p><strong>1、均匀过期</strong></p>
<p>设置不同的过期时间，让缓存失效的时间点尽量均匀。通常可以为有效期增加随机值或者统一规划有效期。</p>
<p><strong>2、加互斥锁</strong></p>
<p>跟缓存击穿解决思路一致，同一时间只让一个线程构建缓存，其他线程阻塞排队。</p>
<p><strong>3、缓存永不过期</strong></p>
<p>跟缓存击穿解决思路一致，缓存在物理上永远不过期，用一个异步的线程更新缓存。</p>
<p><strong>4、双层缓存策略</strong></p>
<p>使用主备两层缓存，他们的作用分别是：</p>
<p>主缓存：有效期按照经验值设置，设置为主读取的缓存，主缓存失效后从数据库加载最新值。</p>
<p>备份缓存：有效期长，获取锁失败时读取的缓存，主缓存更新时需要同步更新备份缓存。</p>
<h2 id="6-4-缓存预热"><a class="header-anchor" href="#6-4-缓存预热"></a>6.4 缓存预热</h2>
<p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统，这样就可以避免在用户请求的时候，先查询数据库，然后再将数据回写到缓存。</p>
<p>如果不进行预热， 那么 Redis 初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。</p>
<blockquote>
<p>缓存预热的操作方法</p>
</blockquote>
<p>1、数据量不大的时候，工程启动的时候进行加载缓存动作；</p>
<p>2、数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；</p>
<p>3、数据量太大的时候，优先保证热点数据进行提前加载到缓存。</p>
<h2 id="6-5-缓存降级"><a class="header-anchor" href="#6-5-缓存降级"></a>6.5 缓存降级</h2>
<p>缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。</p>
<p>在项目实战中通常会将部分热点数据缓存到服务的内存中，这样一旦缓存出现异常，可以直接使用服务的内存数据，从而避免数据库遭受巨大压力。</p>
<p>降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。</p>
<h1 id="7-内存淘汰策略"><a class="header-anchor" href="#7-内存淘汰策略"></a>7. 内存淘汰策略</h1>
<h2 id="7-1-内存淘汰策略的定义"><a class="header-anchor" href="#7-1-内存淘汰策略的定义"></a>7.1 内存淘汰策略的定义</h2>
<p>Redis 内存淘汰策略是指当缓存内存不足时，通过淘汰旧数据处理新加入数据选择的策略。</p>
<h2 id="7-2-最大内存的配置"><a class="header-anchor" href="#7-2-最大内存的配置"></a>7.2 最大内存的配置</h2>
<blockquote>
<p>通过配置文件配置</p>
</blockquote>
<p>可以通过修改 <code>redis.conf</code> 配置文件来配置最大内存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 1024mb  # 设置Redis最大占用内存大小为1024M</span><br></pre></td></tr></table></figure>
<p><mark>注意：</mark> maxmemory 默认配置为 0，在 64 位操作系统下 Redis 最大内存为操作系统剩余内存，在 32 位操作系统下 Redis 最大内存为 3GB。</p>
<blockquote>
<p>动态命令配置</p>
</blockquote>
<p>Redis 支持运行时通过命令动态修改内存大小：</p>
<pre>
127.0.0.1:6379> config set maxmemory 200mb //设置Redis最大占用内存大小为200M
127.0.0.1:6379> config get maxmemory //获取设置的Redis能使用的最大内存大小
1) "maxmemory"
2) "209715200"
</pre>
<h2 id="7-3-淘汰策略的分类"><a class="header-anchor" href="#7-3-淘汰策略的分类"></a>7.3 淘汰策略的分类</h2>
<p>Redis 官方定义了以下八种策略来淘汰旧数据加入新数据：</p>
<blockquote>
<p>noeviction</p>
</blockquote>
<p>默认策略，对于写请求直接返回错误，不进行淘汰。</p>
<blockquote>
<p>allkeys-lru</p>
</blockquote>
<p>lru（less recently used），最近最少使用。从所有的 key 中使用近似 LRU 算法进行淘汰。</p>
<blockquote>
<p>volatile-lru</p>
</blockquote>
<p>lru（less recently used），最近最少使用。从设置了过期时间的 key 中使用近似 LRU 算法进行淘汰。</p>
<blockquote>
<p>allkeys-random</p>
</blockquote>
<p>从所有的 key 中随机淘汰。</p>
<blockquote>
<p>volatile-random</p>
</blockquote>
<p>从设置了过期时间的 key 中随机淘汰。</p>
<blockquote>
<p>volatile-ttl</p>
</blockquote>
<p>ttl（time to live），在设置了过期时间的 key 中根据 key 的过期时间进行淘汰，越早过期的越优先被淘汰。</p>
<blockquote>
<p>allkeys-lfu</p>
</blockquote>
<p>lfu（Least Frequently Used），最少使用频率。从所有的 key 中使用近似 LFU 算法进行淘汰。这种策略从 Redis 4.0 开始支持。</p>
<blockquote>
<p>volatile-lfu</p>
</blockquote>
<p>lfu（Least Frequently Used），最少使用频率。从设置了过期时间的 key 中使用近似 LFU 算法进行淘汰。这种策略从 Redis 4.0 开始支持。</p>
<p><mark>注意：</mark> 当使用 volatile-lru、volatile-random、volatile-ttl 这三种策略时，如果没有设置过期的 key 可以被淘汰，则和 noeviction 一样返回错误。</p>
<h2 id="7-4-LRU-最近最少使用"><a class="header-anchor" href="#7-4-LRU-最近最少使用"></a>7.4 LRU 最近最少使用</h2>
<p>LRU（Least Recently Used），即最近最少使用，是一种缓存置换算法。其核心思想是：如果一个数据在最近一段时间没有被用到，那么将来被使用到的可能性也很小，所以就可以被淘汰掉。</p>
<blockquote>
<p>LRU 在 Redis 中的实现</p>
</blockquote>
<p>Redis 使用的是近似 LRU 算法，它跟常规的 LRU 算法还不太一样。近似 LRU 算法通过随机采样法淘汰数据，每次随机出 5 个（默认）key，从里面淘汰掉最近最少使用的 key。</p>
<p>可以通过 maxmemory-samples 参数修改采样数量， 如：<code>maxmemory-samples 10</code>。</p>
<p>maxmenory-samples 配置的越大，淘汰的结果越接近于严格的 LRU 算法，但因此耗费的 CPU 也很高。</p>
<p>Redis 为了实现近似 LRU 算法，给每个 key 增加了一个额外增加了一个 24bit 的字段，用来存储该 key 最后一次被访问的时间。</p>
<blockquote>
<p>Redis3.0 对近似 LRU 的优化</p>
</blockquote>
<p>Redis3.0 对近似 LRU 算法进行了一些优化。新算法会维护一个候选池（大小为 16），池中的数据根据访问时间进行排序，第一次随机选取的 key 都会放入池中，随后每次随机选取的 key 只有在访问时间小于池中最小的时间才会放入池中，直到候选池被放满。当放满后，如果有新的 key 需要放入，则将池中最后访问时间最大（最近被访问）的移除。</p>
<p>当需要淘汰的时候，则直接从池中选取最近访问时间最小（最久没被访问）的 key 淘汰掉就行。</p>
<h2 id="7-5-LFU-最少使用频率"><a class="header-anchor" href="#7-5-LFU-最少使用频率"></a>7.5 LFU 最少使用频率</h2>
<p>LFU（Least Frequently Used），是 Redis4.0 新加的一种淘汰策略，它的核心思想是根据 key 的最近被访问的频率进行淘汰，很少被访问的优先被淘汰，被访问的多的则被留下来。</p>
<p>LFU 算法能更好的表示一个 key 被访问的热度。假如你使用的是 LRU 算法，一个 key 很久没有被访问到，只刚刚是偶尔被访问了一次，那么它就被认为是热点数据，不会被淘汰，而有些 key 将来是很有可能被访问到的则被淘汰了。如果使用 LFU 算法则不会出现这种情况，因为使用一次并不会使一个 key 成为热点数据。</p>
<h1 id="8-内存模型"><a class="header-anchor" href="#8-内存模型"></a>8. 内存模型</h1>
<p>Redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 Redis 也被叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 Socket，根据 Socket 上的事件来选择对应的事件处理器进行处理。</p>
<blockquote>
<p>那为啥 Redis 单线程模型也能效率这么高？</p>
</blockquote>
<p>1、纯内存操作</p>
<p>2、核心是基于非阻塞的 IO 多路复用机制</p>
<p>3、单线程反而避免了多线程的频繁上下文切换问题</p>
<h1 id="9-整合-SpringBoot"><a class="header-anchor" href="#9-整合-SpringBoot"></a>9. 整合 SpringBoot</h1>
<h2 id="9-1-基础使用"><a class="header-anchor" href="#9-1-基础使用"></a>9.1 基础使用</h2>
<blockquote>
<p>环境准备</p>
</blockquote>
<p>在SpringBoot 中操作数据可以使用：Spring Data xxx</p>
<p>我们要使用 SpringBoot 操作 Redis 就要使用 Spring Data Redis。</p>
<p>新建一个 SpringBoot 项目，导入以下依赖：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E5%AF%BC%E5%85%A5%E6%95%B4%E5%90%88Redis%E9%9C%80%E8%A6%81%E7%9A%84%E4%BE%9D%E8%B5%96.png" alt="导入整合Redis需要的依赖"></p>
<p>进 pom.xml 文件中看看导入的 Redis 相关依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>点进这个依赖可以看到使用的是 lettuce 来操作 Redis：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 SpringBoot 2.x 之后，原来使用的 Jedis 被替换为 lettuce。那这是为什么呢？</p>
<p>Jedis：采用的直连。多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedispool 连接池！这更像 BIO 模式。</p>
<p>lettuce：采用 Netty，实例可以在多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据，更像 NIO 模式。</p>
<p>分析一下 Redis 自动装配的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;RedisOperations.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisAutoConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 我们可以自己定义一个 RedisTemplate 来替换默认的</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean( </span></span><br><span class="line"><span class="meta">        name = &#123;&quot;redisTemplate&quot;&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// 默认的 RedisTemplate 没有过多的设置， redis 对象都是需要序列化的！</span></span><br><span class="line">        <span class="comment">// 两个范型都是 Object 类型，后续使用需要强制类型转换</span></span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span> </span><br><span class="line">    <span class="comment">// 由于 Sring 类型是 Redis 中常用的类型，所以单独提出一个 Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="type">StringRedisTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码可以看到：</p>
<p>SpringBoot 会自动帮我们在容器中生成了一个 RedisTemplate 和一个 StringRedisTemplate。</p>
<p>RedisTemplate的泛型是 <code>&lt;Object,Object&gt;</code>，而我们需要一个泛型为 <code>&lt;String,Object&gt;</code> 形式的 RedisTemplate，导致后续编码需要强制类型转换。</p>
<p>RedisTemplate 没有设置数据存在 Redis 时，key 及 value 的序列化方式。</p>
<p>为什么要设置序列化方式呢？咱们后文介绍。</p>
<p>同时 SpringBoot 自动帮我们生成的 RedisTemplate 不好用，那应该怎么办呢？咱们后文也会介绍。</p>
<blockquote>
<p>修改 SpringBoot 配置文件</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里写虚拟机的静态 ip，我修改了 Windows 的 host 文件</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">redis</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"># Redi s数据库索引（默认为 0）</span></span><br><span class="line"><span class="attr">spring.redis.database</span>= <span class="string">0</span></span><br><span class="line"><span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line"><span class="attr">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment"># 最大阻塞等待时间（负数表示没限制）</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>编写测试代码</p>
</blockquote>
<p>在测试之前，打开虚拟机，连接 Redis，清空库内数据。然后前往 SpringBoot 的测试包内编写测试方法，我们需要先注入 <code>RedisTemplate</code>，我们一般使用 <code>RedisTemplate</code> 来操作 Redis。</p>
<p>RedisTemplate 操作 Redis 不同的数据类型的方法：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RedisTemplate%E7%9A%84opsFor%E6%96%B9%E6%B3%95.png" alt="RedisTemplate的opsFor方法"></p>
<p>除了基本的操作，我们常用的方法都可以使用 RedisTemplate 来操作，比如事务、基本的 CRUD 等，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RedisConnection</span> <span class="variable">connection</span> <span class="operator">=</span> </span><br><span class="line">        redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">    connection.flushDb();</span><br><span class="line">    connection.flushAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，有这么几个常用的类：</p>
<p>1、JedisPoolConfig 用于配置连接池</p>
<p>2、RedisConnectionFactory 用于配置连接信息，这里的 RedisConnectionFactory 是一个接<br>
口，我们需要使用它的实现类，启动器中提供了以下四种工厂模型：</p>
<ul>
<li>JredisConnectionFactory</li>
<li>JedisConnectionFactory</li>
<li>LettuceConnectionFactory</li>
<li>SrpConnectionFactory</li>
</ul>
<p>3、 RedisTemplate 用于 Redis 的基本操作</p>
<hr>
<p>那我们来编写一下测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisSpringbootApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;mofan&quot;</span>,<span class="string">&quot;mofan212.getee.io&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;mofan&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后运行一下代码，可以在控制台打印：<code>mofan212.getee.io</code>，成功获取到数据。</p>
<p>再前往 Linux 中，使用命令获取一下数据：</p>
<pre>127.0.0.1:6379&gt; keys *
1) &quot;\xac\xed\x00\x05t\x00\x05mofan&quot;</pre>
<p>这，这是咋回事？乱码了？</p>
<p>我们可以分析一下 RedisTemplate 的源码，并可以看到没有对 Redis 对象进行序列化：</p>
<p>在 <code>RedisAutoConfiguration</code> 类的 <code>redisTemplate</code> 中，调用了无参构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">    name = &#123;&quot;redisTemplate&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">    RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击进入这个无参构造方法，可以来到 <code>RedisTemplate</code> 类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new &lt;code&gt;RedisTemplate&lt;/code&gt; instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RedisTemplate</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>看看这个类的成员变量：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RedisTemplate%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png" alt="RedisTemplate类的成员变量"></p>
<p>可以看到所有 Redis 序列化对象都是 <code>null</code>，而这也是为什么前面会输出不正确的原因。</p>
<p>那怎么办呢？我们可以自己将 RedisTemplate 进行配置后注入 Spring 容器中，这样的话原来的 RedisTemplate 就会失效。原因能从这这个注解窥见：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">    name = &#123;&quot;redisTemplate&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然如此，那么我们就自己编写一个 RedisTemplate 并注入 Spring 容器中吧！👊</p>
<h2 id="9-2-自定义-RedisTemplate"><a class="header-anchor" href="#9-2-自定义-RedisTemplate"></a>9.2 自定义 RedisTemplate</h2>
<blockquote>
<p>简单测试</p>
</blockquote>
<p>在编写之前，我们需要了解序列化的问题，一般来说，我们的实体类都会实现序列化接口，同时传输对象的时候都会使用 JSON 进行传输。</p>
<p>我们先试试使用 JSON 序列化传输。</p>
<p>Linux 连接 Redis 服务，打开 Redis 客户端，清空当前表。</p>
<p>在刚才的工程中创建一个实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan 2020/12/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">// 一般来说我们会使用 JSON 来传递对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;默烦&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(user);</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;mofan&quot;</span>, string);</span><br><span class="line">    System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;mofan&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试一下，测试通过，控制台输出如下：</p>
<pre>
{"name":"默烦","age":18}
</pre>
<p>进 Linux 下用命令获取 key 试试：</p>
<pre>127.0.0.1:6379&gt; keys *
1) &quot;\xac\xed\x00\x05t\x00\x05mofan&quot;
</pre>
<p>还是乱码了，乱码的问题待会解决。</p>
<p>那如果我们不使用 JSON 序列化呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;默烦&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;mofan&quot;</span>, user);</span><br><span class="line">    System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;mofan&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清空 Redis 的库，再次运行测试，测试不会通过，控制台报以下错：</p>
<pre>
org.springframework.data.redis.serializer.SerializationException: Cannot serialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to serialize object using DefaultSerializer; nested exception is java.lang.IllegalArgumentException: DefaultSerializer requires a Serializable payload but received an object of type [indi.mofan.entity.User]
</pre>
<p>简单来说，就是 User 实体类没有序列化。那我们序列化试试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1669659861831762829L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行测试方法，测试通过，控制台出现：</p>
<pre>
User(name=默烦, age=18)
</pre>
<p>还是进 Linux 下用命令获取 key 试试：</p>
<pre>127.0.0.1:6379&gt; keys *
1) &quot;\xac\xed\x00\x05t\x00\x05mofan&quot;</pre>
<p>还好乱码。</p>
<p>但这至少证明了插入实体进 Redis 时必须要序列化。那每次都用 Jackson 进行序列化？还是每个实体自己实现序列化接口？</p>
<p>那也太麻烦了，RedisTemplate 可以进行序列化，但 SpringBoot 原版的 RedisTemplate 并没有进行序列化（前面已经分析过了）。</p>
<blockquote>
<p>回归正题</p>
</blockquote>
<p>既然 SpringBoot 提供的 RedisTemplate 不好用，那我们就自己配置一个 RedisTemplate，然后注入到 Spring 容器中。</p>
<p><code>RedisConfig.java</code> 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.mofan.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonTypeInfo;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan 2020/12/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JSON 序列化</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jsonRedisSerializer = <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance ,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">        jsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        <span class="comment">// String 的序列化</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key 采用 String 序列化</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// Hash 的 key 也采用 String 序列化</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value 采用 Jackson 序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// Hash 的 value 采用 Jackson 序列化</span></span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们并没有使用 JDK 进行序列化，因为使用 JDK 进行序列化就会乱码。</p>
<p>那么我们来测试一下，实体类不实现序列化接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan 2020/12/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;默烦&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;mofan&quot;</span>, user);</span><br><span class="line">    System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;mofan&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试方法，控制台出现：</p>
<pre>
User(name=默烦, age=18)
</pre>
<p>再进 Linux 下用命令获取 key 试试：</p>
<pre>127.0.0.1:6379&gt; keys *
1) &quot;mofan&quot;
</pre>
<p>奈斯，没有乱码，我们的配置生效了！🎉</p>
<blockquote>
<p>封装工具类</p>
</blockquote>
<p>虽然可以直接使用 RedisTemplate 来操作 Redis，但是需要写很多的代码，不如我们封装一个工具类，让编码更简单。</p>
<p>将这个工具类取名为 <code>RedisUtil</code>，然后将其添加到 Spring 容器中，使用时直接 DI （依赖注入）然后调用方法即可。</p>
<p><code>RedisUtil.java</code> 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.mofan.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan 2020/12/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================== 公共的 =======================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间，单位秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">expire</span><span class="params">(String key, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 的过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key，不能为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getExpire</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断 key 是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true表示存在，false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">hasKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 一个或多个 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(String... key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">                redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.delete(((Collection&lt;String&gt;) CollectionUtils.arrayToList(key)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==================String=======================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 key 获取 value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的 value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="literal">null</span> ? <span class="literal">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加 String 类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功，false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加 String 类型并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间，单位秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几（值大于 0）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">incr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几（值大于 0）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">decr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========================Map===================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hash Get</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键，不能为 null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 值，不能为 null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hget</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 对应的所有值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 键对应的多个值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title function_">hmget</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 键对应的多个值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  对应的多个值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 设置的时间，单位秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     *    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     *    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 Hash 表的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键，不能为 null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项，可以添加多个，不能为 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hdel</span><span class="params">(String key, Object... item)</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断 Hash 表中是否有某项</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键，不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 值，不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 存在即为 true，反之 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hHashKey</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hash递增 如果不存在，就会创建一个，返回新增后的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   增加数量（大于 0）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">hincr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hash 递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   减少数量（大于 0）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">hdecr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================Set==================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 key 获取 Set 中的所有值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sGet</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 value 从一个 Set 中是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">sHashSet</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入 Set 中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值，可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 放入成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sSet</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">long</span>) <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入 Set 中并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time   时间，单位秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值，可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 放入成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sSetAndTime</span><span class="params">(String key, <span class="type">long</span> time, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">long</span>) <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 Set 的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sGetSetSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">long</span>) <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为 value 的 Set</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     *    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">setRemove</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">long</span>) <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =======================List===================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 List 缓存的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     *                 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">lGet</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 List 缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lGetListSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">long</span>) <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取 List 中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0</span></span><br><span class="line"><span class="comment">     *              时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     *                 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lGetIndex</span><span class="params">(String key, <span class="type">long</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 List 放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     *                 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 List 放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     *                 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 List 放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 List 放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改 List 中的某条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lUpdateIndex</span><span class="params">(String key, <span class="type">long</span> index, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除 N 个值为 value 的 List</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     *    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lRemove</span><span class="params">(String key, <span class="type">long</span> count, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">long</span>) <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mofan212.github.io">默烦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mofan212.github.io/posts/The-Basics-Of-Redis-Part-Two/">https://mofan212.github.io/posts/The-Basics-Of-Redis-Part-Two/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://mofan212.github.io" target="_blank">Mofan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Middleware/">Middleware</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post-share"><div class="social-share" data-image="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/73.png" data-sites="wechat,qq,weibo,facebook,twitter"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" target="_blank"><img class="post-qr-code-img" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" target="_blank"><img class="post-qr-code-img" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/posts/Java-Class-Library-Jackson/" title="Jackson 的基本使用"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/74.jpg" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Jackson 的基本使用</div></div></a><a class="next-post pull-right" href="/posts/The-Basics-Of-Redis-Part-One/" title="【上篇】Redis 基础篇"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/72.png" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【上篇】Redis 基础篇</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/posts/Redis-Cluster-And-Distributed-Locks/" title="Redis 集群与分布式锁"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/102.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-28</div><div class="title">Redis 集群与分布式锁</div></div></a><a href="/posts/The-Basics-Of-Redis-Part-One/" title="【上篇】Redis 基础篇"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/72.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-05</div><div class="title">【上篇】Redis 基础篇</div></div></a><a href="/posts/Install-HBase/" title="HBase的安装"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-29</div><div class="title">HBase的安装</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">默烦</div><div class="author-info-description">彩笔的打怪升级之路...</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">153</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mofan212"><i class="fab fa-github"></i><span>follow me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:cy.mofan@foxmail.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a><a class="social-icon" href="https://www.travellings.cn/go.html" target="_blank" title="开往"><i class="fas fa-subway"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站所有博文均是博主的学习笔记与个人理解。<strong><font style="color:red">除特别注明外，</font>如需转载，请在文章头部醒目处附带原文链接并<a target="_blank" rel="noopener" href="https://mofan212.gitee.io/mine/" style="color:#49B1F5;text-decoration:underline">告知我</a></strong>你将转载。😊</br><strong><font style="color:red">严禁未遵循规范的转载。</font></strong>😡</br><strong>死去的评论系统复活啦！欢迎到留言板畅所欲言！</strong>当然也可以使用更高效的<a target="_blank" href="https://space.bilibili.com/23658864/dynamic" style="color:#49B1F5;text-decoration:underline"> 哔哩哔哩私信 </a>或<a href="mailto:cy.mofan@foxmail.com" style="color:#49B1F5;text-decoration:underline" target="_blank">邮箱</a>。 😉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Redis-%E4%BA%8B%E5%8A%A1"><span class="toc-text">1. Redis 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0"><span class="toc-text">1.1 事务概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8"><span class="toc-text">1.2 怎么使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-watch-%E7%9B%91%E6%8E%A7"><span class="toc-text">1.3 watch 监控</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E4%B8%89%E9%98%B6%E6%AE%B5%E5%92%8C%E4%B8%89%E7%89%B9%E6%80%A7"><span class="toc-text">1.4 三阶段和三特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-text">2. 发布订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-text">2.1 什么是发布订阅</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">2.2 常用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%9B%B8%E5%85%B3%E6%A1%88%E4%BE%8B"><span class="toc-text">2.3 相关案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Redis-%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">3. Redis 的复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">3.1 什么是主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-text">3.2 环境配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%86"><span class="toc-text">3.3 一主二仆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="toc-text">3.4 薪火相传</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB"><span class="toc-text">3.5 反客为主</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text">3.6 复制原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">3.7 哨兵模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E5%A4%8D%E5%88%B6%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">3.8 复制的缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Jedis"><span class="toc-text">4. Jedis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%B5%8B%E8%AF%95%E8%BF%9E%E9%80%9A"><span class="toc-text">4.1 测试连通</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%B8%B8%E7%94%A8-API"><span class="toc-text">4.2 常用 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E4%BA%8B%E5%8A%A1"><span class="toc-text">4.3 事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">4.4 主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-JedisPool"><span class="toc-text">4.5 JedisPool</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">5. 三种特殊数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-Geospatial-%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE"><span class="toc-text">5.1 Geospatial 地理位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-HyperLogLog"><span class="toc-text">5.2 HyperLogLog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Bitmaps"><span class="toc-text">5.3 Bitmaps</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9"><span class="toc-text">6. 缓存穿透、击穿、雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">6.1 缓存穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-text">6.2 缓存击穿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-text">6.3 缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-text">6.4 缓存预热</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7"><span class="toc-text">6.5 缓存降级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-text">7. 内存淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">7.1 内存淘汰策略的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%9C%80%E5%A4%A7%E5%86%85%E5%AD%98%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-text">7.2 最大内存的配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">7.3 淘汰策略的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-LRU-%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8"><span class="toc-text">7.4 LRU 最近最少使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-LFU-%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E9%A2%91%E7%8E%87"><span class="toc-text">7.5 LFU 最少使用频率</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">8. 内存模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%95%B4%E5%90%88-SpringBoot"><span class="toc-text">9. 整合 SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-text">9.1 基础使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E8%87%AA%E5%AE%9A%E4%B9%89-RedisTemplate"><span class="toc-text">9.2 自定义 RedisTemplate</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Something-About-Blog/" title="博客搭建与维护"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/42.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="博客搭建与维护"/></a><div class="content"><a class="title" href="/posts/Something-About-Blog/" title="博客搭建与维护">博客搭建与维护</a><time datetime="2024-10-05T16:00:00.000Z" title="更新于 2024-10-06 00:00:00">2024-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Algorithm-Quick-Shell-Sort/" title="【排序算法】快速排序和希尔排序"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/48.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="【排序算法】快速排序和希尔排序"/></a><div class="content"><a class="title" href="/posts/Algorithm-Quick-Shell-Sort/" title="【排序算法】快速排序和希尔排序">【排序算法】快速排序和希尔排序</a><time datetime="2024-09-30T16:00:00.000Z" title="更新于 2024-10-01 00:00:00">2024-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Method-Handle/" title="方法句柄"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/142.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="方法句柄"/></a><div class="content"><a class="title" href="/posts/Method-Handle/" title="方法句柄">方法句柄</a><time datetime="2024-09-05T16:00:00.000Z" title="更新于 2024-09-06 00:00:00">2024-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Annotation-And-Reflection/" title="注解、类的加载、反射"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/20.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="注解、类的加载、反射"/></a><div class="content"><a class="title" href="/posts/Annotation-And-Reflection/" title="注解、类的加载、反射">注解、类的加载、反射</a><time datetime="2024-08-31T16:00:00.000Z" title="更新于 2024-09-01 00:00:00">2024-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/DataStructure-Trie/" title="数据结构之Trie"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/43.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="数据结构之Trie"/></a><div class="content"><a class="title" href="/posts/DataStructure-Trie/" title="数据结构之Trie">数据结构之Trie</a><time datetime="2024-08-28T16:00:00.000Z" title="更新于 2024-08-29 00:00:00">2024-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Spring's-Enhancements-To-Java-Annotation/" title="Spring 对 Java 注解的增强"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/133.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Spring 对 Java 注解的增强"/></a><div class="content"><a class="title" href="/posts/Spring's-Enhancements-To-Java-Annotation/" title="Spring 对 Java 注解的增强">Spring 对 Java 注解的增强</a><time datetime="2024-08-26T16:00:00.000Z" title="更新于 2024-08-27 00:00:00">2024-08-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 默烦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://fastly.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://fastly.jsdelivr.net/npm/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://npm.elemecdn.com/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://fastly.jsdelivr.net/gh/mofan212/blog-static-resources@master/js/mine.min.js"></script><script defer="defer" id="ribbon" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-show-text" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Azathoth,Yog-Sothoth,Shub-Niggurath,Nyarlathotep,Cthulhu,Hastur,Abhoth,Ghroth,Tsathoggua,Cthugha,Deep Ones,Dagon,Chaugnar Faugn,Mordiggian,Shoggoth,Old One,Mi-Go,Great Race of Yith,Flying Polyp,Hounds of Tindalos,Dhole" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://fastly.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'BAFEL7A6K1',
    apiKey: '89fcb5961984c5c054bf04149f345f38',
    indexName: 'mofan212io',
    container: '#docsearch',
    placeholder: '搜索文章',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>
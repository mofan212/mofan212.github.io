<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>方法句柄 | Mofan</title><meta name="author" content="默烦,cy.mofan@foxmail.com"><meta name="copyright" content="默烦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 中 MethodHandle 的使用。">
<meta property="og:type" content="article">
<meta property="og:title" content="方法句柄">
<meta property="og:url" content="https://mofan212.github.io/posts/Method-Handle/">
<meta property="og:site_name" content="Mofan">
<meta property="og:description" content="Java 中 MethodHandle 的使用。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/142.png">
<meta property="article:published_time" content="2023-10-28T16:00:00.000Z">
<meta property="article:modified_time" content="2024-09-05T16:00:00.000Z">
<meta property="article:author" content="默烦">
<meta property="article:tag" content="Java-Lambda">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/142.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "方法句柄",
  "url": "https://mofan212.github.io/posts/Method-Handle/",
  "image": "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/142.png",
  "datePublished": "2023-10-28T16:00:00.000Z",
  "dateModified": "2024-09-05T16:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "默烦",
      "url": "https://mofan212.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/favicon.png"><link rel="canonical" href="https://mofan212.github.io/posts/Method-Handle/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 默烦","link":"链接: ","source":"来源: Mofan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://testingcf.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '方法句柄',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><link rel="stylesheet" href="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources@master/css/myStyle.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css" /><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" /><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Mofan" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources/css/minimal.min.css"/><script src="https://testingcf.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">174</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/reward/"><i class="fa-fw fa-solid fa-coins"></i><span> 赞助</span></a></li><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/post_top_img.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Mofan</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/reward/"><i class="fa-fw fa-solid fa-coins"></i><span> 赞助</span></a></li><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">方法句柄</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-28T16:00:00.000Z" title="发表于 2023-10-29 00:00:00">2023-10-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-05T16:00:00.000Z" title="更新于 2024-09-06 00:00:00">2024-09-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">14.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;距离本文上次更新已经过去&quot;,&quot;messageNext&quot;:&quot;天，请注意时效性。&quot;,&quot;postUpdate&quot;:&quot;2024-09-06 00:00:00&quot;}" hidden></div><p>封面来源：碧蓝航线 飓风与青春之泉 活动CG</p>
<p>本文涉及的代码：<a target="_blank" rel="noopener" href="https://github.com/mofan212/mofan-demo/blob/master/api-study/src/test/java/indi/mofan/MethodHandleTest.java">mofan-demo/api-study/src/test/java/indi/mofan/MethodHandleTest.java</a></p>
<p>参考链接：</p>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tangliMeiMei/category/1775842.html">java方法句柄</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.baeldung.com/java-method-handles">Method Handles in Java</a></p>
</li>
</ul>
<blockquote>
<p>阅读本文之前，请先阅读 <a href="https://mofan212.github.io/posts/Lambda-And-Serialization/">Lambda 与序列化</a> 一文作为前置知识</p>
</blockquote>
<h1 id="1-定义与使用场景"><a class="header-anchor" href="#1-定义与使用场景"></a>1. 定义与使用场景</h1>
<h2 id="1-1-什么是方法句柄"><a class="header-anchor" href="#1-1-什么是方法句柄"></a>1.1 什么是方法句柄</h2>
<p>方法句柄由 JDK7 引入，它的 API 文档是这么定义的：</p>
<blockquote>
<p>A method handle is a typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation, with optional transformations of arguments or return values.</p>
</blockquote>
<p>翻译一下：方法句柄是对底层方法、构造函数、字段或类似的低级操作的有类型的、可直接执行的、并具有参数或返回值的可选转换的引用。</p>
<p>简单来说，方法句柄是一种用于查找、修改和调用方法的底层机制。方法句柄是不可变的，和 <code>String</code> 一样，修改后将产生新的方法句柄，而不是修改原来的方法句柄上，方法句柄也没有可见状态。</p>
<p><strong>通过方法句柄可以直接调用该句柄所引用的底层方法。</strong></p>
<blockquote>
<p>关于翻译</p>
</blockquote>
<p>Method Handle 译为“方法句柄”，Method 的翻译是没有异议的，Handle 作为动词可以译为处理，作为名词可以译为手柄、把手，因此两者结合后将 <code>Method Handle</code> 译为 <strong>方法句柄</strong>，虽然没有什么错，但难以理解。</p>
<p>“将错就错”，记住一点：<code>Handle</code> 一词在计算机领域中通常指代处理程序或处理函数中的标识符或引用，用于表示对特定资源或事件的处理方式。</p>
<p>这样一解释，<code>Method Handle</code> 指代方法的引用似乎更容易理解？</p>
<p>计算机语言的翻译就是这样，比如 Socket 翻译成“套接字”、Robust 翻译成“鲁棒性”都很莫名其妙，让人茫然，只能说习惯就好。</p>
<p>再说句题外话，如果要命名一个方法表示处理某某的含义，这里的“处理”应该使用 <code>process</code>，用于表示执行计算和数据处理的硬件或软件组件，而不是使用 <code>handle</code>。</p>
<h2 id="1-2-使用场景"><a class="header-anchor" href="#1-2-使用场景"></a>1.2 使用场景</h2>
<p>方法句柄的使用场景主要涉及到 Java 的动态代理和反射技术。比如：</p>
<ul>
<li>动态代理：方法句柄可以用来创建动态代理对象，在运行时动态地生成一个代理类，并在代理类中对方法的调用进行拦截和处理，实现 AOP。</li>
<li>反射调用：方法句柄可以用于执行反射调用，相比于传统的反射调用，它更高效。</li>
<li>方法调用转发：可以使用方法句柄来实现方法调用转发，对一些类似的方法进行统一的处理。比如将多个方法调用重定向到同一个方法，并在该方法中统一处理这些调用。</li>
<li>Lambda 表达式和方法引用：Java 8 引入了 Lambda 表达式和方法引用，其幕后实现就是方法句柄。在使用 Lambda 表达式或方法引用时，Java 编译器会使用方法句柄来生成对应的字节码。</li>
<li>动态代码生成：方法句柄提供了生成和调用动态代码的能力，在某些动态编程场景下可能有用。</li>
</ul>
<p>虽然方法句柄提供了强大的动态调用能力，但由于其相对复杂的使用方式和潜在的性能开销，使用方法句柄来调用方法并不是银弹。只有在需要动态生成代码或实现高级的代理和反射功能时才考虑使用方法句柄。</p>
<p>既然方法句柄的使用场景有限，那本文的意义又是什么呢？</p>
<p><mark>此时无用不代表一直无用，等到未来使用到的那一天，曾经的积累就变得弥足珍贵。</mark></p>
<h2 id="1-3-与反射的区别"><a class="header-anchor" href="#1-3-与反射的区别"></a>1.3 与反射的区别</h2>
<p>引入方法句柄是为了与现有的反射 API 一起工作，它们应用在不同的场景，也具有不同的特性。</p>
<p>单从性能角度上看，方法句柄相比于反射更加高效，因为方法句柄的 <strong>access checks</strong>（访问检查）是在创建时进行的，而不是在运行时。在存在 <strong>security manager</strong>（安全管理器）时，这种性能差距还会被进一步放大，因为成员和类的查找也需要进行额外的检查。</p>
<p>然而从使用便捷性的角度上看，方法句柄相较于反射更难以使用。尽管如此，方法句柄还是提供了柯里化、更改参数类型和顺序的方式。</p>
<h1 id="2-使用方式"><a class="header-anchor" href="#2-使用方式"></a>2. 使用方式</h1>
<h2 id="2-1-Quick-Start"><a class="header-anchor" href="#2-1-Quick-Start"></a>2.1 Quick Start</h2>
<p>使用方法句柄需要四步：</p>
<ol>
<li>创建 <code>MethodType</code> 实例；</li>
<li>创建 <code>MethodHandles.Lookup</code> 实例；</li>
<li>查找方法句柄；</li>
<li>调用方法句柄。</li>
</ol>
<p>简单梳理下：首先确定需要调用的目标方法的参数与返回值，根据这些信息创建出 <code>MethodType</code> 实例，该实例是方法参数与返回值的描述，并不指代某一具体方法。之后创建 <code>Lookup</code> 实例用于查找方法句柄，为了锁定某一具体的方法，在查找时需要传入目标方法所在类的 <code>Class</code> 信息、方法名与 <code>MethodType</code> 实例，最后调用查找到的方法句柄即可。</p>
<blockquote>
<p>创建 <code>MethodType</code> 实例</p>
</blockquote>
<p><code>MethodType</code> 描述了方法句柄接收的参数和返回值类型，或者说调用方法句柄时传递的参数和期望的返回值类型。</p>
<p><code>MethodType</code> 实例是不可变的，每次对其的修改都会产生一个新的 <code>MethodType</code>。</p>
<p>创建 <code>MethodType</code> 实例可以使用 <code>MethodType.methodType()</code> 方法，该方法接收一个返回值类型和适量的参数类型，调用方法句柄时，传入的参数类型必须与创建 <code>MethodType</code> 实例时传入的参数类型相匹配。</p>
<p>比如创建返回值和参数类型都为 <code>String</code> 的 <code>MethodType</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(String.class, String.class);</span><br></pre></td></tr></table></figure>
<p>又比如创建无返回值、参数类型为 <code>int</code> 的 <code>MethodType</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class, <span class="type">int</span>.class);</span><br></pre></td></tr></table></figure>
<p>或者创建返回值类型为 <code>List</code>，参数类型为 <code>Object</code> 数组的 <code>MethodType</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(List.class, Object[].class);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建 <code>MethodHandles.Lookup</code> 实例</p>
</blockquote>
<p><code>Lookup</code> 实例通过 <code>MethodHandles</code> 的工厂方法进行创建，能够创建出具有不同访问模式的 <code>Lookup</code> 实例。</p>
<p>创建仅用于查找 <code>public</code> 方法的 <code>Lookup</code> 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodHandles.<span class="type">Lookup</span> <span class="variable">publicLookup</span> <span class="operator">=</span> MethodHandles.publicLookup();</span><br></pre></td></tr></table></figure>
<p>如果要查找 <code>private</code> 或 <code>protected</code> 方法时，则应该这样创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodHandles.<span class="type">Lookup</span> <span class="variable">lookup</span> <span class="operator">=</span> MethodHandles.lookup();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查找方法句柄</p>
</blockquote>
<p>定义了 <code>MethodType</code>，也创建了 <code>Lookup</code> 对象，接下来就是查找方法句柄了。查找方法句柄时需要知道目标方法的所在类和目标方法名称，调用 <code>Lookup</code> 对象的 <code>findVirtual()</code> 方法来查找成员方法的方法句柄。</p>
<p>比如查找 <code>String</code> 对象的 <code>concat()</code> 方法的方法句柄：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MethodHandle</span> <span class="variable">concat</span> <span class="operator">=</span> lookup.findVirtual(String.class, <span class="string">&quot;concat&quot;</span>, concatMethodType);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用方法句柄</p>
</blockquote>
<p>得到方法句柄后，就可以调用方法句柄了，调用时需要传入目标对象（创建的是成员方法的方法句柄）以及调用方法需要的参数信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) concat.invoke(<span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>完整代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuickStart</span><span class="params">()</span> &#123;</span><br><span class="line">    MethodHandles.<span class="type">Lookup</span> <span class="variable">lookup</span> <span class="operator">=</span> MethodHandles.lookup();</span><br><span class="line">    <span class="comment">// concat(String)：返回 String，也接收一个 String</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">concatMethodType</span> <span class="operator">=</span> MethodType.methodType(String.class, String.class);</span><br><span class="line">    <span class="comment">// 目标方法在 String 类中，名为 concat</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">concat</span> <span class="operator">=</span> lookup.findVirtual(String.class, <span class="string">&quot;concat&quot;</span>, concatMethodType);</span><br><span class="line">    <span class="comment">// 调用方法句柄，并强转返回值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) concat.invoke(<span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">    assertThat(result).isEqualTo(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-执行-Lambda-表达式"><a class="header-anchor" href="#2-2-执行-Lambda-表达式"></a>2.2 执行 Lambda 表达式</h2>
<p>利用方法句柄执行目标方法时，需要知道以下信息：</p>
<ul>
<li>目标方法的返回值类型和参数类型</li>
<li>目标方法的所在类的 Class 信息</li>
<li>目标方法名称</li>
<li>目标方法所在的类的实例对象</li>
<li>执行目标方法所需要的参数</li>
</ul>
<p>思维发散一下，对于一个 Lambda 表达式能拿到上述信息吗？如果可以，岂不是可以利用方法句柄执行 Lambda 表达式？</p>
<p>答案是肯定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInvokeLambda</span><span class="params">()</span> &#123;</span><br><span class="line">    Function&lt;Integer, Integer&gt; increase = integer -&gt; integer + <span class="number">1</span>;</span><br><span class="line">    MethodHandles.<span class="type">Lookup</span> <span class="variable">lookup</span> <span class="operator">=</span> MethodHandles.lookup();</span><br><span class="line">    <span class="comment">// 由于泛型擦除均使用 Object</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(Object.class, Object.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">apply</span> <span class="operator">=</span> lookup.findVirtual(increase.getClass(), <span class="string">&quot;apply&quot;</span>, methodType);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> apply.invoke(increase, <span class="number">1</span>);</span><br><span class="line">    assertThat(result).isInstanceOf(Integer.class)</span><br><span class="line">            .isEqualTo(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-实现动态代理"><a class="header-anchor" href="#2-3-实现动态代理"></a>2.3 实现动态代理</h2>
<p>在调用方法句柄前后可以增加额外的逻辑，这其实也是动态代理的一种应用，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HelloImpl</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDynamicProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloImpl</span>();</span><br><span class="line">    MethodHandles.<span class="type">Lookup</span> <span class="variable">lookup</span> <span class="operator">=</span> MethodHandles.lookup();</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(String.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">sayHello</span> <span class="operator">=</span> lookup.findVirtual(HelloImpl.class, <span class="string">&quot;sayHello&quot;</span>, methodType);</span><br><span class="line">    <span class="type">Hello</span> <span class="variable">proxy</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            str = ((String) sayHello.invoke(hello));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            Assertions.fail();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str + <span class="string">&quot; World&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    assertThat(proxy.sayHello()).isEqualTo(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-Lookup"><a class="header-anchor" href="#3-Lookup"></a>3. Lookup</h1>
<h2 id="3-1-单词-Lookup"><a class="header-anchor" href="#3-1-单词-Lookup"></a>3.1 单词 Lookup</h2>
<p>Lookup 意为“查阅、查找”，单词 Find 也可以表示“查找”的含义，但它们有一些细微的区别：</p>
<ul>
<li>Lookup：通常用于在数据结构（哈希表、字典等）中根据 <strong>给定的键</strong> 来查找对应的值，这种查找方式的时间复杂度可以是常量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，也可以是线性时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，具体值取决于数据结构的实现方式；</li>
<li>Find：通常用于在一组数据中查找满足条件的特定元素，经常使用遍历与比较来实现，这种操作的时间复杂度取决于数据集的大小和查找条件的复杂度，可以是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 甚至更高。</li>
</ul>
<h2 id="3-2-创建-Lookup"><a class="header-anchor" href="#3-2-创建-Lookup"></a>3.2 创建 Lookup</h2>
<p>在创建一个方法句柄时，要做的第一件事是拿到 <code>Lookup</code> 对象，它是一个工厂对象，用于创建对 <code>Lookup</code> 类可见的方法、构造函数、字段的方法句柄。</p>
<p>利用 <code>MethodHandles</code> 可以创建具有不同访问模式的 <code>Lookup</code> 对象。</p>
<p>比如创建给 <code>public</code> 方法提供访问的 <code>Lookup</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodHandles.<span class="type">Lookup</span> <span class="variable">publicLookup</span> <span class="operator">=</span> MethodHandles.publicLookup();</span><br></pre></td></tr></table></figure>
<p>如果还要访问 <code>private</code> 和 <code>protected</code> 方法，那么可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodHandles.<span class="type">Lookup</span> <span class="variable">lookup</span> <span class="operator">=</span> MethodHandles.lookup();</span><br></pre></td></tr></table></figure>
<p>后文将普遍采用第二种方式创建 <code>Lookup</code> 对象。</p>
<h1 id="4-方法类型"><a class="header-anchor" href="#4-方法类型"></a>4. 方法类型</h1>
<p>一个类中可以定义很多个方法，就算是同名的方法，也能拥有多个重载。如果要明确创建的方法句柄究竟是哪个方法的引用，那么以下四种信息是必不可少的：</p>
<ol>
<li>方法所在的类</li>
<li>方法名</li>
<li>方法参数类型</li>
<li>方法返回值类型</li>
</ol>
<p>对于第三、第四点可以统称为方法类型，即 <code>MethodType</code>。</p>
<p><code>MethodType</code> 确定了一个方法的参数类型和返回值类型，它与某个具体的方法没有直接关系。它表示方法句柄接收的参数和返回的类型，或者方法句柄的调用者传递的参数和期望的返回类型。</p>
<p>与 <code>MethodHandle</code> 一样，<strong><code>MethodType</code> 也是不可变的，</strong> 对某个 <code>MethodType</code> 的修改将产生一个新的 <code>MethodType</code>。</p>
<p><strong>两个方法句柄是否相等，取决于它们包含的参数类型和返回值类型是否一致。</strong> 比如，<code>java.lang.String#valueOf(int)</code> 方法和 <code>java.lang.Integer#toString(int)</code> 方法的 <code>MethodType</code> 是相等的，因为这两个方法都接收一个 <code>int</code> 类型的参数并返回 <code>String</code> 类型的值。</p>
<h2 id="4-1-构造方法类型"><a class="header-anchor" href="#4-1-构造方法类型"></a>4.1 构造方法类型</h2>
<p><code>MethodType</code> 并未提供公共的构造函数，创建 <code>MethodType</code> 只能通过静态工厂完成。</p>
<blockquote>
<p><code>MethodType.methodType()</code></p>
</blockquote>
<p>使用 <code>MethodType.methodType()</code> 构造 <code>MethodType</code> 是最常见的方式。</p>
<p>该方法有多个重载，其 <strong>第一个参数总是方法的返回值类型，</strong> 后续的参数则表示方法的参数类型。</p>
<p>构造 <code>String#length()</code> 方法的 <code>MethodType</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值类型 int，没有参数</span></span><br><span class="line"><span class="type">MethodType</span> <span class="variable">mt1</span> <span class="operator">=</span> MethodType.methodType(<span class="type">int</span>.class);</span><br></pre></td></tr></table></figure>
<p>如果对应方法没有返回值，其第一个参数使用 <code>void.class</code>。</p>
<p>构造返回值类型和参数类型都是 <code>String</code> 的 <code>MethodType</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值类型 String，参数类型 String</span></span><br><span class="line"><span class="type">MethodType</span> <span class="variable">mt2</span> <span class="operator">=</span> MethodType.methodType(String.class, String.class);</span><br></pre></td></tr></table></figure>
<p>除此之外，<code>MethodType.methodType()</code> 方法的第二个参数也能接收一个 <code>MethodType</code> 实例，新构造的 <code>MethodType</code> 对象具有与传入的 <code>MethodType</code> 实例相同的参数列表。比如将 <code>mt2</code> 作为参数传入，新得到的 <code>MethodType</code> 对象对应的方法的参数类型是 <code>String</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值类型 boolean，参数类型 String</span></span><br><span class="line"><span class="type">MethodType</span> <span class="variable">mt3</span> <span class="operator">=</span> MethodType.methodType(<span class="type">boolean</span>.class, mt2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>MethodType.genericMethodType()</code></p>
</blockquote>
<p>使用该方法能够生成通用的 <code>MethodType</code>，即返回值类型和参数类型都是 <code>Object</code>。</p>
<p>利用这种方式构造的 <code>MethodType</code> <mark>一定</mark> 有返回值。</p>
<p>该方法有两种重载。第一种指定参数的个数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assertThat(MethodType.genericMethodType(<span class="number">2</span>))</span><br><span class="line">        .isEqualTo(MethodType.methodType(Object.class, Object.class, Object.class));</span><br></pre></td></tr></table></figure>
<p>第二种在第一种的基础上，要求指定参数列表最后是否会有 <code>Object[]</code> 类型的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assertThat(MethodType.genericMethodType(<span class="number">1</span>, <span class="literal">true</span>))</span><br><span class="line">        .isEqualTo(MethodType.methodType(Object.class, Object.class, Object[].class));</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>MethodType.fromMethodDescriptorString()</code></p>
</blockquote>
<p>该方法与 <code>MethodType.methodType()</code> 类似，只不过要求传入 <strong>方法描述符</strong>，根据传入的方法描述符构造出与之对应的 <code>MethodType</code>。如果不熟悉方法描述符，可以参考 <a href="https://mofan212.github.io/posts/Lambda-And-Serialization/">Lambda 与序列化</a> 一文中【4.4 Java 描述符】的相关内容。</p>
<p>构造返回值类型和参数类型都是 <code>String</code> 的 <code>MethodType</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">assertThat(MethodType.fromMethodDescriptorString(<span class="string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>, loader))</span><br><span class="line">        .isEqualTo(MethodType.methodType(String.class, String.class));</span><br></pre></td></tr></table></figure>
<p>构造没有返回值，参数类型依次为 <code>int</code>、<code>float</code> 的 <code>MethodType</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assertThat(MethodType.fromMethodDescriptorString(<span class="string">&quot;(IF)V&quot;</span>, loader))</span><br><span class="line">        .isEqualTo(MethodType.methodType(<span class="keyword">void</span>.class, <span class="type">int</span>.class, <span class="type">float</span>.class));</span><br></pre></td></tr></table></figure>
<p>也可以构造返回值类型是 <code>int[]</code>，参数类型依次为 <code>int</code>、<code>String</code> 的 <code>MethodType</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assertThat(MethodType.fromMethodDescriptorString(<span class="string">&quot;(ILjava/lang/String;)[I&quot;</span>, loader))</span><br><span class="line">        .isEqualTo(MethodType.methodType(<span class="type">int</span>[].class, <span class="type">int</span>.class, String.class));</span><br></pre></td></tr></table></figure>
<h2 id="4-2-修改方法类型"><a class="header-anchor" href="#4-2-修改方法类型"></a>4.2 修改方法类型</h2>
<p>在得到 <code>MethodType</code> 实例后，还可以对其进行修改，例如：</p>
<ul>
<li>增加参数类型</li>
<li>在指定位置增加参数类型</li>
<li>删除指定范围内的参数类型</li>
<li>修改指定位置的参数类型</li>
<li>修改返回值类型</li>
</ul>
<p><code>MethodType</code> 是不可变的，对某个 <code>MethodType</code> 的修改将产生一个新的 <code>MethodType</code>，就像 <code>String</code> 一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testModifyMethodType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(String.class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="comment">// 添加一个参数类型</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">anotherMt</span> <span class="operator">=</span> methodType.appendParameterTypes(String.class);</span><br><span class="line">    <span class="comment">// MethodType 是不变的，每次修改都会产生新的 MethodType，就像 String 一样</span></span><br><span class="line">    assertThat(anotherMt).isNotSameAs(methodType);</span><br><span class="line">    assertThat(anotherMt).isEqualTo(MethodType.methodType(String.class, <span class="type">int</span>.class, <span class="type">int</span>.class, String.class));</span><br><span class="line">    <span class="comment">// 指定索引位置添加参数</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">mt</span> <span class="operator">=</span> methodType.insertParameterTypes(<span class="number">1</span>, <span class="type">float</span>.class, <span class="type">double</span>.class);</span><br><span class="line">    assertThat(mt).isEqualTo(MethodType.methodType(String.class, <span class="type">int</span>.class, <span class="type">float</span>.class, <span class="type">double</span>.class, <span class="type">int</span>.class));</span><br><span class="line">    <span class="comment">// 删除某个范围的参数</span></span><br><span class="line">    assertThat(mt.dropParameterTypes(<span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">        .isEqualTo(MethodType.methodType(String.class, <span class="type">double</span>.class, <span class="type">int</span>.class));</span><br><span class="line">    <span class="comment">// 修改指定位置的参数</span></span><br><span class="line">    assertThat(methodType.changeParameterType(<span class="number">0</span>, <span class="type">long</span>.class))</span><br><span class="line">        .isEqualTo(MethodType.methodType(String.class, <span class="type">long</span>.class, <span class="type">int</span>.class));</span><br><span class="line">    <span class="comment">// 修改返回值类型</span></span><br><span class="line">    assertThat(methodType.changeReturnType(<span class="keyword">void</span>.class))</span><br><span class="line">        .isEqualTo(MethodType.methodType(<span class="keyword">void</span>.class, <span class="type">int</span>.class, <span class="type">int</span>.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，还提供了类似“批量修改”的能力，能够一次性对返回类型和所有参数类型进行修改：</p>
<ul>
<li><code>wrap()</code>：将所有基本类型修改为对应的包装类型</li>
<li><code>unwrap()</code>：与 <code>wrap()</code> 相反，将所有包装类型修改为对应的基本类型</li>
<li><code>generic()</code>：将所有类型都修改为 <code>Object</code> 类型</li>
<li><code>erase()</code>：只将引用类型修改为 <code>Object</code> 类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testModifyMethodType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性修改所有的</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">unwrapMt</span> <span class="operator">=</span> MethodType.methodType(<span class="type">int</span>.class, <span class="type">long</span>.class, <span class="type">double</span>.class, String.class);</span><br><span class="line">    <span class="comment">// 包装类型与基本类型的转换</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">wrapMt</span> <span class="operator">=</span> MethodType.methodType(Integer.class, Long.class, Double.class, String.class);</span><br><span class="line">    assertThat(unwrapMt.wrap()).isEqualTo(wrapMt);</span><br><span class="line">    assertThat(wrapMt.unwrap()).isEqualTo(unwrapMt);</span><br><span class="line">    <span class="comment">// 全部变为 Object 类型</span></span><br><span class="line">    assertThat(unwrapMt.generic()).isEqualTo(MethodType.methodType(Object.class, Object.class, Object.class, Object.class));</span><br><span class="line">    <span class="comment">// 只引用类型变 Object 类型</span></span><br><span class="line">    assertThat(unwrapMt.erase()).isEqualTo(MethodType.methodType(<span class="type">int</span>.class, <span class="type">long</span>.class, <span class="type">double</span>.class, Object.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-获取方法句柄"><a class="header-anchor" href="#5-获取方法句柄"></a>5. 获取方法句柄</h1>
<p><code>MethodType</code> 相当于是对某个具体方法的抽象，描述了方法的 <strong>返回类型</strong> 和 <strong>参数类型</strong>。</p>
<p>要指向某个具体的方法，除了知道返回类型和参数类型外，还需要知道 <strong>目标方法的所在类</strong> 与 <strong>方法名</strong>，这两种信息并没有进行分装，而是在构造方法句柄实例时显式传入。</p>
<h2 id="5-1-成员方法"><a class="header-anchor" href="#5-1-成员方法"></a>5.1 成员方法</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要获取 <code>getName()</code> 方法和 <code>setAge()</code> 方法对应的方法句柄，那么在拿到它们对应的 <code>MethodType</code> 实例后，使用 <code>Lookup</code> 对象的 <code>findVirtual()</code> 方法来获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPublicMethod</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// getName</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">getNameMethodType</span> <span class="operator">=</span> MethodType.methodType(String.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">getNameMethodHandle</span> <span class="operator">=</span> lookup.findVirtual(Person.class, <span class="string">&quot;getName&quot;</span>, getNameMethodType);</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// setAge</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">setAgeMethodType</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class, Integer.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">setAgeMethodHandle</span> <span class="operator">=</span> lookup.findVirtual(Person.class, <span class="string">&quot;setAge&quot;</span>, setAgeMethodType);</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到方法句柄之后就可以调用了，上述方法句柄引用的方法都是成员方法，成员方法属于某个实例，调用成员方法时需要明确所属的实例对象与调用方法需要传入的参数，调用方法句柄也是如此（和反射类似）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPublicMethod</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// getName</span></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">perSon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;test&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) getNameMethodHandle.invoke(perSon);</span><br><span class="line">    assertThat(name).isEqualTo(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setAge</span></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    setAgeMethodHandle.invoke(perSon, <span class="number">100</span>);</span><br><span class="line">    assertThat(perSon).extracting(Person::getAge).isEqualTo(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2-构造函数"><a class="header-anchor" href="#5-2-构造函数"></a>5.2 构造函数</h2>
<p>构造函数也有对应的方法句柄，使用 <code>Lookup</code> 实例的 <code>findConstructor()</code> 方法来获取。</p>
<p>与获取成员方法的方法句柄一样，在获取构造函数的方法句柄时，也需要一个 <code>MethodType</code> 实例。</p>
<p>获取 <code>MethodType</code> 实例的方式在前文中已经叙述过，以 <code>MethodType.methodType()</code> 方法为例，该方法的第一个参数总是是方法的返回值类型，那么构造函数的返回值类型是什么呢？</p>
<p>是构造的对象的类型？</p>
<p>不，是 <code>void</code>。</p>
<p>比如 <code>Person</code> 类中有三种构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在需要获取无参构造函数和全参构造函数对应的方法句柄，那么有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 认为构造函数的返回值是 void</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">noArgs</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line">    <span class="comment">// 指定类、MethodType</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">noArgsMethodHandle</span> <span class="operator">=</span> lookup.findConstructor(Person.class, noArgs);</span><br><span class="line">    <span class="comment">// 调用方法句柄</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">noArgsPerson</span> <span class="operator">=</span> (Person) noArgsMethodHandle.invoke();</span><br><span class="line">    assertThat(noArgsPerson).isNotNull();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个参数是返回值类型，后面的是参数列表的数据类型</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">allArgs</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class, String.class, Integer.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">allArgsMethodHandle</span> <span class="operator">=</span> lookup.findConstructor(Person.class, allArgs);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">allArgsPerson</span> <span class="operator">=</span> (Person) allArgsMethodHandle.invoke(<span class="string">&quot;test&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    assertThat(allArgsPerson).extracting(Person::getName, Person::getAge)</span><br><span class="line">        .containsExactly(<span class="string">&quot;test&quot;</span>, <span class="number">18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-静态方法"><a class="header-anchor" href="#5-3-静态方法"></a>5.3 静态方法</h2>
<p>获取静态方法的方法句柄与获取成员方法的方法句柄很类似，它们之间的区别体现在：</p>
<ul>
<li>使用 <code>Lookup</code> 实例的 <code>findStatic()</code> 方法来获取静态方法的方法句柄，而不是 <code>findVirtual()</code>；</li>
<li>成员方法属于某个实例，静态方法则属于类。因此在调用静态方法对应的方法句柄时，无需传入实例对象，直接传入需要的参数即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">returnInt</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> integer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPublicStaticMethod</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">returnIntMethodType</span> <span class="operator">=</span> MethodType.methodType(Integer.class, Integer.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">returnIntMh</span> <span class="operator">=</span> lookup.findStatic(Person.class, <span class="string">&quot;returnInt&quot;</span>, returnIntMethodType);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> (Integer) returnIntMh.invoke(<span class="number">2</span>);</span><br><span class="line">    assertThat(result).isEqualTo(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-4-公共字段"><a class="header-anchor" href="#5-4-公共字段"></a>5.4 公共字段</h2>
<p><code>Person</code> 类中存在两个字段 <code>name</code> 和 <code>bool</code>，前者被 <code>private</code> 修饰，后者被 <code>public</code> 修饰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Boolean bool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>findGetter()</code> 方法获取 <strong>公共字段</strong> 对应的方法句柄：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPublicField</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">getterMh</span> <span class="operator">=</span> lookup.findGetter(Person.class, <span class="string">&quot;bool&quot;</span>, Boolean.class);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    person.setBool(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">bool</span> <span class="operator">=</span> (Boolean) getterMh.invoke(person);</span><br><span class="line">    assertThat(bool).isTrue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以通过 <code>findSetter()</code> 方法获取到的方法句柄对字段值进行修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPublicField</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">setterMh</span> <span class="operator">=</span> lookup.findSetter(Person.class, <span class="string">&quot;bool&quot;</span>, Boolean.class);</span><br><span class="line">    person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    setterMh.invoke(person, <span class="literal">false</span>);</span><br><span class="line">    assertThat(person.bool).isFalse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于静态字段也提供了类似的 API，只不过调用方法句柄时，无需传入实例对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPublicField</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取静态字段的 MethodHandle</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">staticGetterMh</span> <span class="operator">=</span> lookup.findStaticGetter(Person.class, <span class="string">&quot;CONSTANT&quot;</span>, String.class);</span><br><span class="line">    assertThat(((String) staticGetterMh.invoke())).isEqualTo(<span class="string">&quot;HELLO_WORLD&quot;</span>);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">staticSetterMh</span> <span class="operator">=</span> lookup.findStaticSetter(Person.class, <span class="string">&quot;CONSTANT&quot;</span>, String.class);</span><br><span class="line">    staticSetterMh.invoke(<span class="string">&quot;GOOD JOB&quot;</span>);</span><br><span class="line">    assertThat(Person.CONSTANT).isEqualTo(<span class="string">&quot;GOOD JOB&quot;</span>);</span><br><span class="line">    <span class="comment">// 改回去，单元测试的规范</span></span><br><span class="line">    Person.CONSTANT = <span class="string">&quot;HELLO_WORLD&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用以上方式能够获取 <strong>私有字段</strong> 对应的方法句柄吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPublicField</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取私有字段的 Getter</span></span><br><span class="line">    assertThatExceptionOfType(IllegalAccessException.class)</span><br><span class="line">            .isThrownBy(() -&gt; lookup.findGetter(Person.class, <span class="string">&quot;name&quot;</span>, String.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是否定的。当前的 <code>Lookup</code> 实例不能访问 <code>Person</code> 类中的私有字段 <code>name</code>，最终抛出 <code>IllegalAccessException</code>。</p>
<p>前文获取的方法句柄对应的方法或字段都是由 <code>public</code> 修饰的，那非 <code>public</code> 方法或字段的方法句柄应该怎么获取呢？</p>
<h2 id="5-5-私有方法"><a class="header-anchor" href="#5-5-私有方法"></a>5.5 私有方法</h2>
<p>要求获取 <code>MyClass</code> 类内部私有方法 <code>privateMethod()</code> 对应的方法句柄：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">privateMethod</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取私有方法的方法句柄时，需要使用到 <code>Lookup#findSpecial()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@CanIgnoreReturnValue</span></span><br><span class="line"><span class="keyword">private</span> MethodHandle <span class="title function_">getPrivateMh</span><span class="params">(MethodHandles.Lookup lookup, MethodType methodType)</span> &#123;</span><br><span class="line">    <span class="comment">// 最后一个参数用于限定查找方法的范围</span></span><br><span class="line">    <span class="keyword">return</span> lookup.findSpecial(MyClass.class, <span class="string">&quot;privateMethod&quot;</span>, methodType, MyClass.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPrivateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(String.class, <span class="type">int</span>.class);</span><br><span class="line">    assertThatExceptionOfType(IllegalAccessException.class)</span><br><span class="line">            .isThrownBy(() -&gt; getPrivateMh(lookup, methodType))</span><br><span class="line">            .withMessageContaining(<span class="string">&quot;no private access for invokespecial&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依旧抛出了 <code>IllegalAccessException</code> 异常，这是因为使用的 <code>lookup</code> 对象没有访问 <code>privateMethod()</code> 方法的权限。</p>
<p>和反射一样，方法句柄也有权限问题，只不过与反射在运行时进行权限检查不同，方法句柄的权限检查是在创建阶段完成的，而在实际调用过程中，JVM 并不会检查方法句柄的权限。如果多次调用某个方法句柄，与反射调用相比，方法句柄能够节省下多次权限检查的开销。</p>
<p><mark>方法句柄的访问权限与 <code>Lookup</code> 对象的创建位置有关，与方法句柄的创建位置无关。</mark></p>
<p>在 <code>MyClass</code> 类的内部声明一个 <code>Lookup</code> 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodHandles.<span class="type">Lookup</span> <span class="variable">LOOKUP</span> <span class="operator">=</span> MethodHandles.lookup();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPrivateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意权限问题</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">privateMethod</span> <span class="operator">=</span> getPrivateMh(MyClass.LOOKUP, methodType);</span><br><span class="line">    assertThat(privateMethod.invoke(<span class="keyword">new</span> <span class="title class_">MyClass</span>(), <span class="number">212</span>)).asString().isEqualTo(<span class="string">&quot;212&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但问题又来了，如果没法修改源码呢？</p>
<p>在 JDK9 中新增了 <code>MethodHandles.privateLookupIn()</code> 静态方法，该方法可以将一个不具有访问目标类权限的 <code>Lookup</code> 实例模拟成具有相关访问权限的 <code>Lookup</code> 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPrivateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    MethodHandles.<span class="type">Lookup</span> <span class="variable">privateLookup</span> <span class="operator">=</span> MethodHandles.privateLookupIn(MyClass.class, lookup);</span><br><span class="line">    privateMethod = getPrivateMh(privateLookup, methodType);</span><br><span class="line">    assertThat(privateMethod.invoke(<span class="keyword">new</span> <span class="title class_">MyClass</span>(), <span class="number">212</span>)).asString().isEqualTo(<span class="string">&quot;212&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findSpecial()</code> 方法相比于 <code>findVirtual()</code>、<code>findStatic()</code> 多了一个参数，也就是第四个参数 <code>specialCaller</code>，它用于指定调用方法句柄时实际使用的类，必须具有访问私有方法的权限，限定了查找方法的范围，可以与第一个参数 <code>refc</code> 相等，或者是它的子类。</p>
<p>除此之外，传入的 <code>Lookup</code> 实例指向的类必须和 <code>specialCaller</code> 相等。</p>
<p>因此前文中获取私有字段的方法句柄可以修改成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPrivateProperty</span><span class="params">()</span> &#123;</span><br><span class="line">    MethodHandles.<span class="type">Lookup</span> <span class="variable">privateLookup</span> <span class="operator">=</span> MethodHandles.privateLookupIn(Person.class, lookup);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">handle</span> <span class="operator">=</span> privateLookup.findGetter(Person.class, <span class="string">&quot;name&quot;</span>, String.class);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;mofan&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    assertThat(handle.invoke(person)).isEqualTo(<span class="string">&quot;mofan&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以这样获取私有构造器的方法句柄：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPrivateConstructor</span><span class="params">()</span> &#123;</span><br><span class="line">    MethodHandles.<span class="type">Lookup</span> <span class="variable">privateLookup</span> <span class="operator">=</span> MethodHandles.privateLookupIn(Person.class, lookup);</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class, String.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">constructor</span> <span class="operator">=</span> privateLookup.findConstructor(Person.class, methodType);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) constructor.invokeExact(<span class="string">&quot;mofan&quot;</span>);</span><br><span class="line">    assertThat(person).isNotNull()</span><br><span class="line">            .extracting(Person::getName)</span><br><span class="line">            .isEqualTo(<span class="string">&quot;mofan&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>findSpecial()</code> 的细节</p>
</blockquote>
<p>说实话，<code>findSpecial()</code> 的一些细节并不是很好理解，可以参考以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GrandFather</span> &#123;</span><br><span class="line">    String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GrandFather&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Father</span> <span class="keyword">extends</span> <span class="title class_">GrandFather</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Father&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Grandson</span> <span class="keyword">extends</span> <span class="title class_">Son</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GrandSon&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindSpecial</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(String.class);</span><br><span class="line">    MethodHandles.<span class="type">Lookup</span> <span class="variable">grandsonLookup</span> <span class="operator">=</span> MethodHandles.privateLookupIn(Grandson.class, lookup);</span><br><span class="line">    <span class="type">Grandson</span> <span class="variable">grandSon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Grandson</span>();</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">getStr</span> <span class="operator">=</span> grandsonLookup.findSpecial(Grandson.class, <span class="string">&quot;getStr&quot;</span>, methodType, Grandson.class);</span><br><span class="line">    assertThat(getStr.invoke(grandSon)).isEqualTo(<span class="string">&quot;GrandSon&quot;</span>);</span><br><span class="line"></span><br><span class="line">    getStr = grandsonLookup.findSpecial(Son.class, <span class="string">&quot;getStr&quot;</span>, methodType, Grandson.class);</span><br><span class="line">    assertThat(getStr.invoke(grandSon)).isEqualTo(<span class="string">&quot;Father&quot;</span>);</span><br><span class="line"></span><br><span class="line">    getStr = grandsonLookup.findSpecial(Father.class, <span class="string">&quot;getStr&quot;</span>, methodType, Grandson.class);</span><br><span class="line">    assertThat(getStr.invoke(grandSon)).isEqualTo(<span class="string">&quot;Father&quot;</span>);</span><br><span class="line"></span><br><span class="line">    getStr = grandsonLookup.findSpecial(GrandFather.class, <span class="string">&quot;getStr&quot;</span>, methodType, Grandson.class);</span><br><span class="line">    assertThat(getStr.invoke(grandSon)).isEqualTo(<span class="string">&quot;Father&quot;</span>);</span><br><span class="line"></span><br><span class="line">    getStr = MethodHandles.privateLookupIn(Father.class, lookup)</span><br><span class="line">        .findSpecial(GrandFather.class, <span class="string">&quot;getStr&quot;</span>, methodType, Father.class);</span><br><span class="line">    assertThat(getStr.invoke(grandSon)).isEqualTo(<span class="string">&quot;GrandFather&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际使用时，应当尽可能明确目标方法实际所在的类，以便让 <code>refc</code> 和 <code>specialCaller</code> 的值相等。</p>
<h2 id="5-6-搭配反射"><a class="header-anchor" href="#5-6-搭配反射"></a>5.6 搭配反射</h2>
<p>在使用反射时，会按照需求创建以下实例：</p>
<ul>
<li><code>Constructor</code>：构造器</li>
<li><code>Method</code>：方法</li>
<li><code>Field</code>：字段</li>
</ul>
<p>在获取方法句柄时，也能够根据以上实例获取对应的方法句柄：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUnreflect</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    Constructor&lt;Person&gt; constructor = Person.class.getDeclaredConstructor(String.class);</span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">constructorMh</span> <span class="operator">=</span> lookup.unreflectConstructor(constructor);</span><br><span class="line">    assertThat(((Person) constructorMh.invoke(<span class="string">&quot;java&quot;</span>)))</span><br><span class="line">        .extracting(Person::getName)</span><br><span class="line">        .isEqualTo(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">getStr</span> <span class="operator">=</span> Person.class.getDeclaredMethod(<span class="string">&quot;getStr&quot;</span>, String.class, Integer.class);</span><br><span class="line">    getStr.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">getStrMh</span> <span class="operator">=</span> lookup.unreflect(getStr);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) getStrMh.invoke(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;test&quot;</span>, <span class="number">18</span>), <span class="string">&quot;TEST&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    assertThat(str).isEqualTo(<span class="string">&quot;TEST - 20&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用 unreflectSpecial</span></span><br><span class="line">    assertThatExceptionOfType(IllegalAccessException.class)</span><br><span class="line">        .isThrownBy(() -&gt; lookup.unreflectSpecial(getStr, Person.class))</span><br><span class="line">        .withMessageStartingWith(<span class="string">&quot;no private access for invokespecial&quot;</span>);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">getStrMh2</span> <span class="operator">=</span> MethodHandles.privateLookupIn(Person.class, lookup)</span><br><span class="line">        .unreflectSpecial(getStr, Person.class);</span><br><span class="line">    str = (String) getStrMh2.invoke(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;test&quot;</span>, <span class="number">18</span>), <span class="string">&quot;TEST&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    assertThat(str).isEqualTo(<span class="string">&quot;TEST - 20&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有字段</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Person.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">setNameMh</span> <span class="operator">=</span> lookup.unreflectSetter(field);</span><br><span class="line">    setNameMh.invoke(person, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">getNameMh</span> <span class="operator">=</span> lookup.unreflectGetter(field);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) getNameMh.invoke(person);</span><br><span class="line">    assertThat(name).isEqualTo(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果方法句柄引用的信息是私有的，那么先调用对应的 <code>setAccessible()</code> 方法设置访问权限即可。</p>
<p>对于 <code>unreflectSpecial()</code> 方法，第二个参数要求传入一个 <code>Class&lt;?&gt;</code> 对象，作为实际调用目标方法的对象的 <code>Class</code>，要求 <code>Lookup</code> 实例具有访问它的权限，因此需要使用 <code>MethodHandles.privateLookupIn()</code> 对现有的 <code>lookup</code> 对象进行模拟。</p>
<h2 id="5-7-通用的方法句柄"><a class="header-anchor" href="#5-7-通用的方法句柄"></a>5.7 通用的方法句柄</h2>
<p>前文中获取的方法句柄都是利用 <code>Lookup</code> 实例检索得到的，除此之外还可以使用 <code>MethodHandles</code> 中的一些工厂方法来获取一些通用的方法句柄。</p>
<blockquote>
<p>操作数组元素的方法句柄</p>
</blockquote>
<p>利用 <code>MethodHandles</code> 中的 <code>arrayElementGetter()</code> 方法和 <code>arrayElementSetter()</code> 方法可以生成对数组元素进行操作的方法句柄。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testArrayHandle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arrays = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">getter</span> <span class="operator">=</span> MethodHandles.arrayElementGetter(<span class="type">int</span>[].class);</span><br><span class="line">    assertThat(((<span class="type">int</span>) getter.invoke(arrays, <span class="number">1</span>))).isEqualTo(<span class="number">2</span>);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">setter</span> <span class="operator">=</span> MethodHandles.arrayElementSetter(<span class="type">int</span>[].class);</span><br><span class="line">    setter.invoke(arrays, <span class="number">1</span>, <span class="number">212</span>);</span><br><span class="line">    assertThat(arrays[<span class="number">1</span>]).isEqualTo(<span class="number">212</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>MethodHandles.identity()</code></p>
</blockquote>
<p><code>MethodHandles.identity()</code> 方法接收一个 <code>Class&lt;?&gt;</code> 对象，调用时传入的参数的 <code>Class</code> 信息要与创建方法句柄时指定的 <code>Class&lt;?&gt;</code> 相等，最终会将传入的参数值原样返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testIdentity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">stringMh</span> <span class="operator">=</span> MethodHandles.identity(String.class);</span><br><span class="line">    assertThat(stringMh.invoke(<span class="string">&quot;java&quot;</span>)).isEqualTo(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用时传入的参数要与调用 identity() 传入的 Class 对应</span></span><br><span class="line">    assertThatExceptionOfType(WrongMethodTypeException.class)</span><br><span class="line">        .isThrownBy(() -&gt; stringMh.invoke(<span class="number">123</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">personMh</span> <span class="operator">=</span> MethodHandles.identity(Person.class);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">java</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;java&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    assertThat(((Person) personMh.invoke(java)))</span><br><span class="line">        .extracting(Person::getName, Person::getAge)</span><br><span class="line">        .containsExactly(<span class="string">&quot;java&quot;</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>MethodHandles.constant()</code></p>
</blockquote>
<p><code>MethodHandles.constant()</code> 方法像是对 <code>MethodHandles.identity()</code> 方法的进一步简化，调用时需要传入两个参数：</p>
<ul>
<li><code>Class&lt;?&gt; type</code>：调用方法句柄期望的返回类型</li>
<li><code>Object value</code>：调用方法句柄返回的值</li>
</ul>
<p>在调用方法句柄时，总是返回传入的 <code>value</code> 值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConstant</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">stringMh</span> <span class="operator">=</span> MethodHandles.constant(String.class, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">    assertThat(stringMh.invoke()).isEqualTo(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Person</span> <span class="variable">java</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;java&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">personMh</span> <span class="operator">=</span> MethodHandles.constant(Person.class, java);</span><br><span class="line">    assertThat(((Person) personMh.invoke()))</span><br><span class="line">            .extracting(Person::getName, Person::getAge)</span><br><span class="line">            .containsExactly(<span class="string">&quot;java&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    assertThatExceptionOfType(ClassCastException.class)</span><br><span class="line">            .isThrownBy(() -&gt; MethodHandles.constant(<span class="type">long</span>.class, <span class="string">&quot;abc&quot;</span>));</span><br><span class="line">    assertThatExceptionOfType(ClassCastException.class)</span><br><span class="line">            .isThrownBy(() -&gt; MethodHandles.constant(String.class, <span class="number">123</span>));</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">mh</span> <span class="operator">=</span> MethodHandles.constant(<span class="type">long</span>.class, <span class="number">123456</span>);</span><br><span class="line">    assertThat(mh.invoke()).isInstanceOf(Long.class).isEqualTo(<span class="number">123456L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初看 <code>MethodHandles.identity()</code> 和 <code>MethodHandles.constant()</code> 感觉有点意义不明，它们的作用有点类似于 <code>null</code>。如果在某些场景下需要一个方法句柄，但又没有合适的方法句柄，并且不能传入 <code>null</code>，此时就可以使用这两个方法生成简单无害的方法句柄进行占位。</p>
<h1 id="6-调用方法句柄"><a class="header-anchor" href="#6-调用方法句柄"></a>6. 调用方法句柄</h1>
<p>前文在获取到方法句柄后使用了 <code>invoke()</code> 方法来调用方法句柄，但这并不是调用方法句柄的唯一方式，调用方法句柄有以下三种方式：</p>
<ul>
<li><code>invokeExact()</code></li>
<li><code>invoke()</code></li>
<li><code>invokeWithArguments()</code></li>
</ul>
<h2 id="6-1-invokeExact"><a class="header-anchor" href="#6-1-invokeExact"></a>6.1 invokeExact</h2>
<p>使用 <code>invokeExact()</code> 方法调用方法句柄与直接调用方法句柄引用的底层方法是一样的，因此在调用时 <strong>参数类型和返回值类型要严格匹配。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> one, <span class="type">long</span> two)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> one + two;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取 <code>Person</code> 类中 <code>sum()</code> 方法对应的方法句柄，并调用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInvokeExact</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">sumMethodType</span> <span class="operator">=</span> MethodType.methodType(<span class="type">long</span>.class, <span class="type">int</span>.class, <span class="type">long</span>.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">sumMh</span> <span class="operator">=</span> lookup.findVirtual(Person.class, <span class="string">&quot;sum&quot;</span>, sumMethodType);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="comment">// 使用 invoke 成功调用</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> sumMh.invoke(person, Integer.valueOf(<span class="number">1</span>), <span class="number">2</span>);</span><br><span class="line">    assertThat(sum).isEqualTo(<span class="number">3L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invokeExact 将更严格地调用，相当于直接调用引用的方法</span></span><br><span class="line">    assertThatExceptionOfType(WrongMethodTypeException.class).isThrownBy(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 返回值类型不匹配</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> sumMh.invokeExact(person, <span class="number">1L</span>, <span class="number">2L</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    assertThatExceptionOfType(WrongMethodTypeException.class).isThrownBy(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 不写返回值也不行，这种情况认为返回值是 void，相当于返回值类型不匹配</span></span><br><span class="line">        sumMh.invokeExact(person, <span class="number">1L</span>, <span class="number">2L</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    assertThatExceptionOfType(WrongMethodTypeException.class).isThrownBy(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 参数类型不匹配，就算是包装类也不行，要严格匹配</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">long</span>) sumMh.invokeExact(person, Long.valueOf(<span class="number">1L</span>), <span class="number">2L</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 参数类型、返回值类型严格匹配！</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">long</span>) sumMh.invokeExact(person, <span class="number">1</span>, <span class="number">2L</span>);</span><br><span class="line">    assertThat(result).isEqualTo(<span class="number">3L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sum()</code> 方法接收两个基本类型 <code>long</code> 的参数，最终返回 <code>long</code> 类型的值。</p>
<p>使用 <code>invoke()</code> 方法调用方法句柄时，传入的参数类型是 <code>Integer</code> 和 <code>int</code>，期望的返回值类型是 <code>Object</code>，方法句柄能被成功调用。</p>
<p>如果按照相同的调用方式使用 <code>invokeExact()</code> 调用方法句柄，则会抛出 <code>WrongMethodTypeException</code>，因为真正的返回值类型是 <code>long</code>，而不是 <code>Object</code>。</p>
<p>如果方法句柄引用的方法有返回值，那么在使用 <code>invokeExact()</code> 调用方法句柄时，<strong>一定要</strong> 按照真正的返回值类型对返回值进行强转并声明一个变量来接收，如果没有变量接收返回值，会认为方法的返回值类型是 <code>void</code>，即没有返回值。</p>
<p>使用 <code>invokeExact()</code> 调用方法句柄时，<strong>参数类型要严格匹配，</strong> 并且不会自动装箱与拆箱。比如要求的参数类型是 <code>long</code>，但是传入的参数类型是 <code>Long</code>，依旧会抛出 <code>WrongMethodTypeException</code>。</p>
<h2 id="6-2-invoke"><a class="header-anchor" href="#6-2-invoke"></a>6.2 invoke</h2>
<p>相比于 <code>invokeExact()</code>，<code>invoke()</code> 的要求更加松散，使用 <code>invoke()</code> 调用方法句柄时会尝试对参数和返回值进行类型转换。</p>
<p>如果调用方法句柄传入和接收的类型与引用的方法要求传入和接收的类型完全一致时，<code>invoke()</code> 相当于 <code>invokeExact()</code>；否则会对参数类型和返回值类型进行类型转换，转换成真正需要的类型。如果能够转换成功，那么一切安好，否则抛出相关异常。</p>
<p>这种类型转换是通过 <code>MethodHandle#asType()</code> 方法来完成的，<code>asType()</code> 方法能够把当前方法句柄适配到新的<code>MethodType</code> 上，并生成一个新的方法句柄。</p>
<p>正是因为 <code>invoke()</code> 方法的松散性调用，使得在调用方法句柄时普遍采用 <code>invoke()</code> 方法进行调用。</p>
<p><code>invoke()</code> 进行类型转换时会对比所有参数类型和返回值类型是否都可以进行转换，只要其中一个转换失败，那么整个转换过程就会失败。</p>
<p>基本转换规则是：</p>
<ul>
<li>
<p>利用多态完成转换，比如将子类转换为父类；</p>
</li>
<li>
<p>将类型范围较小的基本类型转换为范围更大的基本类型，比如 <code>int</code> 转为 <code>long</code>；</p>
</li>
<li>
<p>利用拆箱、装箱完成转换，比如 <code>int</code> 转换为 <code>Integer</code>，<code>Integer</code> 转换为 <code>int</code>；</p>
</li>
<li>
<p>如果引用的方法有返回值，但调用时没有变量来接收，那么返回值会被丢弃；</p>
</li>
<li>
<p>如果引用的方法没有返回值，但调用时使用引用类型进行接收，最终的返回值会是 <code>null</code>；</p>
</li>
<li>
<p>如果引用的方法没有返回值，但调用时使用基本类型进行接收，最终的返回值会是该基本类型的默认值；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String string)</span> &#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInvokeResult</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class, String.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">print</span> <span class="operator">=</span> lookup.findVirtual(Person.class, <span class="string">&quot;print&quot;</span>, methodType);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有返回值的方法给了返回值，返回 null</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> print.invoke(person, <span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    assertThat(result).isNull();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以基本类型接收，返回基本类型的默认值</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">intResult</span> <span class="operator">=</span> (<span class="type">boolean</span>) print.invoke(person, <span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    assertThat(intResult).isFalse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-invokeWithArguments"><a class="header-anchor" href="#6-3-invokeWithArguments"></a>6.3 invokeWithArguments</h2>
<p><code>invokeWithArguments()</code> 与 <code>invoke()</code> 相比又更加松散，可以指定任意个 <code>Object</code> 类型的参数，与 <code>invokeExact()</code>、<code>invoke()</code> 不同，它的底层实现不是一个本地方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invokeWithArguments</span><span class="params">(Object... arguments)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// Note: Jumbo argument lists are handled in the variable-arity subclass.</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">invocationType</span> <span class="operator">=</span> MethodType.genericMethodType(</span><br><span class="line">        arguments == <span class="literal">null</span> ? <span class="number">0</span> : arguments.length</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> invocationType.invokers()</span><br><span class="line">        .spreadInvoker(<span class="number">0</span>)</span><br><span class="line">        .invokeExact(asType(invocationType), arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>invokeWithArguments()</code> 首先获取传入参数的个数，然后使用 <code>MethodType.genericMethodType()</code> 方法创建出拥有一个 <code>Object</code> 类型返回值和若干个 <code>Object</code> 类型参数的 <code>MethodType</code>，将这个 <code>MethodType</code> 通过 <code>asType()</code> 转换后得到一个新的方法句柄，最后使用 <code>invokeExact()</code> 调用这个方法句柄。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInvokeWithArguments</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">subtractMethodType</span> <span class="operator">=</span> MethodType.methodType(<span class="type">int</span>.class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">subtractMh</span> <span class="operator">=</span> lookup.findVirtual(Person.class, <span class="string">&quot;subtract&quot;</span>, subtractMethodType);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">two</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">one</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    List&lt;Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    arguments.add(person);</span><br><span class="line">    arguments.addAll(List.of(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>&#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invokeExact</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) subtractMh.invokeExact(person, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    assertThat(result).isEqualTo(<span class="number">1</span>);</span><br><span class="line">    assertThatExceptionOfType(WrongMethodTypeException.class)</span><br><span class="line">        .isThrownBy(() -&gt; subtractMh.invokeExact(person, two, one));</span><br><span class="line">    assertThatExceptionOfType(WrongMethodTypeException.class)</span><br><span class="line">        .isThrownBy(() -&gt; subtractMh.invokeExact(arguments));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke</span></span><br><span class="line">    result = (<span class="type">int</span>) subtractMh.invoke(person, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    assertThat(result).isEqualTo(<span class="number">1</span>);</span><br><span class="line">    result = (<span class="type">int</span>) subtractMh.invoke(person, two, one);</span><br><span class="line">    assertThat(result).isEqualTo(<span class="number">1</span>);</span><br><span class="line">    assertThatExceptionOfType(WrongMethodTypeException.class)</span><br><span class="line">        .isThrownBy(() -&gt; subtractMh.invoke(arguments));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invokeWithArguments</span></span><br><span class="line">    result = (<span class="type">int</span>) subtractMh.invokeWithArguments(person, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    assertThat(result).isEqualTo(<span class="number">1</span>);</span><br><span class="line">    result = (<span class="type">int</span>) subtractMh.invokeWithArguments(person, two, one);</span><br><span class="line">    assertThat(result).isEqualTo(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 可以传入参数列表</span></span><br><span class="line">    result = (<span class="type">int</span>) subtractMh.invokeWithArguments(arguments);</span><br><span class="line">    assertThat(result).isEqualTo(<span class="number">1</span>);</span><br><span class="line">    assertThatExceptionOfType(WrongMethodTypeException.class)</span><br><span class="line">        .isThrownBy(() -&gt; subtractMh.invokeWithArguments(person, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>&#125;))</span><br><span class="line">        .withMessage(<span class="string">&quot;cannot convert MethodHandle(Person,int,int)int to (Object,Object)Object&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 <code>invokeExact()</code>、<code>invoke()</code> 相比，可以通过反射拿到 <code>invokeWithArguments()</code> 方法对应的 <code>Method</code> 对象进行调用，而不会抛出 <code>UnsupportedOperationException</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInvokeWithReflect</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">subtractMethodType</span> <span class="operator">=</span> MethodType.methodType(<span class="type">int</span>.class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">subtractMh</span> <span class="operator">=</span> lookup.findVirtual(Person.class, <span class="string">&quot;subtract&quot;</span>, subtractMethodType);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">    Class&lt;MethodHandle&gt; clazz = MethodHandle.class;</span><br><span class="line">    <span class="type">Method</span> <span class="variable">invoke</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;invoke&quot;</span>, Object[].class);</span><br><span class="line">    assertThatThrownBy(() -&gt; invoke.invoke(subtractMh, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;person, <span class="number">2</span>, <span class="number">1</span>&#125;&#125;))</span><br><span class="line">        .hasCauseInstanceOf(UnsupportedOperationException.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">invokeWithArguments</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;invokeWithArguments&quot;</span>, Object[].class);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) invokeWithArguments.invoke(subtractMh, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;person, <span class="number">2</span>, <span class="number">1</span>&#125;&#125;);</span><br><span class="line">    assertThat(result).isEqualTo(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-可变参数的方法句柄"><a class="header-anchor" href="#7-可变参数的方法句柄"></a>7. 可变参数的方法句柄</h1>
<p>方法句柄引用的方法的参数除了是固定的参数外，还可以是可变参数，可变参数可以看成是一个数组。对于这种情况，方法句柄也提供了相关的处理能力，使得可变参数和数组类型的参数之间能够相互转换。</p>
<h2 id="7-1-asVarargsCollector"><a class="header-anchor" href="#7-1-asVarargsCollector"></a>7.1 asVarargsCollector</h2>
<p><code>MethodHandle#asVarargsCollector()</code> 方法能够 <strong>将原始方法句柄中最后一个数组类型的参数转换成对应类型的可变参数，</strong> 转换之后会得到一个新的方法句柄。在调用新的方法句柄时，可以使用可变参数的语法，无需使用数组形式（当然使用数组形式也不会错）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Varargs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Object... objects)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAsVarargsCollector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">deepToString</span> <span class="operator">=</span> lookup.findStatic(Arrays.class, <span class="string">&quot;deepToString&quot;</span>, MethodType.methodType(</span><br><span class="line">        String.class, Object[].class</span><br><span class="line">    ));</span><br><span class="line">    assertThat(deepToString.isVarargsCollector()).isFalse();</span><br><span class="line">    <span class="comment">// 将最后一个数组类型的参数转换成对应类型的可变参数，invoke 时无需使用原始的数组形式</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">mh</span> <span class="operator">=</span> deepToString.asVarargsCollector(Object[].class);</span><br><span class="line">    assertThat(mh.isVarargsCollector()).isTrue();</span><br><span class="line">    assertThat(mh.invoke(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>)).isEqualTo(<span class="string">&quot;[one, two]&quot;</span>);</span><br><span class="line">    <span class="comment">// 当然，继续使用数组也行</span></span><br><span class="line">    assertThat(mh.invoke(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;)).isEqualTo(<span class="string">&quot;[one, two]&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用 invokeExact 调用，还是只能用数组</span></span><br><span class="line">    assertThat((String) mh.invokeExact(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;)).isEqualTo(<span class="string">&quot;[one, two]&quot;</span>);</span><br><span class="line">    assertThatExceptionOfType(WrongMethodTypeException.class)</span><br><span class="line">        .isThrownBy(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) mh.invokeExact(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    assertThat(mh.invoke((Object) <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;)).isEqualTo(<span class="string">&quot;[[one, two]]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Arrays#asList 默认支持</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">asList</span> <span class="operator">=</span> lookup.findStatic(Arrays.class, <span class="string">&quot;asList&quot;</span>, MethodType.methodType(</span><br><span class="line">        List.class, Object[].class</span><br><span class="line">    ));</span><br><span class="line">    assertThat(asList.isVarargsCollector()).isTrue();</span><br><span class="line">    assertThat(asList.invoke()).asList().isEmpty();</span><br><span class="line">    assertThat(asList.invoke(<span class="string">&quot;1&quot;</span>)).asList().containsOnly(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    String[] args = &#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">    assertThat(asList.invoke(args)).asList().containsExactly(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">    assertThat(asList.invoke((Object[]) args)).asList().containsExactly(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">    List&lt;?&gt; list = (List&lt;?&gt;) asList.invoke((Object) args);</span><br><span class="line">    <span class="comment">// 索引 0 位置的元素是个 String 数组，值为 &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;</span></span><br><span class="line">    assertThat(list).hasSize(<span class="number">1</span>).has(HamcrestCondition.matching(Is.is(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;)), Index.atIndex(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可变参数方法默认支持</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">method</span> <span class="operator">=</span> lookup.findVirtual(Varargs.class, <span class="string">&quot;method&quot;</span>, MethodType.methodType(</span><br><span class="line">        <span class="keyword">void</span>.class, Object[].class</span><br><span class="line">    ));</span><br><span class="line">    assertThat(method.isVarargsCollector()).isTrue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-2-asCollector"><a class="header-anchor" href="#7-2-asCollector"></a>7.2 asCollector</h2>
<p><code>MethodHandle#asCollector()</code> 方法与 <code>MethodHandle#asVarargsCollector()</code> 方法很类似，只不过 <code>MethodHandle#asCollector()</code> <strong>只能把指定数量的最后几个参数收集到原始方法句柄对应的方法的数组参数中，</strong> 而不是像 <code>MethodHandle#asVarargsCollector()</code> 将最后所有的参数都收集到数组参数中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAsCollector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(String.class, Object[].class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">deepToString</span> <span class="operator">=</span> lookup.findStatic(Arrays.class, <span class="string">&quot;deepToString&quot;</span>, methodType);</span><br><span class="line">    assertThat((String) deepToString.invokeExact(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;java&quot;</span>&#125;)).isEqualTo(<span class="string">&quot;[java]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与 asVarargsCollector() 方法类似，只不过 asCollector() 只会收集指定数量的参数</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">ts1</span> <span class="operator">=</span> deepToString.asCollector(Object[].class, <span class="number">1</span>);</span><br><span class="line">    assertThat((String) ts1.invokeExact((Object) <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;java&quot;</span>&#125;))</span><br><span class="line">        .isNotEqualTo(<span class="string">&quot;[java]&quot;</span>)</span><br><span class="line">        .isEqualTo(<span class="string">&quot;[[java]]&quot;</span>);</span><br><span class="line">    assertThat((String) ts1.invokeExact((Object) <span class="string">&quot;java&quot;</span>)).isEqualTo(<span class="string">&quot;[java]&quot;</span>);</span><br><span class="line">    assertThatExceptionOfType(WrongMethodTypeException.class)</span><br><span class="line">        .isThrownBy(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> ((String) ts1.invokeExact(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组类型可以是 Object[] 的子类</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">ts2</span> <span class="operator">=</span> deepToString.asCollector(String[].class, <span class="number">2</span>);</span><br><span class="line">    assertThat(ts2.type()).isEqualTo(MethodType.methodType(String.class, String.class, String.class));</span><br><span class="line">    assertThat((String) ts2.invokeExact(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>)).isEqualTo(<span class="string">&quot;[one, two]&quot;</span>);</span><br><span class="line">    assertThatExceptionOfType(WrongMethodTypeException.class)</span><br><span class="line">        .isThrownBy(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 只把最后两个参数收集到数组参数中</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) ts2.invokeExact(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">ts0</span> <span class="operator">=</span> deepToString.asCollector(Object[].class, <span class="number">0</span>);</span><br><span class="line">    assertThat((String) ts0.invokeExact()).isEqualTo(<span class="string">&quot;[]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以嵌套</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">ts22</span> <span class="operator">=</span> deepToString.asCollector(Object[].class, <span class="number">3</span>)</span><br><span class="line">        .asCollector(String[].class, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 最后三个是 Object -&gt; 最后两个是 String -&gt; 前两个 Object，最后两个 String</span></span><br><span class="line">    assertThat((String) ts22.invokeExact((Object) <span class="string">&quot;A&quot;</span>, (Object) <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>))</span><br><span class="line">        .isEqualTo(<span class="string">&quot;[A, B, [C, D]]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组类型可以是任意基本类型</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">byteToString</span> <span class="operator">=</span> lookup.findStatic(</span><br><span class="line">        Arrays.class,</span><br><span class="line">        <span class="string">&quot;toString&quot;</span>,</span><br><span class="line">        MethodType.methodType(String.class, <span class="type">byte</span>[].class)</span><br><span class="line">    ).asCollector(<span class="type">byte</span>[].class, <span class="number">3</span>);</span><br><span class="line">    assertThat((String) byteToString.invokeExact((<span class="type">byte</span>) <span class="number">1</span>, (<span class="type">byte</span>) <span class="number">2</span>, (<span class="type">byte</span>) <span class="number">3</span>)).isEqualTo(<span class="string">&quot;[1, 2, 3]&quot;</span>);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">longToString</span> <span class="operator">=</span> lookup.findStatic(</span><br><span class="line">        Arrays.class,</span><br><span class="line">        <span class="string">&quot;toString&quot;</span>,</span><br><span class="line">        MethodType.methodType(String.class, <span class="type">long</span>[].class)</span><br><span class="line">    ).asCollector(<span class="type">long</span>[].class, <span class="number">1</span>);</span><br><span class="line">    assertThat((String) longToString.invokeExact((<span class="type">long</span>) <span class="number">212</span>)).isEqualTo(<span class="string">&quot;[212]&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-3-asSpreader"><a class="header-anchor" href="#7-3-asSpreader"></a>7.3 asSpreader</h2>
<p><code>MethodHandle#asSpreader()</code> 方法则是与 <code>asVarargsCollector()</code> 和 <code>asCollector()</code> 相反，它能够 <strong>将可变参数转换成数组类型的参数。</strong> 在调用转换后得到的方法句柄时，使用数组作为参数，会按照顺序将数组中的每项依次分配给原始方法句柄中的各个参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAsSpreader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">addExactMethodType</span> <span class="operator">=</span> MethodType.methodType(<span class="type">int</span>.class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">addExact</span> <span class="operator">=</span> lookup.findStatic(Math.class, <span class="string">&quot;addExact&quot;</span>, addExactMethodType);</span><br><span class="line"></span><br><span class="line">    assertThatNoException().isThrownBy(() -&gt; addExact.invoke(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    assertThatNoException().isThrownBy(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) addExact.invokeExact(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 无论那种 invoke 都不接受参数数组</span></span><br><span class="line">    <span class="type">int</span>[] args = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    assertThatExceptionOfType(WrongMethodTypeException.class)</span><br><span class="line">        .isThrownBy(() -&gt; addExact.invoke(args));</span><br><span class="line">    assertThatExceptionOfType(WrongMethodTypeException.class)</span><br><span class="line">        .isThrownBy(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) addExact.invokeExact(args);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// asSpreader() 将长度可变的参数转换成数组</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">addExactAsSpreader</span> <span class="operator">=</span> addExact.asSpreader(<span class="type">int</span>[].class, <span class="number">2</span>);</span><br><span class="line">    assertThat(addExactAsSpreader.invoke(args)).isEqualTo(<span class="number">2</span>);</span><br><span class="line">    assertThat((<span class="type">int</span>) addExactAsSpreader.invokeExact(args)).isEqualTo(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">arguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    assertThatExceptionOfType(WrongMethodTypeException.class)</span><br><span class="line">        .isThrownBy(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 类型还是要强匹配</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) addExactAsSpreader.invokeExact(arguments);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">// 使用 invoke 则无所谓</span></span><br><span class="line">    assertThat(addExactAsSpreader.invoke(arguments)).isEqualTo(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一种使用示例</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">equalsMethodType</span> <span class="operator">=</span> MethodType.methodType(<span class="type">boolean</span>.class, Object.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">equals</span> <span class="operator">=</span> lookup.findVirtual(String.class, <span class="string">&quot;equals&quot;</span>, equalsMethodType);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">methodHandle</span> <span class="operator">=</span> equals.asSpreader(Object[].class, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 甚至可以包括实例对象</span></span><br><span class="line">    assertThat(methodHandle.invoke(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;java&quot;</span>, <span class="string">&quot;java&quot;</span>&#125;))</span><br><span class="line">        .asInstanceOf(InstanceOfAssertFactories.BOOLEAN)</span><br><span class="line">        .isTrue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-4-asFixedArity"><a class="header-anchor" href="#7-4-asFixedArity"></a>7.4 asFixedArity</h2>
<p><code>MethodHandle#asFixedArity()</code> 方法可以 <strong>将接收可变参数的方法转换成接收长度不变的方法，</strong> 因此在调用转换后得到的方法句柄时， <strong>只能使用传入数组。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked, rawtypes&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAsFixedArity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(List.class, Object[].class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">asList</span> <span class="operator">=</span> lookup.findStatic(Arrays.class, <span class="string">&quot;asList&quot;</span>, methodType);</span><br><span class="line">    assertThat(asList.invoke(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)).asList().containsExactly(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">asListFix</span> <span class="operator">=</span> asList.asFixedArity();</span><br><span class="line">    <span class="comment">// 调用方法句柄时只能使用数组作为方法参数</span></span><br><span class="line">    assertThatExceptionOfType(WrongMethodTypeException.class)</span><br><span class="line">        .isThrownBy(() -&gt; asListFix.invoke(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    Object[] args = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    assertThat(asListFix.invoke(args)).asList().containsExactly(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整个数组作为一个参数</span></span><br><span class="line">    List&lt;?&gt; list = (List&lt;?&gt;) asList.invoke((Object) args);</span><br><span class="line">    assertThat(list).hasSize(<span class="number">1</span>).is(HamcrestCondition.matching(Is.is(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)), Index.atIndex(<span class="number">0</span>));</span><br><span class="line">    list = ((List&lt;?&gt;) asListFix.invoke((Object) args));</span><br><span class="line">    assertThat(list).hasSize(<span class="number">3</span>).containsExactlyElementsOf((List) List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="8-参数绑定"><a class="header-anchor" href="#8-参数绑定"></a>8. 参数绑定</h1>
<p>在调用方法句柄之前，可以事先对参数进行绑定，后续调用方法句柄时，无需传入绑定的参数，传入剩余所需的参数即可，参数绑定可以使用 <code>MethodHandle#bindTo()</code> 完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取 <code>setName()</code> 方法对应的方法句柄，由于 <code>setName()</code> 方法是成员方法，因此在调用方法句柄时需要传入 <code>Person</code> 实例对象。</p>
<p>如果想要在调用方法句柄时只传入 <code>setName()</code> 方法实际所需的参数，那么可以使用 <code>bindTo()</code> 方法预先绑定 <code>Person</code> 实例对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBindTo</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">setNameMethodType</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class, String.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">setNameMh</span> <span class="operator">=</span> lookup.findVirtual(Person.class, <span class="string">&quot;setName&quot;</span>, setNameMethodType);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    <span class="comment">// bindTo 的参数对象必须是 Person 对象或其子类对象</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">methodHandle</span> <span class="operator">=</span> setNameMh.bindTo(student);</span><br><span class="line">    methodHandle.invoke(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    assertThat(student).extracting(Student::getName).isEqualTo(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再比如</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">concatMethodType</span> <span class="operator">=</span> MethodType.methodType(String.class, String.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">concat</span> <span class="operator">=</span> lookup.findVirtual(String.class, <span class="string">&quot;concat&quot;</span>, concatMethodType);</span><br><span class="line">    methodHandle = concat.bindTo(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">    assertThat(methodHandle.invoke(<span class="string">&quot;world&quot;</span>)).isEqualTo(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预先绑定参数的方式使得开发者能够只公开方法，而不公开该方法所在的对象，方法句柄的调用者只需关注方法本身，并可以在任何地方直接调用方法句柄，就像直接调用方法一样。</p>
<p>可以多次使用 <code>bindTo()</code> 来绑定多个参数，如果所需的参数都被绑定完了，那在调用时无需传入任何参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBindTo</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多次绑定</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">indexOfMethodType</span> <span class="operator">=</span> MethodType.methodType(<span class="type">int</span>.class, String.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">indexOf</span> <span class="operator">=</span> lookup.findVirtual(String.class, <span class="string">&quot;indexOf&quot;</span>, indexOfMethodType)</span><br><span class="line">        .bindTo(<span class="string">&quot;hello world&quot;</span>).bindTo(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用时无需传入参数</span></span><br><span class="line">    assertThat(indexOf.invoke()).isEqualTo(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>bindTo()</code> 绑定方法参数时， <strong>只能绑定引用类型的参数，</strong> 无法绑定 <code>int</code>、<code>long</code> 等基本类型的参数。</p>
<p>针对这种情况，可以先使用 <code>MethodType#wrap()</code> 方法将包含基本类型的 <code>MethodType</code> 转换成对应包装类型的 <code>MethodType</code>，之后使用 <code>MethodHandle#asType()</code> 方法将原方法句柄转换成使用新 <code>MethodType</code> 的方法句柄。对于新方法句柄，就可以使用 <code>bindTo()</code> 方法进行绑定了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBindTo</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定基本类型</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">substringMethodType</span> <span class="operator">=</span> MethodType.methodType(String.class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">substring</span> <span class="operator">=</span> lookup.findVirtual(String.class, <span class="string">&quot;substring&quot;</span>, substringMethodType);</span><br><span class="line">    assertThatExceptionOfType(IllegalArgumentException.class)</span><br><span class="line">        .isThrownBy(() -&gt; substring.bindTo(<span class="string">&quot;java&quot;</span>).bindTo(<span class="number">2</span>).bindTo(<span class="number">3</span>))</span><br><span class="line">        .withMessage(<span class="string">&quot;no leading reference parameter&quot;</span>);</span><br><span class="line">    <span class="comment">// 对于基本类型的绑定需要使用 wrap() 包装下</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">mh</span> <span class="operator">=</span> substring.asType(substring.type().wrap())</span><br><span class="line">        .bindTo(<span class="string">&quot;java&quot;</span>).bindTo(<span class="number">2</span>).bindTo(<span class="number">3</span>);</span><br><span class="line">    assertThat(mh.invoke()).isEqualTo(<span class="string">&quot;v&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="9-变换方法句柄"><a class="header-anchor" href="#9-变换方法句柄"></a>9. 变换方法句柄</h1>
<p>方法句柄与反射 API 相比，能够进行多种变换，包括对参数和返回值的处理，并且还能够将这些变换进行组合，形成更加复杂的变换。</p>
<p>方法句柄的变换都是由 <code>MethodHandles</code> 类中的静态方法完成，这些静态方法一般都将接收一个方法句柄，最终返回一个变换后的、新的方法句柄。</p>
<h2 id="9-1-dropArguments"><a class="header-anchor" href="#9-1-dropArguments"></a>9.1 dropArguments</h2>
<p><code>drop</code> 意为落下、丢下，<code>dropArguments</code> 的含义并不是舍弃当前方法句柄中的一些参数，而是能够在当前方法句柄中添加一些无用的参数，实际调用时这些参数会被舍弃。</p>
<p>利用 <code>dropArguments</code> 能够使得变换后的方法句柄的参数类型格式符合某些特定的要求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDropArguments</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// String#substring()</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(String.class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">substring</span> <span class="operator">=</span> lookup.findVirtual(String.class, <span class="string">&quot;substring&quot;</span>, methodType);</span><br><span class="line">    assertThat(substring.invoke(<span class="string">&quot;hello world&quot;</span>, <span class="number">6</span>, <span class="number">11</span>)).isEqualTo(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="comment">// 在参数 0 位置处添加 float、double 类型的两个参数</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">newMh</span> <span class="operator">=</span> MethodHandles.dropArguments(substring, <span class="number">0</span>, <span class="type">float</span>.class, <span class="type">double</span>.class);</span><br><span class="line">    <span class="comment">// 实际调用时会忽略添加的两个参数</span></span><br><span class="line">    assertThat(newMh.invoke(<span class="number">0.5f</span>, <span class="number">2.33</span>, <span class="string">&quot;hello world&quot;</span>, <span class="number">6</span>, <span class="number">11</span>)).isEqualTo(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>String#substring()</code> 方法接收两个 <code>int</code> 类型的参数，使用 <code>dropArguments</code> 在参数列表索引为 0 的位置添加 <code>float</code> 和 <code>double</code> 类型的参数，新得到的方法句柄具有以下参数列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float, double, String, int, int</span><br></pre></td></tr></table></figure>
<p>中间的 <code>String</code> 是因为 <code>String#substring()</code> 方法是成员方法，调用时需要传入对应的对象。</p>
<h2 id="9-2-insertArguments"><a class="header-anchor" href="#9-2-insertArguments"></a>9.2 insertArguments</h2>
<p><code>insertArguments</code> 顾名思义就是在当前的方法句柄中插入一些参数，插入的参数会在调用方法句柄时从指定位置依次填充，而无需再次传入。</p>
<p><code>insertArguments</code> 的作用和 <code>MethodHandle#bindTo()</code> 类似，但它更加强大，能够从指定位置开始，依次绑定多个参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertArguments</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// String#concat</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(String.class, String.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">concat</span> <span class="operator">=</span> lookup.findVirtual(String.class, <span class="string">&quot;concat&quot;</span>, methodType);</span><br><span class="line">    assertThat(concat.invoke(<span class="string">&quot;hello &quot;</span>, <span class="string">&quot;world&quot;</span>)).isEqualTo(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置参数 1 位置处的参数个给定的值</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">newMh</span> <span class="operator">=</span> MethodHandles.insertArguments(concat, <span class="number">1</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    <span class="comment">// 因为已经设置了一个值，因此调用时只填一个值</span></span><br><span class="line">    assertThat(newMh.invoke(<span class="string">&quot;hello world&quot;</span>)).isEqualTo(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>String#concat()</code> 是成员方法，并接收一个参数，因此在执行方法句柄时需要传入具体的实例对象和调用方法所需的一个参数，总共两个参数。</p>
<p>使用 <code>insertArguments</code> 在索引 1 位置插入了一个参数，那么在执行时只需要传入索引 0 位置的参数即可。</p>
<h2 id="9-3-filterArguments"><a class="header-anchor" href="#9-3-filterArguments"></a>9.3 filterArguments</h2>
<p>使用 <code>filterArguments</code> 能够对当前方法句柄的参数使用另一个方法句柄进行预处理，使得预处理后的参数满足当前方法句柄的调用要求。</p>
<p>其用法和前面的方法类似，传入原始的方法句柄是毋庸置疑的，然后再传入预处理参数的起始索引，最后传入进行预处理的方法句柄，从起始索引开始，依次使用传入的方法句柄对这些参数进行预处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFilterArguments</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(<span class="type">int</span>.class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="comment">// 接收两个 int，返回最大的 int</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">max</span> <span class="operator">=</span> lookup.findStatic(Math.class, <span class="string">&quot;max&quot;</span>, methodType);</span><br><span class="line">    <span class="comment">// 返回字符串的长度</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">length</span> <span class="operator">=</span> lookup.findVirtual(String.class, <span class="string">&quot;length&quot;</span>, MethodType.methodType(<span class="type">int</span>.class));</span><br><span class="line">    <span class="comment">// 对 max 的索引 1 及其以后的参数使用 length 进行预处理</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">methodHandle</span> <span class="operator">=</span> MethodHandles.filterArguments(max, <span class="number">0</span>, length, length);</span><br><span class="line">    <span class="comment">// 虽然传入的 hello world 是字符串，但是会使用 length 进行预处理，得到字符串的长度</span></span><br><span class="line">    assertThat(methodHandle.invoke(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;hello world&quot;</span>)).isEqualTo(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>Math.max()</code> 方法需要传入两个 <code>int</code> 类型的参数，但实际调用时传入的是两个 <code>String</code> 类型的参数。</p>
<p>在调用前，使用 <code>filterArguments</code> 对原始方法句柄的参数进行预处理，从索引 0 位置的参数开始，依次使用两个名为 <code>length</code> 的方法句柄进行处理。</p>
<p>你以为传入的是两个 <code>String</code>，其实传入的是它们的 <code>length</code>。</p>
<h2 id="9-4-foldArguments"><a class="header-anchor" href="#9-4-foldArguments"></a>9.4 foldArguments</h2>
<p><code>foldArguments</code> 意为“折叠参数”，它能够将执行方法句柄时传入的参数“折叠”为一个新值放在原始参数列表的 <strong>首位</strong>，作为一个新的参数。</p>
<p>“折叠”的逻辑由另一个方法句柄（假设称之为“折叠函数”，我瞎编的 👻）完成。在进行转换时，根据折叠函数所需的参数个数 N，选取实际调用时传入的前 N 个参数，将这前 N 个参数作为折叠函数调用时使用的参数，调用折叠函数后得到一个新值，将这个值插入到原始参数列表的首位。</p>
<p>有两点需要注意：</p>
<ol>
<li>如果折叠函数的返回值类型是 <code>void</code>，则不会在首位添加参数；</li>
<li>如果折叠函数的返回值类型不是 <code>void</code>，那么要求这个类型与调用原始方法句柄时传入的第一个参数类型匹配。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FoldArgument</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getFirst</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFoldArguments</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(<span class="type">int</span>.class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">addExact</span> <span class="operator">=</span> lookup.findStatic(Math.class, <span class="string">&quot;addExact&quot;</span>, methodType);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">getFirst</span> <span class="operator">=</span> lookup.findStatic(FoldArgument.class, <span class="string">&quot;getFirst&quot;</span>,</span><br><span class="line">            MethodType.methodType(<span class="type">int</span>.class, <span class="type">int</span>.class, <span class="type">int</span>.class, <span class="type">int</span>.class));</span><br><span class="line">    <span class="comment">// 对传入的参数按照 addExact 得到新值，然后添加到原参数最前面</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">methodHandle</span> <span class="operator">=</span> MethodHandles.foldArguments(getFirst, addExact);</span><br><span class="line">    <span class="comment">// 1 2 =&gt; 3 1 2</span></span><br><span class="line">    assertThat(methodHandle.invoke(<span class="number">1</span>, <span class="number">2</span>)).isEqualTo(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对转换后的方法句柄 <code>methodHandle</code> 进行调用时，先利用方法句柄 <code>addExact</code> 对传入的参数进行预处理，然后将预处理结果放在原始参数列表的首位，最终使用新的参数列表调用方法句柄 <code>getFirst</code>。</p>
<h2 id="9-5-permuteArguments"><a class="header-anchor" href="#9-5-permuteArguments"></a>9.5 permuteArguments</h2>
<p><code>permute</code> 意为交换、置换，常用于表示改变顺序。<code>permuteArguments</code> 用于对原始方法句柄中的参数进行排列，这种排列可以是：</p>
<ul>
<li>对所有参数重新排列</li>
<li>对部分参数进行排列</li>
<li>忽略某些参数</li>
<li>重复某些参数</li>
</ul>
<p>以上操作只改变参数的排列，不能改变参数个数。除此之外，还要求新旧方法句柄的返回类型必须一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPermuteArguments</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(<span class="type">int</span>.class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">compare</span> <span class="operator">=</span> lookup.findStatic(Integer.class, <span class="string">&quot;compare&quot;</span>, methodType);</span><br><span class="line">    <span class="comment">// 3 比 4 小，相比较时返回 -1</span></span><br><span class="line">    assertThat(compare.invoke(<span class="number">3</span>, <span class="number">4</span>)).isEqualTo(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// permute 即改变序列，下述操作将调用时的两个参数交换位置</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">methodHandle</span> <span class="operator">=</span> MethodHandles.permuteArguments(compare, methodType, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 参数会调换位置，因此相当于 invoke(4, 3)，因此返回 1</span></span><br><span class="line">    assertThat(methodHandle.invoke(<span class="number">3</span>, <span class="number">4</span>)).isEqualTo(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 也可以重复参数</span></span><br><span class="line">    methodHandle = MethodHandles.permuteArguments(compare, methodType, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 虽然像是 3 与 4 比较，其实是 4 与 4 比较</span></span><br><span class="line">    assertThat(methodHandle.invoke(<span class="number">3</span>, <span class="number">4</span>)).isEqualTo(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>permuteArguments</code> 共接收三个参数：</p>
<ol>
<li>原始方法句柄</li>
<li>参数重新排列后，新方法句柄的 <code>MethodType</code></li>
<li>表示排列顺序（索引）的整数，这些整数的个数要与原始方法句柄的参数个数相同，整数出现的位置和值表示排列的顺序。比如 <code>permuteArguments(compare, methodType, 1, 0)</code> 表示调用原始方法句柄的第一个参数是调用新方法句柄的第二个参数</li>
</ol>
<p>对一个方法句柄进行 <code>permuteArguments</code> 能得到一个新的方法句柄，在调用新的方法句柄时，按照 <code>permuteArguments</code> 时给定的排列将传入的参数映射到原始方法句柄上，最终执行的还是原始方法句柄引用的方法。</p>
<h2 id="9-6-catchExceptions"><a class="header-anchor" href="#9-6-catchExceptions"></a>9.6 catchExceptions</h2>
<p>使用该方法可以为原始方法句柄指定异常处理的方法句柄。如果原始方法句柄正常调用完成，直接返回调用结果；如果执行过程中抛出了异常，那么进行异常处理的方法句柄就会被调用。</p>
<p>进行异常处理的方法句柄并不是随意指定的：</p>
<ul>
<li>方法句柄的返回值必须和原始方法句柄的返回值相同，在出现异常后，返回值会作为调用的结果；</li>
<li>方法句柄的第一个参数类型必须是所处理的异常类型（或父类），剩余参数与原始方法句柄参数相同。在出现异常后，也能够拿到调用原始方法句柄所使用的参数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CatchException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">handleException</span><span class="params">(Exception e, String str)</span> &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCatchExceptions</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(<span class="type">int</span>.class, String.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">parseInt</span> <span class="operator">=</span> lookup.findStatic(Integer.class, <span class="string">&quot;parseInt&quot;</span>, methodType);</span><br><span class="line">    assertThat(parseInt.invoke(<span class="string">&quot;212&quot;</span>)).isEqualTo(<span class="number">212</span>);</span><br><span class="line">    <span class="comment">// 如果传入 parseInt 的参数不能转换为整型数据，则会抛出异常，使用另一个方法句柄处理这个异常</span></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">handleExceptionMt</span> <span class="operator">=</span> MethodType.methodType(<span class="type">int</span>.class, Exception.class, String.class);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 异常处理的方法句柄也有一定的要求：</span></span><br><span class="line"><span class="comment">     * 1. 该方法的返回值必须与原方法的返回值一样，第一个参数是处理的异常类型，其他参数依次与原方法对应</span></span><br><span class="line"><span class="comment">     * 2. 这里的异常处理方法是成员方法，因此在 invoke 是要首先传入一个对象，而这与原方法的参数列表类型不对应，因此需要使用</span></span><br><span class="line"><span class="comment">     *    bindTo() 方法，如果异常处理方法也是静态方法，则不存在这个问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">handleException</span> <span class="operator">=</span> lookup.findVirtual(CatchException.class, <span class="string">&quot;handleException&quot;</span>, handleExceptionMt)</span><br><span class="line">        .bindTo(<span class="keyword">new</span> <span class="title class_">CatchException</span>());</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">methodHandle</span> <span class="operator">=</span> MethodHandles.catchException(parseInt, NumberFormatException.class, handleException);</span><br><span class="line">    <span class="comment">// 控制台还打印出 java</span></span><br><span class="line">    assertThat(methodHandle.invoke(<span class="string">&quot;java&quot;</span>)).isEqualTo(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果异常处理方法是成员方法，在调用成员方法的方法句柄时，第一个参数需要传入实例对象，这与规定的第一个参数是处理的异常类型不符，因此在定义异常处理的方法句柄时要使用 <code>bindTo()</code> 方法绑定异常处理方法所属的对象。</p>
<h2 id="9-7-guardWithTest"><a class="header-anchor" href="#9-7-guardWithTest"></a>9.7 guardWithTest</h2>
<p><code>guard</code> 意为保护，<code>guardWithTest</code> 表示“带测试的保护”？</p>
<p><code>guardWithTest</code> 的作用类似 <code>if-else</code>，调用该方法时需要提供三个方法句柄：</p>
<ul>
<li>
<p>第一个方法句柄用于条件判断，因此返回值类型 <strong>必须</strong> 是基本类型 <code>boolean</code>，不能是包装类型 <code>Boolean</code>；</p>
</li>
<li>
<p>第二个和第三个方法句柄对应的 <code>MethodType</code> 必须一致，当条件判断的方法句柄返回 <code>true</code> 时，后续将调用第二个方法句柄，反之调用第三个。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGuardWithTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">guardTest</span> <span class="operator">=</span> lookup.findStatic(GuardWithTest.class, <span class="string">&quot;guardTest&quot;</span>,</span><br><span class="line">                                               MethodType.methodType(<span class="type">boolean</span>.class, <span class="type">int</span>.class));</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(<span class="type">int</span>.class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">max</span> <span class="operator">=</span> lookup.findStatic(Math.class, <span class="string">&quot;max&quot;</span>, methodType);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">min</span> <span class="operator">=</span> lookup.findStatic(Math.class, <span class="string">&quot;min&quot;</span>, methodType);</span><br><span class="line">    <span class="comment">// 使用第一个方法句柄进行判断，条件满足时调用 max，反之调用 min</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">test</span> <span class="operator">=</span> guardTest.asType(guardTest.type().changeParameterType(<span class="number">0</span>, Integer.class)).bindTo(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * guardWithTest() 使用细节：</span></span><br><span class="line"><span class="comment">     * 1. 第一个参数的方法句柄必须返回基本类型 boolean，包装类 Boolean 也不行</span></span><br><span class="line"><span class="comment">     * 2. 第二个、第三个方法句柄的类型必须一致</span></span><br><span class="line"><span class="comment">     * 3. 如果第一个方法句柄对应的方法有参数，则需要使用 bindTo() 方法进行绑定，最终 invoke 传入的参数与</span></span><br><span class="line"><span class="comment">     *    第二个、第三个方法句柄的对应的方法参数一致</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    assertThat(MethodHandles.guardWithTest(test, max, min).invoke(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        .isEqualTo(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用新生成的方法句柄时，传入的参数应该与第二个（或第三个，无所谓，反正它们都是一样的）方法句柄所需的参数一致。</p>
<p>如果用于条件判断的方法句柄也需要接收参数，应该提前使用 <code>bindTo()</code> 方法完成参数的绑定。</p>
<h2 id="9-8-filterReturnValue"><a class="header-anchor" href="#9-8-filterReturnValue"></a>9.8 filterReturnValue</h2>
<p>前面几种方法都是对方法句柄的参数的变换，那返回值能进行变换吗？</p>
<p><code>filterReturnValue</code> 接收两个方法句柄，在调用新生成的方法句柄时，传入的参数应当与第一个方法句柄所需的参数一致， 之后使用这些参数来调用第一个方法句柄，返回的结果会作为参数传递给第二个方法句柄并完成最终的调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFilterReturnValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">substringMt</span> <span class="operator">=</span> MethodType.methodType(String.class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">substring</span> <span class="operator">=</span> lookup.findVirtual(String.class, <span class="string">&quot;substring&quot;</span>, substringMt);</span><br><span class="line"></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">toLowerCaseMt</span> <span class="operator">=</span> MethodType.methodType(String.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">toLowerCase</span> <span class="operator">=</span> lookup.findVirtual(String.class, <span class="string">&quot;toUpperCase&quot;</span>, toLowerCaseMt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// substring 执行得到的结果再使用 toLowerCase 执行</span></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">methodHandle</span> <span class="operator">=</span> MethodHandles.filterReturnValue(substring, toLowerCase);</span><br><span class="line">    assertThat(methodHandle.invoke(<span class="string">&quot;hello world&quot;</span>, <span class="number">6</span>, <span class="number">11</span>)).isEqualTo(<span class="string">&quot;WORLD&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-9-invoker"><a class="header-anchor" href="#9-9-invoker"></a>9.9 invoker</h2>
<p>如果需要对多个方法句柄进行相同的变换，除了多次进行相同的变换外，还可以创建一个用来调用其他方法句柄的方法句柄（这样的方法句柄称为“元方法句柄”）， <strong>对元方法句柄的变换会自动应用到元方法句柄调用的方法句柄上。</strong></p>
<p>创建元方法句柄的方式有两种：</p>
<ul>
<li><code>MethodHandles.invoker(MethodType)</code></li>
<li><code>MethodHandles.exactInvoker(MethodType)</code></li>
</ul>
<p>它们都接收一个 <code>MethodType</code> 类型的参数。</p>
<p>对于 <code>invoker()</code> 来说，它创建出的元方法句柄，等价于使用以下方式创建出的方法句柄：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodHandles.publicLookup().findVirtual(MethodHandle.class, <span class="string">&quot;invoke&quot;</span>, type)</span><br></pre></td></tr></table></figure>
<p>那么 <code>exactInvoker()</code> 就等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodHandles.publicLookup().findVirtual(MethodHandle.class, <span class="string">&quot;invokeExact&quot;</span>, type)</span><br></pre></td></tr></table></figure>
<p>这里的 <code>type</code> 是创建元方法句柄时传入的 <code>MethodType</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testExactInvoker</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">typeInvoker</span> <span class="operator">=</span> MethodType.methodType(String.class, String.class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">invoker</span> <span class="operator">=</span> MethodHandles.exactInvoker(typeInvoker);</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">typeFind</span> <span class="operator">=</span> MethodType.methodType(String.class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">substring</span> <span class="operator">=</span> lookup.findVirtual(String.class, <span class="string">&quot;substring&quot;</span>, typeFind);</span><br><span class="line">    assertThat(invoker.invoke(substring, <span class="string">&quot;hello world&quot;</span>, <span class="number">6</span>, <span class="number">11</span>))</span><br><span class="line">        .isEqualTo(substring.invoke(<span class="string">&quot;hello world&quot;</span>, <span class="number">6</span>, <span class="number">11</span>))</span><br><span class="line">        .isEqualTo(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">toUpperCase</span> <span class="operator">=</span> lookup.findVirtual(</span><br><span class="line">        String.class,</span><br><span class="line">        <span class="string">&quot;toUpperCase&quot;</span>,</span><br><span class="line">        MethodType.methodType(String.class)</span><br><span class="line">    );</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">methodHandle</span> <span class="operator">=</span> MethodHandles.filterReturnValue(invoker, toUpperCase);</span><br><span class="line">    <span class="comment">// 对 invoker 创建的 MethodHandle 进行变换后，调用时这些变换会自动应用在传入的 MethodHandle 上</span></span><br><span class="line">    assertThat((String) methodHandle.invokeExact(substring, <span class="string">&quot;hello world&quot;</span>, <span class="number">6</span>, <span class="number">11</span>)).isEqualTo(<span class="string">&quot;WORLD&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="10-使用方法句柄实现接口"><a class="header-anchor" href="#10-使用方法句柄实现接口"></a>10. 使用方法句柄实现接口</h1>
<p>动态代理可以在运行时为接口生成实现类，方法句柄也具备动态实现某个接口的能力。</p>
<p>这需要使用到 <code>java.lang.invoke.MethodHandleProxies#asInterfaceInstance()</code> 方法，该方法接收两个参数：</p>
<ol>
<li><code>Class&lt;T&gt; intfc</code>：目标接口的 <code>Class</code> 对象，这个 <strong>接口必须是函数式接口</strong></li>
<li><code>MethodHandle target</code>：目标接口中唯一抽象方法对应的 <code>MethodHandle</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAsInterfaceInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">methodType</span> <span class="operator">=</span> MethodType.methodType(String.class, Integer.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">convert</span> <span class="operator">=</span> lookup.findVirtual(UseMethodHandleProxies.class, <span class="string">&quot;convert&quot;</span>, methodType);</span><br><span class="line">    <span class="comment">// 成员方法的 MethodHandle 在调用前需要绑定实例对象</span></span><br><span class="line">    convert = convert.bindTo(<span class="keyword">new</span> <span class="title class_">UseMethodHandleProxies</span>());</span><br><span class="line">    Function&lt;Integer, String&gt; function = MethodHandleProxies.asInterfaceInstance(Function.class, convert);</span><br><span class="line">    assertThat(function.apply(<span class="number">3</span>)).isEqualTo(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就说，通过 <code>asInterfaceInstance()</code> 方法能够将任意方法转换成一个函数式接口。</p>
<p>除此之外，还有一种更复杂的方式实现将任意方法转换成一个函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLambdaMetafactory</span><span class="params">()</span> &#123;</span><br><span class="line">    Class&lt;MethodHandles.Lookup&gt; lookupClass = MethodHandles.Lookup.class;</span><br><span class="line">    <span class="comment">// 不进行权限校验、安全检查的 Lookup</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">implLookup</span> <span class="operator">=</span> lookupClass.getDeclaredField(<span class="string">&quot;IMPL_LOOKUP&quot;</span>);</span><br><span class="line">    implLookup.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    MethodHandles.<span class="type">Lookup</span> <span class="variable">lookup</span> <span class="operator">=</span> (MethodHandles.Lookup) implLookup.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">MethodType</span> <span class="variable">coderMt</span> <span class="operator">=</span> MethodType.methodType(<span class="type">byte</span>.class);</span><br><span class="line">    <span class="type">MethodHandle</span> <span class="variable">coder</span> <span class="operator">=</span> lookup.in(String.class).findSpecial(String.class, <span class="string">&quot;coder&quot;</span>, coderMt, String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包装成函数式接口</span></span><br><span class="line">    <span class="type">CallSite</span> <span class="variable">applyAsInt</span> <span class="operator">=</span> LambdaMetafactory.metafactory(</span><br><span class="line">        <span class="comment">// 能够查找到目标方法的 lookup</span></span><br><span class="line">        lookup,</span><br><span class="line">        <span class="comment">// 需要包装成的函数式接口方法名</span></span><br><span class="line">        <span class="string">&quot;applyAsInt&quot;</span>,</span><br><span class="line">        <span class="comment">// 函数式接口对应的 MethodType</span></span><br><span class="line">        MethodType.methodType(ToIntFunction.class),</span><br><span class="line">        <span class="comment">// 函数式接口方法对应的 MethodType</span></span><br><span class="line">        MethodType.methodType(<span class="type">int</span>.class, Object.class),</span><br><span class="line">        <span class="comment">// 目标方法的 MethodHandle</span></span><br><span class="line">        coder,</span><br><span class="line">        <span class="comment">// 调用目标方法时需要的 MethodType（返回值、实例、参数...）</span></span><br><span class="line">        MethodType.methodType(<span class="type">byte</span>.class, String.class)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    ToIntFunction&lt;String&gt; strCoder = (ToIntFunction&lt;String&gt;) applyAsInt.getTarget().invoke();</span><br><span class="line"></span><br><span class="line">    assertThat(strCoder.applyAsInt(<span class="string">&quot;mofan&quot;</span>)).isEqualTo(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mofan212.github.io">默烦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mofan212.github.io/posts/Method-Handle/">https://mofan212.github.io/posts/Method-Handle/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://mofan212.github.io" target="_blank">Mofan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java-Lambda/">Java-Lambda</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/142.png" data-sites="wechat,qq,weibo,facebook,x"></div><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" target="_blank"><img class="post-qr-code-img" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" target="_blank"><img class="post-qr-code-img" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/SpringBoot-Shutdown-Hook/" title="SpringBoot Shutdown Hook"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/141.png" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">SpringBoot Shutdown Hook</div></div><div class="info-2"><div class="info-item-1">介绍了 System.exit() 方法的源码、SpringBoot 优雅停机等内容。</div></div></div></a><a class="pagination-related" href="/posts/Using-Lambda-Expressions-To-Refactor-Backtracking/" title="使用 Lambda 表达式重构成回溯"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/143.png" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">使用 Lambda 表达式重构成回溯</div></div><div class="info-2"><div class="info-item-1">使用 Lambda 表达式为代码重构提供新思路。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/Java-Lambda-Expression-And-Functional-Programming/" title="Lambda 表达式与函数式编程"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/152.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-20</div><div class="info-item-2">Lambda 表达式与函数式编程</div></div><div class="info-2"><div class="info-item-1">本文介绍了 Java 中的闭包与柯里化，浅谈 Lambda 表达式的执行原理。</div></div></div></a><a class="pagination-related" href="/posts/Combinator-Pattern/" title="Combinator Pattern"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/149.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-28</div><div class="info-item-2">Combinator Pattern</div></div><div class="info-2"><div class="info-item-1">本文介绍了如何在 Java 中使用 Combinator Pattern。</div></div></div></a><a class="pagination-related" href="/posts/Lambda-And-Serialization/" title="Lambda 与序列化"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/104.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-04</div><div class="info-item-2">Lambda 与序列化</div></div><div class="info-2"><div class="info-item-1">怎么通过方法引用来获取字段名称、Lambda 表达式的序列化又是什么？</div></div></div></a><a class="pagination-related" href="/posts/The-Basis-Of-Java-Util-Concurrent/" title="JUC 基础知识"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/63.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-28</div><div class="info-item-2">JUC 基础知识</div></div><div class="info-2"><div class="info-item-1">本文主要介绍了 JDK 1.5 引入的 JUC 包的相关知识。</div></div></div></a><a class="pagination-related" href="/posts/Design-Pattern-Mediator-Pattern/" title="【设计模式】中介者模式"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/148.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-03</div><div class="info-item-2">【设计模式】中介者模式</div></div><div class="info-2"><div class="info-item-1">本文主要对 Java 设计模式中的中介者模式进行了介绍。</div></div></div></a><a class="pagination-related" href="/posts/Design-Pattern-Observer-Pattern/" title="【设计模式】观察者模式"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/91.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-11</div><div class="info-item-2">【设计模式】观察者模式</div></div><div class="info-2"><div class="info-item-1">本文对 Java 设计模式中的观察者模式及其实现与应用进行了介绍。</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">默烦</div><div class="author-info-description">彩笔的打怪升级之路...</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">174</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mofan212"><i class="fab fa-github"></i><span>follow me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:cy.mofan@foxmail.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站所有博文均是博主的学习笔记与个人理解。<strong><font style="color:red">除特别注明外，</font>如需转载，请在文章头部醒目处附带原文链接并<a href="./mine/" style="color:#49B1F5;text-decoration:underline">告知我</a></strong>你将转载。😊</br><strong><font style="color:red">严禁未遵循规范的转载。</font></strong>😡</br><strong>死去的评论系统复活啦！欢迎到留言板畅所欲言！</strong>当然也可以使用更高效的<a target="_blank" href="https://space.bilibili.com/23658864/dynamic" style="color:#49B1F5;text-decoration:underline"> 哔哩哔哩私信 </a>或<a href="mailto:cy.mofan@foxmail.com" style="color:#49B1F5;text-decoration:underline" target="_blank">邮箱</a>。 😉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">1. 定义与使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84"><span class="toc-text">1.1 什么是方法句柄</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">1.2 使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%B8%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.3 与反射的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">2. 使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Quick-Start"><span class="toc-text">2.1 Quick Start</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%89%A7%E8%A1%8C-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2.2 执行 Lambda 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">2.3 实现动态代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Lookup"><span class="toc-text">3. Lookup</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%8D%95%E8%AF%8D-Lookup"><span class="toc-text">3.1 单词 Lookup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%88%9B%E5%BB%BA-Lookup"><span class="toc-text">3.2 创建 Lookup</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9E%8B"><span class="toc-text">4. 方法类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.1 构造方法类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%BF%AE%E6%94%B9%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.2 修改方法类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84"><span class="toc-text">5. 获取方法句柄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">5.1 成员方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">5.2 构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">5.3 静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5"><span class="toc-text">5.4 公共字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-text">5.5 私有方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E6%90%AD%E9%85%8D%E5%8F%8D%E5%B0%84"><span class="toc-text">5.6 搭配反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84"><span class="toc-text">5.7 通用的方法句柄</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84"><span class="toc-text">6. 调用方法句柄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-invokeExact"><span class="toc-text">6.1 invokeExact</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-invoke"><span class="toc-text">6.2 invoke</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-invokeWithArguments"><span class="toc-text">6.3 invokeWithArguments</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84"><span class="toc-text">7. 可变参数的方法句柄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-asVarargsCollector"><span class="toc-text">7.1 asVarargsCollector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-asCollector"><span class="toc-text">7.2 asCollector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-asSpreader"><span class="toc-text">7.3 asSpreader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-asFixedArity"><span class="toc-text">7.4 asFixedArity</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="toc-text">8. 参数绑定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%8F%98%E6%8D%A2%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84"><span class="toc-text">9. 变换方法句柄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-dropArguments"><span class="toc-text">9.1 dropArguments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-insertArguments"><span class="toc-text">9.2 insertArguments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-filterArguments"><span class="toc-text">9.3 filterArguments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-foldArguments"><span class="toc-text">9.4 foldArguments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-permuteArguments"><span class="toc-text">9.5 permuteArguments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-catchExceptions"><span class="toc-text">9.6 catchExceptions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7-guardWithTest"><span class="toc-text">9.7 guardWithTest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-8-filterReturnValue"><span class="toc-text">9.8 filterReturnValue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-9-invoker"><span class="toc-text">9.9 invoker</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">10. 使用方法句柄实现接口</span></a></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>Java Lambda Expression</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Lambda-And-Serialization/" title="Lambda 与序列化"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/104.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Lambda 与序列化"></a><div class="content"><a class="title" href="/posts/Lambda-And-Serialization/" title="Lambda 与序列化">Lambda 与序列化</a><time datetime="2022-07-03T16:00:00.000Z" title="发表于 2022-07-04 00:00:00">2022-07-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Reduce-Functions/" title="Reduce Functions"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/137.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Reduce Functions"></a><div class="content"><a class="title" href="/posts/Reduce-Functions/" title="Reduce Functions">Reduce Functions</a><time datetime="2023-08-26T16:00:00.000Z" title="发表于 2023-08-27 00:00:00">2023-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Method-Handle/" title="方法句柄"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/142.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="方法句柄"></a><div class="content"><a class="title" href="/posts/Method-Handle/" title="方法句柄">方法句柄</a><time datetime="2023-10-28T16:00:00.000Z" title="发表于 2023-10-29 00:00:00">2023-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Using-Lambda-Expressions-To-Refactor-Backtracking/" title="使用 Lambda 表达式重构成回溯"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/143.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="使用 Lambda 表达式重构成回溯"></a><div class="content"><a class="title" href="/posts/Using-Lambda-Expressions-To-Refactor-Backtracking/" title="使用 Lambda 表达式重构成回溯">使用 Lambda 表达式重构成回溯</a><time datetime="2023-11-11T16:00:00.000Z" title="发表于 2023-11-12 00:00:00">2023-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Lambda-Expression-And-Functional-Programming/" title="Lambda 表达式与函数式编程"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/152.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Lambda 表达式与函数式编程"></a><div class="content"><a class="title" href="/posts/Java-Lambda-Expression-And-Functional-Programming/" title="Lambda 表达式与函数式编程">Lambda 表达式与函数式编程</a><time datetime="2024-07-19T16:00:00.000Z" title="发表于 2024-07-20 00:00:00">2024-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Lambda-In-Action/" title="Java Lambda In Action"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/159.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Java Lambda In Action"></a><div class="content"><a class="title" href="/posts/Java-Lambda-In-Action/" title="Java Lambda In Action">Java Lambda In Action</a><time datetime="2025-03-18T16:00:00.000Z" title="发表于 2025-03-19 00:00:00">2025-03-19</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Something-About-Blog/" title="博客搭建与维护"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/42.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="博客搭建与维护"/></a><div class="content"><a class="title" href="/posts/Something-About-Blog/" title="博客搭建与维护">博客搭建与维护</a><time datetime="2026-01-24T16:00:00.000Z" title="更新于 2026-01-25 00:00:00">2026-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Memory-Model/" title="Java 内存模型"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/174.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Java 内存模型"/></a><div class="content"><a class="title" href="/posts/Java-Memory-Model/" title="Java 内存模型">Java 内存模型</a><time datetime="2026-01-02T16:00:00.000Z" title="更新于 2026-01-03 00:00:00">2026-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Bytecode-And-Class-Loading/" title="字节码与类加载"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/173.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="字节码与类加载"/></a><div class="content"><a class="title" href="/posts/Java-Bytecode-And-Class-Loading/" title="字节码与类加载">字节码与类加载</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Class-Resource-Loading-In-Java/" title="Java 的类资源加载"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/103.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Java 的类资源加载"/></a><div class="content"><a class="title" href="/posts/Class-Resource-Loading-In-Java/" title="Java 的类资源加载">Java 的类资源加载</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Annotation-And-Reflection/" title="注解、类的加载、反射"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/20.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="注解、类的加载、反射"/></a><div class="content"><a class="title" href="/posts/Annotation-And-Reflection/" title="注解、类的加载、反射">注解、类的加载、反射</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ren-zhi-jue-xing/" title="认知觉醒"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/172.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="认知觉醒"/></a><div class="content"><a class="title" href="/posts/ren-zhi-jue-xing/" title="认知觉醒">认知觉醒</a><time datetime="2025-12-28T16:00:00.000Z" title="更新于 2025-12-29 00:00:00">2025-12-29</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2020 - 2026 By 默烦</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://testingcf.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://testingcf.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://testingcf.jsdelivr.net/npm/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://testingcf.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://testingcf.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://testingcf.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://gcore.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources@master/js/mine.min.js"></script><script src="/js/tip_portal.js"></script><script defer="defer" id="ribbon" src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-show-text" src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Azathoth,Yog-Sothoth,Shub-Niggurath,Nyarlathotep,Cthulhu,Hastur,Abhoth,Ghroth,Tsathoggua,Cthugha,Deep Ones,Dagon,Chaugnar Faugn,Mordiggian,Shoggoth,Old One,Mi-Go,Great Race of Yith,Flying Polyp,Hounds of Tindalos,Dhole" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://testingcf.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'BAFEL7A6K1',
    apiKey: '89fcb5961984c5c054bf04149f345f38',
    indexName: 'mofan212io',
    container: '#docsearch',
    placeholder: '输入关键字进行搜索',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>
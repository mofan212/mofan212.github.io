<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>从 0 开始的 Spring 5.x 学习 | Mofan</title><meta name="author" content="默烦,cy.mofan@foxmail.com"><meta name="copyright" content="默烦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="温故而知新，可以为师矣。不知刷了几遍这个视频，每次都有新的收获，这次刷的时候顺便做了总结笔记，方便下次复习。">
<meta property="og:type" content="article">
<meta property="og:title" content="从 0 开始的 Spring 5.x 学习">
<meta property="og:url" content="https://mofan212.github.io/posts/Learning-Spring-From-0/index.html">
<meta property="og:site_name" content="Mofan">
<meta property="og:description" content="温故而知新，可以为师矣。不知刷了几遍这个视频，每次都有新的收获，这次刷的时候顺便做了总结笔记，方便下次复习。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/61.jpg">
<meta property="article:published_time" content="2020-10-21T16:00:00.000Z">
<meta property="article:modified_time" content="2022-11-09T16:00:00.000Z">
<meta property="article:author" content="默烦">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/61.jpg"><link rel="shortcut icon" href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/favicon.png"><link rel="canonical" href="https://mofan212.github.io/posts/Learning-Spring-From-0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"距离本文上次更新已经过去","messageNext":"天，请注意时效性。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 默烦","link":"链接: ","source":"来源: Mofan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '从 0 开始的 Spring 5.x 学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-10 00:00:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="referrer" content="no-referrer-when-downgrade" /><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/mofan212/blog-static-resources@master/css/myStyle.min.css"><link rel="stylesheet" href="https://cdn.staticfile.net/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css" /><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Mofan" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/mofan212/blog-static-resources/css/fill-left.min.css"/><script src="https://gcore.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">152</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/post_top_img.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Mofan"><span class="site-name">Mofan</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">从 0 开始的 Spring 5.x 学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-21T16:00:00.000Z" title="发表于 2020-10-22 00:00:00">2020-10-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-09T16:00:00.000Z" title="更新于 2022-11-10 00:00:00">2022-11-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring/">Spring</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>91分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="从 0 开始的 Spring 5.x 学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>封面画师：T5-茨舞（微博）     封面ID：84928287_p0</p>
<p>本文参考：2018 黑马程序员 57 期 张阳 Spring 教程 IDEA 版</p>
<h1 id="1-Spring-概述"><a class="header-anchor" href="#1-Spring-概述"></a>1. Spring 概述</h1>
<h2 id="1-1-Spring-是什么"><a class="header-anchor" href="#1-1-Spring-是什么"></a>1.1 Spring 是什么</h2>
<p>Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和AOP（Aspect Ori ented Programming：面向切面编程）为内核，提供了展现层Spring MVC和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。</p>
<h2 id="1-2-Spring-发展概述"><a class="header-anchor" href="#1-2-Spring-发展概述"></a>1.2 Spring 发展概述</h2>
<p>1997 年 IBM 提出了 EJB 的思想</p>
<p>1998 年，SUN 制定开发标准规范 EJB 1.0</p>
<p>1999 年，EJB 1.1 发布</p>
<p>2001 年，EJB 2.0 发布</p>
<p>2003 年，EJB2.1 发布</p>
<p>2006 年，EJB3.0 发布</p>
<p>Rod Johnson (Spring 之父)，著名作者。Rod 在悉尼大学不仅获得了计算机学位，同时还获得了音乐学位。在回到软件开发领域之前，他还获得了音乐学的博士学位。</p>
<p>Expert 0ne-to-0ne J2EE Design and Development (2002) 阐述了 J2EE 使用 EJB 开发设计的优点及解决方案</p>
<p>Expert One-to-0ne J2EE Development without EJB (2004) 阐述了 J2EE 开发不使用 EJB 的解决方式（Spring雏形）</p>
<p>2017年9月份发布了 Spring 的最新版本 Spring 5.0 通用版（GA）</p>
<h2 id="1-3-Spring-的优势"><a class="header-anchor" href="#1-3-Spring-的优势"></a>1.3 Spring 的优势</h2>
<p><strong>方便解耦，简化开发</strong><br>
通过 Spring 提供的 IoC 容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</p>
<p><strong>AOP 编程的支持</strong><br>
通过 Spring 的 AOP 功能，方便进行面向切面的编程，许多不容易用传统 OOP 实现的功能可以通过AOP 轻松应付。</p>
<p><strong>声明式事务的支持</strong><br>
可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。</p>
<p><strong>方便程序的测试</strong><br>
可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。</p>
<p><strong>方便集成各种优秀框架</strong></p>
<p>Spring 可以降低各种框架的使用难度,提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz<br>
等）的直接支持。</p>
<p><strong>降低 JavaEE API 的使用难度</strong></p>
<p>Spring 对 JavaEE API （如 JDBC、JavaMail、 远程调用等）进行了薄薄的封裝层，使这些 API 的使用难度大为降低。</p>
<p><strong>Java 源码是经典学习范例</strong></p>
<p>Spring 的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对 Java 设计模式灵活运用以及对 Java 技术的高深造诣。它的源代码无疑是 Java 技术的最佳实践的范例。</p>
<h2 id="1-4-Spring-的体系结构"><a class="header-anchor" href="#1-4-Spring-的体系结构"></a>1.4 Spring 的体系结构</h2>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/spring-overview.png" alt="spring-overview"></p>
<h1 id="2-程序的耦合"><a class="header-anchor" href="#2-程序的耦合"></a>2. 程序的耦合</h1>
<h2 id="2-1-耦合与解耦的分析"><a class="header-anchor" href="#2-1-耦合与解耦的分析"></a>2.1 耦合与解耦的分析</h2>
<blockquote>
<p>耦合的测试</p>
</blockquote>
<p>创建一个 Maven 项目导入对应的 mysql 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写以下测试代码进行测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// 1. 注册驱动</span></span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">com</span>.mysql.cj.jdbc.Driver());</span><br><span class="line">        <span class="comment">// 2. 获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/ssm?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&amp;serverTimezone=GMT%2B8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 获取操作数据库的预处理对象‘</span></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pstm</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;select * from account&quot;</span>);</span><br><span class="line">        <span class="comment">// 4. 执行SQL，得到结果集</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> pstm.executeQuery();</span><br><span class="line">        <span class="comment">// 5. 遍历结果集</span></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            System.out.println(resultSet.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6. 释放资源</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        pstm.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据库中对应的 account 表：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/account%E8%A1%A8.png" alt="account表"></p>
<p>运行后测试结果：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/account%E8%A1%A8%E6%9F%A5%E8%AF%A2name%E7%BB%93%E6%9E%9C.png" alt="account表查询name结果"></p>
<hr>
<p>如果 IDEA 在运行时出现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntelliJ IDEA 源值<span class="number">1.5</span>已过时，将在未来所有版本中删除</span><br></pre></td></tr></table></figure>
<p>进入 Project Structure 修改：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/%E4%BF%AE%E6%94%B9ProjectStructure.png" alt="修改ProjectStructure"></p>
<p>然后前往 pom.xml 中添加：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>得到运行结果后我们有这样的一个思考：上述代码中存在一个驱动类 <code>com.mysql.cj.jdbc.Driver()</code>，如果在 pom.xml 中对导入的依赖进行注释，再次运行代码，控制台会直接在代码编译的时候就报错（依赖注释后，驱动类已经不存在，因此在编译期报错）。</p>
<p>我们的类依赖了数据库的具体驱动类（MySQL），如果这时候更换了数据库品牌（比如 Oracle），需要修改源码来重新数据库驱动。这显然不是我们想要的。</p>
<p>这就是<strong>程序的一种耦合</strong> ，所谓耦合就是程序间的依赖关系。这包括：<strong>类之间的依赖、方法间的依赖</strong>。有些耦合可以降低，但是有些耦合无法降低，就像上文代码中的 mysql 依赖一样，如果去除会直接报错。我们应当想方设法降低耦合。</p>
<p>而解耦，就是降低程序间的依赖关系。还有一点很重要：耦合只能降低，不能被消除（有点类似物理中的误差）。</p>
<p>在实际开发中，我们应该做到：<strong>编译期不依赖，运行时才依赖</strong>。</p>
<p>在最初学习 JDBC 时，我们并不是像上文那样注册驱动的，而是采用反射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这样注册驱动有一个好处，是根据字符串来注册的，不像最开始通过一个类进行注册。</p>
<p>如果这个时候我们将 pom.xml 中导入的 mysql 依赖注释，并再次运行代码：程序依然无法跑通，但是并没有在编译期报错，而是运行时出现了一个异常 <code>ClassNotFoundException</code>。</p>
<p>同时，也产生了一个新的问题，mysql 驱动的全限定类名字符串是在 java 类中写死的，一旦要改还是要修改源码。解决这个问题也很简单， <strong>使用配置文件配置</strong>。</p>
<blockquote>
<p>解耦的思路</p>
</blockquote>
<p>通过上面的代码和分析，我们不难得到解耦的思路：</p>
<p>1、通过反射来创建对象，而避免使用 <code>new</code> 关键词</p>
<p>2、通过读取配置文件来获取要创建对象的全限定类名</p>
<h2 id="2-2-代码问题分析"><a class="header-anchor" href="#2-2-代码问题分析"></a>2.2 代码问题分析</h2>
<p>在一个 Web 项目中，通常有这样三层：表现层、业务层、持久层。我们从后层向前书写，那么则有：</p>
<p>持久层接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IAccountDao</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟保存账户</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>持久层实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/15</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 账户的持久层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">IAccountDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存了账户...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>业务层接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IAccountService</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟保存账户</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>业务层实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IAccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">IAccountDao</span> <span class="variable">accountDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountDaoImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模拟表现层调用业务层：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/15</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 模拟一个表现层，用于调用业务层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IAccountService</span> <span class="variable">as</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountServiceImpl</span>();</span><br><span class="line">        as.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码后，控制台会打印出：保存了账户…</p>
<p>但是在上述代码中，我们使用了大量的 <code>new</code> 关键词。如果删除某个实现类，再运行代码，也和最初测试 JDBC 一样，会在编译时就报错，而这就是类之间依赖的耦合。</p>
<h2 id="2-3-工厂模式解耦"><a class="header-anchor" href="#2-3-工厂模式解耦"></a>2.3 工厂模式解耦</h2>
<blockquote>
<p>概念介绍</p>
</blockquote>
<p>在开始进入本节主要内容之前，我们得先明白几个概念：</p>
<p><code>Bean</code>：在计算机英语中，<code>Bean</code> 有可重用组件的含义。</p>
<p>我们以前还接触了一个概念，叫 <code>JavaBean</code>，当时对其的理解就是实体类。实则非也，<code>JavaBean</code> 表示用 <code>Java</code> 语言创建的可重用组件。因此，<code>JavaBean</code> 并不等于实体类。</p>
<p>在 Web 项目中，像 <code>xxxService</code> 或者 <code>xxxDao</code> 都是可以重用的，因此我们不难想到创建一个类，这个类名为 <code>BeanFactory</code>，这个类就是创建 service 和 dao 对象的工厂。</p>
<p>那么如何创建呢？</p>
<p>1、需要一个配置文件来配置我们的 service 和 dao。配置的内容：唯一标识符 = 全限定类名 （类似于 key = value）。</p>
<p>2、通过反射读取配置文件中的配置内容，反射创建对象。配置文件可以是 xml 也可以是 properties。</p>
<blockquote>
<p>具体实现</p>
</blockquote>
<p>为了简单起见，我们编写一个 <code>bean.properties</code> 文件来保存配置文件信息，其内容如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">accountService</span> = <span class="string">com.yang.service.impl.AccountServiceImpl</span></span><br><span class="line"><span class="attr">accountDao</span> = <span class="string">com.yang.dao.impl.AccountDaoImpl</span></span><br></pre></td></tr></table></figure>
<p>然后完善 <code>BeanFactory</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个 Properties 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用静态代码块为 Properties 对象赋值</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化对象</span></span><br><span class="line">            properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            <span class="comment">// 获取 Properties 文件的流对象</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> BeanFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;bean.properties&quot;</span>);</span><br><span class="line">            properties.load(in);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionInInitializerError</span>(<span class="string">&quot;初始化 properties 失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据Bean的名称获取Bean对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">beanPath</span> <span class="operator">=</span> properties.getProperty(beanName);</span><br><span class="line">            System.out.println(beanPath);</span><br><span class="line">            <span class="comment">// 每次都会调用默认构造函数创建对象</span></span><br><span class="line">            bean = Class.forName(beanPath).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们需要改写前面编写的业务层和表现层代码，改写业务层实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IAccountService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private IAccountDao accountDao = new AccountDaoImpl();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">IAccountDao</span> <span class="variable">accountDao</span> <span class="operator">=</span> ((IAccountDao) BeanFactory.getBean(<span class="string">&quot;accountDao&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改写模拟的表现层：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        IAccountService as = new AccountServiceImpl();</span></span><br><span class="line">        <span class="type">IAccountService</span> <span class="variable">as</span> <span class="operator">=</span> (IAccountService) BeanFactory.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">        as.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后运行代码，运行结果如下：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/%E5%B7%A5%E7%A8%8B%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%80%A6%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="工程模式解耦运行结果"></p>
<p>通过上面的运行结果与最初的运行结果比较，我们发现并无差异。</p>
<p>那这真的做到了解耦吗？</p>
<p>我们可以删除某个实现类，比如：<code>AccountServiceImpl</code> 或 <code>AccountDaoImpl</code>，然后再运行代码，虽然控制台依旧无法正常打印出结果，但是并没有在编译期报错，而是运行后抛出 <code>ClassNotFoundException</code> 的异常。</p>
<p>很显然，我们通过上面的工厂模式实现了解耦。 😎</p>
<h2 id="2-4-存在的问题与改进"><a class="header-anchor" href="#2-4-存在的问题与改进"></a>2.4 存在的问题与改进</h2>
<p>通过 2.3 的分析，我们已经利用工厂模式实现了解耦，但仍然存在可以优化的地方。</p>
<p>我们改写一下模拟的表现层，利用 <code>for</code> 循环，打印 <code>IAccountService</code> 对象，同时注释 <code>BeanFactory</code> 类中 <code>getBean()</code> 方法打印 <code>beanPath</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">IAccountService</span> <span class="variable">as</span> <span class="operator">=</span> (IAccountService) BeanFactory.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">        System.out.println(as);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//        as.saveAccount();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出如下：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/%E5%8F%8D%E5%B0%84%E8%A7%A3%E8%80%A6%E5%88%9B%E5%BB%BA%E7%9A%84%E5%A4%9A%E4%BE%8B%E5%AF%B9%E8%B1%A1.png" alt="反射解耦创建的多例对象"></p>
<p>从打印结果我们可以看出，每个 <code>IAccountServiceImpl</code> 对象都不相同，简单来说就是实例化的 <code>IAccountServiceImpl</code> 对象是多例的，而非单例的。</p>
<p>我们再改造一下 <code>AccountServiceImpl</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IAccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">IAccountDao</span> <span class="variable">accountDao</span> <span class="operator">=</span> ((IAccountDao) BeanFactory.getBean(<span class="string">&quot;accountDao&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        accountDao.saveAccount();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再进入模拟的表现层在 <code>for</code> 循环中调用 <code>saveAccount()</code> 并运行，控制台输出如下：</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/多例对象输出结果.png" alt="多例对象输出结果" style="zoom:67%;" />
<p>我们知道类中的方法可以操作类中的成员变量，并可以改变成员变量的值。由于实例化的对象是多例的，每个对象都有一个独立的实例，从而保证了类对象在创建时重新初始化类中的属性（成员变量），因此成员变量 <code>i</code> 一直都输出 1，就算是 <code>i++</code> 后也不会增加 <code>i</code> 的值。</p>
<p>但如果实例化的对象是单例的，对象只会被创建一次，从而类中的成员变量也只会被初始化一次。</p>
<p>在多个线程或多个对象访问单例对象成员变量的值，就会引起值的改变，而对于多例对象就不会出现这样的问题。不过反过来想，多例对象会被创建多次，那么执行效率会没有单例对象高。</p>
<p><strong>在 Web 项目的 service 和 dao 中不存在类中成员变量会被类中的方法调整的情况，也不会有线程安全问题，因此在 Web 项目中使用单例的对象更好，可以提高效率。</strong></p>
<p>实例化的对象是多例的主要原因是在反射创建对象是调用了 <code>newInstance()</code> 方法，调用这个方法后每次都会调用默认构造函数创建对象，因此实例化的对象是多例的。</p>
<p>如果想让创建的 Bean 对象是单例的，我们只能调用 <code>newInstance()</code> 一次，同时还要将创建的对象存入容器中。因为不存入容器中，且长时间不使用这个对象时，由于 Java 的垃圾回收机制，这个对象会被回收，等到下次还想用时，原本创建的对象就不存在了。</p>
<p>这个我知道，那再创建一个对象呗。</p>
<p>创建个 🔨，如果再创建一个不就是多例的了，合着我前面都白讲了？ 😡</p>
<p>那怎么存这个对象？或者说用什么容器存？</p>
<p>前面说了配置文件中存在一个唯一标识符，且一个唯一标识符对应一个全限定类名，这是一种 key-value 形式，那很显然，我们可以使用 <code>Map</code> 来存这个对象。</p>
<p>那对象在什么时候创建？</p>
<p>由于对象要是单例的，那么在静态代码块中读取配置文件后，就可以创建对象了，并将对象存入容器中。</p>
<p>最终修改 <code>BeanFactory</code> 类，得到以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个 Properties 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="comment">// 定义一个 Map，用于存放我们要创建的对象，我们把它称之为容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; beans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用静态代码块为 Properties 对象赋值</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化对象</span></span><br><span class="line">            properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            <span class="comment">// 获取 Properties 文件的流对象</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> BeanFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;bean.properties&quot;</span>);</span><br><span class="line">            properties.load(in);</span><br><span class="line">            <span class="comment">// 实例化容器</span></span><br><span class="line">            beans = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 取出配置文件中所有的 key</span></span><br><span class="line">            Enumeration&lt;Object&gt; keys = properties.keys();</span><br><span class="line">            <span class="comment">// 遍历枚举</span></span><br><span class="line">            <span class="keyword">while</span> (keys.hasMoreElements()) &#123;</span><br><span class="line">                <span class="comment">// 取出每个 key</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keys.nextElement().toString();</span><br><span class="line">                <span class="comment">// 根据 key 获取 value</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">beanPath</span> <span class="operator">=</span> properties.getProperty(key);</span><br><span class="line">                <span class="comment">// 反射创建对象</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> Class.forName(beanPath).newInstance();</span><br><span class="line">                <span class="comment">// 把 key 和 value 存入容器</span></span><br><span class="line">                beans.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionInInitializerError</span>(<span class="string">&quot;初始化 properties 失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 bean 的名称获取对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beans.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后其他代码不变，进入模拟的表现层运行 <code>main()</code> 方法，控制台输出如下：</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/单例对象输出结果.png" alt="单例对象输出结果" style="zoom:67%;" />
<p>从输出结果我们看到创建的 <code>IAccountServiceImpl</code> 对象是单例的，只创建了一个 <code>IAccountServiceImpl</code> 对象，并且随着循环的执行，输出的 <code>i</code> 值也逐渐增加，这也验证了创建的对象是单例的。</p>
<p>到此，我们不仅实现了利用工厂模式解耦，还让我们利用反射创建的对象是单例的，在 Web 项目中拥有更高的执行效率。</p>
<h2 id="2-5-控制反转-IoC"><a class="header-anchor" href="#2-5-控制反转-IoC"></a>2.5 控制反转 - IoC</h2>
<p>前文中叙述了利用工厂模式实现解耦，但还是没解释什么是工厂。</p>
<p>工厂就是负责从容器中获取指定对象的类，而这时候我们获取对象的方式发生了改变。</p>
<p>在没使用工厂时，我们采用这种方式创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">IAccountDao</span> <span class="variable">accountDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountDaoImpl</span>();</span><br></pre></td></tr></table></figure>
<p>这种方式获取对象时，采用 <code>new</code> 的方式，是<mark>主动</mark>的。</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/使用new创建对象.png" alt="使用new创建对象" style="zoom: 67%;" />
<p>使用这种方式，APP 或者说应用跟资源存在必然的联系，并且这种联系是无法相处的。如果我们想要 APP 或资源独立，就很难做到，因为应用和资源之间有必然的联系。</p>
<p>当我们使用工厂来获取对象时，使用这种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">IAccountDao</span> <span class="variable">accountDao</span> <span class="operator">=</span> ((IAccountDao) BeanFactory.getBean(<span class="string">&quot;accountDao&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>这种方式获取对象时，就会向工厂要，有工厂为我们查找或者创建对象，是<mark>被动</mark>的。</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/工厂查找或创建对象.png" alt="工厂查找或创建对象" style="zoom:67%;" />
<p>使用这种方式查找或创建对象时，APP（应用）与资源之间的联系就断开了，而是找工厂要资源，工厂负责跟资源取得联系，并把 APP（应用）想要的资源给它。</p>
<p>这种被动获取对象的思想就是<strong>控制反转</strong>，它是 Spring 框架的核心之一。</p>
<p><strong>控制反转</strong>（Inversion of Control，缩写为<strong>IoC</strong>），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度，这种方式把创建对象的权利交给了框架，是框架的重要特性，并非面向对象编程的专用术语。其中最常见的方式叫做<strong>依赖注入</strong>（Dependency Injection，简称<strong>DI</strong>），还有一种方式叫“依赖查找”（Dependency Lookup）。</p>
<blockquote>
<p>那这为什么叫做控制反转而不叫降低依赖呢？</p>
</blockquote>
<p>最开始使用 <code>new</code> 关键词来创建对象时，会明确指定需要的那个资源（类），可以自己自主找到需要的资源。而后我们放弃使用这种方式来获取资源，使用工厂来查询或创建资源，工厂会利用一个指定的名称来找到某个资源，但这个资源是否可用、是否是我们想要的，就无从得知了，这是根据指定的名称由工厂获取的。</p>
<p>最开始的方式有自主获取资源的权利，想要谁就要谁，<code>new</code> 一下就行了，后面的方式就不同了，没有了自主获取资源的权利，而是利用指定的名称由工厂获取，控制权交给了工厂，控制发生了反转，因此就叫做控制反转，控制反转可以降低程序之间的耦合。</p>
<p>明确 IoC 的作用： 削减计算机程序的耦合（解除我们代码中的依赖关系）。</p>
<p>在实际开发过程中，我们可以自己编写利用工厂获取资源的代码，但是这种底层代码过于繁琐，经常书写会很麻烦，这个时候 Spring 就出现了，利用这个框架就可以实现 IoC。</p>
<h1 id="3-Spring-与-IoC"><a class="header-anchor" href="#3-Spring-与-IoC"></a>3. Spring 与 IoC</h1>
<h2 id="3-1-使用-Spring-创建对象"><a class="header-anchor" href="#3-1-使用-Spring-创建对象"></a>3.1 使用 Spring 创建对象</h2>
<p>在前文中代码的基础上使用 Spring 来创建对象，<code>IAccountDao</code> 和 <code>IAccountService</code> 接口不变，<code>AccountDaoImpl</code> 实现类也不进行修改，将 <code>IAccountService</code> 的实现类 <code>AccountServiceImpl</code> 进行如下修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IAccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">IAccountDao</span> <span class="variable">accountDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountDaoImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最重要的是需要在我们创建的 Maven 项目中导入 Spring 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>并在 resources 目录下创建 Spring 的配置文件，假设取名为 <code>bean.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--把对象的创建交给spring管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yang.service.impl.AccountServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yang.dao.impl.AccountDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后修改 <code>Client</code> 类并运行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟一个表现层，用于调用业务层</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 获取 Spring 的 IoC 容器，并根据 id 获取对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取核心容器对象</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 根据 id 获取对象</span></span><br><span class="line">        <span class="type">IAccountService</span> <span class="variable">as</span> <span class="operator">=</span> (IAccountService) ac.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">        <span class="type">IAccountDao</span> <span class="variable">adao</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;accountDao&quot;</span>, IAccountDao.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(as);</span><br><span class="line">        System.out.println(adao);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出结果如下：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/%E4%BD%BF%E7%94%A8Spring%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.png" alt="使用Spring创建对象"></p>
<p>从控制台的输出结果可以看出，我们使用 Spring 成功创建了对象。🎉</p>
<h2 id="3-2-ApplicationContext"><a class="header-anchor" href="#3-2-ApplicationContext"></a>3.2 ApplicationContext</h2>
<blockquote>
<p>ApplicationContext 三个常用的实现类</p>
</blockquote>
<p>1、<code>ClassPathXmlApplicationContext</code>：它可以加载类路径下的配置文件，要求配置文件必须在类路径下。如果不在，当然就加载不了（相比于第二个实现类，这个更常用）。</p>
<p>2、<code>FileSystemXmlApplicationContext</code>：它可以加载磁盘任意路径下的配置文件（必须有访问权限）</p>
<p>3、<code>AnnotationConfigApplicationContext</code>：它用于读取注解来创建容器</p>
<blockquote>
<p>ApplicationContext 与 BeanFactory</p>
</blockquote>
<p>我们选中 <code>ApplicationContext</code> 后，在 IDEA 中右击它，选中 Diagrams ，再点击 Show Diagram… 可得以下类图：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/ApplicationContext%E7%9A%84%E7%B1%BB%E5%9B%BE.png" alt="ApplicationContext的类图"></p>
<p>可以看出 <code>ApplicationContext</code> 确实是个借口，但并不是最底层借口，它还继承了 <code>BeanFactory</code> 接口。</p>
<p>那么这两个接口有啥区别呢？</p>
<p><code>ApplicationContext</code>：它在创建核心容器时，创建对象采取的策略是 <mark>立即加载</mark> 的方式。也就是说，只要一读取完配置文件就会马上创建配置文件中配置的对象（单例对象适用）。</p>
<p><code>BeanFactory</code>：它在构建核心容器时，创建对象采取的策略是 <mark>延迟加载</mark> 的方式。也就是说，什么时候根据 id 获取对象了，什么时候才真正创建对象（多例对象适用）。</p>
<p>那么问题来了，既然有这两个接口，我们实际使用时采取哪个居多呢？</p>
<p>前文中说，我们创建的对象都是单例的，既然如此，哪什么时候创建更好？</p>
<p>不用多说，显然是读取完配置文件就创建对象，即采用 <code>ApplicationContext</code> 接口创建。同时，<code>BeanFactory</code> 作为一个顶层接口，它里面的抽象方法显然不如其子类 <code>ApplicationContext</code> 完善的，因此，<code>ApplicationContext</code> 更加常用。</p>
<h2 id="3-3-Spring-中-Bean-的细节"><a class="header-anchor" href="#3-3-Spring-中-Bean-的细节"></a>3.3 Spring 中 Bean 的细节</h2>
<blockquote>
<p>三种创建 Bean 的方式</p>
</blockquote>
<p>1、使用<strong>默认构造函数</strong>创建 Bean</p>
<p>在 Spring 配置文件中使用 <code>&lt;bean&gt;</code> 标签，配以 id 和 class 属性后，且没有其他属性和标签时，采用的就是默认构造函数创建 Bean 对象。</p>
<p>如果类中没有默认构造函数，则对象无法创建。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yang.service.impl.AccountServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、使用<strong>普通工厂中的方法</strong>创建对象（使用某个类的方法创建对象，并存入 Spring 容器）</p>
<p>工厂类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/19</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 模拟一个工厂类（工厂创建的类可能是存在 jar 包中的，我们无法通过修改源码的方式来提供默认构造函数）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IAccountService <span class="title function_">getAccountService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 假设 AccountServiceImpl 类是存在 jar 包中的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AccountServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;instanceFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yang.factory.InstanceFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;instanceFactory&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">factory-method</span>=<span class="string">&quot;getAccountService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3、使用<strong>工厂中的静态方法</strong>创建对象（使用某个类中的静态方法创建对象，并存入 Spring 容器）</p>
<p>工厂类与静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟一个工厂类（工厂创建的类存在 jar 包中的，我们无法通过修改源码的方式来提供默认构造函数）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IAccountService <span class="title function_">getAccountService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 假设 AccountServiceImpl 类是存在 jar 包中的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AccountServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yang.factory.StaticFactory&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">factory-method</span>=<span class="string">&quot;getAccountService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Bean 对象的作用范围</p>
</blockquote>
<p>Spring 中创建的 Bean 对象默认是单例的。那么我们应该怎么调整 Bean 的左右范围呢？</p>
<p>可以使用 <code>&lt;bean&gt;</code> 标签中的 <code>scope</code> 属性。这个属性用于指定 Bean 的作用范围，它有如下取值：</p>
<ul>
<li>singleton：单例（默认值）</li>
<li>prototype：多例</li>
<li>request：作用于 Web 应用的请求范围</li>
<li>session：作用于 Web 应用的会话范围</li>
<li><s>global-session：作用于集群环境的会话范围（全局会话范围），如果当前环境不是集群环境，效果等于 <code>session</code>（涉及负载均衡、集群等知识点）</s></li>
<li>application：作用于 Web 应用的 <code>ServletContext</code>。Web 容器用到此 Bean 时创建，容器关闭时销毁</li>
</ul>
<blockquote>
<p>Bean 对象的生命周期</p>
</blockquote>
<p>首先得明白一点：单例对象和多例对象的生命周期肯定是不一样的。</p>
<p>对单例对象来说：当容器创建时，对象出生；只要容器还在，对象一直活着；如果容器销毁，对象就死亡了。</p>
<p>总结：单例对象的生命周期和容器相同。</p>
<p>对多例对象来说：当我们使用对象时，Spring 框架为我们创建；对象只要是在使用过程中就一直活着；当对象长时间不用且没有别的对象引用时，由 Java 的垃圾回收器回收。</p>
<h2 id="3-4-依赖注入"><a class="header-anchor" href="#3-4-依赖注入"></a>3.4 依赖注入</h2>
<blockquote>
<p>基本概念</p>
</blockquote>
<p>依赖注入：Dependency Injection。它是 Spring 框架核心 IoC 的具体实现。</p>
<p>我们知道 IoC 的作用是：降低程序间的依赖关系，或者说降低程序间的依赖关系。</p>
<p>同时将依赖关系的管理都交给 Spring 来维护，在当前类需要用到其他类的对象时，由 Spring 为我们提供，我们只需要在配置文件中说明即可。</p>
<p>这种依赖关系的维护就称之为：依赖注入。</p>
<p>依赖注入能够注入的数据有三类，分别是：基本数据类型和 <code>String</code>、其他 Bean 类型（在配置文件中或者注解配置过的 Bean），复杂类型 / 集合类型。</p>
<p>依赖注入的方式也有三种，分别是：使用构造函数提供、使用 set 方法提供，使用注解提供。</p>
<blockquote>
<p>构造函数注入</p>
</blockquote>
<p>使用构造函数注入时，需要在 <code>&lt;bean&gt;</code> 标签内部使用一个新的标签 <code>&lt;constructor-arg&gt;</code>。</p>
<p>这个标签中有以下几个属性：</p>
<ul>
<li>type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型</li>
<li>index：用于指定要注入的数据在构造函数中参数的索引，索引的位置从 0 开始</li>
<li>name：用于指定要注入的数据在构造函数中参数的名称</li>
</ul>
<p>PS：以上三个属性用于指定给构造函数中哪个参数进行赋值，下面两个指的是赋什么值</p>
<ul>
<li>value：用于赋值基本数据类型和 <code>String</code> 类型的数据</li>
<li>ref：用于赋值其他 Bean 类型，也就是说，必须得是在配置文件中配置过的 Bean</li>
</ul>
<p>特点：在获取 Bean 对象时，注入的数据是必须的操作，否则对象无法创建成功。</p>
<p>弊端：改变了 Bean 对象的实例化方式，使我们在创建对象时，如果用不到某些数据时，也必须提供（注入）。</p>
<blockquote>
<p>set 方法注入</p>
</blockquote>
<p>使用 set 方法注入时，要求被注入的属性必须有 set 方法，set 方法的方法名由 set + 属性首字母大写，如果属性是 <code>boolean</code> 类型就没有 set 方法 , 是 is。（尽量使用 IDEA 的自动生成，还需注意命名规范）</p>
<p>使用 set 方法注入时，需要在 <code>&lt;bean&gt;</code> 标签内部使用一个新标签 <code>&lt;property&gt;</code>。</p>
<p>这个标签有以下几个属性：</p>
<ul>
<li>name：用于指定注入时所调用的 set 方法名称</li>
<li>value：用于赋值基本数据类型和 <code>String</code> 类型的数据</li>
<li>ref：用于赋值其他 Bean 类型，也就是说，必须得是在配置文件中配置过的 Bean</li>
</ul>
<p>特点：创建对象时没有明确的限制，可以直接使用默认构造函数。</p>
<p>弊端：如果有某个成员必须有值，获取对象的 set 方法可能没有执行（可能没有 set 方法）。</p>
<blockquote>
<p>注入集合数据</p>
</blockquote>
<p>假设我们依旧采用 set 方法注入集合数据，那么可以像下面的代码一样进行数据注入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--复杂类型注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yang.service.impl.AccountServiceImpl3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myStrs&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mySet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;TestA&quot;</span> <span class="attr">value</span>=<span class="string">&quot;aaa&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;TestB&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myProps&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;TestC&quot;</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;TestD&quot;</span>&gt;</span>DDD<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看到，用于给 List 结构集合注入的标签有 <code>&lt;array&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;set&gt;</code>，用于给 Map 结构集合注入的标签有 <code>&lt;map&gt;</code> 和 <code>&lt;props&gt;</code>，结构相同，标签可以互换。也就是说，注入数组时，除了可以使用<code>&lt;array&gt;</code>，可以使用 <code>&lt;list&gt;</code> 和 <code>&lt;set&gt;</code>。</p>
<p>PS：注意 Set 集合内的数据是无序的。</p>
<h2 id="3-5-IoC-相关注解"><a class="header-anchor" href="#3-5-IoC-相关注解"></a>3.5 IoC 相关注解</h2>
<p>见【Spring 注解】一文。</p>
<h2 id="3-6-整合-JUnit5"><a class="header-anchor" href="#3-6-整合-JUnit5"></a>3.6 整合 JUnit5</h2>
<p>我们知道，应用程序的入口是 <code>main()</code> 方法。但是在 JUnit 单元测试中，没有 <code>main()</code> 也可以执行，这是因为 JUnit 集成了一个 <code>main()</code> 方法，该方法会判断当前测试类中哪些方法有 <code>@Test</code> 注解，JUnit 会让有 <code>@Test</code> 注解的方法执行。</p>
<p>同时，JUnit 不会关心我们是否使用了某个框架（比如 Spring 框架），在执行测试方法时，JUnit 根本不知道我们是否使用了 Spring 框架，所以也就不会为我们读取配置文件 / 配置类创建 Spring 核心容器。</p>
<p>综上可知，当测试方法执行时，是没有 IoC 容器的。因此就算写了 <code>@Autowired</code> 注解，也是无法实现注入的（容器都没有，注入个 🔨）。</p>
<p>那咋搞？Spring 怎么整合 JUnit 呢？</p>
<blockquote>
<p>Spring 整合 JUnit 的配置</p>
</blockquote>
<p>1、导入 Spring 整合 JUnit 的依赖和 JUnit5 的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>版本号与导入的 Spring 依赖一致<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、使用 JUnit5 提供了一个注解 <code>@ExtendWith</code> 把原有的 <code>main()</code> 方法替换成 Spring 提供的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceTest</span> &#123;&#125; <span class="comment">// 测试类</span></span><br></pre></td></tr></table></figure>
<p>3、告知 Spring 的运行器，Spring 和 IoC 创建是基于 xml 的还是注解的，并说明位置</p>
<p>这里需要用到另外一个注解 <code>@ContextConfiguration</code>。</p>
<p>这个注解有两个主要属性：</p>
<ul>
<li>locations：指定 xml 文件的位置，加上 classpath 关键字，表示在类路径下</li>
<li>classes：指定注解类所在的位置</li>
</ul>
<p><mark>注意：</mark> 当使用 Spring 5.x 版本时，要求 JUnit 的版本是在 4.12 及以上。</p>
<p>测试类及部分测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用junit单元测试：测试我们的配置</span></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &quot;classpath:bean.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">IAccountService</span> <span class="variable">as</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Account&gt; accounts = as.findAllAccount();</span><br><span class="line">        <span class="keyword">for</span> (Account account:accounts)&#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-动态代理"><a class="header-anchor" href="#4-动态代理"></a>4. 动态代理</h1>
<p>动态代理的特点是字节码使用的时候才创建，使用的时候才加载。使用动态代理可以在不修改源码的基础上对方法进行增强。</p>
<p>动态代理有两种：</p>
<ul>
<li>基于接口的动态代理</li>
<li>基于子类的动态代理</li>
</ul>
<h2 id="4-1-基于接口的动态代理"><a class="header-anchor" href="#4-1-基于接口的动态代理"></a>4.1 基于接口的动态代理</h2>
<p>涉及到的类：<code>Proxy</code>，提供者：JDK 官方</p>
<p>那么如何创建代理对象？使用 <code>Proxy</code> 类的 <code>newProxyInstance()</code> 方法</p>
<p><mark>创建代理对象有什么要求？</mark> 被代理类至少实现一个接口，否则不能使用</p>
<p><code>newProxyInstance()</code> 方法的参数：</p>
<ul>
<li>ClassLoader：类加载器，用于加载代理对象的字节码。需要和被代理对象使用相同的类加载器。固定写法。</li>
<li>Class[]：字节码数组，用于让代理对象和被代理对象有相同的方法。固定写法。</li>
<li>InvocationHandler：用于提供增强的代码。它是让我们写如何代理，我们一般都是写一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。此接口的实现类都是谁用谁写。</li>
</ul>
<blockquote>
<p>代码测试</p>
</blockquote>
<p>我们来模拟一个场景：生产厂家生产东西，并交给经销商卖出，消费者从经销商处购买商品。经销商也要吃饭，因此他要收取卖出商品得到的金额的 20% 作为利润，最后生产厂家只能拿到卖出金额的 80%。</p>
<p>对生产厂家要求的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/20</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对生产厂家要求的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saleProduct</span><span class="params">(<span class="type">float</span> money)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterService</span><span class="params">(<span class="type">float</span> money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产厂家：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/20</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 生产厂家</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">IProducer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saleProduct</span><span class="params">(<span class="type">float</span> money)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销售商品，并拿到钱 &quot;</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterService</span><span class="params">(<span class="type">float</span> money)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提供售后服务，并拿到钱 &quot;</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模拟消费者消费，控制台打印生产厂家从经销商处获取的金额：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/20</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 模拟一个消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">IProducer</span> <span class="variable">proxyProducer</span> <span class="operator">=</span> (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),</span><br><span class="line">                producer.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 执行被代理对象的任何接口方法都会经过该方法</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> proxy    代理对象的引用</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method   当前执行的方法</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> args     当前执行方法所需的参数</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span> 和被代理对象有相同的返回值</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">// 提供增强的代码</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 1. 获取方法执行的参数</span></span><br><span class="line">                        <span class="type">Float</span> <span class="variable">money</span> <span class="operator">=</span> (Float) args[<span class="number">0</span>];</span><br><span class="line">                        <span class="comment">// 2. 判断当前方法是不是销售</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;saleProduct&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">                            returnValue = method.invoke(producer, money * <span class="number">0.8f</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        proxyProducer.saleProduct(<span class="number">10000f</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出结果：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png" alt="基于接口的动态代理输出结果"></p>
<h2 id="4-2-基于子类的动态代理"><a class="header-anchor" href="#4-2-基于子类的动态代理"></a>4.2 基于子类的动态代理</h2>
<p>通过前文的分析，我们知道基于接口的动态代理是如何实现的了，但是这种动态代理的类必须实现一个接口，如果不实现一个接口就⑧行。</p>
<p>难道就必须实现一个接口才能动态代理，不然就不行？就没有其他的方法？</p>
<p>那肯定不是！这就得说到基于子类的动态代理了。</p>
<p>基于接口的动态代理使用的都是 JDK 提供的类，要想实现基于子类的动态代理就需要导入第三方依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>涉及到的类：<code>Enhancer</code>，提供者：第三方 <code>cglib</code> 库</p>
<p>那么如何创建代理对象？使用 <code>Enhancer</code> 类的 <code>create()</code> 方法</p>
<p><mark>创建代理对象有什么要求？</mark> 被代理类不能是最终类（被 <code>final</code> 修饰的类，被 <code>final</code> 修饰的类不能被继承）</p>
<p><code>create()</code> 方法的参数：</p>
<ul>
<li>Class：字节码。用于指定被代理对象的字节码。</li>
<li>Callback：用于提供增强的代码。我们一般写的都是 <code>Callback</code> 的子接口实现类：<code>MethodInterceptor</code></li>
</ul>
<blockquote>
<p>代码测试</p>
</blockquote>
<p>和基于接口的动态代理模拟的场景一样，那么则有：</p>
<p>生产厂家：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/20</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 生产厂家</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saleProduct</span><span class="params">(<span class="type">float</span> money)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销售商品，并拿到钱 &quot;</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterService</span><span class="params">(<span class="type">float</span> money)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提供售后服务，并拿到钱 &quot;</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模拟消费者消费，控制台打印生产厂家从经销商处获取的金额：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/20</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 模拟一个消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">cglibProducer</span> <span class="operator">=</span> (Producer)Enhancer.create(producer.getClass(), <span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行被代理对象的任何方法都会经过该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> o 代理对象的引用</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method 当前执行的方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> objects 当前执行方法所需的参数</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> methodProxy 当前执行方法的代理对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> 和被代理对象有相同的返回值</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                <span class="comment">// 提供增强的代码</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 1. 获取方法执行的参数</span></span><br><span class="line">                <span class="type">Float</span> <span class="variable">money</span> <span class="operator">=</span> (Float) objects[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 2. 判断当前方法是不是销售</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;saleProduct&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">                    returnValue = method.invoke(producer, money * <span class="number">0.8f</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cglibProducer.saleProduct(<span class="number">10000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出结果：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png" alt="基于子类的动态代理输出结果"></p>
<h1 id="5-Spring-与-AOP"><a class="header-anchor" href="#5-Spring-与-AOP"></a>5. Spring 与 AOP</h1>
<h2 id="5-1-AOP-概述"><a class="header-anchor" href="#5-1-AOP-概述"></a>5.1 AOP 概述</h2>
<blockquote>
<p>什么是 AOP</p>
</blockquote>
<p>AOP：全称是 Aspect Oriented Programming，即：面向切面编程。</p>
<p>百度百科是这么说的：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91AOP.png" alt="百度百科AOP"></p>
<p>简单的说，就是把我们程序中重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的<br>
基础上，对我们的已有方法进行增强。</p>
<blockquote>
<p>AOP 的作用和优势</p>
</blockquote>
<p>作用：在程序运行期间，不修改源码对已有方法进行增强。</p>
<p>优势：</p>
<ul>
<li>减少重复代码</li>
<li>提高开发效率</li>
<li>维护方便</li>
</ul>
<blockquote>
<p>AOP 的实现方式</p>
</blockquote>
<p>使用动态代理技术。前文说了，动态代理分为基于接口的动态代理和基于子类的动态代理，那么 Spring 是如何选择的呢？</p>
<p>在 Spring 中，框架会根据目标类 <strong>是否实现了接口</strong> 来决定采用哪种动态代理的方式。</p>
<h2 id="5-2-AOP-相关概念"><a class="header-anchor" href="#5-2-AOP-相关概念"></a>5.2 AOP 相关概念</h2>
<p><strong>Joinpoint（连接点）：</strong> 所谓连接点是指那些被拦截到的点。在 Spring 中，这些点指的就是方法，因为 Spring 只支持方法类型的连接点。</p>
<p><strong>Pointcut（切入点）：</strong> 所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。</p>
<p>接口中所有方法都是连接点，但只有真正被增强了的方法是切入点。所有切入点都是连接点，但连接点不一定是切入点。</p>
<p><strong>Advice（通知 / 增强）：</strong> 所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。 通知的类型：前置通知、后置通知、异常通知、最终通知、环绕通知。 可以通过下面这张动态代理的图示来解释：</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/通知的类型.jpg" alt="通知的类型" style="zoom:67%;" />
<p><strong>Introduction（引介）：</strong> 引介是一种特殊的通知。在不修改类代码的前提下，Introduction 可以在运行期为类动态地添加一些方法或 Field。</p>
<p><strong>Target（目标对象）：</strong> 代理的目标对象。</p>
<p><strong>Weaving（织入）：</strong> 织入是指把增强应用到目标对象来创建新的代理对象的过程。 Spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。</p>
<p><strong>Proxy（代理）：</strong> 一个类被 AOP 织入增强后，就产生一个结果代理类。</p>
<p><strong>Aspect（切面）：</strong> 切入点和通知（引介）的结合。</p>
<blockquote>
<p>需要明确的事</p>
</blockquote>
<p>开发阶段：</p>
<p>1、编写核心业务代码（开发主线）</p>
<p>2、把公用代码抽取出来，制作成通知。</p>
<p>3、在配置文件中，声明切入点与通知间的关系，即切面。</p>
<p>运行阶段（Spring框架完成的） ：</p>
<p>Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p>
<h2 id="5-3-基于-XML-配置的-AOP"><a class="header-anchor" href="#5-3-基于-XML-配置的-AOP"></a>5.3 基于 XML 配置的 AOP</h2>
<p>搭建一个简单的环境进行测试基于 XML 配置的 AOP。</p>
<p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>service 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟保存账户</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟更新账户</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateAccount</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟删除账户</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteAccount</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>service 实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了保存&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateAccount</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了更新 &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了删除&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志类，这个类用于打印日志，每次执行业务层的方法就打印日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/21</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 用于记录日志的工具类，它里面提供了公共的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="comment">// 用于打印日志，计划让其在切入点方法执行前执行（切入点方法就是业务层方法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLog</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logger类中的printLog方法开始记录日志了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置Spring的IoC容器，将Service对象配置进去--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yang.service.impl.AccountServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Spring中基于xml的AOP配置步骤--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置Logger类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logger&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yang.util.Logger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logger&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置通知的类型，并建立通知方法和切入点方法的关联--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;printLog&quot;</span> </span></span><br><span class="line"><span class="tag">                        <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.yang.service.impl.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取对象</span></span><br><span class="line">        <span class="type">AccountService</span> <span class="variable">as</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;accountService&quot;</span>, AccountService.class);</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        as.saveAccount();</span><br><span class="line">        as.updateAccount(<span class="number">666</span>);</span><br><span class="line">        as.deleteAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试类后的打印结果：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/%E5%9F%BA%E4%BA%8Exml%E9%85%8D%E7%BD%AE%E7%9A%84AOP%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B.png" alt="基于xml配置的AOP入门案例"></p>
<p>根据上图的数据结果可以看到：每次执行业务层的方法都相应地打印出了日志，我们的入门案例也就成功了。</p>
<blockquote>
<p>总结</p>
</blockquote>
<p>入门案例已经成功，我们来总结一下流程：</p>
<p>1、首先是编写普通的业务代码，然后根据需要编写需要切入的方法</p>
<p>2、编写相应的 Spring 配置文件：</p>
<ul>
<li>配置 Spring 的 IoC 容器，将 Service 对象配置进去</li>
<li>把通知的 Bean 也交给 Spring 管理</li>
<li>使用 <code>&lt;aop:config&gt;</code> 标签表明开始 AOP 的配置</li>
<li>使用 <code>&lt;aop:aspect&gt;</code> 标签表明配置切面</li>
<li>在 <code>&lt;aop:aspect&gt;</code> 内部使用对应的标签来配置通知的类型，建立通知方法和切入点方法的联系</li>
</ul>
<p>3、编写测试方法进行测试</p>
<blockquote>
<p>涉及的标签</p>
</blockquote>
<p><code>&lt;aop:config&gt;</code> 标签：表明开始 AOP 的配置</p>
<p><code>&lt;aop:aspect&gt;</code> 标签：表明配置切面。这个标签内有两个属性：</p>
<ul>
<li>id 属性：给切面提供一个唯一的标志</li>
<li>ref 属性：指定通知类的 bean 的 id</li>
</ul>
<p><code>&lt;aop:before&gt;</code> 标签：该标签是 <code>&lt;aop:aspect&gt;</code> 标签内部的标签，用于配置通知的类型。在上述案例中，我们计划让 <code>printLog()</code> 方法在切入点方法执行前执行，因此是前置通知，使用 <code>&lt;aop:before&gt;</code> 标签。这个标签下有两个主要属性：</p>
<ul>
<li>method 属性：用于指定 Logger 类中哪个方法是前置通知</li>
<li>pointcut 属性：指定切入点表达式。该表达式的含义指的是对业务层中哪些方法增强</li>
</ul>
<p>这里就涉及到 <strong>切入点表达式</strong> 的写法，需要细说一手 ~</p>
<h2 id="5-4-切入点表达式"><a class="header-anchor" href="#5-4-切入点表达式"></a>5.4 切入点表达式</h2>
<p>切入点表达式的写法是：<code>execution(表达式)</code>，需要使用到 <code>execution</code> 关键字，但这并不是重点，重点是这个关键字后括号包裹的表达式应该怎么写。</p>
<p><mark>注意：</mark> <code>execution</code> 关键字不是本节的重点，实际操作中千万别忘记书写了！</p>
<p>表达式的标准写法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 返回值 包名.包名.包名...类名.方法名(参数列表)</span><br></pre></td></tr></table></figure>
<p>根据以上写法，在上述案例中，假设我们需要对 <code>saveAccount()</code> 方法添加前置通知，那么则有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void com.yang.service.impl.AccountServiceImpl.saveAccount()</span><br></pre></td></tr></table></figure>
<p>这是标准表达式的写法，但是这种写法只能针对单一的方法进行增强，实际情况下肯定不可能只针对一个方法进行增强。切入点表达式还有以下简洁写法：</p>
<p>1、访问修饰符可以 <strong>省略</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void com.yang.service.impl.AccountServiceImpl.saveAccount()</span><br></pre></td></tr></table></figure>
<p>这样修改后，还是只能对 <code>saveAccount()</code> 方法进行增强。</p>
<p>2、返回值可以使用通配符表示任意返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* com.yang.service.impl.AccountServiceImpl.saveAccount()</span><br></pre></td></tr></table></figure>
<p>虽然业务层有两种返回值类型，<code>void</code> 和 <code>int</code>，但是由于明确指定了方法，依旧只能对 <code>saveAccount()</code> 方法进行增强。</p>
<p>3、包名可以使用通配符表示任意包，但是有几级包就需要写几个 <code>*</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* *.*.*.*.AccountServiceImpl.saveAccount()</span><br></pre></td></tr></table></figure>
<p>同样，依旧只能对 <code>saveAccount()</code> 方法进行增强。但如果包有很多，岂不是要写很多通配符？</p>
<p>4、包名可以使用 <code>..</code> 表示当前包及其子包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* *..AccountServiceImpl.saveAccount()</span><br></pre></td></tr></table></figure>
<p>由于方法名还是没改变，还是只能对 <code>saveAccount()</code> 方法进行增强。</p>
<p>5、类名和方法名都可以使用 <code>*</code> 来实现通配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* *..*.*()</span><br></pre></td></tr></table></figure>
<p>这下就不一样了，由于业务层中有两个方法都没有参数，因此会对 <code>saveAccount()</code> 和 <code>deleteAccount()</code> 这两个方法进行增强。</p>
<p>6、对应方法的参数列表来说：</p>
<ul>
<li>可以直接写数据类型，基本数据类型直接写名称，引用类型写<code>包名.类名</code>的方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* *..*.*(int)</span><br></pre></td></tr></table></figure>
<p>这样书写后，业务层只有 <code>updateAccount(int i)</code> 方法有 <code>int</code> 类型的参数，因此只有它被增强。</p>
<p>可以在 <code>()</code> 内指定匹配方法的参数类型，如果是基本数据类型和 <code>java.lang</code> 包下的类型可以不用书写全类名，否则需要书写全类名。</p>
<ul>
<li>类型可以使用通配符 <code>*</code> 表示任意类型，但 <mark>必须有参数</mark></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* *..*.*(*)</span><br></pre></td></tr></table></figure>
<p>这样书写后，业务层只有 <code>updateAccount(int i)</code> 方法有参数，因此只有它被增强。</p>
<ul>
<li>可以使用 <code>..</code> 表示有无参数均可，有参数可以是任意类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* *..*.*(..)</span><br></pre></td></tr></table></figure>
<p>这样的书写属于全通配，所有方法都会被增强。</p>
<p>最终可得全通配写法：<code>* *..*.*(..)</code></p>
<p>这表示任意包下的任意类中任意方法都会被增强。</p>
<p>但是实际开发中一般不会使用切入点表达式的全通配写法，我们会切到业务层实现类下的所有方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* com.yang.service.impl.*.*(..)</span><br></pre></td></tr></table></figure>
<p>表明 com 包下 yang 包下 service 包下 impl 包下所有类的所有方法（无论是否有参）都会被增强。</p>
<p>切入点表达式可以这样简洁地书写，就是因为我们导入了以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="5-5-常见四种通知类型"><a class="header-anchor" href="#5-5-常见四种通知类型"></a>5.5 常见四种通知类型</h2>
<p>我们对基于 XML 配置的 AOP 案例中的代码进行部分修改，service 包下的 <code>AccountService</code> 接口和  <code>AccountServiceImpl</code> 实现类不做任何改变。</p>
<p>在 <code>Logger</code> 类中添加另外三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="comment">// 前置通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforePrintLog</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知Logger类中的beforePrintLog方法开始记录日志了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturningPrintLog</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知Logger类中的afterReturningPrintLog方法开始记录日志了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowingPrintLog</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPrintLog</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终通知Logger类中的afterPrintLog方法开始记录日志了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改 Spring 配置文件，增加三种通知的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置Spring的IoC容器，将Service对象配置进去--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yang.service.impl.AccountServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置Logger类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logger&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yang.util.Logger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logger&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置前置通知：在切入点方法执行之前执行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beforePrintLog&quot;</span> </span></span><br><span class="line"><span class="tag">                        <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.yang.service.impl.*.*(..))&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--配置后置通知：在切入点方法正常执行之后执行，它和异常通知永远只会执行一个--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturningPrintLog&quot;</span> </span></span><br><span class="line"><span class="tag">                                 <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.yang.service.impl.*.*(..))&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--配置异常通知：在切入点方法产生异常之后执行，它和后置通知永远只会执行一个--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowingPrintLog&quot;</span> </span></span><br><span class="line"><span class="tag">                                <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.yang.service.impl.*.*(..))&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--配置最终通知：无论切入点方法是否正常执行它都会在其后面执行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;afterPrintLog&quot;</span> </span></span><br><span class="line"><span class="tag">                       <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.yang.service.impl.*.*(..))&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取对象</span></span><br><span class="line">        <span class="type">AccountService</span> <span class="variable">as</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;accountService&quot;</span>, AccountService.class);</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        as.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试类中的测试方法，控制台打印结果如下：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/%E5%9B%9B%E7%A7%8D%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%E8%BE%93%E5%87%BA_1.png" alt="四种通知类型输出_1"></p>
<p>不是配置了四种通知吗？怎么只有三种输出？</p>
<p>修改  <code>AccountServiceImpl</code> 实现类中的 <code>saveAccount()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了保存&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行测试类的测试方法，控制台输出如下：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/%E5%9B%9B%E7%A7%8D%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%E8%BE%93%E5%87%BA_2.png" alt="四种通知类型输出_2"></p>
<p>代码运行出现异常，异常通知成功输出，但是后置通知消失不见。</p>
<blockquote>
<p>总结</p>
</blockquote>
<p>常见四种通知类型分别是：</p>
<p>1、前置通知：在切入点方法执行之前执行</p>
<p>2、后置通知：在切入点方法正常执行之后执行，它和异常通知永远只会执行一个</p>
<p>3、异常通知：在切入点方法产生异常之后执行，它和后置通知永远只会执行一个</p>
<p>4、最终通知：无论切入点方法是否正常执行它都会在其后面执行</p>
<blockquote>
<p>通用化切入点表达式</p>
</blockquote>
<p>在上述代码中，我们配置了四种通知类型，每种通知类型都有属于其本身的标签，每个标签也都有一个 <code>pointcut</code> 属性，因此我们写了四次（长长的）切入点表达式。</p>
<p>但是，这也太蠢了，不能简化一点？优雅一下？</p>
<p>这就涉及到另外一个标签：<code>&lt;aop:pointcut&gt;</code></p>
<p>见名识意，显然这个标签是用于指定切入点表达式的。这个标签有两个属性：</p>
<ul>
<li>id：用于指定表达式的唯一标识符</li>
<li>expression：用于指定切入点表达式的内容</li>
</ul>
<p>那么我们可以对 Spring 配置文件中配置 AOP 部分的代码进行如下优化：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logger&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beforePrintLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturningPrintLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowingPrintLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;afterPrintLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.yang.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个标签可以写在 <code>&lt;aop:aspect&gt;</code> 标签内部，只能当前切面使用。</p>
<p>它还可以写在 <code>&lt;aop:aspect&gt;</code> 标签外面，让所有切面都可以使用。</p>
<p>需要注意的是，根据导入的 xml 约束，<code>&lt;aop:pointcut&gt;</code> 标签只能写在 <code>&lt;aop:aspect&gt;</code> 标签前面，写后面就会报错，还不带提示的那种！</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.yang.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logger&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beforePrintLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturningPrintLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowingPrintLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;afterPrintLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="5-6-环绕通知"><a class="header-anchor" href="#5-6-环绕通知"></a>5.6 环绕通知</h2>
<p>我们对基于 XML 配置的 AOP 案例中的代码进行部分修改，service 包下的 <code>AccountService</code> 接口和  <code>AccountServiceImpl</code> 实现类不做任何改变。</p>
<p>在 <code>Logger</code> 类中添加环绕通知的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aroundPrintLog</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Logger类中的aroundPrintLog方法开始记录日志了...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Spring 配置文件中，修改 AOP 的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.yang.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logger&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;aroundPrintLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:around</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试方法也不变，直接运行：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E5%88%9D%E4%BD%93%E9%AA%8C.png" alt="环绕通知初体验"></p>
<p>这输出结果是个啥玩意？😤</p>
<p>通知方法执行了，但是切入点方法没有执行，搞个​ 🔨</p>
<p>还记得动态代理的环绕通知代码吗？</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/通知的类型.jpg" alt="通知的类型" style="zoom:67%;" />
<p>动态代理的环绕通知有明确的切入点调用，而我们的代码没有。那怎么搞？</p>
<p>Spring 框架为我们提供了一个接口：<code>ProceedingJoinPoint</code>，该接口有一个 <code>proceed()</code> 方法，此方法就相当于明确调用切入点方法。</p>
<p><code>ProceedingJoinPoint</code> 接口可以作为环绕通知的方法参数，在程序执行时，Spring 框架会为我们提供该接口的实现类供我们使用。</p>
<p>因此，我们可以在 <code>proceed()</code> 方法执行前编写前置通知，在 <code>proceed()</code> 执行后编写后置通知，<code>proceed()</code> 方法需要抛出 <code>Throwable</code> 类型的异常，可以在 <code>catch</code> 块里编写异常通知，在 <code>finally</code> 块里编写最终通知。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">aroundPrintLog</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">    Object rtValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] args = pjp.getArgs(); <span class="comment">// 得到方法执行所需的参数</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Logger类中的aroundPrintLog方法开始记录日志了...前置&quot;</span>);</span><br><span class="line"></span><br><span class="line">        rtValue = pjp.proceed(args); <span class="comment">// 明确调用业务层（切入点）方法</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Logger类中的aroundPrintLog方法开始记录日志了...后置&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> rtValue;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123; <span class="comment">// 不能抛出 Exception</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Logger类中的aroundPrintLog方法开始记录日志了...异常&quot;</span>);</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(throwable);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logger类中的aroundPrintLog方法开始记录日志了...最终&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试类的测试方法，控制台打印如下：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E8%BE%93%E5%87%BA_1.png" alt="环绕通知输出_1"></p>
<p>修改  <code>AccountServiceImpl</code> 实现类中的 <code>saveAccount()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了保存&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行测试类的测试方法，控制台打印如下：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SSMImages/%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E8%BE%93%E5%87%BA_2.png" alt="环绕通知输出_2"></p>
<p>控制台的输出都正确！我们自己编写的环绕通知没有问题！ 🎉</p>
<p>根据上面环绕通知的编写过程，不难得出：Spring 中的环绕通知是 Spring 框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。</p>
<h2 id="5-7-基于注解的-AOP"><a class="header-anchor" href="#5-7-基于注解的-AOP"></a>5.7 基于注解的 AOP</h2>
<p>还是根据基于 XML 配置的 AOP 案例中的代码进行修改，完成基于注解的 AOP。</p>
<p><code>AccountService</code> 接口不变，但我们知道需要将 service 对象配置到 IoC 容器中，因此需要在  <code>AccountServiceImpl</code> 实现类上添加 <code>@Service</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IAccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveAccount</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了保存&quot;</span>);</span><br><span class="line"><span class="comment">//        int i = 1/0;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateAccount</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了更新&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteAccount</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了删除&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于日志类 <code>Logger</code> 类来说，也需要将其注入 IoC 容器中，这个类不属于任何一层，因此使用 <code>@Component</code> 注解。</p>
<p>然后我们还需要使用 <code>@Aspect</code> 注解表示 <code>Logger</code> 类是一个切面类。</p>
<p>对于 <code>Logger</code> 类中的方法，需要将它们设置成通知方法，与 XML 中的标签一样，这些通知分别对应了一些注解：</p>
<ul>
<li><code>@Before</code>：前置通知</li>
<li><code>@AfterReturning</code>：后置通知</li>
<li><code>@AfterThrowing</code>：异常通知</li>
<li><code>@After</code>：最终通知</li>
<li><code>@Around()</code>：环绕通知</li>
</ul>
<p>使用了这些注解指定哪些方法是哪些通知之外，还需要指定切入点表达式，这时候需要用到 <code>@Pointcut</code> 注解。</p>
<p>最终，<code>Logger</code> 类改写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;logger&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//表示当前类是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.yang.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">     <span class="comment">// 前置通知</span></span><br><span class="line"><span class="comment">//    @Before(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforePrintLog</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知Logger类中的beforePrintLog方法开始记录日志了。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 后置通知</span></span><br><span class="line"><span class="comment">//    @AfterReturning(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturningPrintLog</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 异常通知</span></span><br><span class="line"><span class="comment">//    @AfterThrowing(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowingPrintLog</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//最终通知</span></span><br><span class="line"><span class="comment">//    @After(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPrintLog</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终通知Logger类中的afterPrintLog方法开始记录日志了。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Around(&quot;pt1()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundPrintLog</span><span class="params">(ProceedingJoinPoint pjp)</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">rtValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] args = pjp.getArgs();<span class="comment">//得到方法执行的参数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Logger类中的aroundPrintLog方法开始记录日志了。。。前置&quot;</span>);</span><br><span class="line">            rtValue = pjp.proceed(args);<span class="comment">//明确调用业务层方法（切入点方法）</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Logger类中的aroundPrintLog方法开始记录日志了。。。后置&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> rtValue;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;Logger类中的aroundPrintLog方法开始记录日志了。。。异常&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Logger类中的aroundPrintLog方法开始记录日志了。。。最终&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rtValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于那四种常见的通知类型和环绕通知不能共存，因此我们将其中一种进行注释并分别测试。</p>
<p>这下就真的完了？</p>
<p>没有！我们还没有开启注解。</p>
<p>可以使用 XML 的方式开启注解与注解扫描：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--告知Spring在创建容器时需要扫描的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.yang&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置Spring开启AOP注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>还可以使用配置类的方式开启注解与注解扫描：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@ComponentScan(basePackages=&quot;com.yang&quot;)</span> </span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfiguration</span> &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于使用了 XML 方式开启注解和注解扫描的情况，可以使用如下测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取对象</span></span><br><span class="line">        <span class="type">IAccountService</span> <span class="variable">as</span> <span class="operator">=</span> (IAccountService) ac.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">        <span class="comment">//3.执行方法</span></span><br><span class="line">        as.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用的是配置类开启注解和注解扫描，就需要使用 <code>AnnotationConfigApplicationContext</code> 来读取配置类。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfiguration.class);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意事项</p>
</blockquote>
<p>1、使用 <code>@Before</code> 等注解指定切入点表达式时，不要漏掉括号。正确示例：<code>@Before(&quot;pt1()&quot;)</code></p>
<p>2、在低版本的 Spring 2.x 中，使用基于注解的 AOP 时，可能会出现消息输出异常的问题（环绕通知不会出现问题）。建议使用的 Spring 版本为 5.2.7 及其以上！</p>
<h1 id="6-JdbcTemplate"><a class="header-anchor" href="#6-JdbcTemplate"></a>6. JdbcTemplate</h1>
<h2 id="6-1-准备工作"><a class="header-anchor" href="#6-1-准备工作"></a>6.1 准备工作</h2>
<p><code>Account</code> 实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> money;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略 GET / SET 方法，toString() 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>account 数据表字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id | name | money</span><br></pre></td></tr></table></figure>
<p>导入的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="6-2-基本使用"><a class="header-anchor" href="#6-2-基本使用"></a>6.2 基本使用</h2>
<p>直接创建一个类，直接编写一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//准备数据源：Spring 内置的数据源</span></span><br><span class="line">        <span class="type">DriverManagerDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>();</span><br><span class="line"></span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql:///ssm?characterEncoding=utf8&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建JdbcTemplate对象</span></span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        <span class="comment">//给jt设置数据源</span></span><br><span class="line">        jt.setDataSource(ds);</span><br><span class="line">        <span class="comment">//2.执行操作</span></span><br><span class="line">        jt.execute(<span class="string">&quot;insert into account(name,money)values (&#x27;ddd&#x27;,1000)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写好后，直接 run 就完事了！</p>
<h2 id="6-3-与-Spring-IoC-结合"><a class="header-anchor" href="#6-3-与-Spring-IoC-结合"></a>6.3 与 Spring IoC 结合</h2>
<p>首先得先编写 Spring 的配置文件，配置数据源、将 <code>JdbcTemplate</code> 注入 Spring 容器中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置JdbcTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span> = <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span> = <span class="string">&quot;jdbc:mysql:///ssm?zeroDateTimeBehavior=convertToNull<span class="symbol">&amp;amp;</span>serverTimezone=GMT%2b8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span> = <span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span> = <span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对象</span></span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jt</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;jdbcTemplate&quot;</span>,JdbcTemplate.class);</span><br><span class="line">        <span class="comment">//执行操作</span></span><br><span class="line">        jt.execute(<span class="string">&quot;insert into account(name,money)values (&#x27;eee&#x27;,1000)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-4-CRUD-操作"><a class="header-anchor" href="#6-4-CRUD-操作"></a>6.4 CRUD 操作</h2>
<p>继续使用 【6.3 与 Spring IoC 结合】的环境，那么 JdbcTemplate 相关的 CRUD 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对象</span></span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jt</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;jdbcTemplate&quot;</span>,JdbcTemplate.class);</span><br><span class="line">        <span class="comment">//执行操作</span></span><br><span class="line">        <span class="comment">//保存</span></span><br><span class="line">        jt.update(<span class="string">&quot;insert into account(name,money)values (?,?)&quot;</span>,<span class="string">&quot;fff&quot;</span>,<span class="number">1200</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line">        jt.update(<span class="string">&quot;update account set name=?, money=? where id=?&quot;</span>,<span class="string">&quot;test&quot;</span>,<span class="number">1200</span>,<span class="number">6</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        jt.update(<span class="string">&quot;delete from account where id=?&quot;</span>,<span class="number">7</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查询所有</span></span><br><span class="line">        List&lt;Account&gt; accounts = jt.query(<span class="string">&quot;select * from account where money &gt; ?&quot;</span>,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class),<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (Account account:accounts)&#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查询一个</span></span><br><span class="line">        List&lt;Account&gt; accounts = jt.query(<span class="string">&quot;select * from account where id = ?&quot;</span>,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class),<span class="number">1</span>);</span><br><span class="line">        System.out.println(accounts.isEmpty()?<span class="string">&quot;No values&quot;</span>:accounts.get(<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用聚合函数</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> jt.queryForObject(<span class="string">&quot;select count(*) from account where money &gt; ?&quot;</span>,Long.class,<span class="number">1000</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-与-Dao-结合"><a class="header-anchor" href="#6-2-与-Dao-结合"></a>6.2 与 Dao 结合</h2>
<p><code>IAccountDao</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IAccountDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据id查询用户</span></span><br><span class="line">    Account <span class="title function_">findAccountById</span><span class="params">(Integer accountId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据名称查询用户</span></span><br><span class="line">    Account <span class="title function_">findAccountByName</span><span class="params">(String accountName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新用户</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateAccount</span><span class="params">(Account account)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.support.JdbcDaoSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 JdbcDaoSupport，使用基于XML的配置时可以去除多余代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDaoImpl</span> <span class="keyword">extends</span> <span class="title class_">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title class_">IAccountDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findAccountById</span><span class="params">(Integer accountId)</span> &#123;</span><br><span class="line">        List&lt;Account&gt; accounts = <span class="built_in">super</span>.getJdbcTemplate().query(<span class="string">&quot;select * from account where id = ?&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class), accountId);</span><br><span class="line">        <span class="keyword">return</span> accounts.isEmpty() ? <span class="literal">null</span> : accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findAccountByName</span><span class="params">(String accountName)</span> &#123;</span><br><span class="line">        List&lt;Account&gt; accounts = <span class="built_in">super</span>.getJdbcTemplate().query(<span class="string">&quot;select * from account where name = ?&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class), accountName);</span><br><span class="line">        <span class="keyword">if</span> (accounts.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (accounts.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;结果不唯一&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateAccount</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.getJdbcTemplate().update(<span class="string">&quot;update account set name = ?,money=? where id = ?&quot;</span>,account.getName(),account.getMoney(),account.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置账户的持久层--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yang.dao.impl.AccountDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span> = <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span> = <span class="string">&quot;jdbc:mysql:///ssm?zeroDateTimeBehavior=convertToNull<span class="symbol">&amp;amp;</span>serverTimezone=GMT%2b8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span> = <span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span> = <span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对象</span></span><br><span class="line">        <span class="type">IAccountDao</span> <span class="variable">accountDao</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;accountDao&quot;</span>,IAccountDao.class);</span><br><span class="line">        <span class="comment">//执行操作</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> accountDao.findAccountById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(account);</span><br><span class="line"></span><br><span class="line">        account.setMoney(<span class="number">66666f</span>);</span><br><span class="line">        accountDao.updateAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相关要点</p>
</blockquote>
<p>在 service 的实现类中，我们继承了 <code>JdbcDaoSupport</code> 类。当代码中存在多个 Dao 并使用了 <code>JdbcTemplate</code> 时，在这些 Dao 文件中会多次书写 <code>JdbcTemplate</code> 及其 set 方法，然后在配置文件中注入。</p>
<p>这样的代码属于多余的，完全可以消除，只需要实现 <code>JdbcDaoSupport</code> 类即可（具体原因可以点开这个类看看），然后按照上面提供的 XML 配置文件进行配置即可。</p>
<p>但是这种方式必须是基于 XML 进行 Spring 配置时才可以使用，如果是使用了注解，就不能继承 <code>JdbcDaoSupport</code> 类，而是需要在 Dao 类中添加：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br></pre></td></tr></table></figure>
<p>因为 <code>JdbcDaoSupport</code> 是 Spring 提供的，里面的代码仅是可读的，我们不能修改这里面的代码。</p>
<h1 id="7-事务管理"><a class="header-anchor" href="#7-事务管理"></a>7. 事务管理</h1>
<h2 id="7-1-手动实现事务管理"><a class="header-anchor" href="#7-1-手动实现事务管理"></a>7.1 手动实现事务管理</h2>
<blockquote>
<p>事务回顾</p>
</blockquote>
<p>事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。</p>
<p>事务就是把一系列的数据库操作当成一个独立的工作单元，这些操作要么全部完成，要么全部不完成。</p>
<p>事务有四个属性（ACID）：</p>
<p>1、原子性（atomicity）：事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用</p>
<p>2、一致性（consistency）：一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中</p>
<p>3、隔离性（isolation）：可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏</p>
<p>4、持久性（durability）：事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中</p>
<blockquote>
<p>案例测试</p>
</blockquote>
<p>假设我们需要实现转账，要实现这个功能就需要涉及到两类用户，一个是转出账户，另一个是转入账户。转出账户减钱，转入账户加钱。如果中间出了意外，则转账失败，转出用户不减钱，转入用户不加钱。</p>
<p>这就涉及到事务管理，事务管理的一大核心就是：将事务自动提交改成手动提交，用于保证数据完整和一致。</p>
<p>根据前文讲述的 AOP 知识，我们可以使用 AOP 来实现事务管理。以下为主要代码：</p>
<p>账户实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Float money;</span><br><span class="line">    <span class="comment">// 省略 GET / SET 方法，以及 toString() 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>业务层实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IAccountService</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;transfer....&quot;</span>);</span><br><span class="line">        <span class="comment">//2.1根据名称查询转出账户</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">source</span> <span class="operator">=</span> accountDao.findAccountByName(sourceName);</span><br><span class="line">        <span class="comment">//2.2根据名称查询转入账户</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">target</span> <span class="operator">=</span> accountDao.findAccountByName(targetName);</span><br><span class="line">        <span class="comment">//2.3转出账户减钱</span></span><br><span class="line">        source.setMoney(source.getMoney()-money);</span><br><span class="line">        <span class="comment">//2.4转入账户加钱</span></span><br><span class="line">        target.setMoney(target.getMoney()+money);</span><br><span class="line">        <span class="comment">//2.5更新转出账户</span></span><br><span class="line">        accountDao.updateAccount(source);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟转账出现意外，转账失败</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.6更新转入账户</span></span><br><span class="line">        accountDao.updateAccount(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dao 层接口和实现类都是涉及的数据库操作，比较简单，篇幅所限就不贴出了。</p>
<p>数据库连接工具类 <code>ConnectionUtils</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接的工具类，它用于从数据源中获取一个连接，并且实现和线程的绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程上的连接</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getThreadConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.先从ThreadLocal上获取</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> tl.get();</span><br><span class="line">            <span class="comment">//2.判断当前线程上是否有连接</span></span><br><span class="line">            <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//3.从数据源中获取一个连接，并且存入ThreadLocal中</span></span><br><span class="line">                conn = dataSource.getConnection();</span><br><span class="line">                tl.set(conn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4.返回当前线程上的连接</span></span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把连接和线程解绑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事务管理工具类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.utils;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和事务管理相关的工具类，它包含了，开启事务，提交事务，回滚事务和释放连接</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConnectionUtils</span><span class="params">(ConnectionUtils connectionUtils)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.connectionUtils = connectionUtils;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启事务</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">beginTransaction</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().commit();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().rollback();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放连接</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().close();<span class="comment">//还回连接池中</span></span><br><span class="line">            connectionUtils.removeConnection();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是使用配置文件将这些 Bean 注入到 Spring IoC 容器中使用了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- 配置Service --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yang.service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入dao --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置Dao对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yang.dao.impl.AccountDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入QueryRunner --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;runner&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;runner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入ConnectionUtils --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionUtils&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connectionUtils&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置QueryRunner--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;runner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbutils.QueryRunner&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--连接数据库的必备信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span> = <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span> = <span class="string">&quot;jdbc:mysql:///ssm?zeroDateTimeBehavior=convertToNull<span class="symbol">&amp;amp;</span>serverTimezone=GMT%2b8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span> = <span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span> = <span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置Connection的工具类 ConnectionUtils --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;connectionUtils&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yang.utils.ConnectionUtils&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yang.utils.TransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入ConnectionUtils --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionUtils&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connectionUtils&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.yang.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置前置通知：开启事务--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beginTransaction&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置后置通知：提交事务--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;commit&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置异常通知：回滚事务--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;rollback&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置最终通知：释放连接--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;release&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试类测试一手：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦 2020/10/21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &quot;classpath:bean.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountService as;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">testTransfer</span><span class="params">()</span>&#123;</span><br><span class="line">        as.transfer(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="number">100f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类中，我们让账户名为 aaa 的用户向用户 bbb 转账 100 元，但是由于业务层实现类中存在我们人为制造的转账意外，因此应该是无法转账成功的。</p>
<p>运行代码后，控制台会打印出除数为 0 的异常，也会打印出在业务层实现类中输出的“transfer…”，如果前往数据库查看数据，会发现两个账户的余额并没有改变。</p>
<p>证明我们自己实现的事务控制没有问题！</p>
<h2 id="7-2-XML-配置的声明式事务管理"><a class="header-anchor" href="#7-2-XML-配置的声明式事务管理"></a>7.2 XML 配置的声明式事务管理</h2>
<p>Spring 在不同的事务管理 API 之上定义了一个抽象层，使得开发人员不必了解底层的事务管理 API 就可以使用 Spring 的事务管理机制。Spring 支持编程式事务管理和声明式的事务管理。</p>
<p>先来说说声明式事务管理，这种事务管理又分为基于 XML 配置的声明式事务管理和基于注解配置的声明式事务管理。</p>
<p>如果要使用基于 XML 配置的声明式事务管理，我们需要在 Spring 配置文件中导入以下约束，千万别导错了，不然标签提供的属性不对：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">	    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">	    http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">	    http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了代码的完整，在此贴上所有代码。</p>
<p>账户实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Float money;</span><br><span class="line">    <span class="comment">// 省略 GET / SET 方法，以及 toString() 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dao 层接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IAccountDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据id查询用户</span></span><br><span class="line">    Account <span class="title function_">findAccountById</span><span class="params">(Integer accountId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据名称查询用户</span></span><br><span class="line">    Account <span class="title function_">findAccountByName</span><span class="params">(String accountName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新用户</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateAccount</span><span class="params">(Account account)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dao 层实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承 JdbcDaoSupport，使用基于XML的配置时可以去除多余代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDaoImpl</span> <span class="keyword">extends</span> <span class="title class_">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title class_">IAccountDao</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findAccountById</span><span class="params">(Integer accountId)</span> &#123;</span><br><span class="line">        List&lt;Account&gt; accounts = <span class="built_in">super</span>.getJdbcTemplate().query(<span class="string">&quot;select * from account where id = ?&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class), accountId);</span><br><span class="line">        <span class="keyword">return</span> accounts.isEmpty() ? <span class="literal">null</span> : accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findAccountByName</span><span class="params">(String accountName)</span> &#123;</span><br><span class="line">        List&lt;Account&gt; accounts = <span class="built_in">super</span>.getJdbcTemplate().query(<span class="string">&quot;select * from account where name = ?&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class), accountName);</span><br><span class="line">        <span class="keyword">if</span> (accounts.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (accounts.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;结果不唯一&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateAccount</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.getJdbcTemplate().update(<span class="string">&quot;update account set name = ?,money=? where id = ?&quot;</span>,account.getName(),account.getMoney(),account.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>service 层接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    Account <span class="title function_">findAccountById</span><span class="params">(Integer accountId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceName 转出账户名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetName 转入账户名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 转出金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>service 层实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccountDao</span><span class="params">(IAccountDao accountDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findAccountById</span><span class="params">(Integer accountId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAccountById(accountId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;transfer....&quot;</span>);</span><br><span class="line">        <span class="comment">//2.1根据名称查询转出账户</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">source</span> <span class="operator">=</span> accountDao.findAccountByName(sourceName);</span><br><span class="line">        <span class="comment">//2.2根据名称查询转入账户</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">target</span> <span class="operator">=</span> accountDao.findAccountByName(targetName);</span><br><span class="line">        <span class="comment">//2.3转出账户减钱</span></span><br><span class="line">        source.setMoney(source.getMoney()-money);</span><br><span class="line">        <span class="comment">//2.4转入账户加钱</span></span><br><span class="line">        target.setMoney(target.getMoney()+money);</span><br><span class="line">        <span class="comment">//2.5更新转出账户</span></span><br><span class="line">        accountDao.updateAccount(source);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.6更新转入账户</span></span><br><span class="line">        accountDao.updateAccount(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是重头戏 —— Spring 配置文件中关于声明式事务管理的配置，先直接上代码，然后再来一一解析：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">                           https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置业务层--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yang.service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置账户的持久层--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yang.dao.impl.AccountDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///ssm?zeroDateTimeBehavior=convertToNull<span class="symbol">&amp;amp;</span>serverTimezone=GMT%2b8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置事务的通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.yang.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--建立切入点和事务通知的对应关系--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上述配置中，我们先配置数据源、将数据源注入持久层、将持久层注入业务层，然后就是基于 XML 的声明式事务控制。</p>
<blockquote>
<p>Spring 中基于 XML 的声明式事务控制配置步骤：</p>
</blockquote>
<p>1、配置事务管理器：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、配置事务的通知，需要导入事务的约束 tx 和 aop 的名称空间和约束，这里的约束千万不要导错了，建议手动复制导入，而不是使用 IDEA 的自动导入。配置事务通知时需要使用到一个新标签 <code>&lt;tx:advice&gt;</code>，这个标签有两个属性：</p>
<ul>
<li>id：给事务管理器取一个唯一标志</li>
<li>transaction-manager：给事务通知提供一个事务管理器引用</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3、配置 AOP 中的通用切入点表达式，建立事务通知和切入点表达式的对应关系</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.yang.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--建立切入点和事务通知的对应关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>4、配置事务的属性，在事务的通知 <code>&lt;tx:advice&gt;</code> 标签的内部进行配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务的属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>标签 <code>&lt;tx:method&gt;</code> 中有多个属性，其左右如下：</p>
<ul>
<li>name：指定某一切入点方法，支持通配符。如：<code>find*</code> 表示以 find 开头的切入点方法。优先级是：全匹配 &gt; 半匹配半通配 &gt; 全通配。</li>
<li>isolation：用于指定事务的隔离级别，默认值 <code>DEFAULT</code>，表示使用数据库的隔离级别</li>
<li>propagation：用于指定事务的传播行为，默认值 <code>REQUIRED</code>，表示一定会有事务，是增删改的选择，查询方法可以选择 <code>SUPPORTS</code></li>
<li>read-only：用于指定事务是否只读。只有查询方法才能设置为 <code>true</code>。默认值是 <code>false</code>，表示读写</li>
<li>timeout：用于指定事务的超时时间，默认值是 -1，表示所使用数据库的默认超时时间。如果指定了数值，以秒为单位</li>
<li>rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不会滚。没有默认值，表示任何异常都回滚。</li>
<li>no-rollback-for：用于指定一个异常，当产生该异常时，事务不会滚，产生其他异常时，事务回滚。没有默认值，表示任何异常都回滚。</li>
</ul>
<h2 id="7-3-事务的隔离级别"><a class="header-anchor" href="#7-3-事务的隔离级别"></a>7.3 事务的隔离级别</h2>
<blockquote>
<p>什么是事务的隔离级别</p>
</blockquote>
<p>事务隔离级反映事务提交并发访问时的处理态度。</p>
<p>这里所指的并发访问就是多个事务（用户）在同一时间访问了相同的数据，而同一时间实际上也有微小的差距，并不是真正意义上的同一时间。</p>
<p>在并发访问数据库时，可能会产生以下问题：<strong>脏读</strong>、<strong>不可重复读</strong> 和 <strong>幻影读</strong>。</p>
<p>这些问题可以通过 <strong>事务的隔离级别</strong> 来解决，通过在隔离级别中设置不同的值，解决并发处理过程中的问题。</p>
<blockquote>
<p>脏读</p>
</blockquote>
<p>脏读（dirty read）：一个事务读取了另一个事务未提交的数据，进而在本事务中产生了数据不一致的现象。</p>
<p>要解决脏读，需要使用 <code>@Transactional(isolation = Isolation.READ_COMMITTED)</code>。</p>
<p>《数据库系统概论（第五版）》（王珊 萨师煊著）中是这样描述的：事务 T<sub>1</sub> 修改某一数据并将其写回磁盘，事务 T<sub>2</sub> 读取同一数据后，T<sub>1</sub> 由于某些原因被撤销，这时 T<sub>1</sub> 修改过的数据恢复原值，T<sub>2</sub> 读到的数据就与数据库中的数据不一致，则 T<sub>2</sub> 读到的数据就为“脏”数据，即不正确的数据。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">T<sub>1</sub></th>
<th style="text-align:center">T<sub>2</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">①</td>
<td style="text-align:center">R© = 100;<br />C = C * 2<br />W© = 200</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">②</td>
<td style="text-align:center"></td>
<td style="text-align:center">R© = 200</td>
</tr>
<tr>
<td style="text-align:center">③</td>
<td style="text-align:center">ROLLBACK<br />C 恢复为 200</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<blockquote>
<p>不可重复读</p>
</blockquote>
<p>不可重复读（non-repeatable read）：一个事务中，多次读取相同的数据，但是读取的结果不一样。</p>
<p>要解决不可重复读，需要使用 <code>@Transactional(isolation = Isolation.REPEATABLE_READ)</code>。其本质就是行锁。</p>
<p>《数据库系统概论（第五版）》（王珊 萨师煊著）中是这样描述的：事务 T<sub>1</sub> 读取数据后，事务 T<sub>2</sub> 执行了更新操作，使 T<sub>1</sub> 无法再现前一次读取结果。具体地讲，不可重复读包括三种情况：</p>
<p>1、事务 T<sub>1</sub> 读取了某一数据后，事务 T<sub>2</sub> 对其进行了修改，当事务 T<sub>1</sub> 再次读该数据时，得到与前一次不同的值。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">T<sub>1</sub></th>
<th style="text-align:center">T<sub>2</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">①</td>
<td style="text-align:center">R(A) = 50<br />R(B) = 100<br />求和 150</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">②</td>
<td style="text-align:center"></td>
<td style="text-align:center">R(B) = 100<br />B = B * 2<br />W(B) = 200</td>
</tr>
<tr>
<td style="text-align:center">③</td>
<td style="text-align:center">R(A) = 50<br />R(B) = 200<br />求和 250，验算不对</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>2、事务 T<sub>1</sub> 按一定条件从数据库中读取了某些数据记录后，事务 T<sub>2</sub> 删除了其中部分记录，当 T<sub>1</sub> 再次按相同条件读取数据时，发现某些记录神秘地消失了。</p>
<p>3、事务 T<sub>1</sub> 按一定条件从数据库中读取某些数据记录后，事务 T<sub>2</sub> 插入了一些数据，当 T<sub>1</sub> 再次按相同条件读取数据时，发现多了一些记录。</p>
<p>后两种不可重复读有时也称为幻影（phantom row）现象。</p>
<blockquote>
<p>幻影读</p>
</blockquote>
<p>幻影读：一个事务中，多次对整表（多条数据）进行查询统计，但是结果不一致。</p>
<p>与《数据库系统概论（第五版）》（王珊 萨师煊著）一书中提到的 <strong>不可重复读的后两种情况</strong> 类似。</p>
<p>要解决幻影读，需要使用 <code>@Transactional(isolation = Isolation.SERIALIZABLE)</code>。其本质就是表锁。</p>
<blockquote>
<p>丢失修改</p>
</blockquote>
<p>《数据库系统概论（第五版）》（王珊 萨师煊著）一书中认为并发操作带来的数据不一致的情况有丢失修改、不可重复读和读“脏”数据。</p>
<p>这里补充一下丢失修改（lost update）：两个事务 T<sub>1</sub> 和 T<sub>2</sub> 读入同一数据并修改，T<sub>2</sub> 提交的结果破坏了 T<sub>1</sub> 提交的结果，导致 T<sub>1</sub> 的修改被丢失。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">T<sub>1</sub></th>
<th style="text-align:center">T<sub>2</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">①</td>
<td style="text-align:center">R(A) = 16</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">②</td>
<td style="text-align:center"></td>
<td style="text-align:center">R(A) = 16</td>
</tr>
<tr>
<td style="text-align:center">③</td>
<td style="text-align:center">A = A - 1 <br />W(A) = 15</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">④</td>
<td style="text-align:center"></td>
<td style="text-align:center">A = A - 1 <br />W(A) = 15</td>
</tr>
</tbody>
</table>
<p>SQL92 没有定义这种现象，解决丢失修改的办法就是加锁。</p>
<blockquote>
<p>数据库对于隔离级别的支持</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">隔离属性的值</th>
<th style="text-align:center">MySQL</th>
<th style="text-align:center">Oracle</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">READ_COMMITTED</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
</tr>
<tr>
<td style="text-align:center">REPEATABLE_READ</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">❌</td>
</tr>
<tr>
<td style="text-align:center">SERIALIZABLE</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
</tr>
</tbody>
</table>
<p>Oracle 不支持 <code>REPEATABLE_READ</code>，那如何解决不可重复读呢？采用的是多版本对比的方式来解决不可重复读。</p>
<blockquote>
<p>Spring 中事务的隔离级别</p>
</blockquote>
<p>在 Spring 中，事务有如下五种隔离级别：</p>
<p><code>DEFAULT</code>：<strong>默认级别</strong>，使用后端数据库默认的隔离级别。如 MySQL 默认采用 <code>REPEATABLE_READ</code>，Oracle 默认采用 <code>READ_COMMITTED</code>；</p>
<p><code>READ_UNCOMMITTED</code>：最低的隔离级别，允许可以读取未提交数据，可能会导致脏读、幻读、不可重复读；</p>
<p><code>READ_COMMITTED</code>：允许读取并发事务已经提交的数据，可以解决脏读，但幻读、不可重复读仍可能发生；</p>
<p><code>REPEATABLE_READ</code>：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以解决脏读和不可重复读，但幻读仍可能发生；</p>
<p><code>SERIALIZABLE</code>：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，事务之间不会产生干扰，<strong>该级别可以解决脏读、不可重复读以及幻读</strong>。这种级别下将严重影响程序的性能，通常情况下不会使用该级别。</p>
<p>从并发安全的角度来讲：SERIALIZABLE 大于 REPEATABLE_READ 大于 READ_COMMITTED；</p>
<p>从运行效率的角度来讲：READ_COMMITTED 大于 REPEATABLE_READ 大于 SERIALIZABLE。</p>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级是 <strong>REPEATABLE-READ（可重读）</strong>。可以通过以下命令来查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@tx_isolation</span>; # MySQL <span class="number">8.0</span> 之前</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction_isolation</span>; # MySQL <span class="number">8.0</span> 以后</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实战中的建议</p>
</blockquote>
<p>推荐使用 Spring 指定的默认隔离级别 <code>DEFAULT</code> 即可，它将使用后端数据库默认的隔离级别。</p>
<p>在未来的实战中，实际的并发访问情况很低，如果真的遇到了并发问题，可以使用乐观锁来解决。如果使用 Hibernate（JPA）可以使用 Version，如果使用 Mybatis，就需要通过拦截器自定义开发。</p>
<h2 id="7-4-事务的传播行为"><a class="header-anchor" href="#7-4-事务的传播行为"></a>7.4 事务的传播行为</h2>
<p>事务的传播行为描述了事务解决嵌套问题的特征。Service 在调用 Service 时，极有可能出现事务的嵌套。所谓事务的嵌套，就是在一个大事务中包含了若干个小事务，它们彼此影响，最终就会导致外部大的事务丧失了事务的原子性。在 Spring 中，共有以下 7 个传播行为：</p>
<p><code>REQUIRED</code>：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中，一般的选择（默认值）</p>
<p><code>SUPPORTS</code>：使用当前事务，如果当前没有事务，就以非事务方式执行</p>
<p><code>REQUERS_NEW</code>：新建事务，如果当前在事务中，把当前事务挂起</p>
<p><code>NOT_SUPPORTED</code>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</p>
<p><code>NEVER</code>：以非事务方式运行，如果当前存在事务，抛出异常</p>
<p><code>MANDATORY</code>：使用当前的事务，如果当前没有事务，就抛出异常</p>
<p><code>NESTED</code>：如果当前没有事务，则执行 REQUIRED 类似的操作。如果当前存在事务，则在嵌套事务内执行，作为子事务。也就是说：如果外部存在事务，<code>NESTED</code> 修饰的内部方法属于外部事务的子事务，外部主事务回滚时，子事务也会回滚，而内部子事务可以单独回滚但不影响外部主事务和其他子事务。</p>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">外部不存在事务</th>
<th style="text-align:center">外部存在事务</th>
<th style="text-align:center">用法</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">REQUIRED</td>
<td style="text-align:center">开启新的事务</td>
<td style="text-align:center">融合到外部事务中</td>
<td style="text-align:center">@Transactional(propagation = Propagation.REQUIRED)</td>
<td style="text-align:center">增删改方法</td>
</tr>
<tr>
<td style="text-align:center">SUPPORTS</td>
<td style="text-align:center">不开启事务</td>
<td style="text-align:center">融合到外部事务中</td>
<td style="text-align:center">@Transactional(propagation = Propagation.SUPPORTS)</td>
<td style="text-align:center">查询方法</td>
</tr>
<tr>
<td style="text-align:center">REQUERS_NEW</td>
<td style="text-align:center">开启新的事务</td>
<td style="text-align:center">挂起外部事务，创建新的事务</td>
<td style="text-align:center">@Transactional(propagation = Propagation.REQUERS_NEW)</td>
<td style="text-align:center">日志记录方法</td>
</tr>
<tr>
<td style="text-align:center">NOT_SUPPORTED</td>
<td style="text-align:center">不开启事务</td>
<td style="text-align:center">挂起外部事务</td>
<td style="text-align:center">@Transactional(propagation = Propagation.NOT_SUPPORTED)</td>
<td style="text-align:center">极其不常用</td>
</tr>
<tr>
<td style="text-align:center">NEVER</td>
<td style="text-align:center">不开启事务</td>
<td style="text-align:center">抛出异常</td>
<td style="text-align:center">@Transactional(propagation = Propagation.NEVER)</td>
<td style="text-align:center">极其不常用</td>
</tr>
<tr>
<td style="text-align:center">MANDATORY</td>
<td style="text-align:center">抛出异常</td>
<td style="text-align:center">融合到外部事务中</td>
<td style="text-align:center">@Transactional(propagation = Propagation.MANDATORY)</td>
<td style="text-align:center">极其不常用</td>
</tr>
<tr>
<td style="text-align:center">NESTED</td>
<td style="text-align:center">开启新的事务</td>
<td style="text-align:center">作为外部事务的子事务</td>
<td style="text-align:center">@Transactional(propagation = Propagation.NESTED)</td>
<td style="text-align:center">极其不常用</td>
</tr>
</tbody>
</table>
<h2 id="7-5-注解配置的声明式事务管理"><a class="header-anchor" href="#7-5-注解配置的声明式事务管理"></a>7.5 注解配置的声明式事务管理</h2>
<p>虽然是基于注解的声明式事务控制，但并不是全注解的声明式事务控制，我们依旧需要在 XML 中进行一些配置。</p>
<p>使用注解配置的声明式事务管理，需要在 Spring 配置文件中添加新的约束：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot; </span></span></span><br><span class="line"><span class="string"><span class="tag">                  http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">                  http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">                  http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="string"><span class="tag">                  http://www.springframework.org/schema/aop/spring-aop.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">                  http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="string"><span class="tag">                  http://www.springframework.org/schema/tx/spring-tx.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">                  http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">                  http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置 Spring 创建容器时要扫描的包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.yang&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们的 Dao 实现类继承了 <code>JdbcDaoSupport</code>，使用基于XML的配置时可以去除多余代码，但现在要使用注解，因此就不能继承 <code>JdbcDaoSupport</code> 类，地老老实实注入 JdbcTemplate。</p>
<p>Dao 实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;accountDao&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">IAccountDao</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//其余代码和基于 XML 的配置相同 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然注入了 JdbcTemplate，但 Spring 容器中并没有啊，因此需要在 Spring 容器中添加 JdbcTemplate：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>添加 JdbcTemplate 时，需要注入数据源，数据源与基于 XML 的配置相同，这里就不列举了。</p>
<p>至于向容器中添加业务层实现类、Dao 成实现类，以及数据的注入，都可以使用相关注解在代码中实现。</p>
<blockquote>
<p>Spring 中基于注解的声明式事务管理配置步骤：</p>
</blockquote>
<p>1、配置事务管理器并注入数据源</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>2、开启 Spring 对注解事务的支持</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启 spring 对注解事务的支持 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span> </span><br></pre></td></tr></table></figure>
<p>3、在需要事务支持的地方使用 <code>@Transactional</code> 注解（一般在业务层实现类添加）</p>
<p>使用了 <code>@Transactional</code> 注解后，XML 中配置事务通知的 <code>&lt;tx:advice&gt;</code> 标签和配置 AOP的 <code>&lt;aop:config&gt;</code> 标签就可以省略了！</p>
<p><code>@Transactional</code> 注解的属性和 XML 中 <code>&lt;tx:method&gt;</code> 标签的属性含义一致（不明白可以进入该注解查看）。</p>
<p>该注解可以出现在接口上，类上和方法上。</p>
<ul>
<li>
<p>出现接口上，表示该接口的所有实现类都有事务支持。</p>
</li>
<li>
<p>出现在类上，表示类中所有方法有事务支持</p>
</li>
<li>
<p>出现在方法上，表示方法有事务支持。</p>
</li>
</ul>
<p>以上三个位置的优先级：方法 &gt; 类 &gt; 接口</p>
<hr>
<p>如果不想使用 XML 配置文件，也可以使用全注解配置，那么就需要创建一个配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@ComponentScan(basePackages=&quot;com.yang&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class, TransactionConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbcConfig.properties&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringTxConfiguration</span> &#123; </span><br><span class="line">  <span class="comment">//配置数据源、配置 JdbcTemplate、配置事务管理器。</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="7-6-与编程式事务管理的对比"><a class="header-anchor" href="#7-6-与编程式事务管理的对比"></a>7.6 与编程式事务管理的对比</h2>
<p>最开始就说了 Spring 支持编程式事务管理和声明式的事务管理，但是在实际开发过程中我们很少使用编程式事务管理。对于一下声明式事务管理和编程式事务管理：</p>
<p><strong>编程式事务管理：</strong></p>
<p>将事务管理代码嵌到业务方法中来控制事务的提交和回滚</p>
<p>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</p>
<p>PS：在 SpringBoot 中，编程式事务管理的使用被大大简化，因此可以使用编程式事务管理来避免提交大事务。</p>
<p><strong>声明式事务管理：</strong></p>
<p>一般情况下比编程式事务好用。</p>
<p>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</p>
<p>将事务管理作为横切关注点，通过 AOP 方法模块化。Spring 中通过 Spring AOP 框架支持声明式事务<br>
管理。</p>
<hr>
<p>如果想了解编程式事务管理，可以参考以下视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Sb411s7vP?p=80">Spring教程IDEA版-4天-2018黑马SSM-02 P80</a></p>
<p>本文也是根据此视频编写的，感谢黑马程序员的张阳老师！ 👍</p>
<hr>
<p><span style="text-align: center;display:block;">Spring 基础完</span></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mofan212.github.io">默烦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mofan212.github.io/posts/Learning-Spring-From-0/">https://mofan212.github.io/posts/Learning-Spring-From-0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mofan212.github.io" target="_blank">Mofan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post_share"><div class="social-share" data-image="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/61.jpg" data-sites="wechat,qq,weibo,facebook,twitter"></div><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://gcore.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" target="_blank"><img class="post-qr-code-img" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" target="_blank"><img class="post-qr-code-img" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/Something-About-Base64/" title="Base64 编码的那些事"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/62.jpg" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Base64 编码的那些事</div></div></a></div><div class="next-post pull-right"><a href="/posts/Java-Socket/" title="Java 网络编程基础"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/60.jpg" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java 网络编程基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/Simple-Use-Of-BeanCopier/" title="BeanCopier 的简单使用"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/84.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-19</div><div class="title">BeanCopier 的简单使用</div></div></a></div><div><a href="/posts/SpringIoC/" title="Spring IoC 巩固理解"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-29</div><div class="title">Spring IoC 巩固理解</div></div></a></div><div><a href="/posts/Spring's-Enhancements-To-Java-Annotation/" title="Spring 对 Java 注解的增强"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/133.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-15</div><div class="title">Spring 对 Java 注解的增强</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">默烦</div><div class="author-info__description">彩笔的打怪升级之路...</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">152</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/23658864/dynamic"><i class="fas fa-running"></i><span>关注我的B站</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mofan212" target="_blank" title="GitHub"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:cy.mofan@foxmail.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a><a class="social-icon" href="https://www.travellings.cn/go.html" target="_blank" title="开往"><i class="fas fa-train"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站所有博文均是博主的学习笔记与个人理解。<strong><font style="color:red">除特别注明外，</font>如需转载，请在文章头部醒目处附带原文链接并<a target="_blank" rel="noopener" href="https://mofan212.gitee.io/mine/" style="color:#49B1F5;text-decoration:underline">告知我</a></strong>你将转载。😊</br><strong><font style="color:red">严禁未遵循规范的转载。</font></strong>😡</br><strong>死去的评论系统复活啦！欢迎到留言板畅所欲言！</strong>当然也可以使用更高效的<a target="_blank" href="https://space.bilibili.com/23658864/dynamic" style="color:#49B1F5;text-decoration:underline"> 哔哩哔哩私信 </a>或<a href="mailto:cy.mofan@foxmail.com" style="color:#49B1F5;text-decoration:underline" target="_blank">邮箱</a>。 😉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Spring-%E6%A6%82%E8%BF%B0"><span class="toc-text">1. Spring 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Spring-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1.1 Spring 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Spring-%E5%8F%91%E5%B1%95%E6%A6%82%E8%BF%B0"><span class="toc-text">1.2 Spring 发展概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Spring-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">1.3 Spring 的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Spring-%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">1.4 Spring 的体系结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%80%A6%E5%90%88"><span class="toc-text">2. 程序的耦合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%80%A6%E5%90%88%E4%B8%8E%E8%A7%A3%E8%80%A6%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-text">2.1 耦合与解耦的分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E4%BB%A3%E7%A0%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">2.2 代码问题分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%80%A6"><span class="toc-text">2.3 工厂模式解耦</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E6%94%B9%E8%BF%9B"><span class="toc-text">2.4 存在的问题与改进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-IoC"><span class="toc-text">2.5 控制反转 - IoC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Spring-%E4%B8%8E-IoC"><span class="toc-text">3. Spring 与 IoC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%BD%BF%E7%94%A8-Spring-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.1 使用 Spring 创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-ApplicationContext"><span class="toc-text">3.2 ApplicationContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Spring-%E4%B8%AD-Bean-%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-text">3.3 Spring 中 Bean 的细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-text">3.4 依赖注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-IoC-%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="toc-text">3.5 IoC 相关注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E6%95%B4%E5%90%88-JUnit5"><span class="toc-text">3.6 整合 JUnit5</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">4. 动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">4.1 基于接口的动态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%9F%BA%E4%BA%8E%E5%AD%90%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">4.2 基于子类的动态代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Spring-%E4%B8%8E-AOP"><span class="toc-text">5. Spring 与 AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-AOP-%E6%A6%82%E8%BF%B0"><span class="toc-text">5.1 AOP 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-AOP-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">5.2 AOP 相关概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%9F%BA%E4%BA%8E-XML-%E9%85%8D%E7%BD%AE%E7%9A%84-AOP"><span class="toc-text">5.3 基于 XML 配置的 AOP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">5.4 切入点表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E5%B8%B8%E8%A7%81%E5%9B%9B%E7%A7%8D%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B"><span class="toc-text">5.5 常见四种通知类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5"><span class="toc-text">5.6 环绕通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84-AOP"><span class="toc-text">5.7 基于注解的 AOP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-JdbcTemplate"><span class="toc-text">6. JdbcTemplate</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-text">6.1 准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">6.2 基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E4%B8%8E-Spring-IoC-%E7%BB%93%E5%90%88"><span class="toc-text">6.3 与 Spring IoC 结合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-CRUD-%E6%93%8D%E4%BD%9C"><span class="toc-text">6.4 CRUD 操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E4%B8%8E-Dao-%E7%BB%93%E5%90%88"><span class="toc-text">6.2 与 Dao 结合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-text">7. 事务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-text">7.1 手动实现事务管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-XML-%E9%85%8D%E7%BD%AE%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-text">7.2 XML 配置的声明式事务管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">7.3 事务的隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-text">7.4 事务的传播行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-text">7.5 注解配置的声明式事务管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">7.6 与编程式事务管理的对比</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Configuration-Annotation/" title="@Configuration 注解的那些事"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/25.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="@Configuration 注解的那些事"/></a><div class="content"><a class="title" href="/posts/Configuration-Annotation/" title="@Configuration 注解的那些事">@Configuration 注解的那些事</a><time datetime="2024-08-07T16:00:00.000Z" title="更新于 2024-08-08 00:00:00">2024-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/MySQL-Advanced-Fourth-Logical-Architecture/" title="【MySQL 高级篇四】逻辑架构"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/134.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="【MySQL 高级篇四】逻辑架构"/></a><div class="content"><a class="title" href="/posts/MySQL-Advanced-Fourth-Logical-Architecture/" title="【MySQL 高级篇四】逻辑架构">【MySQL 高级篇四】逻辑架构</a><time datetime="2024-07-24T16:00:00.000Z" title="更新于 2024-07-25 00:00:00">2024-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Combinator-Pattern/" title="Combinator Pattern"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/149.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Combinator Pattern"/></a><div class="content"><a class="title" href="/posts/Combinator-Pattern/" title="Combinator Pattern">Combinator Pattern</a><time datetime="2024-07-23T16:00:00.000Z" title="更新于 2024-07-24 00:00:00">2024-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Lambda-Expression-And-Functional-Programming/" title="Lambda 表达式与函数式编程"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/152.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Lambda 表达式与函数式编程"/></a><div class="content"><a class="title" href="/posts/Java-Lambda-Expression-And-Functional-Programming/" title="Lambda 表达式与函数式编程">Lambda 表达式与函数式编程</a><time datetime="2024-07-19T16:00:00.000Z" title="更新于 2024-07-20 00:00:00">2024-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Lambda-And-Serialization/" title="Lambda 与序列化"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/104.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Lambda 与序列化"/></a><div class="content"><a class="title" href="/posts/Lambda-And-Serialization/" title="Lambda 与序列化">Lambda 与序列化</a><time datetime="2024-07-19T16:00:00.000Z" title="更新于 2024-07-20 00:00:00">2024-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Spring-Application-Event/" title="Spring 的事件监听机制"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/151.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Spring 的事件监听机制"/></a><div class="content"><a class="title" href="/posts/Spring-Application-Event/" title="Spring 的事件监听机制">Spring 的事件监听机制</a><time datetime="2024-07-13T16:00:00.000Z" title="更新于 2024-07-14 00:00:00">2024-07-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 默烦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://gcore.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://gcore.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://gcore.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://gcore.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://gcore.jsdelivr.net/gh/mofan212/blog-static-resources@master/js/mine.min.js"></script><script src="https://npm.elemecdn.com/mermaid/dist/mermaid.min.js"></script><script defer="defer" id="ribbon" src="https://gcore.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://gcore.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Azathoth,Yog-Sothoth,Shub-Niggurath,Nyarlathotep,Cthulhu,Hastur,Abhoth,Ghroth,Tsathoggua,Cthugha,Deep Ones,Dagon,Chaugnar Faugn,Mordiggian,Shoggoth,Old One,Mi-Go,Great Race of Yith,Flying Polyp,Hounds of Tindalos,Dhole" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://gcore.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'BAFEL7A6K1',
    apiKey: '89fcb5961984c5c054bf04149f345f38',
    indexName: 'mofan212io',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>
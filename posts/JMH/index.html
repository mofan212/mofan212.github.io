<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JMH | Mofan</title><meta name="author" content="默烦,cy.mofan@foxmail.com"><meta name="copyright" content="默烦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JMH 是 OpenJDK 团队开发的一款基准测试工具，常用于代码的性能调优。">
<meta property="og:type" content="article">
<meta property="og:title" content="JMH">
<meta property="og:url" content="https://mofan212.github.io/posts/JMH/index.html">
<meta property="og:site_name" content="Mofan">
<meta property="og:description" content="JMH 是 OpenJDK 团队开发的一款基准测试工具，常用于代码的性能调优。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/144.jpg">
<meta property="article:published_time" content="2023-12-26T16:00:00.000Z">
<meta property="article:modified_time" content="2023-12-30T16:00:00.000Z">
<meta property="article:author" content="默烦">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JMH">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/144.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mofan212.github.io/posts/JMH/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"距离本文上次更新已经过去","messageNext":"天，请注意时效性。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 默烦","link":"链接: ","source":"来源: Mofan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JMH',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-31 00:00:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="referrer" content="no-referrer-when-downgrade" /><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/gh/mofan212/blog-static-resources@master/css/myStyle.min.css"><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/lxgw-wenkai-screen-webfont@1.7.0/style.css" /><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css" /><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Mofan" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/gh/mofan212/blog-static-resources/css/fill-left.min.css"/><script src="https://jsd.onmicrosoft.cn/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">150</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/post_top_img.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Mofan"><span class="site-name">Mofan</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JMH</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-26T16:00:00.000Z" title="发表于 2023-12-27 00:00:00">2023-12-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-30T16:00:00.000Z" title="更新于 2023-12-31 00:00:00">2023-12-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JMH"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>封面来源：本文封面来源于网络，如有侵权，请联系删除。</p>
<p>本文参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aT41177QZ">初识JMH</a></li>
<li><a target="_blank" rel="noopener" href="https://space.bilibili.com/19231724/channel/collectiondetail?sid=796848">JMH高阶使用技巧</a></li>
</ul>
<p>本文涉及的代码：<a target="_blank" rel="noopener" href="https://github.com/mofan212/jmh-study">mofan212/jmh-study</a></p>
<h1 id="1-下载构建官方源码"><a class="header-anchor" href="#1-下载构建官方源码"></a>1. 下载构建官方源码</h1>
<p>GitHub 搜索 <code>jmh</code>，进入 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jmh">openjdk/jmh</a> 页面，clone 官方源码。</p>
<p>用 IDEA 打开项目，执行以下命令（二选一）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不执行单元测试，也不编译测试类</span></span><br><span class="line">mvn install -Dmaven.test.skip=true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者：不执行单元测试，但编译测试类</span></span><br><span class="line">mvn install -DskipTests=true</span><br></pre></td></tr></table></figure>
<p>也可以使用 IDEA 的 Maven 图形化界面完成。</p>
<p>进入 <code>jmh-samples</code> 模块，打开 <code>JMHSample_01_HelloWorld</code> 类，运行其中的 <code>main()</code> 方法。</p>
<p>运行过程中可能出现以下错误：</p>
<pre>
java: 程序包sun.misc不存在
</pre>
<p>需要手动调整 IDEA 的 Java Compiler 设置，将它们设置成当前使用的 JDK 版本，之后便可成功运行。</p>
<h1 id="2-Hello-World"><a class="header-anchor" href="#2-Hello-World"></a>2. Hello World</h1>
<p>从官方示例入手，执行以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JMHSample_01_HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wellHelloThere</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(JMHSample_01_HelloWorld.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>) <span class="comment">// 设置总共测几轮</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行时间比较长，需要耐心等待。</p>
<p><code>wellHelloThere()</code> 被 <code>@Benchmark</code> 注解标记，表示本次测试的就是 <code>wellHelloThere()</code> 方法，尽管它是一个空方法。</p>
<p><code>main()</code> 运行完成后，控制台会打印出测试报告。前几行是 JMH 与当前测试环境的信息，之后有：</p>
<pre>
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: indi.mofan.JMHSample_01_HelloWorld.wellHelloThere
</pre>
<ul>
<li><code>Warmup</code> 表示测试前的预热信息，此处进行 5 轮预热，每次 10 秒。</li>
<li><code>Measurement</code> 表示测试维度，此处进行 5 轮测试，每次 10 秒。</li>
<li><code>Threads</code> 表示测试时的线程信息，此处表示测试时在 1 个线程中执行。</li>
<li><code>Benchmark mode</code> 表示基准模式，<code>Throughput</code> 表示将测试结果以吞吐量的信息显示出来。</li>
</ul>
<p>再来看测试结果：</p>
<pre>
Result "indi.mofan.JMHSample_01_HelloWorld.wellHelloThere":
  2651579229.605 ±(99.9%) 18997454.078 ops/s [Average]
  (min, avg, max) = (2644241675.367, 2651579229.605, 2657354438.867), stdev = 4933578.495
  CI (99.9%): [2632581775.527, 2670576683.683] (assumes normal distribution)
</pre>
<p>99.9% 的情况下，平均吞吐量为 <code>2651579229.605 ops/s</code>，误差 <code>±18997454.078 ops/s</code>。</p>
<p>之后列举出最小值、平均值、最大值，<code>stdev</code> 表示标准差，也就是方差开根号。</p>
<p><code>CI</code> 表示置信区间，这里表示 99.9% 的概率下，测试结果在区间 <code>[2632581775.527, 2670576683.683]</code> 范围内。</p>
<h1 id="3-使用示例"><a class="header-anchor" href="#3-使用示例"></a>3. 使用示例</h1>
<p>使用 JMH 时需要导入以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jmh.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jmh.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-1-Warmup-与-Measurement"><a class="header-anchor" href="#3-1-Warmup-与-Measurement"></a>3.1 @Warmup 与 @Measurement</h2>
<p>在执行第一个示例时，耗时较长，这主要是因为测试过程中的预热次数与测试次数较长，这些信息可以通过 <code>@Warmup</code> 与 <code>@Measurement</code> 注解进行修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Warmup(iterations = 1, time = 1, timeUnit = TimeUnit.SECONDS)</span> <span class="comment">// 预热一轮，每次一秒</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 1, time = 1, timeUnit = TimeUnit.SECONDS)</span> <span class="comment">// 测试一轮，每次一秒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample_01_2_Warmup</span> &#123;</span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wellHelloThere</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(Sample_01_2_Warmup.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>) <span class="comment">// 设置总共测几轮</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，发现相比于第一个示例的运行时间，快了许多。</p>
<p>至于最终结果到底准不准，那就另当别论了。</p>
<p>为了能够更快地看到测试结果，后续测试都将采用这两个配置。</p>
<h2 id="3-2-BenchmarkMode"><a class="header-anchor" href="#3-2-BenchmarkMode"></a>3.2 @BenchmarkMode</h2>
<p>JMH 提供了多种 Benchmark Mode，使用 <code>@BenchmarkMode</code> 注解来指定采用的 Benchmark Mode。</p>
<p><code>@BenchmarkMode</code> 注解经常与 <code>@OutputTimeUnit</code> 注解搭配使用，使用 <code>@OutputTimeUnit</code> 指定输出报告的时间单位。</p>
<p>当前 JMH 可以采用的 Benchmark Mode：</p>
<ul>
<li><code>Mode.Throughput</code>：吞吐量测试，每单位时间测试方法会执行多少次</li>
<li><code>Mode.AverageTime</code>：平均耗时时间，每次操作耗时，采用相同的单位时，与 <code>Mode.Throughput</code> 互为倒数</li>
<li><code>Mode.SampleTime</code>：抽样测试，在执行过程中采样，最快的、50% 快的、90%、95%、99%、99.9%、99.99%、100%，可以使用抽样测试对算法的稳定性进行测试</li>
<li><code>Mode.SingleShotTime</code>：冷启动测试，测试方法在测试中只会运行一次，用于测试冷启动的性能</li>
</ul>
<p><code>@BenchmarkMode</code> 注解并不是只能接收单一的 Mode，它接收的是 <code>Mode</code> 数组，因此能够对测试方法设置多个 Mode。</p>
<p>除此之外还提供了 <code>Mode.All</code> 选项，使用当前 JMH 支持的所有 Benchmark Mode 进行测试。</p>
<h2 id="3-3-State"><a class="header-anchor" href="#3-3-State"></a>3.3 @State</h2>
<blockquote>
<p>基本使用</p>
</blockquote>
<p><code>@State</code> 注解 <strong>只能作用在类</strong> 上，它描述了类对象的作用域，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该静态内部类会在 Benchmark 启动时初始化，可以用作方法的入参</span></span><br><span class="line"><span class="comment"> * 所有测试线程共享一个实例，用于测试有状态实例在多线程共享下的性能</span></span><br><span class="line"><span class="comment"> * 一般用来测试多线程竞争下的性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@State(Scope.Benchmark)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BenchmarkState</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Math.PI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该静态内部类会在 Benchmark 各个线程之前初始化，可以用作方法的入参</span></span><br><span class="line"><span class="comment"> * 所有测试线程各用各的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@State(Scope.Thread)</span> <span class="comment">// 不同线程，不同对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadState</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Math.PI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被 <code>@State</code> 标记的类会在 Benchmark 启动时按照给定的作用域进行初始化，在测试方法中可以使用这些类作为入参进行注入，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 main 方法的配置，会启动 4 个线程去一起执行</span></span><br><span class="line"><span class="comment"> * 每个线程的入参都是不同的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measureUnshared</span><span class="params">(ThreadState state)</span> &#123;</span><br><span class="line">    state.x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动 4 个线程，但入参都是一个实例，竞争会非常激烈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measureShared</span><span class="params">(BenchmarkState state)</span> &#123;</span><br><span class="line">    state.x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">    <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">            .include(Sample_03_States.class.getSimpleName())</span><br><span class="line">            <span class="comment">// 执行每个 Benchmark 时，创建 4 个线程去执行</span></span><br><span class="line">            .threads(<span class="number">4</span>)</span><br><span class="line">            .forks(<span class="number">1</span>)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Default State</p>
</blockquote>
<p>在基本使用中，<code>@State</code> 标记的都是静态内部类，静态内部类的作用和普通类没什么区别。</p>
<p>为了更方便地使用，JMH 提供了 Default State，当 <code>@State</code> 注解作用在 <code>@Benchmark</code> 注解标记的方法所在的类上时，测试方法直接使用的成员变量与测试方法接收当前类实例并使用其成员变量没有区别。</p>
<p>比如下面两种表示是等价的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample_04_DefaultState</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Math.PI;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measure</span><span class="params">()</span> &#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample_04_DefaultState</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Math.PI;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measure</span><span class="params">(Sample_04_DefaultState state)</span> &#123;</span><br><span class="line">        state.x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-Setup-和-TearDown"><a class="header-anchor" href="#3-4-Setup-和-TearDown"></a>3.4 @Setup 和 @TearDown</h2>
<blockquote>
<p>基本使用</p>
</blockquote>
<p><code>@Setup</code> 和 <code>@TearDown</code> 两个注解可以认为是 <code>@State</code> 注解生命周期的一部分：</p>
<ul>
<li><code>@Setup</code>：该注解只能作用在方法上，并且标记的方法所在的类必须被 <code>@State</code> 注解标记。<code>@Setup</code> 注解标记的方法用于完成 <strong>启动 Benchmark 前的准备工作</strong>。</li>
<li><code>@TearDown</code>：该注解与 <code>@Setup</code> 注解类似，只不过该注解标记的方法用于完成 <strong>Benchmark 结束后的检查工作</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 1, time = 1)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 1, time = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample_05_StateFixtures</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动 Benchmark 前的准备工作。</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> <span class="doctag">@Setup</span>&#125; 注解必须在 &#123;<span class="doctag">@code</span> <span class="doctag">@State</span>&#125; 标记的类下才能使用，</span></span><br><span class="line"><span class="comment">     * 实际上也算是 &#123;<span class="doctag">@code</span> <span class="doctag">@State</span>&#125; 管理的对象的生命周期的一部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Setup</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        x = Math.PI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Benchmark 结束后的检查工作。</span></span><br><span class="line"><span class="comment">     * 与 &#123;<span class="doctag">@code</span> <span class="doctag">@Setup</span>&#125; 注解类似，也必须在 &#123;<span class="doctag">@code</span> <span class="doctag">@State</span>&#125; 标记的类下使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TearDown</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> x &gt; Math.PI : <span class="string">&quot;Nothing changed?&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measureRight</span><span class="params">()</span> &#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measureWrong</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(Sample_05_StateFixtures.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .jvmArgs(<span class="string">&quot;-ea&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FixtureLevel</p>
</blockquote>
<p>可以为 <code>@Setup</code> 和 <code>@TearDown</code> 设置 <code>Level</code> 类型的 <code>value</code> 值，默认值是 <code>Level.Trial</code>，表示被标记的方法在整个基准测试中只执行一次。</p>
<p>除此之外，还有两个值可供选择：</p>
<ul>
<li><code>Level.Iteration</code>：每轮循环完成之前（或之后）才会执行</li>
<li><code>Level.Invocation</code>：每次方法被调用之前（或之后）才会执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 1, time = 1)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 3, time = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample_06_FixtureLevel</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Level.Trial: before or after the entire benchmark run (the sequence of iterations)</span></span><br><span class="line"><span class="comment">     * Level.Iteration: before or after the benchmark iteration (the sequence of invocations)</span></span><br><span class="line"><span class="comment">     * Level.Invocation; before or after the benchmark method invocation (WARNING: read the Javadoc before using)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Level.Trial: 整个完整的基准测试完成之前（或之后）才会执行</span></span><br><span class="line"><span class="comment">     * Level.Iteration: 每轮循环完成之前（或之后）才会执行一次</span></span><br><span class="line"><span class="comment">     * Level.Invocation: 每次方法被调用之前（或之后），就会执行一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TearDown(Level.Iteration)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> x &gt; Math.PI : <span class="string">&quot;Nothing changed?&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measureRight</span><span class="params">()</span> &#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measureWrong</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(Sample_06_FixtureLevel.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .jvmArgs(<span class="string">&quot;-ea&quot;</span>)</span><br><span class="line">                <span class="comment">// 默认 false，即使 assert 错误也不会让整个测试失败</span></span><br><span class="line">                <span class="comment">// 如果设置为 true，assert 失败时，整个测试也就失败了</span></span><br><span class="line">                .shouldFailOnError(<span class="literal">false</span>) <span class="comment">// switch to &quot;true&quot; to fail the complete run</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FixtureLevelInvocation</p>
</blockquote>
<p>合理使用 <code>@Setup</code> 和 <code>@TearDown</code> 注解的 <code>value</code> 值，能够模拟一些实际场景，比如模仿线程池的冷启动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Warmup(iterations = 1, time = 1)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 1, time = 1)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample_07_FixtureLevelInvocation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@State(Scope.Benchmark)</span> <span class="comment">// 全局公用这个实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NormalState</span> &#123;</span><br><span class="line">        ExecutorService service;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Setup(Level.Trial)</span> <span class="comment">// 全局只执行一次</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">()</span> &#123;</span><br><span class="line">            service = Executors.newCachedThreadPool();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@TearDown(Level.Trial)</span> <span class="comment">// 全局只执行一次</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">()</span> &#123;</span><br><span class="line">            service.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LaggingState</span> <span class="keyword">extends</span> <span class="title class_">NormalState</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SLEEP_TIME</span> <span class="operator">=</span> Integer.getInteger(<span class="string">&quot;sleepTime&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟冷启动线程池</span></span><br><span class="line">        <span class="meta">@Setup(Level.Invocation)</span> <span class="comment">// 每次调用都会执行</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lag</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="comment">// 每次 Benchmark 方法被调用前，睡 10ms</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(SLEEP_TIME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">measureHot</span><span class="params">(NormalState e,</span></span><br><span class="line"><span class="params">                             <span class="keyword">final</span> Scratch s)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 在线程池中执行任务，阻塞地等待结果的响应</span></span><br><span class="line">        <span class="keyword">return</span> e.service.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(s)).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">measureCold</span><span class="params">(LaggingState e,</span></span><br><span class="line"><span class="params">                              <span class="keyword">final</span> Scratch s)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> e.service.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(s)).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@State(Scope.Thread)</span> <span class="comment">// 每个线程都会用各自的实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Scratch</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">double</span> p;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">            p = Math.log(p);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Double&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> Scratch s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(Scratch s)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.s = s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Double <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s.doWork();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(Sample_07_FixtureLevelInvocation.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LaggingState</code> 中的线程池任务在执行之前，会先休眠 10 ms，而 <code>NormalState</code> 中的线程池任务在执行之前则不会，前者用于模拟线程池的冷启动。</p>
<h2 id="3-5-Dead-Code"><a class="header-anchor" href="#3-5-Dead-Code"></a>3.5 Dead Code</h2>
<p>在使用 JMH 时，一些错误的使用方式可能会导致测试代码被 JVM 优化掉，进而导致基准测试结果不准确。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Warmup(iterations = 1, time = 1)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 1, time = 1)</span></span><br><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JMHSample_08_DeadCode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Math.PI;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">compute</span><span class="params">(<span class="type">double</span> d)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; <span class="number">10</span>; c++) &#123;</span><br><span class="line">            d = d * d / Math.PI;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">baseline</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do nothing, this is a baseline</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measureWrong</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 没有使用计算结果，JVM 将优化这段代码，相当于在测试空方法</span></span><br><span class="line">        compute(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">measureRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 正确的做法，将结果返回，让 JVM 认为计算结果不能省略</span></span><br><span class="line">        <span class="keyword">return</span> compute(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(JMHSample_08_DeadCode.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                <span class="comment">// JDK8 下尽量设置为 server 模式，充分利用 JIT</span></span><br><span class="line">                .jvmArgs(<span class="string">&quot;-server&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述示例代码中：</p>
<ul>
<li><code>baseline()</code>：是一个空方法</li>
<li><code>measureWrong()</code>：由于计算结果并没有返回，JVM 会自动优化，使其耗时测得与 <code>baseline()</code> 一样</li>
<li><code>measureRight()</code>：计算结果正常返回，JVM 不会自动优化，测出真正的执行效率</li>
</ul>
<h2 id="3-6-Blackhole"><a class="header-anchor" href="#3-6-Blackhole"></a>3.6 Blackhole</h2>
<p>为了减少 JVM 的优化，JMH 提供了 <code>Blackhole</code> 对象，使用该对象对执行结果进行消费，让测试结果尽可能准确。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Warmup(iterations = 1, time = 1)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 1, time = 1)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample_09_Blackholes</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="variable">x1</span> <span class="operator">=</span> Math.PI;</span><br><span class="line">    <span class="type">double</span> <span class="variable">x2</span> <span class="operator">=</span> Math.PI * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">compute</span><span class="params">(<span class="type">double</span> d)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; <span class="number">10</span>; c++) &#123;</span><br><span class="line">            d = d * d / Math.PI;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基准</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">baseline</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compute(x1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误示例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">measureWrong</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 编译器会自动识别，在 JIT 的时候直接不执行，使得 JMH 的测试结果不准确</span></span><br><span class="line">        compute(x1);</span><br><span class="line">        <span class="comment">// 真正有用的计算</span></span><br><span class="line">        <span class="keyword">return</span> compute(x2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正确示例 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">measureRight_1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 所有的计算结果都使用了</span></span><br><span class="line">        <span class="keyword">return</span> compute(x1) + compute(x2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正确示例 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measureRight_2</span><span class="params">(Blackhole bh)</span> &#123;</span><br><span class="line">        <span class="comment">// 为了防止编译器“自作主张”，使用 JMH 提供的 Blackhole 对象对执行结果进行消费</span></span><br><span class="line">        bh.consume(compute(x1));</span><br><span class="line">        bh.consume(compute(x2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(Sample_09_Blackholes.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-7-常量折叠"><a class="header-anchor" href="#3-7-常量折叠"></a>3.7 常量折叠</h2>
<p>常量折叠，或者叫常数折叠。百度百科对 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B8%B8%E6%95%B0%E6%8A%98%E5%8F%A0/8331368">常数折叠</a> 的解释是这样的：常数折叠是编译器最佳化技术，被使用在现代的编译器中。进阶的常数传播形式，或称之为稀疏有条件的常量传播，可以更精确地传播常数及无缝的移除无用的程式码。</p>
<p>简单来说：当计算结果是可预测的时候，编译器会在编译时期将结果计算出来，运行时直接使用计算结果，而不是每次都执行运算过程。</p>
<p>由于常量折叠的存在，在使用 JMH 时，应当避免常量折叠，让测试结果更加准确。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Warmup(iterations = 1, time = 1)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 1, time = 1)</span></span><br><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample_10_ConstantFold</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Math.PI;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">wrongX</span> <span class="operator">=</span> Math.PI;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">compute</span><span class="params">(<span class="type">double</span> d)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; <span class="number">10</span>; c++) &#123;</span><br><span class="line">            d = d * d / Math.PI;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基准</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">baseline</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误示例：结果是可预测的，因此计算过程会被省略，直接返回计算结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">measureWrong_1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compute(Math.PI);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误示例：传入的 wrongX 被 final 修饰，错误原因与 &#123;<span class="doctag">@code</span> measureWrong_1()&#125; 一样</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">measureWrong_2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compute(wrongX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正确示例：传入的 x 未被 final 修饰，计算结果不可预测</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">measureRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compute(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(Sample_10_ConstantFold.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-8-错误的循环"><a class="header-anchor" href="#3-8-错误的循环"></a>3.8 错误的循环</h2>
<p>假设需要计算两个数相加的效率，那么可以有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample_11_Loops</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measureRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (x + y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于此，是否可以写一个循环，循环中进行 10 次相加运算，这 10 次循环相加的效率是否等于 1 次相加运算的 10 倍效率呢？</p>
<p>继续增加循环次数，100 次、1000 次、10000 次、100000 次，最终的效率是否是 1 次相加运算的效率的对应倍数呢？</p>
<p>JMH 提供了 <code>@OperationsPerInvocation</code> 注解，该注解接收 <code>int</code> 类型的 <code>value</code> 值，表示运行一次目标方法相当于运行了给定次数的 Benchmark。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">reps</span><span class="params">(<span class="type">int</span> reps)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; reps; i++) &#123;</span><br><span class="line">        s += (x + y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@OperationsPerInvocation(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measureWrong_1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> reps(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@OperationsPerInvocation(10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measureWrong_10</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> reps(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@OperationsPerInvocation(100)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measureWrong_100</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> reps(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@OperationsPerInvocation(1_000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measureWrong_1000</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> reps(<span class="number">1_000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@OperationsPerInvocation(10_000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measureWrong_10000</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> reps(<span class="number">10_000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@OperationsPerInvocation(100_000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measureWrong_100000</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> reps(<span class="number">100_000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试报告会和预期的一致吗？</p>
<p><code>measureRight()</code> 与 <code>measureWrong_1()</code> 的效率类似，但随着循环次数的增加，运行效率也在不断增加，循环 100000 次的效率与 1 次计算的效率更是天差地别。</p>
<p>这告诉我们在测试时，不要利用循环多次的效率来倒推每次的执行的效率，这往往是不准确的。对同种计算循环多次时，JVM 会对其进行优化，以提高执行效率。</p>
<h2 id="3-9-Fork"><a class="header-anchor" href="#3-9-Fork"></a>3.9 @Fork</h2>
<p>JMH 提供了一个 <code>@Fork</code> 注解，那他有什么用呢？一起探究下。</p>
<p>提供 <code>printRunningJvmName()</code> 方法，返回正在运行的 JVM 的名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printRunningJvmName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(<span class="string">&quot;---------------------------------------&quot;</span>);</span><br><span class="line">    System.out.println(name + <span class="string">&quot; jvm name is : &quot;</span> + ManagementFactory.getRuntimeMXBean().getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;---------------------------------------&quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>@Fork(0)</code></p>
</blockquote>
<p><code>@Fork</code> 注解可以作用在类上和方法上，当以 <code>@Fork(0)</code> 的形式作用在方法上时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Warmup(iterations = 1, time = 1)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 1, time = 1)</span></span><br><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample_12_Forking_0</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@Fork(0)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measure_1_c1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup(Level.Trial)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        printRunningJvmName(<span class="string">&quot;setup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        printRunningJvmName(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(Sample_12_Forking_0.class.getSimpleName())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 执行 main 方法与执行 Benchmark 是在同一个 JVM 中</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从最终的测试报告可知，执行 <code>main()</code> 方法与执行 Benchmark 是在同一个 JVM 中。</p>
<blockquote>
<p><code>@Fork(1)</code></p>
</blockquote>
<p>仅仅修改 <code>@Fork(0)</code> 为 <code>@Fork(1)</code>，最终的测试报告又会有什么变化呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@Fork(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measure_1_c1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时执行 <code>main()</code> 方法与执行 Benchmark 不在同一个 JVM 中，也就是在执行 JMH 的整个测试时，会 fork 出一个进程，创建出崭新的 JVM，在这个 JVM 中执行 Benchmark。</p>
<blockquote>
<p><code>@Fork(n)</code></p>
</blockquote>
<p>如果修改为 <code>@Fork(10)</code> 呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@Fork(10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measure_1_c1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Fork(10)</code> 表示在执行 JMH 的整个测试时，fork 出 10 个进程来执行 Benchmark。</p>
<p>fork 进程的操作不是并行的，也就是说，先 fork 出一个进程，创建出一个 JVM，执行 Benchmark，之后销毁 JVM 再 fork 出一个进程，重复 10 次。</p>
<p>注意，这里重复 10 次只是重复创建 10 次 JVM，执行 <code>setup()</code> 方法虽然也只执行了 10 次，但后者还和 <code>@Warmup</code>、<code>@Measurement</code> 和 <code>@Setup</code> 注解有关。</p>
<blockquote>
<p><code>@Fork</code></p>
</blockquote>
<p>如果不显式传入 <code>@Fork</code> 注解的 <code>value</code> 值，其默认值是 <code>-1</code>，这相当于显式传入 <code>5</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@Fork</span> <span class="comment">// 不传具体的值，即为 -1，相当于显式传入 5</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measure_1_c1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但不建议这么使用，如果要传入 <code>5</code>，应当显式指定 <code>value</code> 值为 <code>5</code>。</p>
<p>首先，显式传入的方式更加清晰明确，其次在 <code>@Fork</code> 注解的 Java doc 中并未说明不传具体的值就相当于传入 <code>5</code>，这是在自行测试后得出来的，但指不定在后续的版本中就修改了这个规则呢？</p>
<blockquote>
<p>官方示例</p>
</blockquote>
<p>首先定义 <code>Counter</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定义 <code>Counter1</code> 和 <code>Counter2</code> 作为 <code>Counter</code> 的实现类，但它们实现的逻辑都一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Counter1</span> <span class="keyword">implements</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Counter2</span> <span class="keyword">implements</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着定义 <code>measure()</code> 方法，该方法接收一个<code>Counter</code> 实例，在内部通过循环调用 10 次 <code>Counter</code> 的 <code>inc()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measure</span><span class="params">(Counter c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        s += c.inc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是一系列 Benchmark：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Counter</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter1</span>();</span><br><span class="line"><span class="type">Counter</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter2</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@Fork(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measure_1_c1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * JVM 在执行这段代码时，会假设 Counter 接口只有一个实现</span></span><br><span class="line"><span class="comment">     * 使用了方法内联的 JIT 优化手段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> measure(c1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@Fork(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measure_2_c2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * JVM 在执行这段代码的时候，发现接口的实现类有多个，</span></span><br><span class="line"><span class="comment">     * 使用 Java 的动态方法机制（运行时多态），跟方法内联相比，速度会显著降低</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> measure(c2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@Fork(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measure_3_c1_again</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> measure(c1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@Fork(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measure_4_forked_c1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> measure(c1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@Fork(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">measure_5_forked_c2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> measure(c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初看会认为每个 Benchmark 的测试结果都一样，但在实际运行后会发现它们之间存在着差异。</p>
<p>当测试 <code>measure_1_c1()</code> 时，传入 <code>c1</code> 调用 <code>measure()</code> 方法，JVM 在执行该方法时，会假设 <code>Counter</code> 接口只有一个实现，使用方法内联的 JIT 优化手段，提高执行效率。在测试 <code>measure_2_c2()</code> 时，传入 <code>c2</code> 调用 <code>measure()</code> 方法，同一个 JVM 在执行该方法时，发现 <code>Counter</code> 接口的实现类实际上有多个，使用 Java 的动态方法机制（运行时多态），相比于方法内联，这种方式的执行效率会降低。后续在测试 <code>measure_3_c1_again()</code> 时也是相同情况。</p>
<p>测试 <code>measure_4_forked_c1()</code> 时，该方法被 <code>@Fork(1)</code> 标记，表示测试时会新建一个 JVM 进行测试，此时又会使用方法内联进行优化，最后测试的 <code>measure_5_forked_c2()</code> 也是这样。</p>
<blockquote>
<p>什么时候使用 <code>@Fork</code></p>
</blockquote>
<p>现有如下测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SleepyState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> sleepTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        sleepTime = (<span class="type">long</span>) (Math.random() * <span class="number">1000</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sleepTime = &quot;</span> + sleepTime);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@Fork(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">baseline</span><span class="params">(SleepyState s)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(s.sleepTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目的很简单，在执行 Benchmark 前，获取一个 <code>[0, 1000)</code> 之间的随机数，然后休眠随机数值的毫秒。</p>
<p>最终测得该方法的平均耗时时间应该和获取的随机数差不多。</p>
<p>但问题也来了，随机数的范围很大，每次执行获取的值不同，极端情况下，第一次得到的是 0，第二次得到的是 999，难道这两次能反映整体的平均耗时时间吗？</p>
<p>显然是不行的。</p>
<p>根据大数定律，随着测试次数的增加，最终的效率就越趋近于真实执行效率。</p>
<p>此时可以利用 <code>@Fork</code> 注解，比如在 <code>@Fork(5)</code> 和 <code>@Fork(20)</code> 的情况下，<strong>理论上</strong> 后者应该更趋近于真实执行效率，即 <code>500 ms/op</code>，当然真正执行后 <code>@Fork(5)</code> 更接近也是有可能的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@Fork(5)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fork_1</span><span class="params">(SleepyState s)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(s.sleepTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@Fork(20)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fork_2</span><span class="params">(SleepyState s)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(s.sleepTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-10-Group-与-GroupThreads"><a class="header-anchor" href="#3-10-Group-与-GroupThreads"></a>3.10 @Group 与 @GroupThreads</h2>
<p>在计算两个都被 <code>@Benchmark</code> 注解标记的方法的执行效率时，在测试报告中，它们的执行效率会分开。</p>
<p>如果需要合并多个 Benchmark，可以使用 <code>@Group</code> 注解。使用 <code>@Group</code> 时，需要指定一个 <code>value</code> 值，JMH 会将具有相同 <code>value</code> 值的方法放到同一个 Benchmark 中执行，基于此可以创造一些线程之间的竞争关系。</p>
<p>与之搭配的还有 <code>@GroupThreads</code> 注解，该注解能够指定参与运行特定组的 Benchmark 方法的线程数。</p>
<p>回顾前文中的 <code>@State</code> 注解，它描述了类对象的作用域，它还有个 <code>value</code> 值是 <code>Scope.Group</code>，这在前文中没有提到，<code>@State(Scope.Group)</code> 指定了类对象的作用域是组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State(Scope.Group)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.Throughput)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.MILLISECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample_15_Asymmetric</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger counter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">()</span> &#123;</span><br><span class="line">        counter = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@Group(&quot;g1&quot;)</span></span><br><span class="line">    <span class="meta">@GroupThreads(3)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@Group(&quot;g1&quot;)</span></span><br><span class="line">    <span class="meta">@GroupThreads(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了名为 <code>g1</code> 的组，该组中有两个方法，分别是：</p>
<ul>
<li><code>inc()</code>：同时有三个线程执行 <code>AtomicInteger</code> 的 <code>incrementAndGet()</code> 方法</li>
<li><code>get()</code>：只有一个线程执行 <code>AtomicInteger</code> 的 <code>get()</code> 方法</li>
</ul>
<p>也就是说在 <code>g1</code> 中，同时会有四个线程在执行方法，<code>incrementAndGet()</code> 方法是线程安全的，其底层使用了 CAS，当有多个线程执行该方法时，会存在竞争。</p>
<p>除此之外，还定义了 <code>g2</code>、<code>g3</code> 组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@Group(&quot;g2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 只有一个线程在自增，效率很高</span></span><br><span class="line">    <span class="keyword">return</span> counter.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@Group(&quot;g3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 只有一个线程在 get，效率拉满</span></span><br><span class="line">    <span class="keyword">return</span> counter.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个组中只有一个线程在执行自增或 get，相比于存在线程竞争的 <code>g1</code>，这两个组中的方法的效率 <strong>应该</strong> 更高。</p>
<p>当然这不是一定的，这与硬件条件还有关系，如果发现 <code>g1</code> 的执行效率比 <code>g2</code> 更高，尝试增加 <code>g1</code> 的线程竞争关系，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@Group(&quot;g1&quot;)</span></span><br><span class="line"><span class="meta">@GroupThreads(100)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> counter.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@Group(&quot;g1&quot;)</span></span><br><span class="line"><span class="meta">@GroupThreads(30)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> counter.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时有 100 个线程执行自增，30 个线程执行 get。</p>
<h1 id="4-初阶实战示例"><a class="header-anchor" href="#4-初阶实战示例"></a>4. 初阶实战示例</h1>
<h2 id="4-1-排序算法的效率"><a class="header-anchor" href="#4-1-排序算法的效率"></a>4.1 排序算法的效率</h2>
<p>十大排序算法的复杂度、稳定性如下图（来源：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">十大经典排序算法 | 菜鸟教程</a>）所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/JavaImages/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83%E8%A1%A8.png" alt="排序算法比较表"></p>
<p>更多实现细节可以参考：</p>
<ul>
<li><a href="../Algorithm-Bubble-Selection-Heap-Sort/">【排序算法】冒泡、选择和堆排序</a></li>
<li><a href="../Algorithm-Insertion-Sort/">【排序算法】插入排序和二分搜索</a></li>
<li><a href="../Algorithm-Merge-Sort/">【排序算法】归并排序</a></li>
<li><a href="../Algorithm-Quick-Shell-Sort/">【排序算法】快速排序和希尔排序</a></li>
<li><a href="../Algorithm-Non-Comparative-Sort/">【排序算法】三种非比较排序</a></li>
</ul>
<p>单从平均时间复杂度上来看，冒泡排序、选择排序、插入排序的性能是低于希尔排序、归并排序、快速排序和堆排序的。事实真是如此吗？</p>
<p>设定待排序数组内部元素取值为 0 到 100 的整数，编写 Benchmark 对上述排序算法效率进行比较。</p>
<blockquote>
<p>数组长度为 10</p>
</blockquote>
<pre>
Benchmark                    Mode  Cnt     Score   Error  Units
SortBenchmark.bubbleSort     avgt        148.637          ns/op
SortBenchmark.bucketSort     avgt        614.930          ns/op
SortBenchmark.countingSort   avgt        229.073          ns/op
SortBenchmark.heapSort       avgt        175.842          ns/op
SortBenchmark.insertSort     avgt        118.565          ns/op
SortBenchmark.mergeSort      avgt        665.085          ns/op
SortBenchmark.quickSort      avgt        187.735          ns/op
SortBenchmark.radixSort      avgt       5351.363          ns/op
SortBenchmark.selectionSort  avgt        122.999          ns/op
SortBenchmark.shellSort      avgt        149.182          ns/op
</pre>
<p>以快速排序 quickSort 和插入排序 insertSort 为例，前者的平均时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，后者为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，但根据测试报表可知，在数组长度为 10 的情况下，插入排序的效率更高。</p>
<blockquote>
<p>数组长度为 100</p>
</blockquote>
<pre>
Benchmark                    Mode  Cnt      Score   Error  Units
SortBenchmark.bubbleSort     avgt       10199.883          ns/op
SortBenchmark.bucketSort     avgt        3765.742          ns/op
SortBenchmark.countingSort   avgt        2896.813          ns/op
SortBenchmark.heapSort       avgt        3061.878          ns/op
SortBenchmark.insertSort     avgt        1335.316          ns/op
SortBenchmark.mergeSort      avgt       12285.984          ns/op
SortBenchmark.quickSort      avgt        2555.055          ns/op
SortBenchmark.radixSort      avgt       23673.644          ns/op
SortBenchmark.selectionSort  avgt        4337.397          ns/op
SortBenchmark.shellSort      avgt        2487.184          ns/op
</pre>
<p>此时依旧是插入排序的效率更高。</p>
<blockquote>
<p>数组长度为 10000</p>
</blockquote>
<pre>
Benchmark                    Mode  Cnt         Score   Error  Units
SortBenchmark.bubbleSort     avgt       61518470.000          ns/op
SortBenchmark.bucketSort     avgt        1275125.000          ns/op
SortBenchmark.countingSort   avgt          25470.588          ns/op
SortBenchmark.heapSort       avgt         538462.500          ns/op
SortBenchmark.insertSort     avgt        2728411.765          ns/op
SortBenchmark.mergeSort      avgt       55002733.333          ns/op
SortBenchmark.quickSort      avgt         362605.556          ns/op
SortBenchmark.radixSort      avgt       43962510.000          ns/op
SortBenchmark.selectionSort  avgt       14798706.667          ns/op
SortBenchmark.shellSort      avgt         440547.059          ns/op
</pre>
<p>此时情况发生了好转，快速排序的效率明显领先于插入排序。</p>
<blockquote>
<p>总结</p>
</blockquote>
<p>在判断某一算法的实际效率时，不能一昧迷信时间复杂度，在数组长度较小的情况下，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的插入排序效率也能比 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的快速排序效率高。</p>
<p>正因如此，JDK 底层对 <code>Arrays.sort()</code> 方法的实现也不是简单选用一种排序算法，不同的数组情况，将选择不同的排序算法，比如当数组长度较小时，选择插入排序作为排序逻辑。</p>
<h2 id="4-2-Map-for"><a class="header-anchor" href="#4-2-Map-for"></a>4.2 Map &gt; for ?</h2>
<p>对于 <code>for</code> 循环来说，认为其时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，而对于根据 key 从 <code>Map</code> 中获取对应的 <code>value</code>，认为其时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。单看时间复杂度，<code>Map</code> 的效率大于 <code>for</code> 循环，事实真是如此吗？</p>
<blockquote>
<p>以枚举为例</p>
</blockquote>
<p>以枚举的使用为例，实际开发过程中，枚举类中并不是只有枚举项，通常还会包含其他附加描述信息，比如 <code>code</code>、<code>value</code> 等，然后在使用时根据这些附加信息获取对应的枚举项。</p>
<p>以根据 <code>value</code> 获取枚举项为例：</p>
<ul>
<li>既可以遍历每个枚举项，找到与传入 <code>value</code> 对应的枚举项</li>
<li>也可以用 <code>value</code> 为 key，枚举项为 value 构造 <code>Map</code>，通过该 <code>Map</code> 获取对应的枚举项</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/12/26 23:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumMatch</span> &#123;</span><br><span class="line">    A(<span class="number">1</span>),</span><br><span class="line">    B(<span class="number">2</span>),</span><br><span class="line">    C(<span class="number">3</span>),</span><br><span class="line">    D(<span class="number">4</span>),</span><br><span class="line">    E(<span class="number">5</span>),</span><br><span class="line">    F(<span class="number">6</span>),</span><br><span class="line">    G(<span class="number">7</span>),</span><br><span class="line">    H(<span class="number">8</span>),</span><br><span class="line">    I(<span class="number">9</span>),</span><br><span class="line">    J(<span class="number">10</span>),</span><br><span class="line">    NULL(-<span class="number">1</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer value;</span><br><span class="line"></span><br><span class="line">    EnumMatch(Integer value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumMatch <span class="title function_">matchWithFor</span><span class="params">(Integer value)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (EnumMatch enumMatch : values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (enumMatch.value.equals(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> enumMatch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, EnumMatch&gt; ENUM_MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (EnumMatch enumMatch : values()) &#123;</span><br><span class="line">            ENUM_MAP.put(enumMatch.value, enumMatch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumMatch <span class="title function_">matchWithMap</span><span class="params">(Integer value)</span> &#123;</span><br><span class="line">        <span class="type">EnumMatch</span> <span class="variable">result</span> <span class="operator">=</span> ENUM_MAP.get(value);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            result = EnumMatch.NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EnumMatch</code> 中除 <code>NULL</code> 外，共有 10 个有效的枚举项。</p>
<p>随机生成一个 1 到 10 的随机数，测试使用 <code>for</code> 和 <code>Map</code> 获取对应枚举项的效率：</p>
<pre>
Benchmark                      Mode  Cnt   Score   Error  Units
EnumMatchBenchmark.matchByFor  avgt       27.367          ns/op
EnumMatchBenchmark.matchByMap  avgt       19.456          ns/op
</pre>
<p>此时通过 <code>Map</code> 获取对应枚举项的效率要更高些，但两者的差距并不大。</p>
<p>枚举通常用于类型的表示，其个数往往在 5 个以内。</p>
<p>假设只有 3 个有效的枚举项，随机生成一个 1 到 3 的随机数，测试 <code>for</code> 与 <code>Map</code> 的效率：</p>
<pre>
Benchmark                      Mode  Cnt   Score   Error  Units
EnumMatchBenchmark.matchByFor  avgt       21.513          ns/op
EnumMatchBenchmark.matchByMap  avgt       19.134          ns/op
</pre>
<p>尽管依旧是 <code>Map</code> 的效率领先，但二者的差距基本可以忽略不计。</p>
<p>从代码简洁的角度来看，显然是使用 <code>for</code> 更加简洁、清晰，减少了样板代码的出现。</p>
<blockquote>
<p>以对象为例</p>
</blockquote>
<p>业务开发中，实体类往往存在一个表示唯一标识的字段，后续可能需要从一组数据中筛选出给定标识指向的实体对象。对于筛选方式的实现往往有：</p>
<ul>
<li>
<p>简单暴力使用 <code>for</code> 循环</p>
</li>
<li>
<p>性能极致使用 <code>Map</code></p>
</li>
<li>
<p>简洁易读使用 <code>Stream</code></p>
</li>
</ul>
<p>在一般的认知中，这三种方式的筛选效率关系为：</p>
<pre>
Map &gt; for &gt; Stream
</pre>
<p>事实真是如此吗？</p>
<p>使用整型字段 <code>a</code> 作为 <code>TestObj</code> 对象中的唯一标识，现在需要从 10 个 <code>TestObj</code> 对象中筛选出唯一标识与给定整数相同的 <code>TestObj</code> 对象，使用上述三种筛选方式实现并测试它们的效率：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@Warmup(iterations = 2, time = 5)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 2, time = 5)</span></span><br><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="meta">@Fork(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestObjBenchmark</span> &#123;</span><br><span class="line">    List&lt;TestObj&gt; list;</span><br><span class="line">    Map&lt;Integer, TestObj&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup(Level.Trial)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepareValue</span><span class="params">()</span> &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">TestObj</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestObj</span>();</span><br><span class="line">            obj.setA(i);</span><br><span class="line">            list.add(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (TestObj obj : list) &#123;</span><br><span class="line">            map.put(obj.getA(), obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup(Level.Invocation)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepareA</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">RandomDataGenerator</span>().nextInt(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> TestObj <span class="title function_">getByStream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.stream()</span><br><span class="line">                .filter(i -&gt; i.getA().equals(a))</span><br><span class="line">                .findFirst()</span><br><span class="line">                .orElse(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> TestObj <span class="title function_">getByFor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (TestObj obj : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj.getA().equals(a)) &#123;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> TestObj <span class="title function_">getByMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(TestObjBenchmark.class.getSimpleName())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(options).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的测试报告如下：</p>
<pre>
Benchmark                     Mode  Cnt   Score   Error  Units
TestObjBenchmark.getByFor     avgt    2  37.708          ns/op
TestObjBenchmark.getByMap     avgt    2  22.698          ns/op
TestObjBenchmark.getByStream  avgt    2  59.334          ns/op
</pre>
<p>执行效率的大小关系与先前预想的一致，但它们之间的差距其实也不大。</p>
<p>尽管使用 <code>Stream</code> 的效率最低，但在效率要求不高的场景下，使用 <code>Stream</code> 会让代码更加简洁、清晰，并能极大减少样板代码的输出。</p>
<h2 id="4-3-报表可视化"><a class="header-anchor" href="#4-3-报表可视化"></a>4.3 报表可视化</h2>
<p>除了在控制台中输出测试报告外，JMH 允许以不同的文件格式输出测试报告。比如以 JSON 文件的形式，将测试报告输出到当前模块下 <code>target</code> 目录的 <code>result.json</code> 文件中，则需要在构造 <code>Options</code> 对象时进行以下配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">    <span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">            .include(TestObjBenchmark.class.getSimpleName())</span><br><span class="line">            <span class="comment">// 报表可视化，输出 JSON 文件</span></span><br><span class="line">            .resultFormat(ResultFormatType.JSON)</span><br><span class="line">            <span class="comment">// 输出到当前模块下的 target 目录下</span></span><br><span class="line">            .result(<span class="string">&quot;./official-sample/target/result.json&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Runner</span>(options).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在拿到 <code>result.json</code> 文件后，将该文件拖入以下任意一个网站中，即可实现报表可视化：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://jmh.morethan.io/">JMH Visualizer</a></li>
<li><a target="_blank" rel="noopener" href="https://deepoove.com/jmh-visual-chart/">JMH Visual Chart</a></li>
</ul>
<h1 id="5-高阶使用技巧"><a class="header-anchor" href="#5-高阶使用技巧"></a>5. 高阶使用技巧</h1>
<h2 id="5-1-调整-JVM-编译器策略"><a class="header-anchor" href="#5-1-调整-JVM-编译器策略"></a>5.1 调整 JVM 编译器策略</h2>
<p>首先介绍下 JVM 的方法内联：在编译过程中遇到方法调用时，将调用的目标方法体纳入编译范围之中，并取代原方法调用的优化手段。</p>
<p>比如现有一个私有方法 <code>b()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    i++;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>a()</code> 方法中调用了 <code>b()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 调用私有方法，执行 invokespecial 指令</span></span><br><span class="line">        <span class="comment">// 方法入栈、分配栈上内存</span></span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 <code>b()</code> 方法时，执行 <code>invokespecial</code> 指令。</p>
<p>方法调用也是有性能消耗的，比如会进行方法入栈、分配栈上内存等。</p>
<p>JVM 在编译上述代码时，发现对 <code>b()</code> 方法的调用可以优化为方法内联，即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时不再有对 <code>b()</code> 方法的调用，能够提高执行效率。</p>
<p><strong>注意：</strong> 不是说任何方法的调用都能优化成方法内联，具体细节不再展开，详细内容可以参考周志明《深入理解Java虚拟机》一书中第四部分【程序编译与代码优化】中【编译器优化技术】的【方法内联】。</p>
<p>为了测试方法内联带来的性能影响，JMH 提供了 <code>@CompilerControl</code> 注解，该注解能够告知 JVM 如何对代码进行编译优化（或者说不优化）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">target_blank</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DONT_INLINE: 不进行方法内联优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CompilerControl(CompilerControl.Mode.DONT_INLINE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">target_dontInline</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * INLINE: 强制进行方法内联优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CompilerControl(CompilerControl.Mode.INLINE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">target_inline</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EXCLUDE: 禁止编译，始终使用解释执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CompilerControl(CompilerControl.Mode.EXCLUDE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">target_exclude</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对这些方法进行测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">baseline</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">blank</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 自动优化</span></span><br><span class="line">    target_blank();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dontinline</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 较慢</span></span><br><span class="line">    target_dontInline();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inline</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 最快</span></span><br><span class="line">    target_inline();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exclude</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 最慢</span></span><br><span class="line">    target_exclude();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试报告如下：</p>
<pre>
Benchmark                             Mode  Cnt  Score   Error  Units
Sample_16_CompilerControl.baseline    avgt    3  0.196 ± 0.002  ns/op
Sample_16_CompilerControl.blank       avgt    3  0.196 ± 0.006  ns/op
Sample_16_CompilerControl.dontinline  avgt    3  0.811 ± 2.552  ns/op
Sample_16_CompilerControl.exclude     avgt    3  8.508 ± 1.443  ns/op
Sample_16_CompilerControl.inline      avgt    3  0.222 ± 0.792  ns/op
</pre>
<p>在采用 <code>EXCLUDE</code> 时，执行耗时最长。</p>
<p><code>dontinline()</code> 与 <code>inline()</code> 相比，后者的执行效率更高，进行方法内联优化后，执行效率能得到提升。</p>
<h2 id="5-2-同步线程"><a class="header-anchor" href="#5-2-同步线程"></a>5.2 同步线程</h2>
<p>JMH 在默认情况下，如何执行多线程的基准测试？</p>
<p>JMH 会等待所有线程都启动准备好之后，再同时执行 Benchmark，此时系统负载最高，CPU 使用率最高。</p>
<p>这与实际生产环境上不一样，生产环境上显然不可能等待所有线程都准备好之后，再等待请求访问，系统负载应该是逐步上升，CPU 使用率也是逐步提高。</p>
<p>在使用 <code>OptionsBuilder</code> 构造 <code>Options</code> 对象时，提供了 <code>syncIterations()</code> 方法，该方法能够设置线程同步。默认情况下，其值为 <code>true</code>，表示 JMH 将尝试同步所有工作线程的迭代，以便它们同时开始每次迭代，并在所有线程完成后结束迭代。这可以帮助减少线程之间的协调开销对基准测试结果的影响。</p>
<p>这个选项并不总是有用的。在某些情况下，同步迭代可能会导致额外的同步开销，从而扭曲基准测试结果。此外，如果测试的代码本身就包含同步，那么同步迭代可能会隐藏这些同步的开销。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.MILLISECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample_17_SyncIterations</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> src;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为演示耗时而存在，没有特殊意义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> src;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            s = Math.sin(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(Sample_17_SyncIterations.class.getSimpleName())</span><br><span class="line">                .warmupTime(TimeValue.seconds(<span class="number">1</span>))</span><br><span class="line">                .warmupIterations(<span class="number">1</span>)</span><br><span class="line">                .measurementTime(TimeValue.seconds(<span class="number">1</span>))</span><br><span class="line">                <span class="comment">// 设置线程数为 CPU 核心数 * 16</span></span><br><span class="line">                <span class="comment">// I9-13980HX 32 核心 -&gt; 32 * 16 = 512 线程</span></span><br><span class="line">                .threads(Runtime.getRuntime().availableProcessors() * <span class="number">16</span>)</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 默认值为 true。</span></span><br><span class="line"><span class="comment">                 * true: 线程同步，所有先线程准备好之后再执行</span></span><br><span class="line"><span class="comment">                 * false: 线程逐步执行</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .syncIterations(<span class="literal">true</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置为 <code>true</code> 时：</p>
<pre>
Benchmark                       Mode  Cnt     Score      Error   Units
Sample_17_SyncIterations.test  thrpt    5  8628.210 ± 2454.625  ops/ms
</pre>
<p>设置为 <code>false</code> 时：</p>
<pre>
Benchmark                       Mode  Cnt      Score       Error   Units
Sample_17_SyncIterations.test  thrpt    5  47739.259 ± 98840.596  ops/ms
</pre>
<h2 id="5-3-Control-对象"><a class="header-anchor" href="#5-3-Control-对象"></a>5.3 Control 对象</h2>
<p>在 Benchmark 中写死循环是一件很危险的事，很有可能导致运行无法停止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State(Scope.Group)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample_18_Control_1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@Group(&quot;pingpong&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pingWithoutControl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// flag 期望是 false 时，才设置为 true，否则不设置</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">setSuccess</span> <span class="operator">=</span> flag.compareAndSet(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (setSuccess) &#123;</span><br><span class="line">                <span class="comment">// 设置成功才结束循环，否则一直循环</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@Group(&quot;pingpong&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pongWithoutControl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">setSuccess</span> <span class="operator">=</span> flag.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (setSuccess) &#123;</span><br><span class="line">                <span class="comment">// 设置成功才结束循环，否则一直循环</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在成员变量 <code>flag</code>，<code>pingWithoutControl()</code> 和 <code>pongWithoutControl()</code> 方法都在死循环中尝试对 <code>flag</code> 进行修改。</p>
<p><strong>这两个方法是并行运行的，</strong> 因此可能出现以下情况，导致陷入死循环：</p>
<ul>
<li><code>pingWithoutControl()</code> 方法检查 <code>flag</code>，发现其值为 <code>true</code>，尝试将其修改为 <code>false</code>；</li>
<li><code>pingWithoutControl()</code> 方法在尝试修改的同时，<code>pongWithoutControl()</code> 将 <code>flag</code> 从 <code>false</code> 改成了 <code>true</code>；</li>
<li>此时 <code>pingWithoutControl()</code> 的 CAS 操作就会失败，期望值不再是 <code>true</code>，就导致 <code>pingWithoutControl()</code> 一直处在死循环中。</li>
</ul>
<p>同样的情况也可能发生在 <code>pongWithoutControl()</code> 方法中，不再赘述。</p>
<p>如果有办法判断 JMH 的测试是否已经结束，就能规避此处的死循环。当 JMH 测试结束时，也退出循环。</p>
<p>JMH 提供了 <code>Control</code> 类，当其作为 Benchmark 方法的参数时，JMH 能够将 <code>Control</code> 对象注入到方法中。<code>Control</code> 提供了 JMH 测试开始与结束的判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State(Scope.Group)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample_18_Control_2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@Group(&quot;pingpong&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pingWithoutControl</span><span class="params">(Control cnt)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 测试结束，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (cnt.stopMeasurement) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// flag 期望是 false 时，才设置为 true，否则不设置</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">setSuccess</span> <span class="operator">=</span> flag.compareAndSet(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (setSuccess) &#123;</span><br><span class="line">                <span class="comment">// 设置成功才结束循环，否则一直循环</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@Group(&quot;pingpong&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pongWithoutControl</span><span class="params">(Control cnt)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 测试结束，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (cnt.stopMeasurement) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">setSuccess</span> <span class="operator">=</span> flag.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (setSuccess) &#123;</span><br><span class="line">                <span class="comment">// 设置成功才结束循环，否则一直循环</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 JMH 测试结束时，也会退出循环，无论运行几次，都不会出现死循环。</p>
<h2 id="5-4-SpringBoot-环境下使用-JMH"><a class="header-anchor" href="#5-4-SpringBoot-环境下使用-JMH"></a>5.4 SpringBoot 环境下使用 JMH</h2>
<p>定义 <code>CallService</code> 模拟实际生产环境中的 Service：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Math.sqrt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写测试类使用 JMH 测试 <code>CallService</code> 中 <code>call()</code> 方法的性能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@State(Scope.Benchmark)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.Throughput)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setCallService</span><span class="params">(CallService callService)</span> &#123;</span><br><span class="line">        BeanHolder.setBean(callService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CallService callService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        callService = BeanHolder.getBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        callService.call();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeBenchmark</span><span class="params">()</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line">        <span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(<span class="string">&quot;\\.&quot;</span> + <span class="built_in">this</span>.getClass().getSimpleName() + <span class="string">&quot;\\.&quot;</span>)</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * forks 一定要设置成 0</span></span><br><span class="line"><span class="comment">                 * 让 Benchmark 和启动方法在同一个 JVM 中执行</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .forks(<span class="number">0</span>)</span><br><span class="line">                .warmupIterations(<span class="number">1</span>)</span><br><span class="line">                .warmupTime(TimeValue.seconds(<span class="number">1</span>))</span><br><span class="line">                .measurementIterations(<span class="number">1</span>)</span><br><span class="line">                .measurementTime(TimeValue.seconds(<span class="number">1</span>))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(options).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码不长，有几个注意点：</p>
<ul>
<li>
<p>JMH 相关的注解（比如 <code>@State</code>、<code>@BenchmarkMode</code> 等）还是放在类上；</p>
</li>
<li>
<p>注入 <code>CallService</code> 不再采用字段注入，而是使用 Set 注入，并结合 <code>BeanHolder</code> 以便在 <code>@Setup</code> 方法中为成员变量设置初始值；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setBean</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">        BeanHolder.bean = bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在被 <code>@Test</code> 注解标记的测试方法中构造 <code>Options</code> 对象，执行 <code>Runner</code> 的 <code>run()</code> 方法进行测试；</p>
</li>
<li>
<p>构造 <code>Options</code> 对象时，<code>forks()</code> 方法的参数 <strong>一定要设置成 0</strong>，使得 Benchmark 和启动方法在同一个 JVM 中运行；</p>
</li>
<li>
<p>Benchmark 的编写与先前无异</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mofan212.github.io">默烦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mofan212.github.io/posts/JMH/">https://mofan212.github.io/posts/JMH/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mofan212.github.io" target="_blank">Mofan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JMH/">JMH</a></div><div class="post_share"><div class="social-share" data-image="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/144.jpg" data-sites="wechat,qq,weibo,facebook,twitter"></div><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://jsd.onmicrosoft.cn/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/AliPay.png" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/img/AliPay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="/img/WeChatPay.png" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/img/WeChatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/MySQL-Advanced-Sixth-Data-Structure-Of-Index/" title="【MySQL 高级篇六】索引的数据结构"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/145.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【MySQL 高级篇六】索引的数据结构</div></div></a></div><div class="next-post pull-right"><a href="/posts/Using-Lambda-Expressions-To-Refactor-Backtracking/" title="使用 Lambda 表达式重构成回溯"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/143.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">使用 Lambda 表达式重构成回溯</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/Combinator-Pattern/" title="Combinator Pattern"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/149.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-28</div><div class="title">Combinator Pattern</div></div></a></div><div><a href="/posts/Design-Pattern-Mediator-Pattern/" title="【设计模式】中介者模式"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/148.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-03</div><div class="title">【设计模式】中介者模式</div></div></a></div><div><a href="/posts/Design-Pattern-Proxy-Pattern/" title="【设计模式】代理模式"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/19.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-28</div><div class="title">【设计模式】代理模式</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">默烦</div><div class="author-info__description">彩笔的打怪升级之路...</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">150</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/23658864/dynamic"><i class="fas fa-running"></i><span>关注我的B站</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mofan212" target="_blank" title="GitHub"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:cy.mofan@foxmail.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站所有博文均是博主的学习笔记与个人理解。<strong><font style="color:red">除特别注明外，</font>如需转载，请在文章头部醒目处附带原文链接并<a target="_blank" rel="noopener" href="https://mofan212.gitee.io/mine/" style="color:#49B1F5;text-decoration:underline">告知我</a></strong>你将转载。😊</br><strong><font style="color:red">严禁未遵循规范的转载。</font></strong>😡</br><strong>死去的评论系统复活啦！欢迎到留言板畅所欲言！</strong>当然也可以使用更高效的<a target="_blank" href="https://space.bilibili.com/23658864/dynamic" style="color:#49B1F5;text-decoration:underline"> 哔哩哔哩私信 </a>或<a href="mailto:cy.mofan@foxmail.com" style="color:#49B1F5;text-decoration:underline" target="_blank">邮箱</a>。 😉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%B8%8B%E8%BD%BD%E6%9E%84%E5%BB%BA%E5%AE%98%E6%96%B9%E6%BA%90%E7%A0%81"><span class="toc-text">1. 下载构建官方源码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Hello-World"><span class="toc-text">2. Hello World</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">3. 使用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Warmup-%E4%B8%8E-Measurement"><span class="toc-text">3.1 @Warmup 与 @Measurement</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-BenchmarkMode"><span class="toc-text">3.2 @BenchmarkMode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-State"><span class="toc-text">3.3 @State</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Setup-%E5%92%8C-TearDown"><span class="toc-text">3.4 @Setup 和 @TearDown</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Dead-Code"><span class="toc-text">3.5 Dead Code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Blackhole"><span class="toc-text">3.6 Blackhole</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E5%B8%B8%E9%87%8F%E6%8A%98%E5%8F%A0"><span class="toc-text">3.7 常量折叠</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E9%94%99%E8%AF%AF%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="toc-text">3.8 错误的循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-Fork"><span class="toc-text">3.9 @Fork</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-Group-%E4%B8%8E-GroupThreads"><span class="toc-text">3.10 @Group 与 @GroupThreads</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%88%9D%E9%98%B6%E5%AE%9E%E6%88%98%E7%A4%BA%E4%BE%8B"><span class="toc-text">4. 初阶实战示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87"><span class="toc-text">4.1 排序算法的效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Map-for"><span class="toc-text">4.2 Map &gt; for ?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%8A%A5%E8%A1%A8%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-text">4.3 报表可视化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E9%AB%98%E9%98%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="toc-text">5. 高阶使用技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E8%B0%83%E6%95%B4-JVM-%E7%BC%96%E8%AF%91%E5%99%A8%E7%AD%96%E7%95%A5"><span class="toc-text">5.1 调整 JVM 编译器策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B"><span class="toc-text">5.2 同步线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Control-%E5%AF%B9%E8%B1%A1"><span class="toc-text">5.3 Control 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-SpringBoot-%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8-JMH"><span class="toc-text">5.4 SpringBoot 环境下使用 JMH</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/LinkedHashMap-In-JDK21/" title="JDK21 中的 LinkedHashMap"><img src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/150.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JDK21 中的 LinkedHashMap"/></a><div class="content"><a class="title" href="/posts/LinkedHashMap-In-JDK21/" title="JDK21 中的 LinkedHashMap">JDK21 中的 LinkedHashMap</a><time datetime="2024-07-06T16:00:00.000Z" title="更新于 2024-07-07 00:00:00">2024-07-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/The-Basics-Of-Linux-Part-One/" title="【上篇】Linux 基础"><img src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/96.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【上篇】Linux 基础"/></a><div class="content"><a class="title" href="/posts/The-Basics-Of-Linux-Part-One/" title="【上篇】Linux 基础">【上篇】Linux 基础</a><time datetime="2024-07-04T16:00:00.000Z" title="更新于 2024-07-05 00:00:00">2024-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Quick-Start-To-Arthas/" title="Arthas 快速入门"><img src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/127.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Arthas 快速入门"/></a><div class="content"><a class="title" href="/posts/Quick-Start-To-Arthas/" title="Arthas 快速入门">Arthas 快速入门</a><time datetime="2024-07-01T16:00:00.000Z" title="更新于 2024-07-02 00:00:00">2024-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Commonly-Used-Classes-In-Java/" title="Java 常用类"><img src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/65.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java 常用类"/></a><div class="content"><a class="title" href="/posts/Commonly-Used-Classes-In-Java/" title="Java 常用类">Java 常用类</a><time datetime="2024-06-28T16:00:00.000Z" title="更新于 2024-06-29 00:00:00">2024-06-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Annotation-And-Reflection/" title="注解、类的加载、反射"><img src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="注解、类的加载、反射"/></a><div class="content"><a class="title" href="/posts/Annotation-And-Reflection/" title="注解、类的加载、反射">注解、类的加载、反射</a><time datetime="2024-06-26T16:00:00.000Z" title="更新于 2024-06-27 00:00:00">2024-06-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Supplement-Of-Java-Related-Knowledge-First/" title="Java 相关知识补充"><img src= "/img/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java 相关知识补充"/></a><div class="content"><a class="title" href="/posts/Supplement-Of-Java-Related-Knowledge-First/" title="Java 相关知识补充">Java 相关知识补充</a><time datetime="2024-06-05T16:00:00.000Z" title="更新于 2024-06-06 00:00:00">2024-06-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 默烦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://jsd.onmicrosoft.cn/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://jsd.onmicrosoft.cn/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://jsd.onmicrosoft.cn/npm/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://jsd.onmicrosoft.cn/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://jsd.onmicrosoft.cn/npm/katex/dist/katex.min.css"><script src="https://jsd.onmicrosoft.cn/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://jsd.onmicrosoft.cn/npm/mermaid@10.9.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://jsd.onmicrosoft.cn/gh/mofan212/blog-static-resources@master/js/mine.min.js"></script><script src="https://npm.elemecdn.com/mermaid/dist/mermaid.min.js"></script><script defer="defer" id="ribbon" src="https://jsd.onmicrosoft.cn/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://jsd.onmicrosoft.cn/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Azathoth,Yog-Sothoth,Shub-Niggurath,Nyarlathotep,Cthulhu,Hastur,Abhoth,Ghroth,Tsathoggua,Cthugha,Deep Ones,Dagon,Chaugnar Faugn,Mordiggian,Shoggoth,Old One,Mi-Go,Great Race of Yith,Flying Polyp,Hounds of Tindalos,Dhole" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/@docsearch/css/dist/style.min.css"/><script src="https://jsd.onmicrosoft.cn/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'BAFEL7A6K1',
    apiKey: '89fcb5961984c5c054bf04149f345f38',
    indexName: 'mofan212io',
    container: '#docsearch',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>
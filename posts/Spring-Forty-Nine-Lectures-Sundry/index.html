<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【Spring 四十九讲】杂项 | Mofan</title><meta name="author" content="默烦,cy.mofan@foxmail.com"><meta name="copyright" content="默烦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring 四十九讲中第卌三讲到第卌九讲，杂项。">
<meta property="og:type" content="article">
<meta property="og:title" content="【Spring 四十九讲】杂项">
<meta property="og:url" content="https://mofan212.github.io/posts/Spring-Forty-Nine-Lectures-Sundry/index.html">
<meta property="og:site_name" content="Mofan">
<meta property="og:description" content="Spring 四十九讲中第卌三讲到第卌九讲，杂项。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/126.jpg">
<meta property="article:published_time" content="2023-02-02T16:00:00.000Z">
<meta property="article:modified_time" content="2023-03-27T16:00:00.000Z">
<meta property="article:author" content="默烦">
<meta property="article:tag" content="SpringBoot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/126.jpg"><link rel="shortcut icon" href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/favicon.png"><link rel="canonical" href="https://mofan212.github.io/posts/Spring-Forty-Nine-Lectures-Sundry/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 默烦","link":"链接: ","source":"来源: Mofan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://fastly.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【Spring 四十九讲】杂项',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/mofan212/blog-static-resources@master/css/myStyle.min.css"><link rel="stylesheet" href="https://cdn.staticfile.net/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css" /><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Mofan" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/mofan212/blog-static-resources/css/minimal.min.css"/><script src="https://fastly.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">155</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/post_top_img.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Mofan</span></a><a class="nav-page-title" href="/"><span class="site-name">【Spring 四十九讲】杂项</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【Spring 四十九讲】杂项</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-02T16:00:00.000Z" title="发表于 2023-02-03 00:00:00">2023-02-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-27T16:00:00.000Z" title="更新于 2023-03-28 00:00:00">2023-03-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SpringBoot/">SpringBoot</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">10.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;距离本文上次更新已经过去&quot;,&quot;messageNext&quot;:&quot;天，请注意时效性。&quot;,&quot;postUpdate&quot;:&quot;2023-03-28 00:00:00&quot;}" hidden></div><p>封面画师：T5-茨舞（微博）     封面ID：104959772</p>
<p>参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1P44y1N7QG">黑马程序员Spring视频教程，全面深度讲解spring5底层原理</a></p>
<p>源码仓库：<a target="_blank" rel="noopener" href="https://github.com/mofan212/advanced-spring">mofan212/advanced-spring (github.com)</a></p>
<h1 id="43-FactoryBean"><a class="header-anchor" href="#43-FactoryBean"></a>43. FactoryBean</h1>
<p><code>FactoryBean</code> 是一个接口，可以实现该接口，并指定一个泛型，在重写的方法指定泛型类型对象的创建，然后将实现类交由 Spring 管理，最后 Spring 容器中会增加泛型类型的 Bean。这个 Bean 并不是完全受 Spring 管理，或者说部分受 Spring 管理。</p>
<p>为什么这么说呢？</p>
<p>首先定义一个 <code>Bean2</code>，交由 Spring 管理，但它不是重点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后定义 <code>Bean1</code>，它未交由 Spring 管理，但是在其内部注入了 <code>Bean2</code>、定义初始化方法、实现 <code>Aware</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">getBean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;setBeanFactory(&#123;&#125;)&quot;</span>, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义 <code>Bean1FactoryBean</code>，实现 <code>FactoryBean</code> 接口，指定泛型为 <code>Bean1</code>，将其交由 Spring 管理，Bean 的名称是 <code>bean1</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component(&quot;bean1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1FactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Bean1&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        log.debug(<span class="string">&quot;create bean: &#123;&#125;&quot;</span>, bean1);</span><br><span class="line">        <span class="keyword">return</span> bean1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Bean1.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种方式添加到 Spring 容器中的 Bean 的名称是 <code>bean1</code>，但 Bean 的类型不是 <code>Bean1FactoryBean</code>，或者 <code>FactoryBean</code>，而是 <code>Bean1</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A43</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A43.class);</span><br><span class="line">        <span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;bean1&quot;</span>, Bean1.class);</span><br><span class="line">        System.out.println(bean1);</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>main()</code> 方法后，控制台打印出：</p>
<pre>
indi.mofan.a43.Bean1FactoryBean     - create bean: indi.mofan.a43.Bean1@2667f029 
indi.mofan.a43.Bean1@2667f029
</pre>
<p><code>Bean1</code> 类型的 Bean 被成功添加到 Spring 容器中，但根据打印的日志信息可以看出这个 Bean 没有经历依赖注入阶段、没有回调 <code>Aware</code> 接口、没有经历初始化阶段，其创建是由重写的 <code>getObject()</code> 方法完成的。</p>
<p>这个 Bean 就真的没有经历 Spring Bean 的生命周期中的任何阶段吗？</p>
<p>定义 <code>Bean1PostProcessor</code>，实现 <code>BeanPostProcessor</code> 接口，在 <code>bean1</code> 初始化前后打印日志信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1PostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;bean1&quot;</span>.equals(beanName) &amp;&amp; bean <span class="keyword">instanceof</span> Bean1) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;before [&#123;&#125;] init&quot;</span>, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;bean1&quot;</span>.equals(beanName) &amp;&amp; bean <span class="keyword">instanceof</span> Bean1) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;after [&#123;&#125;] init&quot;</span>, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 <code>main()</code> 方法后，控制台打印出：</p>
<pre>
indi.mofan.a43.Bean1FactoryBean     - create bean: indi.mofan.a43.Bean1@6a28ffa4 
indi.mofan.a43.Bean1PostProcessor   - after [bean1] init 
indi.mofan.a43.Bean1@6a28ffa4
</pre>
<p><code>bean1</code> 进行了初始化后的增强逻辑，但未进行初始化前的增强逻辑。</p>
<p>创建代理对象的时机就是在初始化后，因此由 <code>FactoryBean</code> 创建的 Bean <strong>可以进行代理增强</strong> 。</p>
<blockquote>
<p><code>FactoryBean</code> 接口</p>
</blockquote>
<p><code>FactoryBean</code> 接口中有三个可以被重写的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">OBJECT_TYPE_ATTRIBUTE</span> <span class="operator">=</span> <span class="string">&quot;factoryBeanObjectType&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>getObject()</code> 用于构造 Bean 对象</li>
<li><code>getObjectType()</code> 用于返回 Bean 对象的类型，以便可以通过类型从容器中获取 Bean</li>
<li><code>isSingleton()</code> 每次获取的 Bean 对象是否是单例的</li>
</ul>
<p>从容器中获取 Bean 时可以通过名称获取、可以通过类型获取、也可以通过名称和类型一起获取。如果重写的 <code>getObjectType()</code> 方法返回了 <code>null</code>，那么 <mark>仅仅</mark> 类型从容器中获取 Bean 时，将抛出 <code>NoSuchBeanDefinitionException</code> 异常，并提示没有指定类型的 Bean。</p>
<p>如果重写的 <code>isSingleton()</code> 方法返回 <code>true</code>，那么每次充容器中获取 Bean 对象都是同一个，反之则不是。</p>
<p><mark>注意：</mark> 由 <code>FactoryBean</code> 构造的单例 Bean 不会存放在 <code>DefaultSingletonBeanRegistry</code> 的 <code>singletonFactories</code> 中，而是在 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>factoryBeanInstanceCache</code> 中。</p>
<blockquote>
<p>获取 <code>FactoryBean</code> 类型的 Bean</p>
</blockquote>
<p>肯定不能简单地通过名称获取，那会返回其泛型参数类型的 Bean，那通过类型获取呢？比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.getBean(Bean1FactoryBean.class)</span><br></pre></td></tr></table></figure>
<p>答案是可行的。</p>
<p>除此之外，还可以在名称前添加 <code>&amp;</code>，然后通过名称来获取（有点指针的味道？）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.getBean(<span class="string">&quot;&amp;bean1&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="44-Indexed"><a class="header-anchor" href="#44-Indexed"></a>44. @Indexed</h1>
<p>Spring 在进行组件扫描时，会遍历项目中依赖的所有 Jar 包中类路径下所有的文件，找到被 <code>@Component</code> 及其衍生注解标记的类，然后把它们组装成 BeanDefinition 添加到 Spring 容器中。</p>
<p>如果扫描的返回过大，势必会大大地影响项目启动速度。</p>
<p>为了优化扫描速度，引入以下依赖，Spring 将扫描过程提前到编译期：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-indexer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现有如下类信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这几个类都与 <code>A44</code> 存放于同一包路径下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A44</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">        <span class="comment">// 组件扫描核心类</span></span><br><span class="line">        <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(beanFactory);</span><br><span class="line">        scanner.scan(A44.class.getPackage().getName());</span><br><span class="line"></span><br><span class="line">        Arrays.stream(beanFactory.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>main()</code> 方法，控制台打印出：</p>
<pre>
bean2
bean3
bean1
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
</pre>
<p>这没什么奇怪的，<code>bean1</code>、<code>bean2</code> 和 <code>bean3</code> 都被添加到 Spring 容器中。</p>
<p>在编译生成的 <code>target</code> 目录下的 <code>classes/META-INF/spring.components</code> 文件里有以下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">indi.mofan.a44.Bean1=org.springframework.stereotype.Component</span><br><span class="line">indi.mofan.a44.Bean2=org.springframework.stereotype.Component</span><br><span class="line">indi.mofan.a44.Bean3=org.springframework.stereotype.Component</span><br></pre></td></tr></table></figure>
<p>如果删除最后两条信息，再次运行 <code>main()</code> 方法呢？</p>
<pre>
bean1
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
</pre>
<p>此时只有 <code>bean1</code> 被添加到 Spring 容器中，也就是说会先以 <code>spring.components</code> 文件中的信息为主。</p>
<p>那 <code>spring.components</code> 是怎么什么的？</p>
<p>它是在引入 <code>spring-context-indexer</code> 依赖后，在编译期根据类是否被 <code>@Indexed</code> 注解标记，生成 <code>spring.components</code> 文件及内容。</p>
<p>到目前为止，虽然都没显式使用 <code>@Indexed</code> 注解，但它包含在 <code>@Component</code> 注解中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结</p>
</blockquote>
<p>导入 <code>spring-context-indexer</code> 依赖后，在编译期根据 <code>@Indexed</code> 生成 <code>META-INF/spring.components</code> 文件。</p>
<p>Spring 在扫描组件时，如果发现 <code>META-INF/spring.components</code> 文件存在，以它为准加载 BeanDefinition，反之遍历包含 Jar 包类路径下所有 class 信息。</p>
<h1 id="45-代理进一步理解"><a class="header-anchor" href="#45-代理进一步理解"></a>45. 代理进一步理解</h1>
<p>在 Spring 的代理中，依赖注入和初始化针对的是目标对象，代理对象和目标对象是两个对象，两者的成员变量不会共享。</p>
<p>确保项目中已导入以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>依赖注入和初始化针对的是目标对象</p>
</blockquote>
<p>现有如下类信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> initialized;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;setBean2(Bean2 bean2)&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">        initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">getBean2</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;getBean2()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInitialized</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;isInitialized()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> initialized;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为 <code>Bean1</code> 中的每个方法定制一个前置通知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 Bean1 中所有的方法进行匹配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* indi.mofan.a45.Bean1.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一 SpringBoot 主启动类，它与 <code>Bean1</code>、<code>Bean2</code> 和 <code>MyAspect</code> 在同一包路径下，确保它们能被自动添加到 Spring 容器中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A45</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A45.class, args);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>main()</code> 方法，控制台输出：</p>
<pre>
indi.mofan.a45.Bean1                - setBean2(Bean2 bean2) 
indi.mofan.a45.Bean1                - init 
</pre>
<p><code>Bean1</code> 中的依赖注入和初始化被成功执行，但 <strong>并没有被增强。</strong></p>
<p>由于 <code>Bean1</code> 被增强了，从 Spring 容器中获取的对象将是代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A45.class, args);</span><br><span class="line">    <span class="type">Bean1</span> <span class="variable">proxy</span> <span class="operator">=</span> context.getBean(Bean1.class);</span><br><span class="line"></span><br><span class="line">    proxy.setBean2(<span class="keyword">new</span> <span class="title class_">Bean2</span>());</span><br><span class="line">    proxy.init();</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>
before
indi.mofan.a45.Bean1                - setBean2(Bean2 bean2) 
before
indi.mofan.a45.Bean1                - init 
</pre>
<p>主动调用的 <code>setBean2()</code> 和 <code>init()</code> 方法 <strong>都被增强。</strong></p>
<blockquote>
<p>代理对象与目标对象的成员变量不共享</p>
</blockquote>
<p>尝试打印代理对象和目标对象的成员变量信息（直接访问，不使用方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A45.class, args);</span><br><span class="line">    <span class="type">Bean1</span> <span class="variable">proxy</span> <span class="operator">=</span> context.getBean(Bean1.class);</span><br><span class="line">    </span><br><span class="line">    showProxyAndTarget(proxy);</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showProxyAndTarget</span><span class="params">(Bean1 proxy)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; 代理中的成员变量&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;\tinitialized = &quot;</span> + proxy.initialized);</span><br><span class="line">    System.out.println(<span class="string">&quot;\tbean2 = &quot;</span> + proxy.bean2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (proxy <span class="keyword">instanceof</span> Advised) &#123;</span><br><span class="line">        <span class="type">Advised</span> <span class="variable">advised</span> <span class="operator">=</span> (Advised) proxy;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; 目标中的成员变量&quot;</span>);</span><br><span class="line">        <span class="type">Bean1</span> <span class="variable">target</span> <span class="operator">=</span> (Bean1) advised.getTargetSource().getTarget();</span><br><span class="line">        System.out.println(<span class="string">&quot;\tinitialized = &quot;</span> + target.initialized);</span><br><span class="line">        System.out.println(<span class="string">&quot;\tbean2 = &quot;</span> + target.bean2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>
<font>>>>>></font> 代理中的成员变量
&#9;initialized = false
&#9;bean2 = null
<font>>>>>></font> 目标中的成员变量
&#9;initialized = true
&#9;bean2 = indi.mofan.a45.Bean2@771db12c
</pre>
<p>由于依赖注入和初始化只针对目标对象，因此代理对象中的成员变量的值都是初始值。</p>
<p>在实际应用过程中，不会直接去访问成员变量，而是通过方法去访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A45.class, args);</span><br><span class="line">    <span class="type">Bean1</span> <span class="variable">proxy</span> <span class="operator">=</span> context.getBean(Bean1.class);</span><br><span class="line"></span><br><span class="line">    showProxyAndTarget(proxy);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    System.out.println(proxy.getBean2());</span><br><span class="line">    System.out.println(proxy.isInitialized());</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>
before
indi.mofan.a45.Bean1                - getBean2() 
indi.mofan.a45.Bean2@771db12c
before
indi.mofan.a45.Bean1                - isInitialized() 
true
</pre>
<p>通过方法访问代理对象的成员变量时，这些方法会被增强，同时代理对象中的方法又会去调用目标对象的方法，从而读取出正确的值。</p>
<blockquote>
<p>只会对能被重写的方法进行增强</p>
</blockquote>
<p>在 <code>Bean1</code> 中增加几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">	<span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1() 成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2() final 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m3() static 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m4() private 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// static、final、private 修饰的方法不会被增强</span></span><br><span class="line">    proxy.m1();</span><br><span class="line">    proxy.m2();</span><br><span class="line">    Bean1.m3();</span><br><span class="line">    <span class="type">Method</span> <span class="variable">m4</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;m4&quot;</span>);</span><br><span class="line">    m4.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    m4.invoke(proxy);</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>
before
m1() 成员方法
m2() final 方法
m3() static 方法
m4() private 方法
</pre>
<p>能被重写的成员方法成功被增强，但被 <code>final</code> 修饰的、被 <code>static</code> 修饰的方法和私有方法由于无法被重写，因此它们不能被增强。如果想增强这些方法，可以使用 AspectJ 编译器增强或者 Agent 类加载。</p>
<h1 id="46-Value-注入底层"><a class="header-anchor" href="#46-Value-注入底层"></a>46. @Value 注入底层</h1>
<p>现有一 <code>Bean1</code> 类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;JAVA_HOME&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String home;</span><br><span class="line">    <span class="meta">@Value(&quot;18&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要解析 <code>@Value(&quot;$&#123;JAVA_HOME&#125;&quot;)</code> 和 <code>@Value(&quot;18&quot;)</code> 的值，其中 <code>JAVA_HOME</code> 以系统环境变量填充，<code>18</code> 为整型。</p>
<p>解析分为两步：</p>
<ol>
<li>获取 <code>@Value</code> 注解中 <code>value</code> 属性值；</li>
<li>解析属性值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A46</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A46.class);</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getDefaultListableBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="type">ContextAnnotationAutowireCandidateResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>();</span><br><span class="line">        resolver.setBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        test1(context, resolver);</span><br><span class="line">        test2(context, resolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(AnnotationConfigApplicationContext context,</span></span><br><span class="line"><span class="params">                              ContextAnnotationAutowireCandidateResolver resolver)</span> &#123;</span><br><span class="line">        <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;home&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 获取 @Value 的内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> resolver.getSuggestedValue(dd1).toString();</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析 $&#123;&#125;</span></span><br><span class="line">        value = context.getEnvironment().resolvePlaceholders(value);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>
${JAVA_HOME}
D:\environment\JDK1.8
</pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(AnnotationConfigApplicationContext context,</span></span><br><span class="line"><span class="params">                          ContextAnnotationAutowireCandidateResolver resolver)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;age&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 获取 @Value 的内容</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> resolver.getSuggestedValue(dd1).toString();</span><br><span class="line">    System.out.println(<span class="string">&quot;@Value 的 value 属性值: &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 $&#123;&#125;</span></span><br><span class="line">    value = context.getEnvironment().resolvePlaceholders(value);</span><br><span class="line">    System.out.println(<span class="string">&quot;解析得到的值: &quot;</span> + value);</span><br><span class="line">    System.out.println(<span class="string">&quot;解析得到的值的类型: &quot;</span> + value.getClass());</span><br><span class="line">    <span class="comment">// 转成字段的类型</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">age</span> <span class="operator">=</span> context.getBeanFactory()</span><br><span class="line">        .getTypeConverter()</span><br><span class="line">        .convertIfNecessary(value, dd1.getDependencyType());</span><br><span class="line">    System.out.println(<span class="string">&quot;转换后的类型: &quot;</span> + age.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>
@Value 的 value 属性值: 18
解析得到的值: 18
解析得到的值的类型: class java.lang.String
转换后的类型: class java.lang.Integer
</pre>
<blockquote>
<p>EL 表达式的解析</p>
</blockquote>
<p>假设有如下几个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;@bean3&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Bean3 bean3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;bean3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean4</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#x27;hello, &#x27; + &#x27;$&#123;JAVA_HOME&#125;&#x27;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样要求解析 <code>@Value</code> 中的 <code>value</code> 属性值。</p>
<p>如果沿用 <code>test2()</code> 方法进行解析，控制台打印出：</p>
<pre>
@Value 的 value 属性值: #{@bean3}
解析得到的值: #{@bean3}
解析得到的值的类型: class java.lang.String
<font style="color:red">Exception in thread "main" org.springframework.beans.<font style="color:gray">ConversionNotSupportedException</font>: Failed to convert value of type 'java.lang.String' to required type 'indi.mofan.a46.A46$Bean3'; nested exception is java.lang.IllegalStateException: Cannot convert value of type 'java.lang.String' to required type 'indi.mofan.a46.A46$Bean3': no matching editors or conversion strategy found</font>
</pre>
<p>最后一步数据转换出了问题，无法将 <code>String</code> 转换成 <code>A46$Bean3</code> 类型，也就是说解析 <code>@bean3</code> 失败了，程序仍然把它当成字符串，而不是注入的 Bean。</p>
<p>为了解析成功，需要在转换前解析 <code>#&#123;&#125;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    test3(context, resolver, Bean2.class.getDeclaredField(<span class="string">&quot;bean3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    test3(context, resolver, Bean4.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">(AnnotationConfigApplicationContext context,</span></span><br><span class="line"><span class="params">                          ContextAnnotationAutowireCandidateResolver resolver,</span></span><br><span class="line"><span class="params">                          Field field)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(field, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 获取 @Value 的内容</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> resolver.getSuggestedValue(dd1).toString();</span><br><span class="line">    System.out.println(<span class="string">&quot;@Value 的 value 属性值: &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 $&#123;&#125;</span></span><br><span class="line">    value = context.getEnvironment().resolvePlaceholders(value);</span><br><span class="line">    System.out.println(<span class="string">&quot;解析得到的值: &quot;</span> + value);</span><br><span class="line">    System.out.println(<span class="string">&quot;解析得到的值的类型: &quot;</span> + value.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 #&#123;&#125;</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean3</span> <span class="operator">=</span> context.getBeanFactory()</span><br><span class="line">        .getBeanExpressionResolver()</span><br><span class="line">        .evaluate(value, <span class="keyword">new</span> <span class="title class_">BeanExpressionContext</span>(context.getBeanFactory(), <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> context.getBeanFactory()</span><br><span class="line">        .getTypeConverter()</span><br><span class="line">        .convertIfNecessary(bean3, dd1.getDependencyType());</span><br><span class="line">    System.out.println(<span class="string">&quot;转换后的类型: &quot;</span> + result.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>
@Value 的 value 属性值: #{@bean3}
解析得到的值: #{@bean3}
解析得到的值的类型: class java.lang.String
转换后的类型: class indi.mofan.a46.A46$Bean3
<font>>>>>>>>>>>>>>>>>>>></font>
@Value 的 value 属性值: #{'hello, ' + '${JAVA_HOME}'}
解析得到的值: #{'hello, ' + 'D:\environment\JDK1.8'}
解析得到的值的类型: class java.lang.String
转换后的类型: class java.lang.String
</pre>
<h1 id="47-Autowired-注入底层"><a class="header-anchor" href="#47-Autowired-注入底层"></a>47. @Autowired 注入底层</h1>
<h2 id="47-1-注入方式"><a class="header-anchor" href="#47-1-注入方式"></a>47.1 注入方式</h2>
<blockquote>
<p>按成员变量类型注入</p>
</blockquote>
<p>现有一 <code>Bean1</code> 类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要被注入的对象所在类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;bean2&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从容器中获取需要被注入的 Bean 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A47_1</span>&#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A47_1.class);</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getDefaultListableBeanFactory();</span><br><span class="line">        </span><br><span class="line">        <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean2&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">        System.out.println(beanFactory.doResolveDependency(dd1, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>indi.mofan.a47.A47_1$Bean2@222545dc</pre>
<blockquote>
<p>按参数类型注入</p>
</blockquote>
<p>对 <code>Bean1</code> 进行修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 <code>setBean2()</code> 方法的 <code>Bean2</code> 类型参数进行注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">setBean2</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;setBean2&quot;</span>, Bean2.class);</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd2</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(setBean2, <span class="number">0</span>), <span class="literal">false</span>);</span><br><span class="line">    System.out.println(beanFactory.doResolveDependency(dd2, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>indi.mofan.a47.A47_1$Bean2@222545dc</pre>
<blockquote>
<p>包装为 <code>Optional&lt;Bean2&gt;</code></p>
</blockquote>
<p>对 <code>Bean1</code> 进行修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Optional&lt;Bean2&gt; bean3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果直接按照以下方式获取 <code>DependencyDescriptor</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DependencyDescriptor</span> <span class="variable">dd3</span> <span class="operator">=</span> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean3&quot;</span>), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>其 <code>dd3.getDependencyType()</code> 方法将返回 <code>Optional</code> 的 <code>Class</code> 对象，这显然是不对的。</p>
<p>Spring 提供为 <code>DependencyDescriptor</code> 提供了解决这个问题的方法，即“增加嵌套等级”来获取内嵌类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd3.increaseNestingLevel();</span><br></pre></td></tr></table></figure>
<p>执行 <code>increaseNestingLevel()</code> 方法后，<code>dd3.getDependencyType()</code> 方法返回的 <code>Bean2</code> 的 <code>Class</code> 对象。</p>
<p>因此注入 <code>Optional&lt;Bean2&gt;</code> 类型的成员变量应该按照：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd3</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean3&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (Optional.class.equals(dd3.getDependencyType())) &#123;</span><br><span class="line">        dd3.increaseNestingLevel();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd3, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(Optional.ofNullable(result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>Optional[indi.mofan.a47.A47_1$Bean2@222545dc]</pre>
<p>注入 <code>Optional</code> 对象和使用 <code>@Autowired(required = false)</code> 的作用是一样的，当容器中不存在目标 Bean 时，不会抛出 <code>NoSuchBeanDefinitionException</code> 异常。</p>
<blockquote>
<p>包装为 <code>ObjectFactory&lt;Bean2&gt;</code></p>
</blockquote>
<p>对 <code>Bean1</code> 进行修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectFactory&lt;Bean2&gt; bean4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入 <code>ObjectFactory&lt;Bean2&gt;</code> 类型的对象与注入 <code>Optional&lt;Bean2&gt;</code> 类型的对象类似，只不过 <code>ObjectFactory</code> 提供了 <strong>延迟注入</strong> 的能力，也就是说 <code>Bean2</code> 对象不会立即被注入，而是在需要时才被注入。</p>
<p><code>ObjectFactory</code> 是一个函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入的应该是 <code>ObjectFactory</code> 对象，在调用该对象的 <code>getObject()</code> 方法时，<code>Bean2</code> 对象才被注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd4</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean4&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (ObjectFactory.class.equals(dd4.getDependencyType())) &#123;</span><br><span class="line">        dd4.increaseNestingLevel();</span><br><span class="line">        ObjectFactory&lt;Bean2&gt; objectFactory = () -&gt;</span><br><span class="line">            (Bean2) beanFactory.doResolveDependency(dd4, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(objectFactory.getObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>indi.mofan.a47.A47_1$Bean2@222545dc</pre>
<p>与 <code>ObjectFactory</code> 类似的还有个名为 <code>ObjectProvider</code> 的接口，后者继承了前者。</p>
<p>与 <code>ObjectFactory</code> 相比，<code>ObjectProvider</code> 提供了类似于 <code>Optional</code> 的安全注入功能，当容器中不存在目标 Bean 时， 不会抛出 <code>NoSuchBeanDefinitionException</code> 异常。<code>ObjectProvider</code> 提供的 <code>getIfAvailable()</code> 在获取不存在的 Bean 时，不会抛出异常，而是返回 <code>null</code>。</p>
<blockquote>
<p>对 <code>@Lazy</code> 的处理</p>
</blockquote>
<p>对 <code>Bean1</code> 进行修改，在成员变量 <code>bean2</code> 上使用 <code>@Lazy</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>@Lazy</code> 注解标记的成员变量，注入的对象不再是目标对象，而是其代理对象，因此不能使用 <code>DefaultListableBeanFactory</code> 对象的 <code>doResolveDependency()</code> 方法来获取注入的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd5</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean2&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="type">ContextAnnotationAutowireCandidateResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>();</span><br><span class="line">    resolver.setBeanFactory(beanFactory);</span><br><span class="line">    <span class="comment">// 根据 @Lazy 创建代理对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> resolver.getLazyResolutionProxyIfNecessary(dd5, <span class="string">&quot;bean1&quot;</span>);</span><br><span class="line">    System.out.println(proxy);</span><br><span class="line">    System.out.println(proxy.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>
indi.mofan.a47.A47_1$Bean2@222545dc
class indi.mofan.a47.A47_1$Bean2$$EnhancerBySpringCGLIB$$d631a20c
</pre>
<p><code>@Lazy</code> 实现的 <strong>延迟注入</strong> （前面讲的 <code>ObjectFactory</code> 和 <code>ObjectProvider</code> 也有延迟注入功能，但与 <code>@Lazy</code> 的实现不一样）不是不注入，而是注入目标对象的代理对象，当使用到代理对象中的方法时，代理对象就会去 Spring 容器中寻找真正的目标对象，然后调用目标对象对应的方法。</p>
<p><code>@Lazy</code> 的实现细节可以在 <code>ContextAnnotationAutowireCandidateResolver</code> 中看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">QualifierAnnotationAutowireCandidateResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getLazyResolutionProxyIfNecessary</span><span class="params">(DependencyDescriptor descriptor, </span></span><br><span class="line"><span class="params">                                                    <span class="meta">@Nullable</span> String beanName)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果有 @Lazy 注解，就创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> (isLazy(descriptor) ? </span><br><span class="line">                buildLazyResolutionProxy(descriptor, beanName) : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isLazy</span><span class="params">(DependencyDescriptor descriptor)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Annotation ann : descriptor.getAnnotations()) &#123;</span><br><span class="line">            <span class="comment">// 获取 @Lazy 注解信息</span></span><br><span class="line">            <span class="type">Lazy</span> <span class="variable">lazy</span> <span class="operator">=</span> AnnotationUtils.getAnnotation(ann, Lazy.class);</span><br><span class="line">            <span class="keyword">if</span> (lazy != <span class="literal">null</span> &amp;&amp; lazy.value()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">MethodParameter</span> <span class="variable">methodParam</span> <span class="operator">=</span> descriptor.getMethodParameter();</span><br><span class="line">        <span class="keyword">if</span> (methodParam != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// --snip--</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">buildLazyResolutionProxy</span><span class="params">(<span class="keyword">final</span> DependencyDescriptor descriptor, </span></span><br><span class="line"><span class="params">                                              <span class="keyword">final</span> <span class="meta">@Nullable</span> String beanName)</span> &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">        <span class="comment">// 获取代理对象</span></span><br><span class="line">        <span class="keyword">return</span> pf.getProxy(dlbf.getBeanClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：包装为 <code>Provider&lt;Bean2&gt;</code></p>
</blockquote>
<p><code>Provider</code> 接口是由 JSR-330 提出，要想使用此接口，需要导入以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  不要惊讶，版本号就是 1  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对 <code>Bean1</code> 进行修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Provider&lt;Bean2&gt; bean5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入 <code>Provider</code> 类型的对象与注入 <code>ObjectFactory&lt;Bean2&gt;</code> 类型的对象极其相似，<code>Provider</code> 也提供了 <strong>延迟注入</strong> 的能力，注入的是 <code>Provider</code> 对象，在调用该对象的 <code>get()</code> 方法时，<code>Bean2</code> 对象才被注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean5&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (Provider.class.equals(dd6.getDependencyType())) &#123;</span><br><span class="line">        dd6.increaseNestingLevel();</span><br><span class="line">        Provider&lt;Bean2&gt; provider = () -&gt;</span><br><span class="line">            (Bean2)  beanFactory.doResolveDependency(dd6, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(provider.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>indi.mofan.a47.A47_1$Bean2@222545dc</pre>
<p><code>Optional</code> 类型、<code>ObjectFactory</code> 类型、<code>ObjectProvider</code> 类型、JSR-330 提供的类型的注入逻辑可在 <code>DefaultListableBeanFactory#resolveDependency()</code> 方法中看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveDependency</span><span class="params">(DependencyDescriptor descriptor,</span></span><br><span class="line"><span class="params">                                <span class="meta">@Nullable</span> String requestingBeanName,</span></span><br><span class="line"><span class="params">                                <span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames,</span></span><br><span class="line"><span class="params">                                <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line">    <span class="keyword">if</span> (Optional.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="comment">// 对 Optional 的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() ||</span><br><span class="line">            ObjectProvider.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="comment">// 对 ObjectFactory、ObjectProvider 的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="comment">// 对 JSR-330 提供的类型的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="47-2-类型匹配细节"><a class="header-anchor" href="#47-2-类型匹配细节"></a>47.2 类型匹配细节</h2>
<p>无论是 <code>@Value</code> 注入，还是 <code>@Autowired</code> 注入，最终都会调用 <code>DefaultListableBeanFactory#doResolveDependency()</code> 方法。</p>
<p>现有如下几个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Dao</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;dao1&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dao1</span> <span class="keyword">implements</span> <span class="title class_">Dao</span>&lt;Student&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;dao2&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dao2</span> <span class="keyword">implements</span> <span class="title class_">Dao</span>&lt;Teacher&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service1&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service1</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service2&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service2</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service3&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service3</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一目标类 <code>Target</code>，对其进行依赖注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Service[] serviceArray;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Service&gt; serviceList;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfigurableApplicationContext applicationContext;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Dao&lt;Teacher&gt; dao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;service2&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组类型</p>
</blockquote>
<p>Spring 容器中肯定不存在数组类型且元素类型为 <code>Service</code> 的 Bean 对象，因此注入的 <code>Service</code> 数组应当是容器中 <code>Service</code> 类型的 Bean 数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A47_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A47_2.class);</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getDefaultListableBeanFactory();</span><br><span class="line"></span><br><span class="line">        testArray(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testArray</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">        <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target.class.getDeclaredField(<span class="string">&quot;serviceArray&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (dd1.getDependencyType().isArray()) &#123;</span><br><span class="line">            <span class="comment">// 获取数组中的元素类型</span></span><br><span class="line">            Class&lt;?&gt; componentType = dd1.getDependencyType().getComponentType();</span><br><span class="line">            System.out.println(componentType);</span><br><span class="line">            String[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                beanFactory, </span><br><span class="line">                componentType</span><br><span class="line">            );</span><br><span class="line">            List&lt;Object&gt; beans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> dd1.resolveCandidate(name, componentType, beanFactory);</span><br><span class="line">                beans.add(bean);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">array</span> <span class="operator">=</span> beanFactory.getTypeConverter()</span><br><span class="line">                .convertIfNecessary(beans, dd1.getDependencyType());</span><br><span class="line">            System.out.println(array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>
interface indi.mofan.a47.A47_2$Service
service3
service2
service1
[Lindi.mofan.a47.A47_2$Service;@49139829
</pre>
<p>相关源码可在 <code>DefaultListableBeanFactory#resolveMultipleBeans()</code> 方法中看到。</p>
<blockquote>
<p><code>List</code> 类型</p>
</blockquote>
<p>注入 <code>List&lt;Service&gt;</code> 类型数据的逻辑与注入 <code>Service[]</code> 类型数据的逻辑类似，只不过在容器中寻找目标 Bean 时不再通过数组元素类型，而是通过 <code>List</code> 的泛型类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd2</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target.class.getDeclaredField(<span class="string">&quot;serviceList&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (List.class.equals(dd2.getDependencyType())) &#123;</span><br><span class="line">        <span class="comment">// 获取泛型信息</span></span><br><span class="line">        Class&lt;?&gt; resolve = dd2.getResolvableType().getGeneric().resolve();</span><br><span class="line">        System.out.println(resolve);</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        String[] names = </span><br><span class="line">            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, resolve);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> dd2.resolveCandidate(name, resolve, beanFactory);</span><br><span class="line">            list.add(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>
interface indi.mofan.a47.A47_2$Service
[indi.mofan.a47.A47_2$Service3@35e2d654, indi.mofan.a47.A47_2$Service2@1bd4fdd, indi.mofan.a47.A47_2$Service1@55183b20]
</pre>
<p><mark>注意：</mark> 对于注入的集合类型数据，注入的类型必须是 <code>Collection</code> 及其 <strong>子接口</strong>，比如不支持直接注入 <code>ArrayList</code> 类型的数据。</p>
<p>相关源码可在 <code>DefaultListableBeanFactory#resolveMultipleBeans()</code> 方法中看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">resolveMultipleBeans</span><span class="params">(DependencyDescriptor descriptor, </span></span><br><span class="line"><span class="params">                                    <span class="meta">@Nullable</span> String beanName,</span></span><br><span class="line"><span class="params">                                    <span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, </span></span><br><span class="line"><span class="params">                                    <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">    <span class="keyword">if</span> (descriptor <span class="keyword">instanceof</span> StreamDependencyDescriptor) &#123;</span><br><span class="line">		<span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (type.isArray()) &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Collection.class.isAssignableFrom(type) &amp;&amp; type.isInterface()) &#123;</span><br><span class="line">        <span class="comment">// 就是这里的判断</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Map.class == type) &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中可以看到，<code>@Autowired</code> 还支持 <code>Map</code> 类型数据的注入，此时注入的 Map 的 key 是 Bean 的名称，value 是 Bean 对象，这种方式常常配合策略模式使用。需要注意的是，只支持注入 <code>Map</code> 接口，不支持其子类。</p>
<blockquote>
<p>特殊类型 <code>ConfigurableApplicationContext</code></p>
</blockquote>
<p><code>ConfigurableApplicationContext</code> 是 <code>ApplicationContext</code> 接口的子接口。</p>
<p>需要注意的是，在 Spring 容器中并不存在 <code>ConfigurableApplicationContext</code> 类型、或 <code>ApplicationContext</code> 类型的 Bean。</p>
<p>Spring 容器中的所有单例 Bean 对象存放在 <code>DefaultListableBeanFactory</code> 中，在 <code>DefaultListableBeanFactory</code> 父类 <code>DefaultSingletonBeanRegistry</code> 中有一成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>singletonObjects</code> 用于存放 Spring 容器中的所有单例 Bean 对象。</p>
<p>类似 <code>ApplicationContext</code>、<code>BeanFactory</code> 类型的对象则是放在 <code>DefaultListableBeanFactory</code> 中的 <code>resolvableDependencies</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ConfigurableListableBeanFactory</span>, BeanDefinitionRegistry, Serializable &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; resolvableDependencies = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些特殊对象是在调用 <code>ApplicationContext</code> 的 <code>refresh()</code> 方法时添加到 <code>resolvableDependencies</code> 中的。可在 <code>AbstractApplicationContext</code> 的 <code>refresh()</code> 方法中看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">    <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="built_in">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此在注入诸如 <code>ConfigurableApplicationContext</code> 特殊类型的对象时，不能直接使用 <code>getBean()</code> 方法获取，而是应该从 <code>resolvableDependencies</code> 集合中获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testApplicationContext</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(</span><br><span class="line">        Target.class.getDeclaredField(<span class="string">&quot;applicationContext&quot;</span>), </span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">    <span class="type">Field</span> <span class="variable">resolvableDependencies</span> <span class="operator">=</span> </span><br><span class="line">        DefaultListableBeanFactory.class.getDeclaredField(<span class="string">&quot;resolvableDependencies&quot;</span>);</span><br><span class="line">    resolvableDependencies.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Object&gt; dependencies = </span><br><span class="line">        (Map&lt;Class&lt;?&gt;, Object&gt;) resolvableDependencies.get(beanFactory);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : dependencies.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 左边类型                      右边类型</span></span><br><span class="line">        <span class="keyword">if</span> (entry.getKey().isAssignableFrom(dd3.getDependencyType())) &#123;</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>org.springframework.beans.factory.support.DefaultListableBeanFactory@7364985f: defining beans<br/> [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,<br/>org.springframework.context.annotation.internalAutowiredAnnotationProcessor,<br/>org.springframework.context.annotation.internalCommonAnnotationProcessor,<br/>org.springframework.context.event.internalEventListenerProcessor,<br/>org.springframework.context.event.internalEventListenerFactory,<br/>a47_2,service3,service2,service1,dao2,dao1]; root of factory hierarchy</pre>
<blockquote>
<p>泛型类型</p>
</blockquote>
<p>容器中 <code>Dao</code> 类型的 Bean 有多个，而依赖注入的是 <code>Dao&lt;Teacher&gt;</code> 类型的对象，因此需要判断容器中的 Bean 对象泛型类型是否为指定类型。判断逻辑可以使用 <code>ContextAnnotationAutowireCandidateResolver</code> 的 <code>isAutowireCandidate()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGeneric</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd4</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target.class.getDeclaredField(<span class="string">&quot;dao&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    Class&lt;?&gt; type = dd4.getDependencyType();</span><br><span class="line">    <span class="type">ContextAnnotationAutowireCandidateResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>();</span><br><span class="line">    resolver.setBeanFactory(beanFactory);</span><br><span class="line">    <span class="comment">// 循环所有的目标类型 Bean 名称</span></span><br><span class="line">    <span class="keyword">for</span> (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, type)) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> beanFactory.getMergedBeanDefinition(name);</span><br><span class="line">        <span class="comment">// 对比 BeanDefinition 的泛型与 DependencyDescriptor 的泛型是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (resolver.isAutowireCandidate(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(bd, name), dd4)) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(dd4.resolveCandidate(name, type, beanFactory));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>
dao2
indi.mofan.a47.A47_2$Dao2@74f0ea28
</pre>
<blockquote>
<p><code>@Qualifier</code></p>
</blockquote>
<p>当容器中存在多个相同类型的 Bean 对象，在执行依赖注入时可以使用 <code>@Qualifier</code> 注解来指定需要注入的 Bean 对象的名称。判断逻辑同样使用 <code>ContextAnnotationAutowireCandidateResolver</code> 的 <code>isAutowireCandidate()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testQualifier</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd5</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target.class.getDeclaredField(<span class="string">&quot;service&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    Class&lt;?&gt; type = dd5.getDependencyType();</span><br><span class="line">    <span class="type">ContextAnnotationAutowireCandidateResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>();</span><br><span class="line">    resolver.setBeanFactory(beanFactory);</span><br><span class="line">    <span class="keyword">for</span> (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, type)) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> beanFactory.getMergedBeanDefinition(name);</span><br><span class="line">        <span class="comment">// DependencyDescriptor 对象中包含了 @Qualifier 注解信息</span></span><br><span class="line">        <span class="keyword">if</span> (resolver.isAutowireCandidate(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(bd, name), dd5)) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(dd5.resolveCandidate(name, type, beanFactory));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>
service2
indi.mofan.a47.A47_2$Service2@1bd4fdd
</pre>
<blockquote>
<p><code>@Primary</code></p>
</blockquote>
<p>当容器中存在多个相同类型的 Bean 对象时，在执行依赖注入时除了可以使用 <code>@Qualifier</code> 注解外，还可以在被注入的 Bean 对象所在类上使用 <code>@Primary</code> 注解，指定执行依赖注入时使用的主要 Bean 对象。</p>
<p>如果 Bean 对象的所在类被 <code>@Primary</code> 注解标记，那么在构造 <code>BeanDefinition</code> 时就会记录这个信息。</p>
<p>通常情况下，<code>@Primary</code> 注解只有一个作用在同种类型的 Bean 上，存在多个时，Spring 依旧无法区分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service1&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service1</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Component(&quot;service2&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service2</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service3&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service3</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPrimary</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target1.class.getDeclaredField(<span class="string">&quot;service&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    Class&lt;?&gt; type = dd.getDependencyType();</span><br><span class="line">    <span class="keyword">for</span> (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, type)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.getMergedBeanDefinition(name).isPrimary()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;primary: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>primary: service2</pre>
<blockquote>
<p>默认规则</p>
</blockquote>
<p>当容器中存在多个相同类型的 Bean 对象时，除了使用 <code>@Qualifier</code> 或 <code>@Primary</code> 注解外，<code>@Autowired</code> 注解还支持按照成员变量名称进行匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target2</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Service service3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service1&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service1</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Component(&quot;service2&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service2</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service3&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service3</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testDefault</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target2.class.getDeclaredField(<span class="string">&quot;service3&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    Class&lt;?&gt; type = dd.getDependencyType();</span><br><span class="line">    <span class="keyword">for</span> (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, type)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(dd.getDependencyName())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;default: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>default: service3</pre>
<h1 id="48-事件-监听器"><a class="header-anchor" href="#48-事件-监听器"></a>48. 事件 - 监听器</h1>
<p>Spring 提供了事件发布 - 监听（订阅）机制，利用该机制可以令主要业务与附加业务解耦，是观察者模式的一种体现。</p>
<p>本节介绍事件的监听，事件的发布将在下一节进行介绍。</p>
<h2 id="48-1-监听器的实现"><a class="header-anchor" href="#48-1-监听器的实现"></a>48.1 监听器的实现</h2>
<blockquote>
<p>实现 <code>ApplicationListener</code> 接口</p>
</blockquote>
<p>需求模拟：假设现有一个【主线业务】，要求在【主线业务】执行完成之后，执行【发送短信】、【发送邮件】。</p>
<p>常规写法是将这三种业务依次写在一个方法里，程序顺序执行它们，但这将增加代码的耦合性。</p>
<p>利用 Spring 提供的事件发布 - 监听（订阅）机制来解决这个问题可以大大地降低代码的耦合性。</p>
<p>首先定义事件的类型，用于后续的发布和监听，该事件类必须继承 <code>ApplicationEvent</code> 抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">1541319641201302606L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【主线业务】执行完成后，发送事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBusiness</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;主线业务&quot;</span>);</span><br><span class="line"></span><br><span class="line">        publisher.publishEvent(<span class="keyword">new</span> <span class="title class_">MyEvent</span>(<span class="string">&quot;MyService.doBusiness()&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后定义两个监听器，监听发布的事件，执行【发送短信】、【发送邮件】，定义的监听器需要实现 <code>ApplicationListener</code> 接口，并交由 Spring 管理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SmsApplicationListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;MyEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(MyEvent event)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;发送短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmailApplicationListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;MyEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(MyEvent event)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;发送邮件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用 <code>doBusiness()</code> 串联整个逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A48_1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A48_1.class);</span><br><span class="line">        context.getBean(MyService.class).doBusiness();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>main()</code> 方法后，控制台打印出：</p>
<pre>
[main] indi.mofan.a48.A48_1$MyService      - 主线业务 
[main] i.m.a.A48_1$EmailApplicationListener - 发送邮件 
[main] i.m.a.A48_1$SmsApplicationListener  - 发送短信 
</pre>
<blockquote>
<p>使用 <code>@EventListener</code> 注解</p>
</blockquote>
<p>监听器的实现除了实现 <code>ApplicationListener</code> 接口外，还可以使用 <code>@EventListener</code> 注解。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listener</span><span class="params">(MyEvent myEvent)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;发送短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listener</span><span class="params">(MyEvent myEvent)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;发送邮件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>main()</code> 方法后，控制台输出相同的内容。</p>
<h2 id="48-2-异步事件"><a class="header-anchor" href="#48-2-异步事件"></a>48.2 异步事件</h2>
<p>从上文控制台输出的信息可知，事件都是在主线程 <code>main</code> 中被监听，都是同步执行的。</p>
<p>那怎么发送异步事件呢？</p>
<p><code>ApplicationEventPublisher</code> 底层利用了 <code>SimpleApplicationEventMulticaster</code> 来发布事件，<code>SimpleApplicationEventMulticaster</code> 在发布事件时可以指定是否使用线程池，如果实现了线程池，那么就是异步事件，反之为同步。</p>
<p>因此可以先添加一个线程池 Bean，然后使 <code>SimpleApplicationEventMulticaster</code> 利用这个线程池 Bean 来发送事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">executor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">    executor.setCorePoolSize(<span class="number">3</span>);</span><br><span class="line">    executor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">    executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法名称必须是 applicationEventMulticaster，才能对 Bean 进行覆盖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SimpleApplicationEventMulticaster <span class="title function_">applicationEventMulticaster</span><span class="params">(ThreadPoolTaskExecutor executor)</span> &#123;</span><br><span class="line">    <span class="type">SimpleApplicationEventMulticaster</span> <span class="variable">multicaster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>();</span><br><span class="line">    <span class="comment">// 使用线程池异步发送事件</span></span><br><span class="line">    multicaster.setTaskExecutor(executor);</span><br><span class="line">    <span class="keyword">return</span> multicaster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>注意</mark>：<code>SimpleApplicationEventMulticaster</code> 类型的 Bean 的名称必须是 <code>applicationEventMulticaster</code>，这样才能覆盖原本未使用线程池的 Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A48_2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A48_2.class);</span><br><span class="line">        context.getBean(MyService.class).doBusiness();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 睡两秒，消息监听成功后才关闭容器</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>main()</code> 方法后，控制台打印出：</p>
<pre>
[main] indi.mofan.a48.A48_2$MyService      - 主线业务 
[executor-1] indi.mofan.a48.A48_2$EmailService   - 发送邮件 
[executor-2] indi.mofan.a48.A48_2$SmsService     - 发送短信 
</pre>
<p>【主线业务】、【发送短信】和【发送邮件】都在不同线程中被执行。</p>
<blockquote>
<p>【补充】<code>@Async</code> 实现异步事件</p>
</blockquote>
<p>实际开发中，在监听器方法或监听器类上添加 <code>@Async</code> 注解即可实现异步事件。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listener</span><span class="params">(MyEvent myEvent)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;发送短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listener</span><span class="params">(MyEvent myEvent)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;发送邮件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>main()</code> 方法后，根据控制台打印出的信息可知仍是同步消息，这是因为 <strong>没有开启异步支持。</strong></p>
<p>在配置类上使用 <code>@EnableAsync</code> 注解，开启异步支持：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAsync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(TestAsync.class);</span><br><span class="line">        context.getBean(MyService.class).doBusiness();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title function_">executor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">3</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以注入自行实现的线程池 Bean，使用这个 Bean 来发布异步事件。当然也可以不注入，Spring 提供了默认的线程池。</p>
<p><strong>建议：</strong> 使用 <code>@EnableAsync</code> 注解时，尽量指定 <code>proxyTargetClass</code> 的属性值为 <code>true</code>，采用 CGLib 动态代理，避免监听器类实现接口而监听器方法又未在基类中声明时，导致使用默认 JDK 动态代理失败。</p>
<p>运行 <code>main()</code> 方法，控制台打印出：</p>
<pre>
[main] indi.mofan.a48.TestAsync$MyService  - 主线业务 
[executor-2] indi.mofan.a48.TestAsync$SmsService - 发送短信 
[executor-1] i.mofan.a48.TestAsync$EmailService  - 发送邮件 
</pre>
<h2 id="48-3-自定义事件监听注解"><a class="header-anchor" href="#48-3-自定义事件监听注解"></a>48.3 自定义事件监听注解</h2>
<p>无论是实现 <code>ApplicationListener</code> 接口，还是使用 <code>@EventListener</code> 注解，监听器类都需要交由 Spring 管理，那 Spring 是怎么实现事件的监听的呢？</p>
<p>以自定义时间监听注解为例，简单了解 Spring 的事件监听机制。</p>
<p>自定义 <code>@MyListener</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@interface</span> MyListener &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义事件类型 <code>MyEvent</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6388410688691384516L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义两个监听器类，监听 <code>MyEvent</code> 事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="meta">@MyListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listener</span><span class="params">(MyEvent myEvent)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;发送短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line">    <span class="meta">@MyListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listener</span><span class="params">(MyEvent myEvent)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;发送邮件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定义 <code>MyService</code>，在该业务类中的 <code>doBusiness()</code> 方法发送 <code>MyEvent</code> 事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBusiness</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;主线业务&quot;</span>);</span><br><span class="line">        publisher.publishEvent(<span class="keyword">new</span> <span class="title class_">MyEvent</span>(<span class="string">&quot;MyService.doBusiness()&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是解析 <code>@MyListener</code> 注解了：</p>
<ol>
<li>首先需要获取容器中的所有 Bean 对象</li>
<li>查看这些 Bean 对象中是否存在被 <code>@MyListener</code> 注解标记的方法</li>
<li>将被 <code>@MyListener</code> 注解标记的方法转换成事件监听器添加到 Spring 容器中（适配器模式），这些事件监听器需要判断监听的事件类型是否与原始方法的参数类型一致，一致的情况下才执行方法</li>
<li>在第一步中需要拿到容器中的所有 Bean 对象，因此前面的逻辑要在 Spring 中所有单例 Bean 初始化完成后才执行，可以使用 <code>SmartInitializingSingleton</code> 接口实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SmartInitializingSingleton <span class="title function_">smartInitializingSingleton</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="comment">// Spring 中所有单例 Bean 初始化完成后调用此处理器</span></span><br><span class="line">    <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(name);</span><br><span class="line">            <span class="keyword">for</span> (Method method : bean.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.isAnnotationPresent(MyListener.class)) &#123;</span><br><span class="line">                    <span class="comment">// 添加事件监听器</span></span><br><span class="line">                    context.addApplicationListener((event) -&gt; &#123;</span><br><span class="line">                        <span class="comment">// 监听器方法的事件类型</span></span><br><span class="line">                        Class&lt;?&gt; eventType = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">if</span> (eventType.isAssignableFrom(event.getClass())) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                method.invoke(bean, event);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A48_3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A48_3.class);</span><br><span class="line">        context.getBean(MyService.class).doBusiness();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>
[main] indi.mofan.a48.A48_3$MyService      - 主线业务 
[main] indi.mofan.a48.A48_3$EmailService   - 发送邮件 
[main] indi.mofan.a48.A48_3$SmsService     - 发送短信
</pre>
<h2 id="48-4-【补充】监听器执行顺序"><a class="header-anchor" href="#48-4-【补充】监听器执行顺序"></a>48.4 【补充】监听器执行顺序</h2>
<p>当一个事件有多个对应的监听器时，这些监听器的执行顺序是不确定的。</p>
<p>如果需要监听器按指定的顺序执行，可以使监听器类实现 <code>SmartApplicationListener</code> 接口，重写 <code>getOrder()</code> 方法，指定监听器优先级。除此之外，使用 <code>@Order</code> 注解、在实现 <code>ApplicationListener</code> 接口的基础上再实现 <code>Ordered</code> 接口也能实现相同的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SmsService1</span> &#123;</span><br><span class="line">    <span class="meta">@Order(1)</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listener</span><span class="params">(MyEvent myEvent)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;发送短信-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmailService1</span> &#123;</span><br><span class="line">    <span class="meta">@Order(2)</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listener</span><span class="params">(MyEvent myEvent)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;发送邮件-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SmsService2</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;MyEvent&gt;, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(MyEvent event)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;发送短信-2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmailService2</span> <span class="keyword">implements</span> <span class="title class_">SmartApplicationListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsEventType</span><span class="params">(Class&lt;? extends ApplicationEvent&gt; eventType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MyEvent.class.equals(eventType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;发送邮件-2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>
[main] i.m.a.TestSmartApplicationListener$MyService - 主线业务 
[main] i.m.a.TestSmartApplicationListener$SmsService1 - 发送短信-1 
[main] i.m.a.TestSmartApplicationListener$EmailService1 - 发送邮件-1 
[main] i.m.a.TestSmartApplicationListener$SmsService2 - 发送短信-2 
[main] i.m.a.TestSmartApplicationListener$EmailService2 - 发送邮件-2 
</pre>
<h2 id="48-5-【补充】事件的传播"><a class="header-anchor" href="#48-5-【补充】事件的传播"></a>48.5 【补充】事件的传播</h2>
<p>当 Spring 容器嵌套 Spring 容器时，通过子容器发布事件，能够在父容器监听到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">    parent.registerBean(MyListener.class);</span><br><span class="line">    parent.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">    child.setParent(parent);</span><br><span class="line">    child.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过子容器发布事件，能够在父容器监听到</span></span><br><span class="line">    child.publishEvent(<span class="keyword">new</span> <span class="title class_">MyEvent</span>(<span class="string">&quot;子容器发送的事件...&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7002403082731659626L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyEvent</span><span class="params">(String source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyListener</span> &#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listener</span><span class="params">(MyEvent myEvent)</span> &#123;</span><br><span class="line">        log.debug(String.valueOf(myEvent.getSource()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>[main] i.m.a.EventPropagationTest$MyListener - 子容器发送的事件... </pre>
<h2 id="48-6-【补充】带泛型的事件"><a class="header-anchor" href="#48-6-【补充】带泛型的事件"></a>48.6 【补充】带泛型的事件</h2>
<p>现有一个事件类 <code>MutationEvent</code>，接收一个泛型参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MutationEvent</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2718823625228147843L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T source;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MutationEvent</span><span class="params">(T data, String type)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(data);</span><br><span class="line">        <span class="built_in">this</span>.source = data;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件对应的监听器 <code>MutationEventListener</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ChineseHamburger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MutationEventListener</span> &#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlePizza</span><span class="params">(MutationEvent&lt;Pizza&gt; event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听到 Pizza...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;类型是: &quot;</span> + event.getType());</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> event.getSource();</span><br><span class="line">        System.out.println(<span class="string">&quot;Pizza 名称为: &quot;</span> + pizza.getName() </span><br><span class="line">                           + <span class="string">&quot;, 价格为: &quot;</span> + pizza.getPrice());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleChineseHamburger</span><span class="params">(MutationEvent&lt;ChineseHamburger&gt; event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听到肉夹馍...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;类型是: &quot;</span> + event.getType());</span><br><span class="line">        <span class="type">ChineseHamburger</span> <span class="variable">hamburger</span> <span class="operator">=</span> event.getSource();</span><br><span class="line">        System.out.println(<span class="string">&quot;肉夹馍的价格是: &quot;</span> + hamburger.getPrice() </span><br><span class="line">                           + <span class="string">&quot;, 大小是: &quot;</span> + hamburger.getSize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试发布 <code>MutationEvent&lt;Pizza&gt;</code> 类型的事件，看看监听器是否能监听到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">    context.registerBean(MutationEventListener.class);</span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pizza</span>(<span class="string">&quot;NewYorkPizza&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    context.publishEvent(<span class="keyword">new</span> <span class="title class_">MutationEvent</span>&lt;&gt;(pizza, <span class="string">&quot;ONE&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>main()</code> 方法后，抛出 <code>ClassCastException</code> 异常，提示无法将 <code>Pizza</code> 转换成 <code>ChineseHamburger</code>，事件监听失败。</p>
<p>由于泛型擦除，无法通过事件真正的内部对象类型来分发事件，为了解决这个问题，需要使类实现 <code>ResolvableTypeProvider</code> 接口。</p>
<p>如果未实现 <code>ResolvableTypeProvider</code> 接口：</p>
<ul>
<li>但实现了 <code>ApplicationEvent</code> 接口，尽管在监听器方法和发布事件时都指定了泛型参数信息，但所有的监听器方法都会被执行，由此可能产生 <code>ClassCastException</code>；</li>
<li>也未实现 <code>ApplicationEvent</code> 接口，就算发送的泛型事件的内部对象类型与监听器指定的泛型事件的内部对象类型一样，也不会监听成功。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MutationEvent</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> <span class="keyword">implements</span> <span class="title class_">ResolvableTypeProvider</span> &#123;</span><br><span class="line">	<span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResolvableType <span class="title function_">getResolvableType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResolvableType.forClassWithGenerics(getClass(),</span><br><span class="line">                ResolvableType.forInstance(<span class="built_in">this</span>.source));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行 <code>main()</code> 方法后，不再抛出异常，控制台打印出：</p>
<pre>
监听到 Pizza...
类型是: ONE
Pizza 名称为: NewYorkPizza, 价格为: 25.0
</pre>
<p>再发布泛型参数类型为 <code>ChineseHamburger</code> 的事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ChineseHamburger</span> <span class="variable">hamburger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChineseHamburger</span>(<span class="number">18</span>, <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    context.publishEvent(<span class="keyword">new</span> <span class="title class_">MutationEvent</span>&lt;&gt;(hamburger, <span class="string">&quot;TWO&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>
监听到 Pizza...
类型是: ONE
Pizza 名称为: NewYorkPizza, 价格为: 25.0
监听到肉夹馍...
类型是: TWO
肉夹馍的价格是: 18.0, 大小是: M
</pre>
<h1 id="49-事件-发布器"><a class="header-anchor" href="#49-事件-发布器"></a>49. 事件 - 发布器</h1>
<h2 id="49-1-自定义事件发布"><a class="header-anchor" href="#49-1-自定义事件发布"></a>49.1 自定义事件发布</h2>
<p>前文说到，事件的发布使用了 <code>SimpleApplicationEventMulticaster</code>，它的顶层接口是 <code>ApplicationEventMulticaster</code>，尝试自定义 <code>ApplicationEventMulticaster</code> 的实现类，实现事件的发布。</p>
<p><code>ApplicationEventMulticaster</code> 接口的抽象方法有很多，本节只实现重要方法，采用默认适配器处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AbstractApplicationEventMulticaster</span> <span class="keyword">implements</span> <span class="title class_">ApplicationEventMulticaster</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; listener)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addApplicationListenerBean</span><span class="params">(String listenerBeanName)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; listener)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeApplicationListenerBean</span><span class="params">(String listenerBeanName)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeApplicationListeners</span><span class="params">(Predicate&lt;ApplicationListener&lt;?&gt;&gt; predicate)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeApplicationListenerBeans</span><span class="params">(Predicate&lt;String&gt; predicate)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeAllListeners</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(ApplicationEvent event, ResolvableType eventType)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要实现的方法有两个：</p>
<ul>
<li><code>addApplicationListenerBean()</code>：收集容器中所有的监听器</li>
<li><code>multicastEvent()</code> ：发布事件</li>
</ul>
<p>收集监听器时，需要获取监听器支持的事件类型，将原始的监听器封装为支持事件类型检查的监听器，这种监听器在发布事件时，使用线程池支持发布异步事件。</p>
<p>发布事件时，遍历容器中所有监听器，当监听器支持的事件类型与发布的事件类型一致时才发布事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ApplicationEventMulticaster <span class="title function_">applicationEventMulticaster</span><span class="params">(ConfigurableApplicationContext context, ThreadPoolTaskExecutor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AbstractApplicationEventMulticaster</span>() &#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;GenericApplicationListener&gt; listeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集监听器</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addApplicationListenerBean</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="type">ApplicationListener</span> <span class="variable">listener</span> <span class="operator">=</span> context.getBean(name, ApplicationListener.class);</span><br><span class="line">            <span class="comment">// System.out.println(listener);</span></span><br><span class="line">            <span class="comment">// 获取该监听器支持的事件类型</span></span><br><span class="line">            <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> ResolvableType.forClass(listener.getClass()).getInterfaces()[<span class="number">0</span>].getGeneric();</span><br><span class="line">            <span class="comment">// System.out.println(type);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将原始的 listener 封装为支持事件类型检查的 listener</span></span><br><span class="line">            <span class="type">GenericApplicationListener</span> <span class="variable">genericApplicationListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationListener</span>() &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 是否支持某种事件类型</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> eventType 真实的事件类型</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@return</span> 是否支持某事件类型</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsEventType</span><span class="params">(ResolvableType eventType)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> type.isAssignableFrom(eventType);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">                    executor.submit(() -&gt; listener.onApplicationEvent(event));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            listeners.add(genericApplicationListener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布事件</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(ApplicationEvent event, ResolvableType eventType)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (GenericApplicationListener listener : listeners) &#123;</span><br><span class="line">                <span class="keyword">if</span> (listener.supportsEventType(ResolvableType.forClass(event.getClass()))) &#123;</span><br><span class="line">                    listener.onApplicationEvent(event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="49-2-非-ApplicationEvent-事件"><a class="header-anchor" href="#49-2-非-ApplicationEvent-事件"></a>49.2 非 ApplicationEvent 事件</h2>
<p>如果发送的事件不是 <code>ApplicationEvent</code> 类型时，Spring 会将其包装为 <code>PayloadApplicationEvent</code> 并用泛型技术解析事件对象的原始类型。</p>
<p>包装为 <code>PayloadApplicationEvent</code> 类型的逻辑无需实现，直接使用即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ApplicationEventMulticaster <span class="title function_">applicationEventMulticaster</span><span class="params">(ConfigurableApplicationContext context, ThreadPoolTaskExecutor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A49</span>.AbstractApplicationEventMulticaster() &#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;GenericApplicationListener&gt; listeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            listeners.add(<span class="keyword">new</span> <span class="title class_">GenericApplicationListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> PayloadApplicationEvent) &#123;</span><br><span class="line">                        PayloadApplicationEvent&lt;?&gt; payloadApplicationEvent = </span><br><span class="line">                            (PayloadApplicationEvent&lt;?&gt;) event;</span><br><span class="line">                        System.out.println(payloadApplicationEvent.getPayload());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsEventType</span><span class="params">(ResolvableType eventType)</span> &#123;</span><br><span class="line">                    System.out.println(eventType);</span><br><span class="line">                    <span class="comment">// eventType --&gt; PayloadApplicationEvent&lt;Object&gt;</span></span><br><span class="line">                    <span class="comment">// eventType --&gt; PayloadApplicationEvent&lt;String&gt;</span></span><br><span class="line">                    <span class="keyword">return</span> (Inter.class.isAssignableFrom(eventType.getGeneric().toClass()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">            multicastEvent(event, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(ApplicationEvent event, ResolvableType eventType)</span> &#123;</span><br><span class="line">            listeners.stream().filter(applicationListener -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (eventType == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (applicationListener <span class="keyword">instanceof</span> GenericApplicationListener) &#123;</span><br><span class="line">                    <span class="type">GenericApplicationListener</span> <span class="variable">listener</span> <span class="operator">=</span> </span><br><span class="line">                        (GenericApplicationListener) applicationListener;</span><br><span class="line">                    <span class="keyword">return</span> listener.supportsEventType(eventType);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;).forEach(listener -&gt; listener.onApplicationEvent(event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEventPublisher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(TestEventPublisher.class);</span><br><span class="line"></span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        context.publishEvent(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> <span class="title class_">Bean1</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>main()</code> 方法后，控制台打印出：</p>
<pre>
org.springframework.context.PayloadApplicationEvent&lt;java.lang.Object&gt;
org.springframework.context.PayloadApplicationEvent&lt;java.lang.String&gt;
org.springframework.context.PayloadApplicationEvent&lt;indi.mofan.a49.TestEventPublisher$Bean1&gt;
indi.mofan.a49.TestEventPublisher$Bean1@7ba18f1b
</pre>
<h2 id="49-3-【补充】Spring-内置事件"><a class="header-anchor" href="#49-3-【补充】Spring-内置事件"></a>49.3 【补充】Spring 内置事件</h2>
<p>Spring 的内置事件有很多，在此列举几个与 Spring 容器启动相关的事件，如果需要在 Spring 容器启动的某个时刻进行一些操作，就可以监听这些事件：</p>
<table>
<thead>
<tr>
<th style="text-align:center">事件类型</th>
<th style="text-align:center">触发时机</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ContextRefreshedEvent</td>
<td style="text-align:center">在调用 <code>ConfigurableApplicationContext</code> 接口中的 <code>refresh()</code> 方法时触发</td>
</tr>
<tr>
<td style="text-align:center">ContextStartedEvent</td>
<td style="text-align:center">在调用 <code>ConfigurableApplicationContext</code> 的 <code>start()</code> 方法时触发</td>
</tr>
<tr>
<td style="text-align:center">ContextStoppedEvent</td>
<td style="text-align:center">在调用 <code>ConfigurableApplicationContext</code> 的 <code>stop()</code> 方法时触发</td>
</tr>
<tr>
<td style="text-align:center">ContextClosedEvent</td>
<td style="text-align:center">当 <code>ApplicationContext</code> 被关闭时触发该事件，也就是调用 <code>close()</code> 方法触发</td>
</tr>
</tbody>
</table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mofan212.github.io">默烦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mofan212.github.io/posts/Spring-Forty-Nine-Lectures-Sundry/">https://mofan212.github.io/posts/Spring-Forty-Nine-Lectures-Sundry/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://mofan212.github.io" target="_blank">Mofan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SpringBoot/">SpringBoot</a></div><div class="post-share"><div class="social-share" data-image="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/126.jpg" data-sites="wechat,qq,weibo,facebook,twitter"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" target="_blank"><img class="post-qr-code-img" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" target="_blank"><img class="post-qr-code-img" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/Spring-Forty-Nine-Lectures-Spring-Boot/" title="【Spring 四十九讲】SpringBoot"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/125.jpg" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">【Spring 四十九讲】SpringBoot</div></div><div class="info-2"><div class="info-item-1">Spring 四十九讲中第卅七讲到第卌二讲，Spring Boot。</div></div></div></a><a class="pagination-related" href="/posts/Quick-Start-To-Arthas/" title="Arthas 快速入门"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/127.png" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Arthas 快速入门</div></div><div class="info-2"><div class="info-item-1">Arthas 是一款由阿里巴巴出品的线上监控诊断产品。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/Configuration-Annotation/" title="@Configuration 注解的那些事"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/25.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2024-08-08</div><div class="info-item-2">@Configuration 注解的那些事</div></div><div class="info-2"><div class="info-item-1">从源码层面介绍 @Configuration 注解的 Full 模式与 Lite 模式。</div></div></div></a><a class="pagination-related" href="/posts/SpringBoot-Thymeleaf-Development-Process/" title="SpringBoot + Thymeleaf开发流程"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2020-07-20</div><div class="info-item-2">SpringBoot + Thymeleaf开发流程</div></div><div class="info-2"><div class="info-item-1">本文基于 SpringBoot 2.2.4 ，介绍了 SpringBoot 与 Thymeleaf 结合的基础开发流程。</div></div></div></a><a class="pagination-related" href="/posts/Spring-BeanDefinition/" title="BeanDefinition"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/153.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2024-08-11</div><div class="info-item-2">BeanDefinition</div></div><div class="info-2"><div class="info-item-1">Spring 中绕不开的一个类 —— BeanDefinition。</div></div></div></a><a class="pagination-related" href="/posts/SpringBoot-Data/" title="SpringBoot与数据库"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2020-12-13</div><div class="info-item-2">SpringBoot与数据库</div></div><div class="info-2"><div class="info-item-1">本文基于 SpringBoot 2.2.4 ，介绍了 SpringBoot 如何整合数据库。</div></div></div></a><a class="pagination-related" href="/posts/SpringBoot-Shutdown-Hook/" title="SpringBoot Shutdown Hook"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/141.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2024-07-11</div><div class="info-item-2">SpringBoot Shutdown Hook</div></div><div class="info-2"><div class="info-item-1">介绍了 System.exit() 方法的源码、SpringBoot 优雅停机等内容。</div></div></div></a><a class="pagination-related" href="/posts/Principles-Of-SpringBoot/" title="SpringBoot原理"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2020-11-05</div><div class="info-item-2">SpringBoot原理</div></div><div class="info-2"><div class="info-item-1">误人子弟系列，不要看，后续找个时间重写。😶</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">默烦</div><div class="author-info-description">彩笔的打怪升级之路...</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">155</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mofan212"><i class="fab fa-github"></i><span>follow me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:cy.mofan@foxmail.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a><a class="social-icon" href="https://www.travellings.cn/go.html" target="_blank" title="开往"><i class="fas fa-subway"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站所有博文均是博主的学习笔记与个人理解。<strong><font style="color:red">除特别注明外，</font>如需转载，请在文章头部醒目处附带原文链接并<a target="_blank" rel="noopener" href="https://mofan212.gitee.io/mine/" style="color:#49B1F5;text-decoration:underline">告知我</a></strong>你将转载。😊</br><strong><font style="color:red">严禁未遵循规范的转载。</font></strong>😡</br><strong>死去的评论系统复活啦！欢迎到留言板畅所欲言！</strong>当然也可以使用更高效的<a target="_blank" href="https://space.bilibili.com/23658864/dynamic" style="color:#49B1F5;text-decoration:underline"> 哔哩哔哩私信 </a>或<a href="mailto:cy.mofan@foxmail.com" style="color:#49B1F5;text-decoration:underline" target="_blank">邮箱</a>。 😉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#43-FactoryBean"><span class="toc-text">43. FactoryBean</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#44-Indexed"><span class="toc-text">44. @Indexed</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#45-%E4%BB%A3%E7%90%86%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3"><span class="toc-text">45. 代理进一步理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#46-Value-%E6%B3%A8%E5%85%A5%E5%BA%95%E5%B1%82"><span class="toc-text">46. @Value 注入底层</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#47-Autowired-%E6%B3%A8%E5%85%A5%E5%BA%95%E5%B1%82"><span class="toc-text">47. @Autowired 注入底层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#47-1-%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-text">47.1 注入方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-2-%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D%E7%BB%86%E8%8A%82"><span class="toc-text">47.2 类型匹配细节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#48-%E4%BA%8B%E4%BB%B6-%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-text">48. 事件 - 监听器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#48-1-%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">48.1 监听器的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-2-%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6"><span class="toc-text">48.2 异步事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%B3%A8%E8%A7%A3"><span class="toc-text">48.3 自定义事件监听注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-4-%E3%80%90%E8%A1%A5%E5%85%85%E3%80%91%E7%9B%91%E5%90%AC%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">48.4 【补充】监听器执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-5-%E3%80%90%E8%A1%A5%E5%85%85%E3%80%91%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD"><span class="toc-text">48.5 【补充】事件的传播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-6-%E3%80%90%E8%A1%A5%E5%85%85%E3%80%91%E5%B8%A6%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-text">48.6 【补充】带泛型的事件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#49-%E4%BA%8B%E4%BB%B6-%E5%8F%91%E5%B8%83%E5%99%A8"><span class="toc-text">49. 事件 - 发布器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#49-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83"><span class="toc-text">49.1 自定义事件发布</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-2-%E9%9D%9E-ApplicationEvent-%E4%BA%8B%E4%BB%B6"><span class="toc-text">49.2 非 ApplicationEvent 事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-3-%E3%80%90%E8%A1%A5%E5%85%85%E3%80%91Spring-%E5%86%85%E7%BD%AE%E4%BA%8B%E4%BB%B6"><span class="toc-text">49.3 【补充】Spring 内置事件</span></a></li></ol></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>黑马程序员 Spring 四十九讲</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Spring-Forty-Nine-Lectures-Container-And-Bean/" title="【Spring 四十九讲】容器与 Bean"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/122.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="【Spring 四十九讲】容器与 Bean"></a><div class="content"><a class="title" href="/posts/Spring-Forty-Nine-Lectures-Container-And-Bean/" title="【Spring 四十九讲】容器与 Bean">【Spring 四十九讲】容器与 Bean</a><time datetime="2023-01-07T16:00:00.000Z" title="发表于 2023-01-08 00:00:00">2023-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Spring-Forty-Nine-Lectures-AOP/" title="【Spring 四十九讲】AOP"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/123.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="【Spring 四十九讲】AOP"></a><div class="content"><a class="title" href="/posts/Spring-Forty-Nine-Lectures-AOP/" title="【Spring 四十九讲】AOP">【Spring 四十九讲】AOP</a><time datetime="2023-01-20T16:00:00.000Z" title="发表于 2023-01-21 00:00:00">2023-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Spring-Forty-Nine-Lectures-MVC/" title="【Spring 四十九讲】WebMVC"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/124.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="【Spring 四十九讲】WebMVC"></a><div class="content"><a class="title" href="/posts/Spring-Forty-Nine-Lectures-MVC/" title="【Spring 四十九讲】WebMVC">【Spring 四十九讲】WebMVC</a><time datetime="2023-01-26T16:00:00.000Z" title="发表于 2023-01-27 00:00:00">2023-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Spring-Forty-Nine-Lectures-Spring-Boot/" title="【Spring 四十九讲】SpringBoot"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/125.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="【Spring 四十九讲】SpringBoot"></a><div class="content"><a class="title" href="/posts/Spring-Forty-Nine-Lectures-Spring-Boot/" title="【Spring 四十九讲】SpringBoot">【Spring 四十九讲】SpringBoot</a><time datetime="2023-01-28T16:00:00.000Z" title="发表于 2023-01-29 00:00:00">2023-01-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Spring-Forty-Nine-Lectures-Sundry/" title="【Spring 四十九讲】杂项"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/126.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="【Spring 四十九讲】杂项"></a><div class="content"><a class="title" href="/posts/Spring-Forty-Nine-Lectures-Sundry/" title="【Spring 四十九讲】杂项">【Spring 四十九讲】杂项</a><time datetime="2023-02-02T16:00:00.000Z" title="发表于 2023-02-03 00:00:00">2023-02-03</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/DataStructure-Union-Find/" title="高级数据结构之并查集"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/50.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="高级数据结构之并查集"/></a><div class="content"><a class="title" href="/posts/DataStructure-Union-Find/" title="高级数据结构之并查集">高级数据结构之并查集</a><time datetime="2025-01-01T16:00:00.000Z" title="更新于 2025-01-02 00:00:00">2025-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/FreeMarker-Template-Author's-Guide/" title="FreeMarker 模板开发"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/68.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="FreeMarker 模板开发"/></a><div class="content"><a class="title" href="/posts/FreeMarker-Template-Author's-Guide/" title="FreeMarker 模板开发">FreeMarker 模板开发</a><time datetime="2024-12-26T16:00:00.000Z" title="更新于 2024-12-27 00:00:00">2024-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/How-To-Install-Rust-On-Windows/" title="如何在 Windows 下安装 Rust"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/155.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="如何在 Windows 下安装 Rust"/></a><div class="content"><a class="title" href="/posts/How-To-Install-Rust-On-Windows/" title="如何在 Windows 下安装 Rust">如何在 Windows 下安装 Rust</a><time datetime="2024-11-22T16:00:00.000Z" title="更新于 2024-11-23 00:00:00">2024-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Algorithm-Shortest-Path/" title="【算法】图的最短路径"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/53.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="【算法】图的最短路径"/></a><div class="content"><a class="title" href="/posts/Algorithm-Shortest-Path/" title="【算法】图的最短路径">【算法】图的最短路径</a><time datetime="2024-10-27T16:00:00.000Z" title="更新于 2024-10-28 00:00:00">2024-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/How-To-Parse-Spring-Configuration-Classes/" title="Spring 配置类的解析"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/154.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Spring 配置类的解析"/></a><div class="content"><a class="title" href="/posts/How-To-Parse-Spring-Configuration-Classes/" title="Spring 配置类的解析">Spring 配置类的解析</a><time datetime="2024-10-25T16:00:00.000Z" title="更新于 2024-10-26 00:00:00">2024-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Something-About-Blog/" title="博客搭建与维护"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/42.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="博客搭建与维护"/></a><div class="content"><a class="title" href="/posts/Something-About-Blog/" title="博客搭建与维护">博客搭建与维护</a><time datetime="2024-10-06T16:00:00.000Z" title="更新于 2024-10-07 00:00:00">2024-10-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 默烦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://fastly.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://fastly.jsdelivr.net/npm/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://npm.elemecdn.com/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://fastly.jsdelivr.net/gh/mofan212/blog-static-resources@master/js/mine.min.js"></script><script defer="defer" id="ribbon" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-show-text" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Azathoth,Yog-Sothoth,Shub-Niggurath,Nyarlathotep,Cthulhu,Hastur,Abhoth,Ghroth,Tsathoggua,Cthugha,Deep Ones,Dagon,Chaugnar Faugn,Mordiggian,Shoggoth,Old One,Mi-Go,Great Race of Yith,Flying Polyp,Hounds of Tindalos,Dhole" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://fastly.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'BAFEL7A6K1',
    apiKey: '89fcb5961984c5c054bf04149f345f38',
    indexName: 'mofan212io',
    container: '#docsearch',
    placeholder: '输入关键字进行搜索',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>
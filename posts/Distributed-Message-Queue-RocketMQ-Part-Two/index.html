<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【下篇】分布式消息队列 RocketMQ | Mofan</title><meta name="author" content="默烦,cy.mofan@foxmail.com"><meta name="copyright" content="默烦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文介绍了 RocketMQ 的工作原理与应用。">
<meta property="og:type" content="article">
<meta property="og:title" content="【下篇】分布式消息队列 RocketMQ">
<meta property="og:url" content="https://mofan212.github.io/posts/Distributed-Message-Queue-RocketMQ-Part-Two/index.html">
<meta property="og:site_name" content="Mofan">
<meta property="og:description" content="本文介绍了 RocketMQ 的工作原理与应用。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/95.png">
<meta property="article:published_time" content="2021-09-18T16:00:00.000Z">
<meta property="article:modified_time" content="2021-09-18T16:00:00.000Z">
<meta property="article:author" content="默烦">
<meta property="article:tag" content="Middleware">
<meta property="article:tag" content="RocketMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/95.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【下篇】分布式消息队列 RocketMQ",
  "url": "https://mofan212.github.io/posts/Distributed-Message-Queue-RocketMQ-Part-Two/",
  "image": "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/95.png",
  "datePublished": "2021-09-18T16:00:00.000Z",
  "dateModified": "2021-09-18T16:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "默烦",
      "url": "https://mofan212.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/favicon.png"><link rel="canonical" href="https://mofan212.github.io/posts/Distributed-Message-Queue-RocketMQ-Part-Two/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 默烦","link":"链接: ","source":"来源: Mofan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://testingcf.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【下篇】分布式消息队列 RocketMQ',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><link rel="stylesheet" href="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources@master/css/myStyle.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css" /><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" /><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Mofan" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources/css/minimal.min.css"/><script src="https://testingcf.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">164</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">36</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/post_top_img.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Mofan</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【下篇】分布式消息队列 RocketMQ</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-18T16:00:00.000Z" title="发表于 2021-09-19 00:00:00">2021-09-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-18T16:00:00.000Z" title="更新于 2021-09-19 00:00:00">2021-09-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Middleware/">Middleware</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">25.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>89分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;距离本文上次更新已经过去&quot;,&quot;messageNext&quot;:&quot;天，请注意时效性。&quot;,&quot;postUpdate&quot;:&quot;2021-09-19 00:00:00&quot;}" hidden></div><p>封面来源：本文封面来源于网络，如有侵权，请联系删除。</p>
<p>本文参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cf4y157sz">【尚硅谷】2021最新版RocketMQ教程丨轻松入门分布式消息系统</a></p>
<h1 id="1-RocketMQ-工作原理"><a class="header-anchor" href="#1-RocketMQ-工作原理"></a>1. RocketMQ 工作原理</h1>
<h2 id="1-1-消息的生产"><a class="header-anchor" href="#1-1-消息的生产"></a>1.1 消息的生产</h2>
<h3 id="1-1-1-消息的生产过程"><a class="header-anchor" href="#1-1-1-消息的生产过程"></a>1.1.1 消息的生产过程</h3>
<p>Producer 可以将消息写入到某 Broker 中的某 Queue 中，其经历了如下过程：</p>
<p>1、Producer 发送消息之前，会先向 NameServer 发出获取 <strong>消息 Topic 的路由信息</strong> 的请求；</p>
<p>2、NameServer 返回该 Topic 的 <strong>路由表</strong> 及 <strong>Broker 列表</strong>；</p>
<p>3、Producer 根据代码中指定的 Queue 选择策略，从 Queue 列表中选出一个队列，用于后续存储消息；</p>
<p>4、Produer 对消息做一些特殊处理，例如，消息本身超过 4M，则会对其进行压缩；</p>
<p>5、Producer 向选择出的 Queue 所在的 Broker 发出 RPC 请求，将消息发送到选择出的 Queue；</p>
<blockquote>
<p>路由表</p>
</blockquote>
<p>实际上是一个Map，Key 为 Topic 名称，Value 是一个 QueueData 实例列表。QueueData 并不是一个 Queue 对应一个 QueueData，而是一个 Broker 中该 Topic 的所有 Queue 对应一个QueueData。也就是说，只要涉及到该 Topic 的 Broker，一个 Broker 对应一个 QueueData。QueueData 中包含 BrokerName。简单来说，路由表的 Key 为 Topic 名称，Value 则为所有涉及该 Topic 的 BrokerName 列表。</p>
<blockquote>
<p>Borker 列表</p>
</blockquote>
<p>实际上也是一个 Map，Key 为 BrokerName，Value 为 BrokerData。</p>
<p>那么一个 Broker 对应一个 BrokerData 实例？这种说法是不对。一套 BrokerName 名称相同的 Master-Slave 小集群对应一个 BrokerData。BrokerData 中包含 BrokerName 和一个 Map。该 Map 的 Key 为 BrokerId，Value 为该 Broker 对应的地址。BrokerId 为 0 表示该 Broker 为 Master，非 0 则表示 Slave。</p>
<h3 id="1-1-2-Queue-选择算法"><a class="header-anchor" href="#1-1-2-Queue-选择算法"></a>1.1.2 Queue 选择算法</h3>
<p>对于无序消息，其 Queue 选择算法，也称为消息投递算法，常见的有两种：</p>
<blockquote>
<p>轮询算法</p>
</blockquote>
<p>默认选择算法。该算法保证了每个 Queue 中可以均匀的获取到消息。</p>
<p>但该算法存在一个问题：由于某些原因，在某些 Broker 上的 Queue 的投递延迟可能较严重，将导致 Producer 的缓存队列中出现较大的消息积压，影响消息的投递性能。</p>
<blockquote>
<p>最小投递延迟算法</p>
</blockquote>
<p>该算法会统计每次消息投递的时间延迟，然后根据统计出的结果将消息投递到时间延迟最小的 Queue。如果延迟相同，则采用轮询算法投递。该算法可以有效提升消息的投递性能。</p>
<p>该算法也存在一个问题：消息在 Queue 上的分配不均匀。投递延迟小的 Queue 其可能会存在大量的消息，进而对该 Queue 的消费者压力会增大，降低消息的消费能力，导致 MQ 中消息的堆积。</p>
<h2 id="1-2-消息的存储"><a class="header-anchor" href="#1-2-消息的存储"></a>1.2 消息的存储</h2>
<p>RocketMQ 中的消息存储在本地文件系统中，这些相关文件默认在当前用户主目录下的 store 目录中：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E6%B6%88%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE.png" alt="RocketMQ消息的存储位置"></p>
<blockquote>
<p>各文件解析</p>
</blockquote>
<p>abort：该文件在Broker启动后会自动创建，正常关闭Broker，该文件会自动消失。若在没有启动 Broker 的情况下，发现这个文件是存在的，则说明之前 Broker 的关闭是非正常关闭。很显然，在上图中我并没有启动 Broker，因此 abort 文件是不存在的。</p>
<p>checkpoint：存放着 commitlog、consumequeue、index 文件的最后刷盘时间戳。</p>
<p>commitlog：存放着 commitlog 文件，而消息是写在 commitlog 文件中的。</p>
<p>config：存放着 Broker 运行期间的一些配置数据。</p>
<p>consumequeue：存放着 consumequeue 文件，队列就存放在这个目录中。</p>
<p>index：其中存放着消息索引文件 indexFile。</p>
<p>lock：运行期间使用到的全局资源锁。</p>
<h3 id="1-2-1-commitlog-文件"><a class="header-anchor" href="#1-2-1-commitlog-文件"></a>1.2.1 commitlog 文件</h3>
<p>说明：在很多资料中 commitlog 目录中的文件简单就称为 commitlog 文件。但在源码中，该文件被命名为 mappedFile。</p>
<blockquote>
<p>目录与文件</p>
</blockquote>
<p>commitlog 目录中存放着很多的 mappedFile 文件，当前 Broker 中的所有消息都是落盘到这些 mappedFile 文件中的。</p>
<p>mappedFile 文件最大可以为1G（小于等于1G）。如果恰好有一条消息需要落盘到某个 mappedFile 文件中，但是其剩余空间又放不下这条消息，那么这条消息就只能放到另一个 mappedFile 文件中，此时最初的 mappedFile 文件大小就小于 1G。</p>
<p>mappedFile 文件名由 20 位十进制数构成，表示当前文件的第一条消息的起始位移偏移量。</p>
<p>第一个文件名一定是 20 位 0 构成的，因为第一个文件的第一条消息的偏移量 commitlog offset 为 0。当第一个文件放满时，则会自动生成第二个文件继续存放消息。假设第一个文件大小是 <code>1073741820</code> 字节（1G = 1073741824 字节），则第二个文件名就是 <code>00000000001073741820</code>。以此类推，第 n 个文件名应该是前 n-1 个文件大小之和。一个 Broker 中所有 mappedFile 文件的 commitlog offset 是连续的。</p>
<p>需要注意的是，一个 Broker 中仅包含一个 commitlog 目录，所有的 mappedFile 文件都是存放在该目录中的。也就是说无论当前 Broker 中存放着多少 Topic 的消息，这些消息都是被顺序写入到了 mappedFile 文件中的。换而言之，这些消息在 Broker 中存放时并没有被按照 Topic 进行分类存放。</p>
<p>由于 mappedFile 文件是顺序读写的文件，所以其访问效率很高。无论是在 SSD 磁盘还是 SATA 磁盘，通常情况下，顺序存取效率都会高于随机存取。</p>
<blockquote>
<p>消息单元</p>
</blockquote>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/commitlog%E4%B8%AD%E5%90%8D%E7%A7%B0%E4%B8%BAn%E7%9A%84mapperFile%E6%96%87%E4%BB%B6%E5%86%85%E9%83%A8%E6%B6%88%E6%81%AF%E5%AD%98%E6%94%BE%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="commitlog中名称为n的mapperFile文件内部消息存放结构示意图"></p>
<p>mappedFile 文件内容由一个个的消息单元构成。每个消息单元中包含消息总长度 MsgLen、消息的物理位置 physicalOffset、消息体内容 Body、消息体长度 BodyLength、消息主题 Topic、Topic 长度 TopicLength、消息生产者 BornHost、消息发送时间戳 BornTimestamp、消息所在的队列 QueueId、消息在 Queue 中存储的偏移量 QueueOffset 等近 20 余项消息相关属性。</p>
<p>需要注意到，消息单元中是包含 Queue 相关属性的。那么 commitlog 与 Queue 间的关系是什么？</p>
<p>一个 mappedFile 文件中第 <code>m+1</code> 个消息单元的 commitlog offset 偏移量为：</p>
<p><code>L(m+1) = L(m) + MsgLen(m) (m &gt;= 0)</code></p>
<h3 id="1-2-2-ConsumeQueue"><a class="header-anchor" href="#1-2-2-ConsumeQueue"></a>1.2.2 ConsumeQueue</h3>
<blockquote>
<p>目录与文件</p>
</blockquote>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/consumequeue%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B.png" alt="consumequeue文件示例"></p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85.png" alt="RocketMQ生产者与消费者"></p>
<p>为了提高效率，会为每个 Topic 在 <code>~/store/consumequeue</code> 中创建一个目录，目录名为 Topic 名称。在该 Topic 目录下，会再为每个该 Topic 的 Queue 建立一个目录，目录名为 queueId。每个目录中存放着若干 consumequeue 文件，consumequeue 文件是 commitlog 的索引文件，可以根据 consumequeue 定位到具体的消息。</p>
<p>consumequeue 文件名也由 20 位数字构成，表示当前文件的第一个索引条目的起始位移偏移量。与 mappedFile 文件名不同的是，其后续文件名是固定的，这是因为 consumequeue 文件大小是固定不变的。</p>
<blockquote>
<p>索引条目</p>
</blockquote>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/consumerqueue%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E6%9D%A1%E7%9B%AE%E7%9A%84%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="consumerqueue文件的一个索引条目的结构示意图"></p>
<p>每个 consumequeue 文件可以包含 30w 个索引条目，每个索引条目包含了三个消息重要属性：消息在 mappedFile 文件中的偏移量 CommitLog Offset、消息长度、消息 Tag 的 hashcode 值。这三个属性占 20 个字节，所以每个文件的大小是固定的 <code>30w * 20</code>字节。</p>
<p>一个 consumequeue 文件中所有消息的 Topic 一定是相同的，但每条消息的 Tag 可能不同。</p>
<h3 id="1-2-3-对文件的读写"><a class="header-anchor" href="#1-2-3-对文件的读写"></a>1.2.3 对文件的读写</h3>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99.png" alt="RocketMQ对文件的读写"></p>
<blockquote>
<p>消息写入</p>
</blockquote>
<p>一条消息进入到 Broker 后将经历以下几个过程才最终被持久化：</p>
<p>1、Broker 根据 queueId，获取到该消息对应索引条目要在 consumequeue 目录中的写入偏移量，即 QueueOffset；</p>
<p>2、将 queueId、queueOffset 等数据，与消息一起封装为消息单元；</p>
<p>3、将消息单元写入到 commitlog，同时形成消息索引条目；</p>
<p>4、将消息索引条目分发到相应的 consumequeue。</p>
<blockquote>
<p>消息拉取</p>
</blockquote>
<p>当 Consumer 来拉取消息时会经历以下几个步骤：</p>
<p>1、Consumer 获取到其要消费消息所在 Queue 的 <strong>消费偏移量 offset</strong>，计算出其要消费消息的消息 offset。消费偏移量 offset 就是消费进度，Consumer 对某个 Queue 的消费 offset，即消费到了该 Queue 的第几条消息，并且 <code>消息 offset = 消费offset + 1</code>；</p>
<p>2、Consumer 向 Broker 发送拉取请求，其中会包含其要拉取消息的 Queue、消息 offset 及消息 Tag；</p>
<p>3、Broker 计算在该 consumequeue 中的 queueOffset。其中 <code>queueOffset = 消息offset * 20字节</code>；</p>
<p>4、从该 queueOffset 处开始向后查找 <strong>第一个指定</strong> Tag 的索引条目；</p>
<p>5、解析该索引条目的前 8 个字节，即可定位到该消息在 commitlog 中的 commitlog offset；</p>
<p>6、从对应 commitlog offset 中读取消息单元发送给 Consumer。</p>
<blockquote>
<p>性能提升</p>
</blockquote>
<p>RocketMQ 中，无论是消息本身还是消息索引，都是存储在磁盘上的。那么这样不会影响消息的消费吗？</p>
<p>当然不会。其实 RocketMQ 的性能在目前的 MQ 产品中性能是非常高的，因为系统通过一系列相关机制大大提升了性能。</p>
<p>首先，RocketMQ 对文件的读写操作是通过 <strong>mmap 零拷贝</strong> 进行的，将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率。</p>
<p>其次，consumequeue 中的数据是顺序存放的，还引入了 <strong>PageCache 的预读取机制</strong>，使得对 consumequeue 文件的读取几乎接近于内存读取，即使在有消息堆积情况下也不会影响性能。</p>
<p>RocketMQ 中可能会影响性能的是对 commitlog 文件的读取。因为对 commitlog 文件来说，读取消息时会产生大量的随机访问，而随机访问会严重影响性能。不过，如果选择合适的系统 IO 调度算法，比如设置调度算法为 Deadline（同时采用 SSD 固态硬盘的话），随机读的性能也会有所提升。</p>
<blockquote>
<p>PageCache 机制</p>
</blockquote>
<p>PageCache 机制，页面缓存机制，是操作系统对文件的缓存机制，用于加速对文件的读写操作。一般来说，程序对文件进行 <strong>顺序读写</strong> 的速度几乎接近于内存读写速度，主要原因是由于 OS （操作系统）使用 PageCache 机制对读写访问操作进行性能优化，将一部分的内存用作 PageCache。</p>
<p>写操作：OS 会先将数据写入到 PageCache 中，随后会以异步方式由 pdflush（page dirty flush）内核线程将 Cache中的数据刷盘到物理磁盘。</p>
<p>读操作：若用户要读取数据，其首先会从 PageCache 中读取，若没有命中，则 OS 再从物理磁盘上加载该数据到 PageCache 的同时，也会顺序对其相邻数据块中的数据进行预读取。</p>
<h3 id="1-2-4-与-Kafka-的对比"><a class="header-anchor" href="#1-2-4-与-Kafka-的对比"></a>1.2.4 与 Kafka 的对比</h3>
<p>RocketMQ 的很多思想来源于 Kafka，比如 commitlog 与 consumequeue 就是来自 Kafka 的。</p>
<p>RocketMQ 中的 commitlog 目录与 consumequeue 的结合类似于 Kafka 中的 partition 分区目录。mappedFile 文件类似于 Kafka 中的 segment 段。</p>
<p>Kafka 中 Topic 的消息被分割为一个或多个 partition。partition 是一个物理概念，对应到系统上就是 Topic 目录下的一个或多个目录。每个 partition 中包含的文件称为 segment，是具体存放消息的文件。</p>
<p>Kafka 中消息存放的目录结构是：Topic 目录下有 partition 目录，partition 目录下有 segment 文件。</p>
<p>Kafka 中没有二级分类标签 Tag 这个概念。</p>
<p>Kafka 中无需索引文件。因为生产者是将消息直接写在了 partition 中的，消费者也是直接从 partition 中读取数据的。</p>
<h2 id="1-3-indexFile"><a class="header-anchor" href="#1-3-indexFile"></a>1.3 indexFile</h2>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/indexFile%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B.png" alt="indexFile文件示例"></p>
<p>除了通过通常的指定 Topic 进行消息消费外，RocketMQ 还提供了 <strong>根据 key 进行消息查询的功能</strong>。该查询是通过 store 目录中的 index 子目录中的 indexFile 进行索引实现的快速查询。当然，这个 indexFile 中的索引数据是在 <strong>包含了 Key 的消息</strong> 被发送到 Broker 时写入的。如果消息中没有包含 Key，则不会写入。</p>
<h3 id="1-3-1-索引条目结构"><a class="header-anchor" href="#1-3-1-索引条目结构"></a>1.3.1 索引条目结构</h3>
<p>每个 Broker 中会包含一组 indexFile，每个 indexFile 都是以一个 <strong>时间戳</strong> 命名的（这个 indexFile 被创建时的时间戳）。每个 indexFile 文件由三部分构成：indexHeader，slots 槽位，indexes 索引数据。每个 indexFile文件中包含 500w 个 slot 槽。而每个 slot 槽又可能会挂载很多的 index 索引单元。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/indexFile%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="indexFile文件结构示意图"></p>
<p>indexHeader 固定 40 个字节，其中存放着如下数据：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/indexHeader%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="indexHeader结构示意图"></p>
<blockquote>
<p>indexHeader 中各数据解析</p>
</blockquote>
<p>beginTimestamp：该 indexFile 中第一条消息的存储时间；</p>
<p>endTimestamp：该 indexFile 中最后一条消息存储时间；</p>
<p>beginPhyoffset：该 indexFile 中第一条消息在 commitlog 中的偏移量 commitlog offset；</p>
<p>endPhyoffset：该 indexFile 中最后一条消息在 commitlog 中的偏移量 commitlog offset；</p>
<p>hashSlotCount：已经填充有 index 的 slot 数量（并不是每个 slot 槽下都挂载有 index 索引单元，这里统计的是所有挂载了 index 索引单元的 slot 槽的数量）；</p>
<p>indexCount：该 indexFile 中包含的索引单元个数（统计出当前 indexFile 中所有 slot 槽下挂载的所有 index 索引单元的数量和）。</p>
<hr>
<p>indexFile 中最复杂的是 slots 与 indexes 间的关系。在实际存储时，indexes 是在 slots 后面的，但为了便于理解，将它们的关系展示为如下形式：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/slots%E4%B8%8Eindexes%E5%85%B3%E7%B3%BB%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="slots与indexes关系结构示意图"></p>
<p>key 的 hash 值 % 500w 的结果即为 slot 槽位，然后将该 slot 值修改为该 index 索引单元的 indexNo，根据这个indexNo 可以计算出该 index 单元在 indexFile 中的位置。不过，该取模结果的重复率是很高的，为了解决该问题，在每个 index 索引单元中增加了 preIndexNo，用于指定该 slot 中当前 index 索引单元的前一个 index 索引单元。而 slot 中始终存放的是其下最新的 index 索引单元的 indexNo，这样的话，只要找到了 slot 就可以找到其最新的 index索引单元，而通过这个 index 索引单元就可以找到其之前的所有 index 索引单元。</p>
<p>indexNo 是一个在 indexFile 中的流水号，从 0 开始依次递增。在一个 indexFile 中所有 indexNo 是以此递增的。indexNo 在 index 索引单元中是没有体现的，其是通过 indexes 中依次数出来的。</p>
<p>index 索引单元默写 20 个字节，其中存放着以下四个属性：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/index%E7%B4%A2%E5%BC%95%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="index索引单元结构示意图"></p>
<blockquote>
<p>index 索引单元属性解析</p>
</blockquote>
<p>keyHash：消息中指定的业务 key 的 hash 值；</p>
<p>phyOffset：当前 key 对应的消息在 commitlog 中的偏移量 commitlog offset；</p>
<p>timeDiff：当前 key 对应消息的存储时间与当前 indexFile 创建时间的时间差；</p>
<p>preIndexNo：当前 slot 下当前 index 索引单元的前一个 index 索引单元的 indexNo。</p>
<h3 id="1-3-2-indexFile-的创建"><a class="header-anchor" href="#1-3-2-indexFile-的创建"></a>1.3.2 indexFile 的创建</h3>
<p>indexFile 的文件名为当前文件被创建时的时间戳。这个时间戳有什么用处呢？</p>
<p>根据业务 key 进行查询时，查询条件除了 key 之外，还需要指定一个要查询的时间戳，表示要查询不大于该时间戳的最新的消息，即查询指定时间戳之前存储的最新消息。这个时间戳文件名可以简化查询，提高查询效率。</p>
<p>indexFile 文件创建的条件（时机）有两个：</p>
<p>1、当第一条带 key 的消息发送来后，系统发现没有 indexFile，此时会创建第一个 indexFile 文件；</p>
<p>2、当一个 indexFile 中挂载的 index 索引单元数量超出 2000w 个时，会创建新的 indexFile。当带 key 的消息发送到来后，系统会找到最新的 indexFile，并从其 indexHeader 的最后 4 字节中读取到 indexCount。若 <code>indexCount &gt;= 2000w</code>，就创建新的 indexFile。</p>
<p>由于可以推算出，一个 indexFile 最大可有 <code>(40 + 500w * 4 + 2000w * 20)</code> 字节</p>
<h3 id="1-3-3-查询流程"><a class="header-anchor" href="#1-3-3-查询流程"></a>1.3.3 查询流程</h3>
<p>当消费者通过业务 key 来查询相应的消息时，其需要经过一个相对较复杂的查询流程。不过，在分析查询流程之前，首先要清楚几个定位计算式子：</p>
<p>1、计算指定消息 key 的 slot 槽位序号：<code>slot槽位序号 = key 的 hash % 500w</code></p>
<p>2、计算槽位序号为 n 的 slot 在 indexFile 中的起始位置：<code>slot(n)位置 = 40 + (n - 1) * 4</code></p>
<p>3、计算 indexNo 为 m 的 index 在 indexFile 中的位置：<code>index(m)位置 = 40 + 500w * 4 + (m - 1) * 20</code></p>
<p>在上述式子中，40 为 indexFile 中 indexHeader 的字节数，<code>500w * 4</code> 是所有 slots 所占的字节数。</p>
<p>具体查询流程如下：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E6%B6%88%E6%81%AF%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="RocketMQ消息查询流程"></p>
<h2 id="1-4-消息的消费"><a class="header-anchor" href="#1-4-消息的消费"></a>1.4 消息的消费</h2>
<p>消费者从 Broker 中获取消息的方式有两种：pull 拉取方式和 push 推动方式。消费者组对于消息消费的模式又分为两种：集群消费 Clustering 和广播消费 Broadcasting。</p>
<h3 id="1-4-1-获取消费类型"><a class="header-anchor" href="#1-4-1-获取消费类型"></a>1.4.1 获取消费类型</h3>
<blockquote>
<p>拉取式消费</p>
</blockquote>
<p>Consumer 主动从 Broker 中拉取消息，主动权由 Consumer 控制。一旦获取了批量消息，就会启动消费过程。不过，该方式的实时性较弱，当 Broker 中有了新的消息时消费者并不能及时发现并消费。</p>
<p>由于拉取时间间隔是由用户指定的，所以在设置该间隔时需要注意平稳：间隔太短，空请求比例会增加；间隔太长，消息的实时性太差。</p>
<blockquote>
<p>推送式消费</p>
</blockquote>
<p>该模式下 Broker 收到数据后会主动推送给 Consumer。该获取方式一般实时性较高。</p>
<p>该获取方式是典型的 <strong>发布 - 订阅</strong> 模式，即 Consumer 向其关联的 Queue 注册了监听器，一旦发现有新的消息到来就会触发回调的执行，回调方法是 Consumer 去 Queue 中拉取消息。而这些都是基于 Consumer 与 Broker 间的长连接的。长连接的维护是需要消耗系统资源的。</p>
<blockquote>
<p>两者之间的对比</p>
</blockquote>
<p>pull：需要应用去实现对关联 Queue 的遍历，实时性差，但便于应用控制消息的拉取；</p>
<p>push：封装了对关联 Queue 的遍历，实时性强，但会占用较多的系统资源。</p>
<h3 id="1-4-2-消费模式"><a class="header-anchor" href="#1-4-2-消费模式"></a>1.4.2 消费模式</h3>
<blockquote>
<p>广播消费模式</p>
</blockquote>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E5%B9%BF%E6%92%AD%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="RocketMQ广播消费模式示意图"></p>
<p>广播消费模式下，相同 Consumer Group 的每个 Consumer 实例都接收同一个 Topic 的全量消息，即每条消息都会被发送到 Consumer Group 中的 <strong>每个</strong> Consumer。</p>
<blockquote>
<p>集群消费模式</p>
</blockquote>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E9%9B%86%E7%BE%A4%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="RocketMQ集群消费模式示意图"></p>
<p>集群消费模式下，相同 Consumer Group 的每个 Consumer 实例 <strong>平均分摊</strong> 同一个 Topic 的消息，即每条消息只会被发送到 Consumer Group 中的 <strong>某个</strong> Consumer。</p>
<blockquote>
<p>消息进度保存</p>
</blockquote>
<p>广播模式：消费进度保存在 Consumer 端。因为广播模式下 Consumer Group 中每个 Consumer 都会消费所有消息，但它们的消费进度是不同，所以 Consumer 各自保存各自的消费进度。</p>
<p>集群模式：消费进度保存在 Broker 中。Consumer Group 中的所有 Consumer 共同消费同一个 Topic 中的消息，同一条消息只会被消费一次。消费进度会参与到了消费的负载均衡中，故消费进度是需要共享的。</p>
<p>下图是 Broker 中存放的各个 Topic 的各个 Queue 的消费进度：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E5%90%84%E4%B8%AATopic%E7%9A%84%E5%90%84%E4%B8%AAQueue%E7%9A%84%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%BA%A6.png" alt="各个Topic的各个Queue的消费进度"></p>
<h3 id="1-4-3-Rebalance-机制"><a class="header-anchor" href="#1-4-3-Rebalance-机制"></a>1.4.3 Rebalance 机制</h3>
<p>Rebalance 机制讨论的前提是：消费模式是 <strong>集群消费模式</strong>。</p>
<blockquote>
<p>什么是 Rebalance</p>
</blockquote>
<p>Rebalance 即再均衡，指的是将⼀个 Topic 下的多个 Queue 在同⼀个 Consumer Group 中的多个 Consumer 间进行重新分配的过程。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E7%9A%84Rebalance.png" alt="RocketMQ的Rebalance"></p>
<p>Rebalance 机制的本意是为了提升消息的 <strong>并行消费能力</strong>。例如，⼀个 Topic 下 5 个队列，在只有 1 个消费者的情况下，这个消费者将负责消费这 5 个队列的消息。如果此时我们增加⼀个消费者，那么就可以给其中⼀个消费者分配 2 个队列，给另⼀个分配 3 个队列，从而提升消息的并行消费能力。</p>
<blockquote>
<p>Rebalance 限制</p>
</blockquote>
<p>由于⼀个队列最多分配给⼀个消费者，因此当某个消费者组下的消费者实例数量 <strong>大于</strong> 队列的数量时，多余的消费者实例将分配不到任何队列。</p>
<blockquote>
<p>Rebalance 危害</p>
</blockquote>
<p>Rebalance 的在提升消费能力的同时，也带来一些问题：</p>
<p><strong>消费暂停：</strong> 在只有一个 Consumer 时，其负责消费所有队列，在新增了一个 Consumer 后会触发 Rebalance 的发生。此时原 Consumer 就需要暂停部分队列的消费，等到这些队列分配给新的 Consumer 后，这些暂停消费的队列才能继续被消费。</p>
<p><strong>消费重复：</strong> Consumer 在消费新分配给自己的队列时，必须接着之前 Consumer 提交的消费进度的 offset 继续消费。然而默认情况下，offset 是异步提交的，这种异步性将导致提交到 Broker 的 offset 与 Consumer 实际消费的消息并不一致。这个不一致的差值就是可能会重复消费的消息。</p>
<p>同步提交：Consumer 提交了其消费完毕的一批消息的 offset 给 Broker 后，需要等待 Broker 的成功 ACK。当收到 ACK 后，Consumer 才会继续获取并消费下一批消息。在等待 ACK 期间，Consumer 是阻塞的。</p>
<p>异步提交：Consumer 提交了其消费完毕的一批消息的 offset 给 Broker 后，不需要等待 Broker 的成功 ACK。Consumer 可以直接获取并消费下一批消息。</p>
<p>对于一次性读取消息的数量，需要根据具体业务场景选择一个相对均衡的是很有必要的。因为数量过大，系统性能提升了，但产生重复消费的消息数量可能会增加；数量过小，系统性能会下降，但被重复消费的消息数量可能会减少。</p>
<p><strong>消费突刺：</strong> 由于 Rebalance 可能导致重复消费，如果需要重复消费的消息过多，或者因为 Rebalance 暂停时间过长从而导致积压了部分消息，那么有可能会导致在 Rebalance 结束之后瞬间需要消费很多消息。</p>
<blockquote>
<p>Rebalance 产生的原因</p>
</blockquote>
<p>导致 Rebalance 产生的原因，无非就两个：消费者所订阅 Topic 的 Queue 数量发生变化，或消费者组中消费者的数量发生变化。</p>
<p>Queue 数量发生变化的场景：Broker 扩容或缩容、Broker 升级运维、Broker 与 NameServer 间的网络异常、Queue 扩容或缩容。</p>
<p>消费者数量发生变化的场景：Consumer Group 扩容或缩容、Consumer 升级运维、Consumer 与 NameServer 间网络异常。</p>
<blockquote>
<p>Rebalance 过程</p>
</blockquote>
<p>在 Broker 中维护着多个 Map 集合，这些集合中动态存放着当前 Topic 中 Queue 的信息、Consumer Group 中 Consumer 实例的信息。一旦发现消费者所订阅的 Queue 数量发生变化，或消费者组中消费者的数量发生变化，立即向 Consumer Group 中的每个实例发出 Rebalance 通知。</p>
<p>Consumer 实例在接收到通知后会采用 <strong>Queue 分配算法</strong> 自己获取到相应的 Queue，即由 Consumer 实例自主进行 Rebalance。</p>
<p><strong>Broker 中几个重要的 Map 集合：</strong></p>
<p>TopicConfigManager：key 是 Topic 名称，value 是 TopicConfig。TopicConfig 中维护着该 Topic 中所有 Queue 的数据。</p>
<p>ConsumerManager：key 是ConsumserGroupId，value 是 ConsumerGroupInfo。ConsumerGroupInfo中维护着该Group中所有Consumer实例数据。</p>
<p>ConsumerOffsetManager：key 为 Topic 与订阅该 Topic 的 Group 的组合，即 topic@group，value 是一个内层 Map。内层 Map 的 key 为 QueueId，内层 Map 的 value 为该 Queue 的消费进度 offset。</p>
<blockquote>
<p>与 Kafka 对比</p>
</blockquote>
<p>在 Kafka 中，一旦发现出现了 Rebalance 条件，Broker 会调用 Group Coordinator 来完成 Rebalance。Coordinator 是 Broker 中的一个进程。Coordinator 会在 Consumer Group 中选出一个 Group Leader，由这个 Leader 根据自己本身组情况完成 Partition 分区的再分配。这个再分配结果会上报给 Coordinator，并由 Coordinator 同步给 Group 中的所有 Consumer 实例。</p>
<p>Kafka 中的 Rebalance 是由 Consumer Leader 完成的，而 RocketMQ 中的 Rebalance 是由每个 Consumer 自身完成的，Group 中不存在 Leader。</p>
<h3 id="1-4-4-Queue-分配算法"><a class="header-anchor" href="#1-4-4-Queue-分配算法"></a>1.4.4 Queue 分配算法</h3>
<p>一个 Topic 中的 Queue 只能由 Consumer Group 中的一个 Consumer 进行消费，而一个 Consumer 可以同时消费多个 Queue 中的消息。那么 Queue 与 Consumer 间的配对关系是如何确定的，即 Queue 要分配给哪个 Consumer 进行消费，这也是有算法策略的。常见的有四种策略，这些策略是通过在创建 Consumer 时的构造器传进去的。</p>
<blockquote>
<p>平均分配策略</p>
</blockquote>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/Queue%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B9%B3%E5%9D%87%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.png" alt="Queue分配算法之平均分配策略"></p>
<p>该算法是要根据 <code>avg = QueueCount / ConsumerCount</code> 的计算结果进行分配的。如果能够整除，则按顺序将 avg 个 Queue 逐个分配 Consumer；如果不能整除，则将多余出的 Queue 按照 Consumer 顺序逐个分配。</p>
<p>简单来说就是先计算好每个 Consumer 应该分得几个 Queue，然后再依次将这些数量的 Queue 逐个分配个 Consumer。</p>
<blockquote>
<p>环形平均策略</p>
</blockquote>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/Queue%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E4%B9%8B%E7%8E%AF%E5%BD%A2%E5%B9%B3%E5%9D%87%E7%AD%96%E7%95%A5.png" alt="Queue分配算法之环形平均策略"></p>
<p>环形平均算法是指，根据消费者的顺序，依次在由 Queue 队列组成的环形图中逐个分配。</p>
<p>该算法不用事先计算每个 Consumer 需要分配几个 Queue，直接一个一个分即可。</p>
<blockquote>
<p>一致性 hash 策略</p>
</blockquote>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/Queue%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E4%B9%8B%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AD%96%E7%95%A5.png" alt="Queue分配算法之一致性hash策略"></p>
<p>该算法会将 Consumer 的 hash 值作为 Node 节点存放到 hash 环上，然后将 Queue 的 hash 值也放到 hash 环上，通过 <strong>顺时针</strong> 方向，距离 Queue 最近的那个 Consumer 就是该 Queue 要分配的 Consumer。</p>
<p>该算法会存在 <strong>分配不均</strong> 的问题。</p>
<blockquote>
<p>同机房策略</p>
</blockquote>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/Queue%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E4%B9%8B%E5%90%8C%E6%9C%BA%E6%88%BF%E7%AD%96%E7%95%A5.png" alt="Queue分配算法之同机房策略"></p>
<p>该算法会根据 Queue 的部署机房位置和 Consumer 的位置，过滤出当前 Consumer 相同机房的 Queue，然后按照平均分配策略或环形平均策略对同机房 Queue 进行分配。如果没有同机房 Queue，则按照平均分配策略或环形平均策略对所有 Queue 进行分配。</p>
<blockquote>
<p>对比</p>
</blockquote>
<p>前两种平均分配策略由于算法简单，因此分配效率较高，相对而言一致性 hash 策略的分配效率就较低。另外，一致性 hash 策略分配的结果有很大可能存在分配不平均的情况。</p>
<p>那一致性 hash 算法的存在有有何意义呢？它可以有效减少由于消费者组扩容或缩容所带来的大量的 Rebalance。</p>
<p>因此一致性 hash 算法的应用场景实在 Consumer 数量变化较频繁的场景。</p>
<p>平均分配策略与一致性 hash 策略在 Consumer 扩容后的 Rebalance 情况示例图：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E5%B9%B3%E5%9D%87%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E4%B8%8B%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E6%89%A9%E5%AE%B9%E5%89%8D%E5%90%8E.png" alt="平均分配策略下消费者组扩容前后"></p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AD%96%E7%95%A5%E4%B8%8B%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E6%89%A9%E5%AE%B9%E5%89%8D%E5%90%8E.png" alt="一致性hash策略下消费者组扩容前后"></p>
<h3 id="1-4-5-至少一次原则"><a class="header-anchor" href="#1-4-5-至少一次原则"></a>1.4.5 至少一次原则</h3>
<p>RocketMQ 有一个原则：每条消息必须要被 <strong>成功消费</strong> 一次。</p>
<p>那么什么是成功消费呢？Consumer 在消费完消息后会向其 <strong>消费进度记录器</strong> 提交其消费消息的 offset，offset 被成功记录到记录器中，那么这条消费就被成功消费了。</p>
<blockquote>
<p>什么是消费进度记录器？</p>
</blockquote>
<p>对于广播消费模式来说，Consumer 本身就是消费进度记录器。</p>
<p>对于集群消费模式来说，Broker 是消费进度记录器。</p>
<h2 id="1-5-订阅关系的一致性"><a class="header-anchor" href="#1-5-订阅关系的一致性"></a>1.5 订阅关系的一致性</h2>
<p>订阅关系的一致性指的是，同一个消费者组（Group ID相同）下所有 Consumer 实例所订阅的 Topic 与 Tag 及对消息的处理逻辑必须完全一致。否则，消息消费的逻辑就会混乱，甚至导致消息丢失。</p>
<h3 id="1-5-1-正确订阅关系"><a class="header-anchor" href="#1-5-1-正确订阅关系"></a>1.5.1 正确订阅关系</h3>
<p>多个消费者组订阅了多个 Topic，并且每个消费者组里的多个消费者实例的订阅关系保持了一致。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E7%9A%84%E6%AD%A3%E7%A1%AE%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB.png" alt="RocketMQ的正确订阅关系"></p>
<h3 id="1-5-2-错误订阅关系"><a class="header-anchor" href="#1-5-2-错误订阅关系"></a>1.5.2 错误订阅关系</h3>
<p>一个消费者组订阅了多个 Topic，但是该消费者组里的多个 Consumer 实例的订阅关系并没有保持一致。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E7%9A%84%E9%94%99%E8%AF%AF%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB.png" alt="RocketMQ的错误订阅关系"></p>
<blockquote>
<p>订阅了不同 Topic</p>
</blockquote>
<p>该例中的错误在于，同一个消费者组中的两个 Consumer 实例订阅了不同的 Topic。</p>
<p>Consumer 实例 1-1：（订阅了 Topic 为 <code>jodie_test_A</code>，Tag 为所有的消息）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(PropertyKeyConst.GROUP_ID, <span class="string">&quot;GID_jodie_test_1&quot;</span>);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> ONSFactory.createConsumer(properties);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;jodie_test_A&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        System.out.println(message.getMsgID());</span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>
<p>Consumer 实例 1-2：（订阅了 Topic为 <code>jodie_test_B</code>，Tag 为所有的消息）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(PropertyKeyConst.GROUP_ID, <span class="string">&quot;GID_jodie_test_1&quot;</span>);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> ONSFactory.createConsumer(properties);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;jodie_test_B&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        System.out.println(message.getMsgID());</span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>订阅了不同 Tag</p>
</blockquote>
<p>该例中的错误在于，同一个消费者组中的两个 Consumer 订阅了相同 Topic 的不同 Tag。</p>
<p>Consumer 实例 2-1：（订阅了 Topic 为 <code>jodie_test_A</code>，Tag 为 TagA 的消息）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(PropertyKeyConst.GROUP_ID, <span class="string">&quot;GID_jodie_test_2&quot;</span>);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> ONSFactory.createConsumer(properties);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;jodie_test_A&quot;</span>, <span class="string">&quot;TagA&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        System.out.println(message.getMsgID());</span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Consumer 实例 2-2：（订阅了 Topic 为 <code>jodie_test_A</code>，Tag 为所有的消息）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(PropertyKeyConst.GROUP_ID, <span class="string">&quot;GID_jodie_test_2&quot;</span>);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> ONSFactory.createConsumer(properties);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;jodie_test_A&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        System.out.println(message.getMsgID());</span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>订阅了不同数量的 Topic</p>
</blockquote>
<p>该例中的错误在于，同一个消费者组中的两个 Consumer 订阅了不同数量的 Topic。</p>
<p>Consumer 实例 3-1：（该 Consumer 订阅了两个 Topic）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(PropertyKeyConst.GROUP_ID, <span class="string">&quot;GID_jodie_test_3&quot;</span>);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> ONSFactory.createConsumer(properties);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;jodie_test_A&quot;</span>, <span class="string">&quot;TagA&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        System.out.println(message.getMsgID());</span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;jodie_test_B&quot;</span>, <span class="string">&quot;TagB&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        System.out.println(message.getMsgID());</span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>
<p>Consumer 实例 3-2：（该 Consumer 订阅了一个 Topic）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(PropertyKeyConst.GROUP_ID, <span class="string">&quot;GID_jodie_test_3&quot;</span>);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> ONSFactory.createConsumer(properties);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;jodie_test_A&quot;</span>, <span class="string">&quot;TagB&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        System.out.println(message.getMsgID());</span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="1-6-offset-管理"><a class="header-anchor" href="#1-6-offset-管理"></a>1.6 offset 管理</h2>
<p><mark>这里的 offset 指的是 Consumer 的消费进度 offset。</mark></p>
<p>消费进度 offset 是用来记录每个 Queue 的不同消费组的消费进度的。根据消费进度记录器的不同，可以分为两种模式：本地模式和远程模式。</p>
<h3 id="1-6-1-offset-本地管理模式"><a class="header-anchor" href="#1-6-1-offset-本地管理模式"></a>1.6.1 offset 本地管理模式</h3>
<p>当消费模式为 <strong>广播消费</strong> 时，offset 使用本地模式存储。因为每条消息会被所有的消费者消费，每个消费者管理自己的消费进度，各个消费者之间不存在消费进度的交集。</p>
<p>Consumer 在广播消费模式下 offset 相关数据以 JSON 的形式持久化到 Consumer 本地磁盘文件中，默认文件路径为当前用户主目录下的 <code>.rocketmq_offsets/$&#123;clientId&#125;/$&#123;group&#125;/Offsets.json</code>。</p>
<p>其中 <code>$&#123;clientId&#125;</code> 为当前消费者id，默认为 <code>ip@DEFAULT</code>；<code>$&#123;group&#125;</code> 为消费者组名称。</p>
<h3 id="1-6-2-offset-远程管理模式"><a class="header-anchor" href="#1-6-2-offset-远程管理模式"></a>1.6.2 offset 远程管理模式</h3>
<p>当消费模式为 <strong>集群消费</strong> 时，offset 使用远程模式管理。因为所有 Cosnumer 实例对消息采用的是均衡消费，所有 Consumer 共享 Queue 的消费进度。</p>
<p>Consumer 在集群消费模式下 offset 相关数据以 JSON 的形式持久化到 Broker 磁盘文件中，文件路径为当前用户主目录下的 <code>store/config/consumerOffset.json</code>。</p>
<p>Broker 启动时会加载这个文件，并写入到一个双层 Map（ConsumerOffsetManager）。外层 Map 的 Key为 topic@group，Value 为内层 Map。内层 Map 的 Key 为 queueId，Value 为 offset。当发生 Rebalance 时，新的 Consumer 会从该 Map 中获取到相应的数据来继续消费。</p>
<p>如果仅仅是为了持续消费，offset 也可以采用本地模式存储。但是这样带来了一个问题，比如某个时间点某个 Consumer 挂了，此时就会产生 Rebalance 机制，原先被挂了的 Consumer 消费的 Queue 重新分配给新的 Consumer 消费，而这时新的 Consumer 并不知道这个 Queue 的消费进度。因此集群模式下 offset 采用远程管理模式，主要是为了保证 Rebalance 机制。</p>
<h3 id="1-6-3-offset-用途"><a class="header-anchor" href="#1-6-3-offset-用途"></a>1.6.3 offset 用途</h3>
<p>消费者是如何从最开始持续消费消息的？消费者要消费的第一条消息的起始位置是用户自己通过 <code>consumer.setConsumeFromWhere()</code> 方法指定的。</p>
<p>在 Consumer 启动后，其要消费的第一条消息的起始位置常用的有三种，这三种位置可以通过 <code>ConsumeFromWhere</code> 枚举的枚举项来设置。</p>
<blockquote>
<p>ConsumeFromWhere 枚举可选值</p>
</blockquote>
<p>1、CONSUME_FROM_LAST_OFFSET：从 queue 的当前最后一条消息开始消费；</p>
<p>2、CONSUME_FROM_FIRST_OFFSET：从 queue 的第一条消息开始消费；</p>
<p>3、CONSUME_FROM_TIMESTAMP：从指定的具体时间戳位置的消息开始消费。这个具体时间戳是通过 <code>consumer.setConsumeTimestamp(&quot;yyyyMMddHHmmss&quot;)</code> 指定的 。</p>
<p>当消费完一批消息后，Consumer 会提交其消费进度 offset 给 Broker，Broker 在收到消费进度后会将其更新到那个双层 Map（ConsumerOffsetManager）及 consumerOffset.json 文件中，然后向该 Consumer 进行 ACK，而 ACK 内容中包含三项数据：当前消费队列的最小 offset（minOffset）、最大 offset（maxOffset）、及下次消费的起始 offset（nextBeginOffset，这个值保证了持续消费）。</p>
<h3 id="1-6-4-重试队列"><a class="header-anchor" href="#1-6-4-重试队列"></a>1.6.4 重试队列</h3>
<p>当 RocketMQ 对消息的消费出现异常时，会将发生异常的消息的 offset 提交到 Broker 中的重试队列。系统在发生消息消费异常时会为当前的 topic@group 创建一个重试队列，该队列以 <code>%RETRY%</code>开头，到达重试时间后进行消费重试。</p>
<h3 id="1-6-5-offset-的同步提交与异步提交"><a class="header-anchor" href="#1-6-5-offset-的同步提交与异步提交"></a>1.6.5 offset 的同步提交与异步提交</h3>
<p>集群消费模式下，Consumer 消费完消息后会向 Broker 提交消费进度 offset，其提交方式分为两种：</p>
<p><strong>同步提交：</strong> 消费者在消费完一批消息后会向 Broker 提交这些消息的 offset，然后等待 Broker 的成功响应。若在等待超时之前收到了成功响应，则继续读取下一批消息进行消费（从 ACK 中获取 nextBeginOffset）。若没有收到响应，则会重新提交，直到获取到响应。而在这个等待过程中，消费者是阻塞的。这种提交方式严重影响了消费者的吞吐量。</p>
<p><strong>异步提交：</strong> 消费者在消费完一批消息后向 Broker 提交 offset，但无需等待 Broker的成功响应，可以继续读取并消费下一批消息。这种方式提高了消费者的吞吐量。但需要注意，Broker 在收到提交的 offset后，还是会向消费者进行响应的，可能还没有收到 ACK，此时 Consumer 会从 Broker 中直接获取 nextBeginOffset（ACK 中的 nextBeginOffset 是来自于 Broker 的）。</p>
<h2 id="1-7-消费幂等"><a class="header-anchor" href="#1-7-消费幂等"></a>1.7 消费幂等</h2>
<h3 id="1-7-1-什么是消费幂等"><a class="header-anchor" href="#1-7-1-什么是消费幂等"></a>1.7.1 什么是消费幂等</h3>
<p>当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响，那么这个消费过程就是消费幂等的。</p>
<p>幂等：幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。</p>
<p>在互联网应用中，尤其在网络不稳定的情况下，消息很有可能会出现重复发送或重复消费。如果重复的消息可能会影响业务处理，那么就应该对消息做幂等处理。</p>
<h3 id="1-7-2-消息重复的场景分析"><a class="header-anchor" href="#1-7-2-消息重复的场景分析"></a>1.7.2 消息重复的场景分析</h3>
<p>什么情况下可能会出现消息被重复消费呢？最常见的有以下三种情况：</p>
<blockquote>
<p>发送时消息重复</p>
</blockquote>
<p>当一条消息已被成功发送到 Broker 并完成持久化，此时出现了网络闪断，从而导致 Broker 对 Producer 应答失败。如果此时 Producer 意识到消息发送失败并尝试再次发送消息，此时 Broker 中就可能会出现两条内容相同并且 Message ID 也相同的消息，那么后续 Consumer 就一定会消费两次该消息。</p>
<blockquote>
<p>消费时消息重复</p>
</blockquote>
<p>消息已投递到 Consumer 并完成业务处理，当 Consumer 给 Broker 反馈应答时网络闪断，Broker 没有接收到消费成功响应。为了保证消息至少被消费一次的原则，Broker 将在网络恢复后再次尝试投递之前已被处理过的消息。此时消费者就会收到与之前处理过的内容相同、Message ID 也相同的消息。</p>
<blockquote>
<p>Rebalance 时消息重复</p>
</blockquote>
<p>当 Consumer Group 中的 Consumer 数量发生变化时，或其订阅的 Topic 的 Queue 数量发生变化时，会触发 Rebalance，此时 Consumer 可能会收到曾经被消费过的消息。</p>
<h3 id="1-7-3-通用解决方案"><a class="header-anchor" href="#1-7-3-通用解决方案"></a>1.7.3 通用解决方案</h3>
<blockquote>
<p>幂等解决方案的两要素</p>
</blockquote>
<p>幂等解决方案的设计中涉及到两项要素：幂等令牌，与唯一性处理。只要充分利用好这两要素，就可以设计出好的幂等解决方案。</p>
<p>幂等令牌：是生产者和消费者两者中的既定协议，通常指具备唯⼀业务标识的字符串。例如，订单号、流水号。一般由 Producer 随着消息一同发送来的。</p>
<p>唯一性处理：服务端通过采用⼀定的算法策略，保证同⼀个业务逻辑不会被重复执行成功多次。例如，对同一笔订单的多次支付操作，只会成功一次。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p>对于常见的系统，幂等性操作的通用性解决方案是：</p>
<p>1、首先通过缓存去重。在缓存中如果已经存在了某幂等令牌，则说明本次操作是重复性操作；若缓存没有命中，则进入下一步。</p>
<p>2、在唯一性处理之前，先在数据库中查询幂等令牌作为索引的数据是否存在。若存在，则说明本次操作为重复性操作；若不存在，则进入下一步。</p>
<p>3、在同一事务中完成三项操作：唯一性处理后，将幂等令牌写入到缓存，并将幂等令牌作为唯一索引的数据写入到 DB 中。</p>
<p>在第 1 步已经判断过是否是重复性操作了，为什么第 2 步还要再次判断？能够进入第 2 步，说明已经不是重复操作了，那么第 2 次判断是否重复？</p>
<p>当然不重复，缓存中的数据一般是具有时效期的。如果缓存中的数据一旦过期，就会发生缓存穿透，这时请求将直接到达数据库管理系统（DBMS）。</p>
<blockquote>
<p>解决方案举例</p>
</blockquote>
<p>以支付场景为例：</p>
<p>1、当支付请求到达后，首先会从 Redis 缓存中去获取 Key 为 <strong>支付流水号</strong> 的缓存 Value。若 Value 不空，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识；若 Value 为空，则进入下一步操作；</p>
<p>2、在 DBMS 中根据 <strong>支付流水号</strong> 查询是否存在相应实例。若存在，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识；若不存在，则说明本次操作是首次操作，进入下一步完成唯一性处理；</p>
<p>3、在分布式事务中完成以下三项操作：</p>
<p>1）完成支付任务；</p>
<p>2）将当前支付流水号作为 Key，任意字符串作为 Value，通过 <code>set(key, value, expireTime)</code> 将数据写入到 Redis 缓存；</p>
<p>3）将当前支付流水号作为主键，与其它相关数据共同写入到 DBMS。</p>
<h3 id="1-7-4-消费幂等的实现"><a class="header-anchor" href="#1-7-4-消费幂等的实现"></a>1.7.4 消费幂等的实现</h3>
<p>综上所述，消费幂等的解决方案很简单：为消息指定不会重复的唯一标识。因为 Message ID 有可能出现重复的情况，所以真正安全的幂等处理，不建议以 Message ID 作为处理依据。最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息 Key 设置。</p>
<p>以支付场景为例，可以将消息的 Key 设置为订单号，作为幂等处理的依据。具体代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">message.setKey(<span class="string">&quot;ORDERID_100&quot;</span>);</span><br><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message); </span><br></pre></td></tr></table></figure>
<p>消费者收到消息时可以根据消息的 Key 即订单号来实现消费幂等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt;  msgs,</span></span><br><span class="line"><span class="params">                                                    ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(MessageExt msg : msgs)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> msg.getKeys();</span><br><span class="line">            <span class="comment">// 根据业务唯一标识 Key 做幂等处理</span></span><br><span class="line">            <span class="comment">// ……</span></span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>
<p>RocketMQ 能够保证消息不丢失，但不能保证消息不重复。</p>
<h2 id="1-8-消息堆积与消费延迟"><a class="header-anchor" href="#1-8-消息堆积与消费延迟"></a>1.8 消息堆积与消费延迟</h2>
<h3 id="1-8-1-概念"><a class="header-anchor" href="#1-8-1-概念"></a>1.8.1 概念</h3>
<p>消息处理流程中，如果 Consumer 的消费速度跟不上 Producer 的发送速度，MQ 中未处理的消息会越来越多（进的多出的少），这部分消息就被称为 <strong>堆积消息</strong>。消息出现堆积进而会造成消息的 <strong>消费延迟</strong>。</p>
<p>以下场景需要重点关注消息堆积和消费延迟问题：</p>
<p>1、业务系统上下游能力不匹配造成的持续堆积，且无法自行恢复。</p>
<p>2、业务系统对消息的消费实时性要求较高，即使是短暂的堆积造成的消费延迟也无法接受。</p>
<h3 id="1-8-2-产生原因分析"><a class="header-anchor" href="#1-8-2-产生原因分析"></a>1.8.2 产生原因分析</h3>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E4%B8%8E%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E5%9B%BE%E7%A4%BA.png" alt="RocketMQ消息拉取与消息消费图示"></p>
<p>Consumer 使用长轮询 Pull 模式消费消息时，分为以下两个阶段：</p>
<p><strong>1、消息拉取</strong></p>
<p>Consumer 通过长轮询 Pull 模式批量拉取的方式从服务端获取消息，将拉取到的消息缓存到本地缓冲队列中。对于拉取式消费，在内网环境下会有很高的吞吐量，所以这一阶段一般不会成为消息堆积的瓶颈。</p>
<p>一个单线程单分区的低规格主机（Consumer，4Core 8GB），可达到几万的 TPS（系统吞吐量）。如果是多个分区多个线程，则可以轻松达到几十万的 TPS。</p>
<p><strong>2、消息消费</strong></p>
<p>Consumer 将本地缓存的消息提交到消费线程中，使用业务消费逻辑对消息进行处理，处理完毕后获取到一个结果，这是真正的消息消费过程。此时 Consumer 的消费能力完全依赖于消息的 <strong>消费耗时</strong> 和 <strong>消费并发度</strong>。如果由于业务处理逻辑复杂等原因，导致处理单条消息的耗时较长，则整体的消息吞吐量肯定不会太高，此时就会导致 Consumer 本地缓冲队列达到上限，进而停止从服务端拉取消息，造成消息堆积。</p>
<blockquote>
<p>结论</p>
</blockquote>
<p>消息堆积的主要瓶颈在于客户端的消费能力，而消费能力由消费耗时和消费并发度决定。 <mark>注意，消费耗时的优先级要高于消费并发度。</mark> 因此需要在保证了消费耗时的合理性前提下，再考虑消费并发度问题。</p>
<h3 id="1-8-3-消费耗时"><a class="header-anchor" href="#1-8-3-消费耗时"></a>1.8.3  消费耗时</h3>
<p>影响消息处理时长的主要因素是代码逻辑，而代码逻辑中可能会影响处理时长代码主要有两种类型：<strong>CPU 内部计算型代码</strong> 和 <strong>外部 I/O 操作型代码</strong>。</p>
<p>通常情况下代码中如果没有复杂的递归和循环的话，内部计算耗时相对外部 I/O 操作来说几乎可以忽略。所以外部 IO 型代码是影响消息处理时长的主要症结所在。</p>
<blockquote>
<p>外部 I/O 操作型代码举例</p>
</blockquote>
<p>1、读写外部数据库。例如对远程 MySQL 的访问；</p>
<p>2、读写外部缓存系统。例如对远程 Redis 的访问；</p>
<p>3、下游系统调用。例如 Dubbo 的 RPC 远程调用，Spring Cloud 的对下游系统的 Http 接口调用。</p>
<p>关于下游系统调用逻辑需要进行提前梳理，掌握每个调用操作预期的耗时，这样做是为了能够判断消费逻辑中 I/O 操作的耗时是否合理。通常消息堆积是由于下游系统出现了 <strong>服务异常</strong> 或 <strong>达到了 DBMS 容量限制</strong>，导致消费耗时增加。</p>
<p>服务异常，并不仅仅是系统中出现的类似 500 这样的代码错误，而可能是更加隐蔽的问题。例如，网络带宽问题。如果达到了 DBMS 容量限制，也会引发消息的消费耗时增加。</p>
<h3 id="1-8-4-消费并发度"><a class="header-anchor" href="#1-8-4-消费并发度"></a>1.8.4 消费并发度</h3>
<p>一般情况下，消费者端的消费并发度由单节点线程数和节点数量共同决定，其值为 <strong>单节点线程数 * 节点数量</strong>。不过，通常需要优先调整单节点的线程数，若单机硬件资源达到了上限，则需要通过横向扩展来提高消费并发度。</p>
<blockquote>
<p>单节点线程数与节点数量</p>
</blockquote>
<p>单节点线程数，即单个 Consumer 所包含的线程数量；</p>
<p>节点数量，即 Consumer Group 所包含的 Consumer 数量。</p>
<blockquote>
<p>顺序消息的消费并发度</p>
</blockquote>
<p>对于普通消息、延时消息及事务消息，并发度计算都是 <strong>单节点线程数 * 节点数量</strong>，但对于顺序消息则是不同的，顺序消息的消费并发度等于 <strong>Topic 的 Queue 分区数量</strong>。</p>
<p>1、全局顺序消息：该类型消息的 Topic 只有一个 Queue 分区，这样可以保证该 Topic 的所有消息被顺序消费。为了保证这个全局顺序性，Consumer Group 中在同一时刻只能有一个 Consumer 的一个线程进行消费，所以其并发度为 1。</p>
<p>2、分区顺序消息：该类型消息的 Topic 有多个 Queue 分区，这样只可以保证该 Topic 的每个 Queue 分区中的消息被顺序消费，不能保证整个 Topic 中消息的顺序消费。为了保证这个分区顺序性，每个 Queue 分区中的消息在 Consumer Group 中的同一时刻只能有一个 Consumer 的一个线程进行消费。也就是说，在同一时刻最多会出现多个 Queue 分区有多个 Consumer 的多个线程并行消费，所以分区顺序消息的并发度为 Topic 的分区数量。</p>
<h3 id="1-8-5-单机线程数计算"><a class="header-anchor" href="#1-8-5-单机线程数计算"></a>1.8.5 单机线程数计算</h3>
<p>对于一台主机中线程池中线程数的设置需要谨慎，不能盲目直接调大线程数，设置过大的线程数反而会带来大量的线程切换的开销。理想环境下单节点的最优线程数计算模型为：<code>C * (T1 + T2) / T1</code>。</p>
<p>其中：C 表示 CPU 的内核数；T1 表示 CPU 内部逻辑计算耗时；T2 表示外部 I/O 操作耗时。</p>
<p>最优线程数 = C * (T1 + T2) / T1 = C * T1 / T1 + C * T2 / T1 = C + C * T2 / T1</p>
<p>注意，该计算出的数值是理想状态下的理论数据。在生产环境中，不建议直接使用，应当根据当前环境，先设置一个比该值小的数值然后观察其压测效果，然后再根据效果逐步调大线程数，直至找到在该环境中性能最佳时的值。</p>
<h3 id="1-8-6-如何避免"><a class="header-anchor" href="#1-8-6-如何避免"></a>1.8.6 如何避免</h3>
<p>为了避免在业务使用时出现非预期的消息堆积和消费延迟问题，需要在前期设计阶段对整个业务逻辑进行完善的排查和梳理。其中最重要的就是 <strong>梳理消息的消费耗时</strong> 和 <strong>设置消息消费的并发度</strong>。</p>
<blockquote>
<p>梳理消息的消费耗时</p>
</blockquote>
<p>通过压测获取消息的消费耗时，并对耗时较高的操作的代码逻辑进行分析。梳理消息的消费耗时需要关注以下信息：</p>
<p>1、消息消费逻辑的计算复杂度是否过高，代码是否存在无限循环和递归等缺陷。</p>
<p>2、消息消费逻辑中的 I/O 操作是否是必须的，能否用本地缓存等方案规避。</p>
<p>3、消费逻辑中的复杂耗时的操作是否可以做异步化处理。如果可以，是否会造成逻辑错乱。</p>
<blockquote>
<p>设置消费并发度</p>
</blockquote>
<p>对于消息消费并发度的计算，可以通过以下两步实施：</p>
<p>1、逐步调大单个Consumer节点的线程数，并观测节点的系统指标，得到单个节点最优的消费线程数和消息吞吐量。</p>
<p>2、根据上下游链路的 <strong>流量峰值</strong> 计算出需要设置的节点数。其中，节点数 = 流量峰值 / 单个节点消息吞吐量。</p>
<h2 id="1-9-消息的清理"><a class="header-anchor" href="#1-9-消息的清理"></a>1.9 消息的清理</h2>
<p>消息被消费过后会被清理掉吗？不会。</p>
<p>消息是被顺序存储在 commitlog 文件的，且消息大小不定长，所以消息的清理是不可能以消息为单位进行清理的，而是以 commitlog 文件为单位进行清理的。否则会急剧下降清理效率，并实现逻辑复杂。</p>
<p>commitlog 文件存在一个过期时间，默认为 72 小时，即三天。除了用户手动清理外，在以下情况下也会被自动清理，无论文件中的消息是否被消费过：</p>
<p>1、文件过期，且到达 <strong>清理时间点</strong>（默认为凌晨4点）后，自动清理过期文件；</p>
<p>2、文件过期，且磁盘空间占用率已达 <strong>过期清理警戒线</strong>（默认75%）后，无论是否达到清理时间点，都会自动清理过期文件；</p>
<p>3、磁盘占用率达到 <strong>清理警戒线</strong>（默认 85%）后，开始按照设定好的规则清理文件，无论是否过期，默认会从最老的文件开始清理；</p>
<p>4、磁盘占用率达到 <strong>系统危险警戒线</strong>（默认 90%）后，Broker 将拒绝消息写入；</p>
<blockquote>
<p>注意事项</p>
</blockquote>
<p>1、对于 RocketMQ 系统来说，删除一个 1G 大小的文件，是一个压力巨大的 IO 操作。在删除过程中，系统性能会骤然下降。所以，其默认清理时间点为凌晨 4 点，访问量最小的时间。也正因如此，我们要保障磁盘空间的空闲率，不要使系统出现在其它时间点删除 commitlog 文件的情况。</p>
<p>2、官方建议 RocketMQ 服务的 Linux 文件系统采用 ext4。因为对于文件删除操作，ext4 要比 ext3 性能更好。</p>
<h1 id="2-RocketMQ-的应用"><a class="header-anchor" href="#2-RocketMQ-的应用"></a>2. RocketMQ 的应用</h1>
<h2 id="2-1-普通消息"><a class="header-anchor" href="#2-1-普通消息"></a>2.1 普通消息</h2>
<h3 id="2-1-1-消息发送分类"><a class="header-anchor" href="#2-1-1-消息发送分类"></a>2.1.1 消息发送分类</h3>
<p>Producer对于消息的发送方式也有多种选择，不同的方式会产生不同的系统效果。</p>
<blockquote>
<p>同步发送消息</p>
</blockquote>
<p>同步发送消息是指，Producer 发出⼀条消息后，会在收到 MQ 返回的 ACK 之后才发下⼀条消息。该方式的消息可靠性最高，但消息发送效率太低。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E5%90%8C%E6%AD%A5%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF.png" alt="RocketMQ同步发送消息"></p>
<blockquote>
<p>异步发送消息</p>
</blockquote>
<p>异步发送消息是指，Producer 发出消息后无需等待 MQ 返回 ACK，直接发送下⼀条消息。该方式的消息可靠性可以得到保障，消息发送效率也可以。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF.png" alt="RocketMQ异步发送消息"></p>
<blockquote>
<p>单向发送消息</p>
</blockquote>
<p>单向发送消息是指，Producer 仅负责发送消息，不等待、不处理 MQ 的 ACK。该发送方式时 MQ 也不返回 ACK。该方式的消息发送效率最高，但消息可靠性较差。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E5%8D%95%E5%90%91%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF.png" alt="RocketMQ单向发送消息"></p>
<h3 id="2-1-2-代码举例"><a class="header-anchor" href="#2-1-2-代码举例"></a>2.1.2 代码举例</h3>
<blockquote>
<p>初始化项目</p>
</blockquote>
<p>创建一个 Maven 的 Java 工程 rocketmq-test。然后修改其 pom.xml 文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，这个依赖的版本号要和我们使用的 RocketMQ 版本一致。除此之外，别忘记启动服务器或虚拟机上的 RocketMQ，以及本地的 RocketMQ 控制台（还记得前面启动控制台时遇到的坑吗？在启动 Broker 时要添加一些参数表示使用 broker.conf 的配置）。</p>
<blockquote>
<p>定义同步消息发送生产者</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步消息发送生产者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/12 17:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个 Producer，参数为 Producer Group 名称</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定 NameServer 的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置当发送失败时重试发送的次数，默认为 2 次</span></span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 设置发送超时时限，默认为 3s</span></span><br><span class="line">        producer.setSendMsgTimeout(<span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// 开启生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者发送 100 条信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">byte</span>[] body = (<span class="string">&quot;Hi&quot;</span> + i).getBytes();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;someTopic&quot;</span>, <span class="string">&quot;someTag&quot;</span>, body);</span><br><span class="line">            <span class="comment">// 为消息指定 key</span></span><br><span class="line">            message.setKeys(<span class="string">&quot;key-&quot;</span> + i);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭 Producer</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>SendResult</code> 中有一个名为 <code>sendStatus</code> 的属性，它是一个枚举，表示发送的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息发送的状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SendStatus</span> &#123;</span><br><span class="line">    <span class="comment">// 发送成功</span></span><br><span class="line">    SEND_OK,</span><br><span class="line">	<span class="comment">// 刷盘超时。当 Broker 设置的刷盘策略为同步刷盘时才可能出现这种状态，异步刷盘不会出现。</span></span><br><span class="line">    FLUSH_DISK_TIMEOUT,</span><br><span class="line">    <span class="comment">// Slave 同步超时。当 Broker 集群设置的 Master-Slave 的复制方式为同步复制时才会出现这种状态，异步复制不会出现。</span></span><br><span class="line">    FLUSH_SLAVE_TIMEOUT,</span><br><span class="line">    <span class="comment">// 没有可用的 Slave。当 Broker 集群设置为 Master-Slave 的复制方式为同步复制时才会出现这种状态，异步复制不会出现。</span></span><br><span class="line">    SLAVE_NOT_AVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码后，就可以在控制台看到消息的发送状态。</p>
<p>但是我在第一次运行时出现了意外，控制台出现以下错误：</p>
<pre>
No route info of this topic: someTopic
</pre>
<p>经过查阅资料后得知，需要在启动 Broker 时指定 <code>autoCreateTopicEnable=true</code>，因此启动 Broker 完整的命令是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqbroker -n xx.xxx.xxx.xx:9876 -c conf/broker.conf autoCreateTopicEnable=true  &gt;  bin/startMqBroker.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p><code>xx.xxx.xxx.xx</code> 表示服务器或虚拟机的 IP 地址。</p>
<blockquote>
<p>定义异步消息发送生产者</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步消息发送生产者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/12 21:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定异步发送失败后不进行重试发送</span></span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 指定新创建的 Topic 的 Queue 数量为 2，默认为 4</span></span><br><span class="line">        producer.setDefaultTopicQueueNums(<span class="number">2</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">byte</span>[] body = (<span class="string">&quot;Hi&quot;</span> + i).getBytes();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;myTopicA&quot;</span>, <span class="string">&quot;myTag&quot;</span>, body);</span><br><span class="line">            <span class="comment">// 异步发送，指定回调</span></span><br><span class="line">            producer.send(message, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">                <span class="comment">// 当 producer 接收到 MQ 发送来的 ACK 后就会触发该回调方法的执行</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                    System.out.println(sendResult);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">                    throwable.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程休眠</span></span><br><span class="line">        <span class="comment">/* 由于采用的是异步发送，若不进行休眠，消息还未发送就会将 producer 关闭而导致报错 */</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义单向消息发送生产者</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单向消息发送生产者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/12 22:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneWayProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">byte</span>[] body = (<span class="string">&quot;Hi&quot;</span> + i).getBytes();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;single&quot;</span>, <span class="string">&quot;someTag&quot;</span>, body);</span><br><span class="line">            <span class="comment">// 单向发送</span></span><br><span class="line">            producer.sendOneway(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;producer shutdown&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义消息消费者</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息消费者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/12 22:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 定义一个 pull 消费者</span></span><br><span class="line">        <span class="comment">/* DefaultLitePullConsumer consumer = new DefaultLitePullConsumer(&quot;cg&quot;); */</span></span><br><span class="line">        <span class="comment">// 定义一个 push 消费者</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定 NameServer</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定从第一条消息开始消费</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        <span class="comment">// 指定消费 Topic 和 Tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;someTopic&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定采用“广播模式”进行消费，默认为集群模式</span></span><br><span class="line">        <span class="comment">/* consumer.setMessageModel(MessageModel.BROADCASTING); */</span></span><br><span class="line">        <span class="comment">// 注册消息监听器</span></span><br><span class="line">        consumer.registerMessageListener((MessageListenerConcurrently) (messageList, consumeConcurrentlyContext) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 一旦 Broker 中有了其订阅消息就会触发该 Lambda 表达式的执行</span></span><br><span class="line">            <span class="comment">// 其返回值为当前 consumer 消费的状态</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 逐条发送消息</span></span><br><span class="line">            <span class="keyword">for</span> (MessageExt msg : messageList) &#123;</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回消费状态，消费成功</span></span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启消费者消费</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码后，成功消费消息，控制台打印出信息，但是此时程序并没有终止，依旧处于监听状态，如果有新的且符合条件的消息进入 RocketMQ 中，就会被消费。</p>
<p>如果我们手动终止程序，并再次运行程序，会发现控制台仅打印出 <code>Consumer Started</code>，并没有消息被消费的信息，这是因为 RocketMQ 中已经没有符合条件且没有被消费的消息了。如果我们使用生产者生产符合条件的消息，消费者就会再次消费消息，控制台也就能看到打印出的消息信息了。</p>
<h2 id="2-2-顺序消息"><a class="header-anchor" href="#2-2-顺序消息"></a>2.2 顺序消息</h2>
<h3 id="2-2-1-什么是顺序消息"><a class="header-anchor" href="#2-2-1-什么是顺序消息"></a>2.2.1 什么是顺序消息</h3>
<p>顺序消息指的是，严格按照消息的 <strong>发送顺序</strong> 进行 <strong>消费</strong> 的消息（FIFO）。</p>
<p>默认情况下生产者会把消息以 Round Robin 轮询方式发送到不同的 Queue 分区队列，而消费消息时会从多个 Queue 上拉取消息，这种情况下的发送和消费是不能保证顺序的。如果将消息仅发送到同一个 Queue 中，消费时也只从这个 Queue 上拉取消息，就严格保证了消息的顺序性。</p>
<h3 id="2-2-2-为什么需要顺序消息"><a class="header-anchor" href="#2-2-2-为什么需要顺序消息"></a>2.2.2 为什么需要顺序消息</h3>
<p>例如，现在有 <code>TOPIC ORDER_STATUS</code>（订单状态），其下有 4 个 Queue 队列，该 Topic 中的不同消息用于描述当前订单的不同状态。假设订单有状态：未支付、已支付、发货中、发货成功、发货失败。</p>
<p>根据以上订单状态，生产者从 <strong>时序</strong> 上可以生成如下几个消息：</p>
<pre>
订单T0000001:未支付 --> 订单T0000001:已支付 --> 订单T0000001:发货中 --> 订单T0000001:发货失败
</pre>
<p>消息发送到 MQ 中之后，Queue 的选择如果采用轮询策略，消息在 MQ 的存储可能如下：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E8%AE%A2%E5%8D%95%E7%8A%B6%E6%80%81%E6%B6%88%E6%81%AF%E5%9C%A8RocketMQ%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E5%8F%AF%E8%83%BD.png" alt="订单状态消息在RocketMQ中的存储可能"></p>
<p>这种情况下，我们希望 Consumer 消费消息的顺序和我们发送是一致的，然而上述 MQ 的投递和消费方式，我们无法保证顺序是正确的。对于顺序异常的消息，Consumer 即使设置有一定的状态容错，也不能完全处理好这么多种随机出现组合情况。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E5%AE%9A%E4%B9%89%E7%AD%96%E7%95%A5%EF%BC%8C%E8%AE%A2%E5%8D%95%E7%8A%B6%E6%80%81%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E5%AD%98%E6%94%BE%E5%9C%A8RocketMQ.png" alt="定义策略，订单状态消息顺序存放在RocketMQ"></p>
<p>基于上述的情况，可以设计如下方案：对于相同订单号的消息，通过一定的策略，将其放置在一个 Queue 中，然后消费者再采用一定的策略（例如，一个线程独立处理一个 Queue，保证处理消息的顺序性），能够保证消费的顺序性。</p>
<h3 id="2-2-3-有序性分类"><a class="header-anchor" href="#2-2-3-有序性分类"></a>2.2.3 有序性分类</h3>
<p>根据有序范围的不同，RocketMQ 可以严格地保证两种消息的有序性：<strong>分区有序</strong> 与 <strong>全局有序</strong>。</p>
<blockquote>
<p>全局有序</p>
</blockquote>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E5%85%A8%E5%B1%80%E6%9C%89%E5%BA%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="RocketMQ全局有序示意图"></p>
<p>当发送和消费参与的 Queue 只有一个时所保证的有序是整个 Topic 中消息的顺序， 称为 <strong>全局有序</strong>。</p>
<p>在创建 Topic 时指定 Queue 的数量。有三种指定方式：</p>
<p>1、在代码中创建 Produce r时，可以指定其自动创建的 Topic 的 Queue 数量；</p>
<p>2、在 RocketMQ 可视化控制台中手动创建 Topic 时指定 Queue 数量；</p>
<p>3、使用 <code>mqadmin</code> 命令手动创建 Topic 时指定 Queue 数量。</p>
<blockquote>
<p>分区有序</p>
</blockquote>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E5%88%86%E5%8C%BA%E6%9C%89%E5%BA%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="RocketMQ分区有序示意图"></p>
<p>如果有多个 Queue 参与，其仅可保证在该 Queue 分区队列上的消息顺序，则称为 <strong>分区有序</strong>。</p>
<p>如何实现 Queue 的选择？在定义 Producer 时我们可以指定消息队列选择器，而这个选择器是我们自己实现了 <code>MessageQueueSelector</code> 接口定义的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageQueueSelector</span> &#123;</span><br><span class="line">    MessageQueue <span class="title function_">select</span><span class="params">(List&lt;MessageQueue&gt; var1, Message var2, Object var3)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义选择器的选择算法时，一般需要使用选择 Key。这个选择 Key 可以是消息 Key 也可以是其它数据，但无论谁做选择 Key，都不能重复，都是唯一的。</p>
<p>一般性的选择算法是，让选择 Key（或其 hash 值）与该 Topic 所包含的 Queue 的数量取模，其结果即为选择出的 Queue 的 QueueId。</p>
<p>取模算法存在一个问题：不同选择 Key与 Queue 数量取模结果可能会是相同的，即不同选择 Key 的消息可能会出现在相同的 Queue，即同一个 Consuemr 可能会消费到不同选择 Key 的消息。这个问题如何解决？</p>
<p>一般性的作法是，从消息中获取到选择 Key，对其进行判断。若是当前 Consumer 需要消费的消息，则直接消费，否则，什么也不做。这种做法要求选择 Key 要能够随着消息一起被 Consumer 获取到。此时使用消息 Key 作为选择 Key 是比较好的做法。</p>
<p>以上做法会不会出现如下新的问题呢？不属于那个 Consumer 的消息被拉取走了，那么应该消费该消息的 Consumer 是否还能再消费该消息呢？</p>
<p>同一个 Queue 中的消息不可能被同一个 Group 中的不同 Consumer 同时消费。所以，消费现一个 Queue 的不同选择 Key 的消息的 Consumer 一定属于不同的 Group，而不同的 Group 中的 Consumer 间的消费是相互隔离的，互不影响的。</p>
<h3 id="2-2-4-代码举例"><a class="header-anchor" href="#2-2-4-代码举例"></a>2.2.4 代码举例</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺序消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/13 0:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderedProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 若使用全局有序，需要设置 Queue 的数量为 1</span></span><br><span class="line">        <span class="comment">/* producer.setDefaultTopicQueueNums(1); */</span></span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 仅为了演示使用整型作为 orderId</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">orderId</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">byte</span>[] body = (<span class="string">&quot;Hi&quot;</span> + i).getBytes();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicA&quot;</span>, <span class="string">&quot;TagA&quot;</span>, body);</span><br><span class="line">            <span class="comment">// 将 orderId 作为消息 Key</span></span><br><span class="line">            message.setKeys(orderId.toString());</span><br><span class="line">            <span class="comment">// send() 方法的第三个参数会传递给选择器方法的第三个参数，即 Lambda 表达式中的参数 o</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message, (list, msg, o) -&gt; &#123;</span><br><span class="line">                <span class="comment">/* 以下为具体的选择算法 */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 以下是使用消息 Key 作为选择 Key 的选择算法</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> Integer.parseInt(message.getKeys());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 以下是使用参数 o 作为选择 Key 的选择算法</span></span><br><span class="line">                <span class="comment">/* Integer id = (Integer) o; */</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> id % list.size();</span><br><span class="line">                <span class="keyword">return</span> list.get(index);</span><br><span class="line">            &#125;, orderId);</span><br><span class="line"></span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-延时消息"><a class="header-anchor" href="#2-3-延时消息"></a>2.3 延时消息</h2>
<h3 id="2-3-1-什么是延时消息"><a class="header-anchor" href="#2-3-1-什么是延时消息"></a>2.3.1 什么是延时消息</h3>
<p>当消息写入到 Broker 后，在指定的时长后才可被消费处理的消息，称为延时消息。</p>
<p>采用 RocketMQ 的延时消息可以实现 <strong>定时任务</strong> 的功能，而无需使用定时器。典型的应用场景有电商交易中超时未支付关闭订单的场景、12306 平台订票超时未支付取消订票等。</p>
<p>在电商平台中，订单创建时会发送一条延迟消息。这条消息将会在 30 分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消订单，将商品再次放回到库存；如果完成支付，则忽略。</p>
<p>在 12306 平台中，车票预订成功后就会发送一条延迟消息。这条消息将会在 45 分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消预订，将车票再次放回到票池；如果完成支付，则忽略。</p>
<h3 id="2-3-2-延时等级"><a class="header-anchor" href="#2-3-2-延时等级"></a>2.3.2 延时等级</h3>
<p>延时消息的延迟时长不支持随意时长的延迟，是通过特定的延迟等级来指定的。延时等级定义在 RocketMQ 服务端的 <code>MessageStoreConfig</code> 类中的 <code>messageDelayLevel</code> 变量中：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/MessageStoreConfig%E4%B8%AD%E7%9A%84messageDelayLevel.png" alt="MessageStoreConfig中的messageDelayLevel"></p>
<p>也就是说，若指定的延时等级为 3，则表示延迟时长为 10s，即延迟等级是从 1 开始计数的。</p>
<p>当然，如果需要自定义的延时等级，可以通过在 Broker 加载的配置中新增如下配置（例如下面增加了 1 天这个等级 1d）。配置文件在 RocketMQ 安装目录下的 conf 目录中。</p>
<pre>
messageDelayLevel = 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h 1d
</pre>
<h3 id="2-3-3-延时消息实现原理"><a class="header-anchor" href="#2-3-3-延时消息实现原理"></a>2.3.3 延时消息实现原理</h3>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="RocketMQ延时消息的实现原理"></p>
<blockquote>
<p>修改消息</p>
</blockquote>
<p>Producer 将消息发送到 Broker 后，Broker 会首先将消息写入到 commitlog 文件，然后需要将其分发到相应的 consumequeue。不过，在分发之前，系统会先判断消息中是否带有延时等级。若没有，则直接正常分发；若有则需要经历一个复杂的过程：</p>
<p>1、修改消息的 Topic 为 <code>SCHEDULE_TOPIC_XXXX</code>；</p>
<p>2、根据延时等级，在 consumequeue 目录中 <code>SCHEDULE_TOPIC_XXXX</code> 主题下创建出相应的 queueId 目录与 consumequeue 文件（如果没有这些目录与文件的话）；</p>
<p>延迟等级 delayLevel 与 queueId 的对应关系为 <code>queueId = delayLevel - 1</code>。需要注意，在创建 queueId 目录时，并不是一次性地将所有延迟等级对应的目录全部创建完毕，而是用到哪个延迟等级创建哪个目录。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E7%B4%A2%E5%BC%95%E5%8D%95%E5%85%83%E5%9B%BE%E7%A4%BA.png" alt="RocketMQ索引单元图示"></p>
<p>3、修改消息索引单元内容。索引单元中的 Message Tag HashCode 部分原本存放的是消息的 Tag 的 Hash 值，现修改为消息的 <strong>投递时间</strong>。投递时间是指该消息被重新修改为原 Topic 后再次被写入到 commitlog 中的时间。投递时间 = 消息存储时间 + 延时等级时间。消息存储时间指的是消息被发送到 Broker 时的时间戳。</p>
<p>4、将消息索引写入到 <code>SCHEDULE_TOPIC_XXXX</code> 主题下相应的 consumequeue 中。</p>
<p>SCHEDULE_TOPIC_XXXX 目录中各个延时等级 Queue 中的消息是如何排序的？</p>
<p>是按照消息投递时间排序的。一个 Broker 中同一等级的所有延时消息会被写入到 consumequeue 目录中 SCHEDULE_TOPIC_XXXX 目录下相同 Queue 中。也就是说，一个 Queue 中消息投递时间的延迟等级时间是相同的，那么投递时间就取决于于消息存储时间了，即按照消息被发送到 Broker 的时间进行排序的。</p>
<blockquote>
<p>投递延时消息</p>
</blockquote>
<p>Broker 内部有⼀个延迟消息服务类 <code>ScheuleMessageService</code>，其会消费 SCHEDULE_TOPIC_XXXX 中的消息，即按照每条消息的投递时间，将延时消息投递到⽬标 Topic 中。不过，在投递之前会从 commitlog 中将原来写入的消息再次读出，并将其原来的延时等级设置为 0，即原消息变为了一条不延迟的普通消息，然后再次将消息投递到目标Topic中。</p>
<p><code>ScheuleMessageService</code> 在 Broker 启动时，会创建并启动一个定时器 Timer，用于执行相应的定时任务。系统会根据延时等级的个数，定义相应数量的 TimerTask，每个 TimerTask 负责一个延迟等级消息的消费与投递。每个 TimerTask 都会检测相应 Queue 队列的第一条消息是否到期。若第一条消息未到期，则后面的所有消息更不会到期（消息是按照投递时间排序的）；若第一条消息到期了，则将该消息投递到目标 Topic，即消费该消息。</p>
<blockquote>
<p>将消息重新写入 commitlog</p>
</blockquote>
<p>延迟消息服务类 <code>ScheuleMessageService</code> 将延迟消息再次发送给了 commitlog，并再次形成新的消息索引条目，分发到相应 Queue。</p>
<p>这其实就是一次普通消息发送，只不过这次的消息 Producer 是延迟消息服务类 <code>ScheuleMessageService</code>。</p>
<h3 id="2-3-4-代码举例"><a class="header-anchor" href="#2-3-4-代码举例"></a>2.3.4 代码举例</h3>
<blockquote>
<p>定义延迟消息生产者</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延迟消息生产者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/14 22:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">byte</span>[] body = (<span class="string">&quot;Hi&quot;</span> + i).getBytes();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicB&quot;</span>, <span class="string">&quot;someTag&quot;</span>, body);</span><br><span class="line">            <span class="comment">// 指定消息延迟等级为 3 级，即延迟 10s</span></span><br><span class="line">            message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">            <span class="comment">// 输出消息被发送的时间</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">            System.out.println(<span class="string">&quot; ,&quot;</span> + sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义延迟消息消费者（跟普通的消费者一样）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延迟消息消费者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/14 22:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OtherConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TopicB&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener((MessageListenerConcurrently) (messageList, consumeConcurrentlyContext) -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (MessageExt message : messageList) &#123;</span><br><span class="line">                <span class="comment">// 输出消息被消费的时间</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">                System.out.println(<span class="string">&quot; ,&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们先运行消费者，再运行生产者生产消息，消息生产成功后消费者并不会立即消费消息，而是要得到延迟时间过后才消费消息。</p>
<h2 id="2-4-事务消息"><a class="header-anchor" href="#2-4-事务消息"></a>2.4 事务消息</h2>
<h3 id="2-4-1-问题引入"><a class="header-anchor" href="#2-4-1-问题引入"></a>2.4.1 问题引入</h3>
<p>这里的一个需求场景是：工行用户 A 向建行用户 B 转账 1 万元。</p>
<p>我们可以使用同步消息来处理该需求场景：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E8%BD%AC%E8%B4%A6%E6%93%8D%E4%BD%9C%E7%9A%84%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="转账操作的同步消息处理方式示意图"></p>
<p>1、工行系统发送一个给 B 增款 1 万元的同步消息 M 给 Broker；</p>
<p>2、消息被 Broker 成功接收后，向工行系统发送成功 ACK；</p>
<p>3、工行系统收到成功 ACK 后从用户 A 中扣款 1 万元；</p>
<p>4、建行系统从 Broker 中获取到消息 M；</p>
<p>5、建行系统消费消息 M，即向用户 B 中增加 1 万元。</p>
<p>这其中是有问题的：若第3步中的扣款操作失败，但消息已经成功发送到了 Broker。对于 RocketMQ 来说，只要消息写入成功，那么这个消息就可以被消费。此时建行系统中用户 B 增加了 1 万元，出现了数据不一致问题。</p>
<h3 id="2-4-2-解决思路"><a class="header-anchor" href="#2-4-2-解决思路"></a>2.4.2 解决思路</h3>
<p>解决思路是，让第 1、2、3 步具有原子性，要么全部成功，要么全部失败。即消息发送成功后，必须要保证扣款成功。如果扣款失败，则回滚发送成功的消息，而该思路即使用事务消息。这里要使用分布式事务解决方案。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E8%BD%AC%E8%B4%A6%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BA%8B%E7%89%A9%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="转账操作的事物消息处理方式示意图"></p>
<p>使用事务消息来处理该需求场景：</p>
<p>1、事务管理器 TM 向事务协调器 TC 发起指令，开启全局事务；</p>
<p>2、工行系统发一个给 B 增款 1 万元的事务消息 M 给 TC；</p>
<p>3、TC 会向 Broker 发送 <strong>半事务消息</strong> prepareHalf，将消息 M <strong>预提交</strong> 到 Broker。此时的建行系统是看不到 Broker 中的消息 M 的；</p>
<p>4、Broker 会将预提交执行结果 Report 给 TC；</p>
<p>5、如果预提交失败，则 TC 会向 TM 上报预提交失败的响应，全局事务结束；如果预提交成功，TC 会调用工行系统的 <strong>回调操作</strong>，去完成工行用户 A 的 <strong>预扣款</strong> 1 万元的操作；</p>
<p>6、工行系统会向 TC 发送预扣款执行结果，即本地事务的执行状态；</p>
<p>7、TC 收到预扣款执行结果后，会将结果上报给 TM。</p>
<p>预扣款执行结果存在三种可能性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述本地事务执行状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">LocalTransactionState</span> &#123;</span><br><span class="line"> COMMIT_MESSAGE,  <span class="comment">// 本地事务执行成功</span></span><br><span class="line"> ROLLBACK_MESSAGE,  <span class="comment">// 本地事务执行失败</span></span><br><span class="line"> UNKNOW,  <span class="comment">// 不确定，表示需要进行回查以确定本地事务的执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8、TM 会根据上报结果向 TC 发出不同的确认指令：</p>
<p>① 若预扣款成功（本地事务状态为 COMMIT_MESSAGE），则 TM 向 TC 发送 Global Commit 指令；</p>
<p>② 若预扣款失败（本地事务状态为 ROLLBACK_MESSAGE），则TM向TC发送Global Rollback指令；</p>
<p>③ 若现未知状态（本地事务状态为 UNKNOW），则会触发工行系统的本地事务状态回查操作。回查操作会将回查结果（至多回查 15 次），即 COMMIT_MESSAGE 或 ROLLBACK_MESSAGE Report 给 TC。TC 将结果上报给 TM，TM 会再向 TC 发送最终确认指令 Global Commit 或 Global Rollback。</p>
<p>9、TC 在接收到指令后会向 Broker 与工行系统发出确认指令；</p>
<p>① TC 接收的若是 Global Commit 指令，则向 Broker 与工行系统发送 Branch Commit 指令。此时Broker中的消息M才可被建行系统看到；此时的工行用户A中的扣款操作才真正被确认；<br>
② TC 接收到的若是 Global Rollback 指令，则向 Broker 与工行系统发送 Branch Rollback 指令。此时 Broker 中的消息 M 将被撤销，工行用户 A 中的扣款操作将被回滚。</p>
<p>以上方案就是为了确保消息投递与扣款操作能够在一个事务中，要成功都成功，有一个失败，则全部回滚。</p>
<p>以上方案并不是一个典型的 XA 模式，因为 XA 模式中的分支事务是异步的，而事务消息方案中的消息预提交与预扣款操作间是同步的。</p>
<h3 id="2-4-3-基础"><a class="header-anchor" href="#2-4-3-基础"></a>2.4.3 基础</h3>
<blockquote>
<p>分布式事务</p>
</blockquote>
<p>对于分布式事务，通俗地说就是，一次操作由若干分支操作组成，这些分支操作分属不同应用，分布在不同服务器上。分布式事务需要保证这些分支操作要么全部成功，要么全部失败。分布式事务与普通事务一样，就是为了保证操作结果的一致性。</p>
<blockquote>
<p>事务消息</p>
</blockquote>
<p>RocketMQ 提供了类似 X/Open XA 的分布式事务功能，通过事务消息能达到分布式事务的最终一致。XA 是一种分布式事务解决方案，一种分布式事务处理模式。</p>
<blockquote>
<p>半事务消息</p>
</blockquote>
<p>暂不能投递的消息，发送方已经成功地将消息发送到了 Broker，但是 Broker 未收到最终确认指令，此时该消息被标记成“暂不能投递”状态，即不能被消费者看到。处于该种状态下的消息即半事务消息。</p>
<blockquote>
<p>本地事务状态</p>
</blockquote>
<p>Producer <strong>回调操作</strong> 执行的结果为本地事务状态，其会发送给 TC，而 TC 会再发送给 TM。TM 会根据 TC 发送来的本地事务状态来决定全局事务确认指令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述本地事务执行状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">LocalTransactionState</span> &#123;</span><br><span class="line"> COMMIT_MESSAGE,  <span class="comment">// 本地事务执行成功</span></span><br><span class="line"> ROLLBACK_MESSAGE,  <span class="comment">// 本地事务执行失败</span></span><br><span class="line"> UNKNOW,  <span class="comment">// 不确定，表示需要进行回查以确定本地事务的执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>消息回查</p>
</blockquote>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E6%B6%88%E6%81%AF%E4%BC%9A%E6%9F%A5%E7%9A%84%E8%A2%AB%E8%B0%83%E7%94%A8%E5%9C%BA%E6%99%AF%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="消息会查的被调用场景示意图"></p>
<p>消息回查，即重新查询本地事务的执行状态。本例就是重新到 DB 中查看预扣款操作是否执行成功。</p>
<p>注意，消息回查不是重新执行回调操作。回调操作是进行预扣款操作，而消息回查则是查看预扣款操作执行的结果。</p>
<p>引发消息回查的原因最常见的有两个：</p>
<p>1、回调操作返回 <code>UNKNWON</code>；</p>
<p>2、TC 没有接收到 TM 的最终全局事务确认指令。</p>
<blockquote>
<p>RocketMQ 中的消息回查设置</p>
</blockquote>
<p>关于消息回查，有三个常见的属性设置。它们都在 Broker 加载的配置文件（broker.conf）中设置，例如：</p>
<p>1、transactionTimeout = 20，指定 TM 在 20 秒内应将最终确认状态发送给 TC，否则引发消息回查。默认为 60 秒。</p>
<p>2、transactionCheckMax = 5，指定最多回查 5 次，超过后将丢弃消息并记录错误日志。默认 15 次。</p>
<p>3、transactionCheckInterval = 10，指定设置的多次消息回查的时间间隔为 10 秒。默认为 60 秒。</p>
<h3 id="2-4-4-XA-模式三剑客"><a class="header-anchor" href="#2-4-4-XA-模式三剑客"></a>2.4.4 XA 模式三剑客</h3>
<blockquote>
<p>XA 协议</p>
</blockquote>
<p>XA（Unix Transaction）是一种分布式事务解决方案，一种分布式事务处理模式，是基于 XA 协议的。XA 协议由 Tuxedo（Transaction for Unix has been Extended for Distributed Operation，分布式操作扩展之后的 Unix 事务系统）首先提出的，并交给 X/Open 组织，作为资源管理器与事务管理器的接口标准。</p>
<p>XA 模式中有三个重要组件：TC、TM、RM。</p>
<blockquote>
<p>TC</p>
</blockquote>
<p>Transaction Coordinator，事务协调者。维护全局和分支事务的状态，驱动全局事务提交或回滚。RocketMQ 中 Broker 充当 TC。</p>
<blockquote>
<p>TM</p>
</blockquote>
<p>Transaction Manager，事务管理器。定义全局事务的范围：开始全局事务、提交或回滚全局事务。它实际是全局事务的发起者。RocketMQ 中事务消息的 Producer 充当 TM。</p>
<blockquote>
<p>RM</p>
</blockquote>
<p>Resource Manager，资源管理器。管理分支事务处理的资源，与 TC 交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。RocketMQ 中事务消息的 Producer 及 Broker 均是 RM。</p>
<h3 id="2-4-5-XA-模式架构"><a class="header-anchor" href="#2-4-5-XA-模式架构"></a>2.4.5 XA 模式架构</h3>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/XA%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84.png" alt="XA模式架构"></p>
<p>XA 模式是一个典型的 2PC，其执行原理如下：</p>
<p>1、TM 向 TC 发起指令，开启一个全局事务；</p>
<p>2、根据业务要求，各个 RM 会逐个向 TC 注册分支事务，然后 TC 会逐个向 RM 发出预执行指令；</p>
<p>3、各个 RM 在接收到指令后会在进行本地事务预执行；</p>
<p>4、RM 将预执行结果 Report 给 TC，这个结果可能是成功，也可能是失败；</p>
<p>5、TC 在接收到各个 RM 的 Report 后会将汇总结果上报给 TM，根据汇总结果 TM 会向 TC 发出确认指令。</p>
<p>若所有结果都是成功响应，则向 TC 发送 Global Commit指令；只要有结果是失败响应，则向 TC 发送 Global Rollback 指令。</p>
<p>6、TC 在接收到指令后再次向 RM 发送确认指令。</p>
<p>事务消息方案并不是一个典型的 XA 模式。因为 XA 模式中的分支事务是异步的，而事务消息方案中的消息预提交与预扣款操作间是同步的。</p>
<h3 id="2-4-6-注意"><a class="header-anchor" href="#2-4-6-注意"></a>2.4.6 注意</h3>
<p>1、事务消息不支持延时消息；</p>
<p>2、对于事务消息要做好幂等性检查，因为事务消息可能不止一次被消费（因为存在回滚后再提交的情况）。</p>
<h3 id="2-4-7-代码举例"><a class="header-anchor" href="#2-4-7-代码举例"></a>2.4.7 代码举例</h3>
<blockquote>
<p>定义工行事务监听器</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工行事务监听器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/15 23:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ICBCTransactionListener</span> <span class="keyword">implements</span> <span class="title class_">TransactionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回调操作方法</span></span><br><span class="line"><span class="comment">     * 消息预提交成功就会触发该方法的执行，用于完成本地事务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message message, Object o)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;预提交消息成功：&quot;</span> + message);</span><br><span class="line">        <span class="comment">/* 假设接收到的 TAGA 的消息就表示扣款操作成功，TAGB 的消息表示扣款失败，</span></span><br><span class="line"><span class="comment">        *  TAGC 表示扣款结果不清楚，需要执行消息回查*/</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGA&quot;</span>, message.getTags())) &#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGB&quot;</span>, message.getTags())) &#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGC&quot;</span>, message.getTags())) &#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息回查方法，常见的引发原因有：</span></span><br><span class="line"><span class="comment">     * 1、回调操作返回 UNKNOWN</span></span><br><span class="line"><span class="comment">     * 2、TC 没有接收到 TM 的最终全局事务确认指令</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageExt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt messageExt)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行消息回查&quot;</span> + messageExt.getTags());</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义事务消息生产者</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务消息生产者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/15 23:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">TransactionMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionMQProducer</span>(<span class="string">&quot;tpg&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个线程池</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">100</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2000</span>), (Runnable r) -&gt; &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">            thread.setName(<span class="string">&quot;client-transaction-msg-check-thread&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为生产者指定一个线程池</span></span><br><span class="line">        producer.setExecutorService(threadPoolExecutor);</span><br><span class="line">        <span class="comment">// 为生产者添加事务监听器</span></span><br><span class="line">        producer.setTransactionListener(<span class="keyword">new</span> <span class="title class_">ICBCTransactionListener</span>());</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        String[] tags = &#123;<span class="string">&quot;TAGA&quot;</span>, <span class="string">&quot;TAGB&quot;</span>, <span class="string">&quot;TAGC&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">byte</span>[] body = (<span class="string">&quot;Hi&quot;</span> + i).getBytes();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TTopic&quot;</span>, tags[i], body);</span><br><span class="line">            <span class="comment">// 发送事务消息。第二个参数用于指定在执行本地事务时要使用的业务参数</span></span><br><span class="line">            <span class="type">TransactionSendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.sendMessageInTransaction(message, <span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;发送结果为：&quot;</span> + sendResult.getSendStatus());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>事务消息的消费者</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务消息的消费者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/15 23:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener((MessageListenerConcurrently) (messageList, consumeConcurrentlyContext) -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (MessageExt msg : messageList) &#123;</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们运行消息生产者时，三条消息都会预提交成功，但是 <code>TAGC</code> 对应的消息会执行消息回查，因为 <code>TAGC</code> 对应的消息在进行预提交时返回的是 <code>UNKNOW</code>。</p>
<p>然后再运行消费者时，会消费 <code>TAGA</code> 和 <code>TAGC</code> 对应的消息，不会消费 <code>TAGB</code> 对应的消息，这是因为 <code>TAGB</code> 对应的消息在预提交时返回了 <code>ROLLBACK_MESSAGE</code>，导致消息回滚。</p>
<h2 id="2-5-批量消息"><a class="header-anchor" href="#2-5-批量消息"></a>2.5 批量消息</h2>
<h3 id="2-5-1-批量发送消息"><a class="header-anchor" href="#2-5-1-批量发送消息"></a>2.5.1 批量发送消息</h3>
<blockquote>
<p>发送限制</p>
</blockquote>
<p>生产者进行消息发送时可以一次发送多条消息，这可以大大提升 Producer 的发送效率。不过需要注意以下几点：</p>
<p>1、批量发送的消息必须具有相同的 Topic；</p>
<p>2、批量发送的消息必须具有相同的刷盘策略；</p>
<p>3、批量发送的消息不能是延时消息与事务消息。</p>
<blockquote>
<p>批量发送大小</p>
</blockquote>
<p>默认情况下，一批发送的消息总大小不能超过 4MB 字节。如果想超出该值，有两种解决方案：</p>
<p>方案一：将批量消息进行拆分，拆分为若干不大于 4M 的消息集合分多次批量发送。</p>
<p>方案二：在 Producer 端与 Broker 端修改属性：Producer 端需要在发送之前设置 Producer 的 <code>maxMessageSize</code> 属性，同时 Broker 端需要修改其加载的配置文件中的 <code>maxMessageSize</code> 属性。</p>
<blockquote>
<p>生产者发送的消息大小</p>
</blockquote>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/Producer%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="Producer发送消息的结构"></p>
<p>生产者通过 <code>send()</code> 方法发送的 Message，并不是直接将 Message 序列化后发送到网络上的，而是通过这个 Message 生成了一个字符串发送出去的。这个字符串由四部分构成：Topic、消息 Body、消息日志（占 20 字节），及用于描述消息的一堆属性 key-value。这些属性中包含例如生产者地址、生产时间、要发送的 QueueId 等，最终写入到 Broker 中消息单元中的数据都是来自于这些属性。</p>
<h3 id="2-5-2-批量消费消息"><a class="header-anchor" href="#2-5-2-批量消费消息"></a>2.5.2 批量消费消息</h3>
<blockquote>
<p>修改批量属性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageListenerConcurrently</span> <span class="keyword">extends</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line">    ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> ConsumeConcurrentlyContext context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Consumer 的 MessageListenerConcurrently 监听接口的 <code>consumeMessage()</code> 方法的第一个参数为消息列表，但默认情况下每次只能消费一条消息。若要使其一次可以消费多条消息，则可以通过修改 Consumer 的 <code>consumeMessageBatchMaxSize</code> 属性来指定。不过，该值不能超过 32，因为默认情况下消费者每次可以拉取的消息最多是 32 条。若要修改一次拉取的最大值，则可通过修改 Consumer 的 <code>pullBatchSize</code> 属性来指定。</p>
<blockquote>
<p>存在的问题</p>
</blockquote>
<p>Consumer 的 pullBatchSize 属性与 consumeMessageBatchMaxSize 属性是否设置的越大越好？</p>
<p>当然不是。</p>
<p>pullBatchSize 值设置的越大，Consumer 每拉取一次需要的时间就会越长，且在网络上传输出现问题的可能性就越高。若在拉取过程中若出现了问题，那么本批次所有消息都需要全部重新拉取。<br>
consumeMessageBatchMaxSize 值设置的越大，Consumer 的消息并发消费能力越低，且这批被消费的消息具有相同的消费结果。因为 consumeMessageBatchMaxSize 指定的一批消息只会使用一个线程进行处理，且在处理过程中只要有一个消息处理异常，则这批消息需要全部重新再次消费处理。</p>
<h3 id="2-5-3-代码举例"><a class="header-anchor" href="#2-5-3-代码举例"></a>2.5.3 代码举例</h3>
<p>该批量发送的需求是，不修改最大发送 4M 的默认值，但要防止发送的批量消息超出 4M 的限制。</p>
<blockquote>
<p>定义消息列表分割器</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息分割器：其只会处理每条消息的大小不超过 4M 的情况。</span></span><br><span class="line"><span class="comment"> * 若存在某条消息，其本身大小大于 4M，这个分割器无法处理。</span></span><br><span class="line"><span class="comment"> * 其直接将这条消息构成一个子列表返回，并不进行分割。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/16 22:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageListSplitter</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;List&lt;Message&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定极限值为 4M</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE_LIMIT</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放所有要发送的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Message&gt; messages;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要进行批量发送消息的小集合起始索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> currIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageListSplitter</span><span class="params">(List&lt;Message&gt; messages)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messages = messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断当前开始遍历的消息索引是否小于消息总数</span></span><br><span class="line">        <span class="keyword">return</span> currIndex &lt; messages.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Message&gt; <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> currIndex;</span><br><span class="line">        <span class="comment">// 记录当前要发送的这一小批次消息列表的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">            <span class="comment">// 获取当前遍历的消息</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messages.get(nextIndex);</span><br><span class="line">            <span class="comment">// 统计当前遍历的消息的大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temSize</span> <span class="operator">=</span> message.getTopic().length() + message.getBody().length;</span><br><span class="line">            Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                temSize += entry.getKey().length() + entry.getValue().length();</span><br><span class="line">            &#125;</span><br><span class="line">            temSize = temSize + <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断当前消息本身是否大于 4M</span></span><br><span class="line">            <span class="keyword">if</span> (temSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nextIndex - currIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                    nextIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                totalSize += temSize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前消息列表的子集合 [currIndex, nextIndex)</span></span><br><span class="line">        List&lt;Message&gt; subList = <span class="built_in">this</span>.messages.subList(currIndex, nextIndex);</span><br><span class="line">        <span class="comment">// 下次遍历的开始索引</span></span><br><span class="line">        currIndex = nextIndex;</span><br><span class="line">        <span class="keyword">return</span> subList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义批量消息生产者</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量消息生产者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/16 23:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定要发送消息的最大大小，默认是 4M。同时需要修改 Broker 配置文件的 maxMessageSize 属性</span></span><br><span class="line">        producer.setMaxMessageSize(<span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义要发送的消息集合</span></span><br><span class="line">        List&lt;Message&gt; messages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">byte</span>[] body = (<span class="string">&quot;Hi&quot;</span> + i).getBytes();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;someTopic&quot;</span>, <span class="string">&quot;someTag&quot;</span>, body);</span><br><span class="line">            messages.add(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义消息列表分割器，将消息列表分割为多个不超过 4M 的小列表</span></span><br><span class="line">        <span class="type">MessageListSplitter</span> <span class="variable">splitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageListSplitter</span>(messages);</span><br><span class="line">        <span class="keyword">while</span> (splitter.hasNext()) &#123;</span><br><span class="line">            List&lt;Message&gt; next = splitter.next();</span><br><span class="line">            producer.send(next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义批量消息消费者</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量消息消费者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/17 22:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;someTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定每次可以消费 10 条消息，默认为 1</span></span><br><span class="line">        consumer.setConsumeMessageBatchMaxSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 指定每次可以从 Broker 中拉取 40 条消息，默认为 32</span></span><br><span class="line">        consumer.setPullBatchSize(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 消费成功的返回结果</span></span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            <span class="comment">// 消费失败的返回结果</span></span><br><span class="line">            <span class="comment">/* return ConsumeConcurrentlyStatus.RECONSUME_LATER; */</span></span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-6-消息过滤"><a class="header-anchor" href="#2-6-消息过滤"></a>2.6 消息过滤</h2>
<p>消息者在进行消息订阅时，除了可以指定要订阅消息的 Topic 外，还可以对指定 Topic 中的消息根据指定条件进行过滤，即可以订阅比 Topic 更加细粒度的消息类型。</p>
<p>对于指定 Topic 消息的过滤有两种过滤方式：Tag 过滤与 SQL 过滤。</p>
<h3 id="2-6-1-Tag-过滤"><a class="header-anchor" href="#2-6-1-Tag-过滤"></a>2.6.1 Tag 过滤</h3>
<p>通过 Consumer 的 <code>subscribe()</code> 方法指定要订阅消息的 Tag。如果订阅多个 Tag 的消息，Tag 间使用或运算符（双竖线 <code>||</code>）连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;CID_EXAMPLE&quot;</span>);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;TOPIC&quot;</span>, <span class="string">&quot;TAGA || TAGB || TAGC&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-6-2-SQL-过滤"><a class="header-anchor" href="#2-6-2-SQL-过滤"></a>2.6.2 SQL 过滤</h3>
<p>SQL 过滤是一种通过特定表达式对事先埋入到消息中的 <strong>用户属性</strong> 进行筛选过滤的方式。通过 SQL 过滤，可以实现对消息的复杂过滤。不过，只有使用 <strong>PUSH 模式</strong> 的消费者才能使用 SQL 过滤。</p>
<p>SQL 过滤表达式中支持多种常量类型与运算符。</p>
<blockquote>
<p>支持的常量类型</p>
</blockquote>
<p>数值：比如：123，3.1415</p>
<p>字符：必须用单引号包裹起来，比如：‘abc’</p>
<p>布尔：TRUE 或 FALSE</p>
<p>NULL：特殊的常量，表示空</p>
<blockquote>
<p>支持的运算符</p>
</blockquote>
<p>数值比较：&gt;，&gt;=，&lt;，&lt;=，BETWEEN，=</p>
<p>字符比较：=，&lt;&gt;，IN</p>
<p>逻辑运算 ：AND，OR，NOT</p>
<p>NULL判断：IS NULL 或者 IS NOT NULL</p>
<p>默认情况下 Broker 没有开启消息的 SQL 过滤功能，需要在 Broker 加载的配置文件中添加如下属性，以开启该功能：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">enablePropertyFilter</span> = <span class="string">true</span></span><br></pre></td></tr></table></figure>
<p>在启动 Broker 时需要指定这个修改过的配置文件。例如对于单机 Broker 的启动，其修改的配置文件是 conf/broker.conf，启动时使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqbroker -n localhost:9876 -c conf/broker.conf &amp;</span><br></pre></td></tr></table></figure>
<p>由于我们早已修改了 broker.conf 配置文件，加上前面出现的一系列错误，因此我们的启动 Broker 命令应该如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqbroker -n xx.xxx.xxx.xx:9876 -c conf/broker.conf autoCreateTopicEnable=true  &gt;  bin/startMqBroker.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p><code>xx.xxx.xxx.xx</code> 表示服务器或虚拟机的 IP 地址。</p>
<h3 id="2-6-3-代码举例"><a class="header-anchor" href="#2-6-3-代码举例"></a>2.6.3 代码举例</h3>
<blockquote>
<p>Tag 过滤</p>
</blockquote>
<p>定义 Tag 过滤 Producer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义Tag过滤Producer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/18 22:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterByTagProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        String[] tags = &#123;<span class="string">&quot;myTagA&quot;</span>, <span class="string">&quot;myTagB&quot;</span>, <span class="string">&quot;myTagC&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">byte</span>[] body = (<span class="string">&quot;Hi&quot;</span> + i).getBytes();</span><br><span class="line">            <span class="type">String</span> <span class="variable">tag</span> <span class="operator">=</span> tags[i % tags.length];</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;myTopic&quot;</span>, tag, body);</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义 Tag 过滤 Consumer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义Tag过滤Consumer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/18 22:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterByTagConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 仅订阅 myTagA 与 myTagB，没有 myTagC</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;myTopic&quot;</span>, <span class="string">&quot;myTagA || myTagB&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先运行生产者的代码，再运行消费者的代码。运行后可在控制台看到消费者消费的消息 Tag 只有 <code>TagA</code> 和 <code>TagB</code>，没有 <code>TagC</code>，证明我们的 Tag 过滤是成功的。</p>
<blockquote>
<p>SQL 过滤</p>
</blockquote>
<p>定义 SQL 过滤 Producer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义SQL过滤Producer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/18 22:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterBySqlProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">byte</span>[] body = (<span class="string">&quot;Hi&quot;</span> + i).getBytes();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicE&quot;</span>, <span class="string">&quot;myTag&quot;</span>, body);</span><br><span class="line">            <span class="comment">// 事先埋入用户属性 age</span></span><br><span class="line">            message.putUserProperty(<span class="string">&quot;age&quot;</span>, i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义 SQL 过滤 Consumer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义SQL过滤Consumer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/19 21:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterBySqlConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        <span class="comment">// 过滤出 age 介于 0 到 6 之间的消息</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TopicE&quot;</span>, MessageSelector.bySql(<span class="string">&quot;age between 0 and 6&quot;</span>));</span><br><span class="line">        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先运行生产者的代码，再运行消费者的代码。生产者的代码可以成功运行，但当我们运行消费者的代码对消息进行消费时，控制台出现以下错误：</p>
<pre>
Exception in thread "main" org.apache.rocketmq.client.exception.MQClientException: CODE: 1  DESC: The broker does not support consumer to filter message by SQL92
For more information, please visit the url, http://rocketmq.apache.org/docs/faq/
</pre>
<p>很显然，这是我们没有开启 SQL 过滤功能，我们只需要按照前面所说的方式开启即可。</p>
<p>我们先关闭 RocketMQ，然后按照要求修改配置后并重启 RocketMQ。此时可以看控制台看到 RocketMQ 消费的消息的 age 都是介于 0 到 6 之间的，证明 SQL 过过滤成功。</p>
<h2 id="2-7-消息发送重试机制"><a class="header-anchor" href="#2-7-消息发送重试机制"></a>2.7 消息发送重试机制</h2>
<h3 id="2-7-1-说明"><a class="header-anchor" href="#2-7-1-说明"></a>2.7.1 说明</h3>
<p>Producer 对发送失败的消息进行重新发送的机制，称为消息发送重试机制，也称为消息重投机制。对于消息重投，需要注意以下几点：</p>
<p>1、生产者在发送消息时，若采用 <strong>同步或异步发送</strong> 方式，发送失败会重试，但 oneway  消 息发送方式发送失败是没有重试机制的；</p>
<p>2、只有普通消息具有发送重试机制，顺序消息是没有的；</p>
<p>3、消息重投机制可以保证消息尽可能发送成功、不丢失，但可能会造成消息重复，消息重复在 RocketMQ 中是无法避免的问题；</p>
<p>4、消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会成为大概率事件 Producer 主动重发、Consumer 负载变化（发生 Rebalance，不会导致消息重复，但可能出现重复消费）也会导致重复消息；</p>
<p>5、消息重复无法避免，但要避免消息的重复消费；</p>
<p>6、避免消息重复消费的解决方案是，为消息添加唯一标识（例如消息 key），使消费者对消息进行消费判断来避免重复消费；</p>
<p>7、消息发送重试有三种策略可以选择：同步发送失败策略、异步发送失败策略、消息刷盘失败策略。</p>
<h3 id="2-7-2-同步发送失败策略"><a class="header-anchor" href="#2-7-2-同步发送失败策略"></a>2.7.2 同步发送失败策略</h3>
<p>对于普通消息，消息发送默认采用 round-robin 策略来选择所发送到的队列。如果发送失败，默认重试 2 次，但在重试时是不会选择上次发送失败的 Broker，而是选择其它 Broker。当然，若只有一个 Broker 其也只能发送到该 Broker，但其会尽量发送到该 Broker 上的其它 Queue。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Producer，参数为 Producer Group 名称</span></span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line"><span class="comment">// 指定 NameServer 的地址</span></span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line"><span class="comment">// 设置当发送失败时重试发送的次数，默认为 2 次</span></span><br><span class="line">producer.setRetryTimesWhenSendAsyncFailed(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 设置发送超时时限，默认为 3s</span></span><br><span class="line">producer.setSendMsgTimeout(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>
<p>同时，Broker 还具有 <strong>失败隔离</strong> 功能，使 Producer 尽量选择未发生过发送失败的 Broker 作为目标 Broker。其可以保证其它消息尽量不发送到有问题的 Broker，为了提升消息发送效率，降低消息发送耗时。</p>
<p>如果超过重试次数，则抛出异常，由 Producer 去保证消息不丢。当然当生产者出现 RemotingException、MQClientException 和 MQBrokerException时，Producer 会自动重投消息。</p>
<blockquote>
<p>思考：如果需要自行实现 <strong>失败隔离</strong> 功能，如何来做？</p>
</blockquote>
<p>1、方案一：Producer 中维护某 JUC 的 Map 集合，其 key 是发生失败的时间戳，value 为 Broker 实例。Producer 中还维护着一个 Set 集合，其中存放着所有未发生发送异常的 Broker 实例。选择目标 Broker 是从该 Set 集合中选择的。再定义一个定时任务，定期从 Map 集合中将长期未发生发送异常的 Broker 清理出去，并添加到 Set 集合。</p>
<p>2）方案二：为 Producer 中的 Broker 实例添加一个标识，例如是一个 AtomicBoolean 属性。只要该 Broker 上发生过发送异常，就将其置为 true。选择目标 Broker 就是选择该属性值为 false 的 Broker。再定义一个定时任务，定期将 Broker 的该属性置为 false。</p>
<p>3）方案三：为 Producer 中的 Broker 实例添加一个标识，例如是一个 AtomicLong 属性。只要该 Broker 上发生过发送异常，就使其值增一。选择目标 Broker 就是选择该属性值最小的 Broker。若该值相同，采用轮询方式选择。</p>
<h3 id="2-7-3-异步发送失败策略"><a class="header-anchor" href="#2-7-3-异步发送失败策略"></a>2.7.3 异步发送失败策略</h3>
<p>异步发送失败重试时，异步重试不会选择其他 Broker，仅在同一个 Broker 上做重试，所以该策略无法保证消息不丢失。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line"><span class="comment">// 指定异步发送失败后不进行重试发送</span></span><br><span class="line">producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-7-4-消息刷盘失败策略"><a class="header-anchor" href="#2-7-4-消息刷盘失败策略"></a>2.7.4 消息刷盘失败策略</h3>
<p>消息刷盘超时（Master 或 Slave）或 Slave 不可用（Slave 在做数据同步时向 Master 返回状态不是 SEND_OK）时，默认是不会将消息尝试发送到其他 Broker 的。不过，对于重要消息可以通过在 Broker 的配置文件设置 retryAnotherBrokerWhenNotStoreOK 属性为 true 来开启。</p>
<h2 id="2-8-消息消费重试机制"><a class="header-anchor" href="#2-8-消息消费重试机制"></a>2.8 消息消费重试机制</h2>
<h3 id="2-8-1-顺序消息的消费重试"><a class="header-anchor" href="#2-8-1-顺序消息的消费重试"></a>2.8.1 顺序消息的消费重试</h3>
<p>对于顺序消息，当 Consumer 消费消息失败后，为了保证消息的顺序性，其会自动不断地进行消息重试，直到消费成功。消费重试默认间隔时间为 1000 毫秒。重试期间应用会出现消息消费被阻塞的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line"><span class="comment">// 顺序消息消费失败的消费重试时间间隔，单位毫秒，默认为 1000，其取值范围为 [10, 30000]</span></span><br><span class="line">consumer.setSuspendCurrentQueueTimeMillis(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>由于对顺序消息的重试是无休止、不间断的，直至消费成功，所以对于顺序消息的消费，务必要保证应用能够及时监控并处理消费失败的情况，避免消费被永久性阻塞。</p>
<p><mark>注意：</mark> 顺序消息没有发送失败重试机制，但具有消费失败重试机制。</p>
<h3 id="2-8-2-无序消息的消费重试"><a class="header-anchor" href="#2-8-2-无序消息的消费重试"></a>2.8.2 无序消息的消费重试</h3>
<p>对于无序消息（普通消息、延时消息、事务消息），当 Consumer 消费消息失败时，可以通过设置返回状态达到消息重试的效果。不过需要注意，无序消息的重试 <strong>只对集群消费方式生效</strong>，广播消费方式不提供失败重试特性。也就是说，对于广播消费消费失败后，失败消息不再重试，继续消费后续消息。</p>
<h3 id="2-8-3-消费重试次数与间隔"><a class="header-anchor" href="#2-8-3-消费重试次数与间隔"></a>2.8.3 消费重试次数与间隔</h3>
<p>对于 <strong>无序消息集群消费</strong> 下的重试消费，每条消息默认最多重试 16 次，但每次重试的间隔时间是不同的，会逐渐变长。每次重试的间隔时间如下表。</p>
<table>
<thead>
<tr>
<th style="text-align:center">重试次数</th>
<th style="text-align:center">与上次重试的间隔时间</th>
<th style="text-align:center">重试次数</th>
<th style="text-align:center">与上次重试的间隔时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">10 秒</td>
<td style="text-align:center">9</td>
<td style="text-align:center">7 分钟</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">30 秒</td>
<td style="text-align:center">10</td>
<td style="text-align:center">8 分钟</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1 分钟</td>
<td style="text-align:center">11</td>
<td style="text-align:center">9 分钟</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2 分钟</td>
<td style="text-align:center">12</td>
<td style="text-align:center">10 分钟</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">3 分钟</td>
<td style="text-align:center">13</td>
<td style="text-align:center">20 分钟</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">4 分钟</td>
<td style="text-align:center">14</td>
<td style="text-align:center">30 分钟</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">5 分钟</td>
<td style="text-align:center">15</td>
<td style="text-align:center">1 小时</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">6 分钟</td>
<td style="text-align:center">16</td>
<td style="text-align:center">2 小时</td>
</tr>
</tbody>
</table>
<p>若一条消息在一直消费失败的前提下，将会在正常消费后的第 4 小时 46 分后进行第 16 次重试。若仍然失败，则将消息投递到 <strong>死信队列</strong>。</p>
<blockquote>
<p>修改消费重试次数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line"><span class="comment">// 修改消费重试次数</span></span><br><span class="line">consumer.setMaxReconsumeTimes(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>对于修改过的重试次数，将按照以下策略执行：</p>
<p>1、若修改值小于 16，按照指定间隔进行重试；</p>
<p>2、若修改值大于 16，则超过 16 次的重试时间间隔均为 2 小时。</p>
<p>对于 Consumer Group，若仅修改了一个 Consumer 的消费重试次数，则会应用到该 Group 中所有其它 Consumer 实例。若出现多个 Consumer 均做了修改的情况，则采用覆盖方式生效，即最后被修改的值会覆盖前面设置的值。</p>
<h3 id="2-8-4-重试队列"><a class="header-anchor" href="#2-8-4-重试队列"></a>2.8.4 重试队列</h3>
<p>对于需要重试消费的消息，并不是 Consumer 在等待了指定时长后再次去拉取原来的消息进行消费，而是将这些需要重试消费的消息放入到了一个特殊 Topic 的队列中，而后进行再次消费的。这个特殊的队列就是重试队列。</p>
<p>当出现需要进行重试消费的消息时，Broker 会为每个消费组都设置一个 Topic 名称为 <code>%RETRY%consumerGroup@consumerGroup</code> 的重试队列。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RocketMQ%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97.png" alt="RocketMQ重试队列"></p>
<p>这个重试队列是针对消息者组的，而不是针对每个 Topic 设置的（一个 Topic 的消息可以让多个消费者组进行消费，所以会为这些消费者组各创建一个重试队列）。只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列。</p>
<p>我们发现消费重试的时间间隔与延时消费的延时等级十分相似，除了没有延时等级的前两个时间外，其它的时间都是相同的。这是因为 Broker 对于重试消息的处理是通过 <strong>延时消息</strong> 实现的，先将消息保存到 SCHEDULE_TOPIC_XXXX 延迟队列中，延迟时间到后，会将消息投递到 <code>%RETRY%consumerGroup@consumerGroup</code> 重试队列中。</p>
<h3 id="2-8-5-消费重试配置方式"><a class="header-anchor" href="#2-8-5-消费重试配置方式"></a>2.8.5 消费重试配置方式</h3>
<p>集群消费方式下，消息消费失败后若希望消费重试，则需要在 <strong>消息监听器接口</strong> 的实现中明确进行如下三种方式之一的配置：</p>
<p>方式一：返回 <code>ConsumeConcurrentlyStatus.RECONSUME_LATER</code>（推荐）</p>
<p>方式二：返回 <code>null</code></p>
<p>方式三：抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息重试消费者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/9/19 23:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetryConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;rocketmq:9876&quot;</span>);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;someTopic&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 注册消息监听器</span></span><br><span class="line">        consumer.registerMessageListener((MessageListenerConcurrently) (messageList, consumeConcurrentlyContext) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : messageList) &#123;</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="comment">// 以下三种情况均可引发消息重试</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">                <span class="comment">/* return null;</span></span><br><span class="line"><span class="comment">                   return new RuntimeException(&quot;消息异常&quot;); */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回消费状态，消费成功</span></span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启消费者消费</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-8-6-消费不重试配置方式"><a class="header-anchor" href="#2-8-6-消费不重试配置方式"></a>2.8.6 消费不重试配置方式</h3>
<p>集群消费方式下，消息消费失败后若不希望消费重试，则可以在捕获到异常后同样返回与消费成功后的相同的结果，即 <code>ConsumeConcurrentlyStatus.CONSUME_SUCCESS</code>。</p>
<h2 id="2-9-死信队列"><a class="header-anchor" href="#2-9-死信队列"></a>2.9 死信队列</h2>
<h3 id="2-9-1-什么是死信队列"><a class="header-anchor" href="#2-9-1-什么是死信队列"></a>2.9.1 什么是死信队列</h3>
<p>当一条消息初次消费失败，消息队列会自动进行消费重试。达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，但是消息队列不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。这个队列就是死信队列（Dead-Letter Queue，DLQ），而其中的消息则称为死信消息（Dead-Letter Message，DLM）。</p>
<p>死信队列是用于处理无法被正常消费的消息的。</p>
<h3 id="2-9-2-死信队列的特征"><a class="header-anchor" href="#2-9-2-死信队列的特征"></a>2.9.2 死信队列的特征</h3>
<p>死信队列具有如下特征：</p>
<p>1、死信队列中的消息不会再被消费者正常消费，即 DLQ 对于消费者是不可见的；</p>
<p>2、死信存储有效期与正常消息相同，均为 3 天（commitlog 文件的过期时间），3 天后会被自动删除；</p>
<p>3、死信队列就是一个特殊的 Topic，名称为 %DLQ%consumerGroup@consumerGroup，即每个消费者组都有一个死信队列；</p>
<p>4、如果⼀个消费者组未产生死信消息，则不会为其创建相应的死信队列。</p>
<h3 id="2-9-3-死信消息的处理"><a class="header-anchor" href="#2-9-3-死信消息的处理"></a>2.9.3 死信消息的处理</h3>
<p>实际上，当⼀条消息进入死信队列，就意味着系统中某些地方出现了问题，从而导致消费者无法正常消费该消息，比如代码中原本就存在 Bug。因此，对于死信消息，通常需要开发人员进行特殊处理。最关键的步骤是要排查可疑因素，解决代码中可能存在的 Bug，然后再将原来的死信消息再次进行投递消费。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mofan212.github.io">默烦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mofan212.github.io/posts/Distributed-Message-Queue-RocketMQ-Part-Two/">https://mofan212.github.io/posts/Distributed-Message-Queue-RocketMQ-Part-Two/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://mofan212.github.io" target="_blank">Mofan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Middleware/">Middleware</a><a class="post-meta__tags" href="/tags/RocketMQ/">RocketMQ</a></div><div class="post-share"><div class="social-share" data-image="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/95.png" data-sites="wechat,qq,weibo,facebook,twitter"></div><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" target="_blank"><img class="post-qr-code-img" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" target="_blank"><img class="post-qr-code-img" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/Design-Pattern-Template-Method-Pattern/" title="【设计模式】模板方法模式"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/94.png" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">【设计模式】模板方法模式</div></div><div class="info-2"><div class="info-item-1">本文主要对 Java 设计模式中的模板方法模式进行了介绍。</div></div></div></a><a class="pagination-related" href="/posts/The-Basics-Of-Linux-Part-One/" title="【上篇】Linux 基础"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/96.png" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">【上篇】Linux 基础</div></div><div class="info-2"><div class="info-item-1">本文介绍了 Linux 中用户管理、实用指令、权限管理、定时任务、网络配置和进程管理等内容。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/Distributed-Message-Queue-RocketMQ-Part-One/" title="【上篇】分布式消息队列 RocketMQ"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/90.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-04</div><div class="info-item-2">【上篇】分布式消息队列 RocketMQ</div></div><div class="info-2"><div class="info-item-1">本文介绍了 RocketMQ 的安装与启动以及围绕它们进行拓展的相关知识点。</div></div></div></a><a class="pagination-related" href="/posts/Install-HBase/" title="HBase的安装"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/9.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-29</div><div class="info-item-2">HBase的安装</div></div><div class="info-2"><div class="info-item-1">本文基于Hadoop 3.2.1 对虚拟机上HBase的安装与安装过程中可能出现的问题进行了讲解。</div></div></div></a><a class="pagination-related" href="/posts/HBase-Shell/" title="HBase Shell操作"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-29</div><div class="info-item-2">HBase Shell操作</div></div><div class="info-2"><div class="info-item-1">本文基于Hadoop 3.2.1 对虚拟机上HBase的Shell操作进行了简单的介绍，但没有涉及过滤器的使用。</div></div></div></a><a class="pagination-related" href="/posts/The-Basis-Of-ElasticSearch/" title="Elasticsearch 入门"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/67.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-18</div><div class="info-item-2">Elasticsearch 入门</div></div><div class="info-2"><div class="info-item-1">本文介绍了 ES 的安装与相关基础知识，在文末实现了一个京东搜索的小 Demo。</div></div></div></a><a class="pagination-related" href="/posts/Advanced-HBase/" title="HBase原理"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-29</div><div class="info-item-2">HBase原理</div></div><div class="info-2"><div class="info-item-1">本文简单介绍了 HBase 的原理包括架构原理、读写流程、读写拓展、数据删除时间等内容。</div></div></div></a><a class="pagination-related" href="/posts/Redis-Cluster-And-Distributed-Locks/" title="Redis 集群与分布式锁"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/102.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-28</div><div class="info-item-2">Redis 集群与分布式锁</div></div><div class="info-2"><div class="info-item-1">本文介绍了 Redis 集群的模拟搭建、故障恢复、利用 Redis 实现简单的分布式锁和 Redis 6 中的新特性。</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">默烦</div><div class="author-info-description">彩笔的打怪升级之路...</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">164</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">36</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mofan212"><i class="fab fa-github"></i><span>follow me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:cy.mofan@foxmail.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站所有博文均是博主的学习笔记与个人理解。<strong><font style="color:red">除特别注明外，</font>如需转载，请在文章头部醒目处附带原文链接并<a href="./mine/" style="color:#49B1F5;text-decoration:underline">告知我</a></strong>你将转载。😊</br><strong><font style="color:red">严禁未遵循规范的转载。</font></strong>😡</br><strong>死去的评论系统复活啦！欢迎到留言板畅所欲言！</strong>当然也可以使用更高效的<a target="_blank" href="https://space.bilibili.com/23658864/dynamic" style="color:#49B1F5;text-decoration:underline"> 哔哩哔哩私信 </a>或<a href="mailto:cy.mofan@foxmail.com" style="color:#49B1F5;text-decoration:underline" target="_blank">邮箱</a>。 😉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-RocketMQ-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">1. RocketMQ 工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%B6%88%E6%81%AF%E7%9A%84%E7%94%9F%E4%BA%A7"><span class="toc-text">1.1 消息的生产</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E6%B6%88%E6%81%AF%E7%9A%84%E7%94%9F%E4%BA%A7%E8%BF%87%E7%A8%8B"><span class="toc-text">1.1.1 消息的生产过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-Queue-%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="toc-text">1.1.2 Queue 选择算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%B6%88%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-text">1.2 消息的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-commitlog-%E6%96%87%E4%BB%B6"><span class="toc-text">1.2.1 commitlog 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-ConsumeQueue"><span class="toc-text">1.2.2 ConsumeQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-text">1.2.3 对文件的读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-%E4%B8%8E-Kafka-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">1.2.4 与 Kafka 的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-indexFile"><span class="toc-text">1.3 indexFile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E7%B4%A2%E5%BC%95%E6%9D%A1%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-text">1.3.1 索引条目结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-indexFile-%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">1.3.2 indexFile 的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B"><span class="toc-text">1.3.3 查询流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9"><span class="toc-text">1.4 消息的消费</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E8%8E%B7%E5%8F%96%E6%B6%88%E8%B4%B9%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.4.1 获取消费类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.4.2 消费模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-Rebalance-%E6%9C%BA%E5%88%B6"><span class="toc-text">1.4.3 Rebalance 机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-4-Queue-%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">1.4.4 Queue 分配算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-5-%E8%87%B3%E5%B0%91%E4%B8%80%E6%AC%A1%E5%8E%9F%E5%88%99"><span class="toc-text">1.4.5 至少一次原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">1.5 订阅关系的一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-%E6%AD%A3%E7%A1%AE%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB"><span class="toc-text">1.5.1 正确订阅关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-%E9%94%99%E8%AF%AF%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB"><span class="toc-text">1.5.2 错误订阅关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-offset-%E7%AE%A1%E7%90%86"><span class="toc-text">1.6 offset 管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-offset-%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.6.1 offset 本地管理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-2-offset-%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.6.2 offset 远程管理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-3-offset-%E7%94%A8%E9%80%94"><span class="toc-text">1.6.3 offset 用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-4-%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97"><span class="toc-text">1.6.4 重试队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-5-offset-%E7%9A%84%E5%90%8C%E6%AD%A5%E6%8F%90%E4%BA%A4%E4%B8%8E%E5%BC%82%E6%AD%A5%E6%8F%90%E4%BA%A4"><span class="toc-text">1.6.5 offset 的同步提交与异步提交</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E6%B6%88%E8%B4%B9%E5%B9%82%E7%AD%89"><span class="toc-text">1.7 消费幂等</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E8%B4%B9%E5%B9%82%E7%AD%89"><span class="toc-text">1.7.1 什么是消费幂等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-2-%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E7%9A%84%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-text">1.7.2 消息重复的场景分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-3-%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">1.7.3 通用解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-4-%E6%B6%88%E8%B4%B9%E5%B9%82%E7%AD%89%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.7.4 消费幂等的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E4%B8%8E%E6%B6%88%E8%B4%B9%E5%BB%B6%E8%BF%9F"><span class="toc-text">1.8 消息堆积与消费延迟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">1.8.1 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-2-%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-text">1.8.2 产生原因分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-3-%E6%B6%88%E8%B4%B9%E8%80%97%E6%97%B6"><span class="toc-text">1.8.3  消费耗时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-4-%E6%B6%88%E8%B4%B9%E5%B9%B6%E5%8F%91%E5%BA%A6"><span class="toc-text">1.8.4 消费并发度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-5-%E5%8D%95%E6%9C%BA%E7%BA%BF%E7%A8%8B%E6%95%B0%E8%AE%A1%E7%AE%97"><span class="toc-text">1.8.5 单机线程数计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-6-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="toc-text">1.8.6 如何避免</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-%E6%B6%88%E6%81%AF%E7%9A%84%E6%B8%85%E7%90%86"><span class="toc-text">1.9 消息的清理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-RocketMQ-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">2. RocketMQ 的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF"><span class="toc-text">2.1 普通消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%88%86%E7%B1%BB"><span class="toc-text">2.1.1 消息发送分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-text">2.1.2 代码举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-text">2.2 顺序消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-text">2.2.1 什么是顺序消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-text">2.2.2 为什么需要顺序消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%9C%89%E5%BA%8F%E6%80%A7%E5%88%86%E7%B1%BB"><span class="toc-text">2.2.3 有序性分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-text">2.2.4 代码举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-text">2.3 延时消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-text">2.3.1 什么是延时消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%BB%B6%E6%97%B6%E7%AD%89%E7%BA%A7"><span class="toc-text">2.3.2 延时等级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">2.3.3 延时消息实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-text">2.3.4 代码举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-text">2.4 事务消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="toc-text">2.4.1 问题引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-text">2.4.2 解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E5%9F%BA%E7%A1%80"><span class="toc-text">2.4.3 基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-XA-%E6%A8%A1%E5%BC%8F%E4%B8%89%E5%89%91%E5%AE%A2"><span class="toc-text">2.4.4 XA 模式三剑客</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-5-XA-%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84"><span class="toc-text">2.4.5 XA 模式架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-6-%E6%B3%A8%E6%84%8F"><span class="toc-text">2.4.6 注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-7-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-text">2.4.7 代码举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF"><span class="toc-text">2.5 批量消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-text">2.5.1 批量发送消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E6%89%B9%E9%87%8F%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-text">2.5.2 批量消费消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-text">2.5.3 代码举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4"><span class="toc-text">2.6 消息过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-Tag-%E8%BF%87%E6%BB%A4"><span class="toc-text">2.6.1 Tag 过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-SQL-%E8%BF%87%E6%BB%A4"><span class="toc-text">2.6.2 SQL 过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-3-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-text">2.6.3 代码举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-text">2.7 消息发送重试机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-1-%E8%AF%B4%E6%98%8E"><span class="toc-text">2.7.1 说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-2-%E5%90%8C%E6%AD%A5%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5"><span class="toc-text">2.7.2 同步发送失败策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-3-%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5"><span class="toc-text">2.7.3 异步发送失败策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-4-%E6%B6%88%E6%81%AF%E5%88%B7%E7%9B%98%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5"><span class="toc-text">2.7.4 消息刷盘失败策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-text">2.8 消息消费重试机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-1-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95"><span class="toc-text">2.8.1 顺序消息的消费重试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-2-%E6%97%A0%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95"><span class="toc-text">2.8.2 无序消息的消费重试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-3-%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0%E4%B8%8E%E9%97%B4%E9%9A%94"><span class="toc-text">2.8.3 消费重试次数与间隔</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-4-%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97"><span class="toc-text">2.8.4 重试队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-5-%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-text">2.8.5 消费重试配置方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-6-%E6%B6%88%E8%B4%B9%E4%B8%8D%E9%87%8D%E8%AF%95%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-text">2.8.6 消费不重试配置方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-text">2.9 死信队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-text">2.9.1 什么是死信队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-2-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">2.9.2 死信队列的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-3-%E6%AD%BB%E4%BF%A1%E6%B6%88%E6%81%AF%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">2.9.3 死信消息的处理</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Git/" title="Git理论与使用"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/3.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Git理论与使用"/></a><div class="content"><a class="title" href="/posts/Git/" title="Git理论与使用">Git理论与使用</a><time datetime="2025-08-26T16:00:00.000Z" title="更新于 2025-08-27 00:00:00">2025-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Lambda-In-Action/" title="Java Lambda In Action"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/159.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Java Lambda In Action"/></a><div class="content"><a class="title" href="/posts/Java-Lambda-In-Action/" title="Java Lambda In Action">Java Lambda In Action</a><time datetime="2025-08-19T16:00:00.000Z" title="更新于 2025-08-20 00:00:00">2025-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Docker-Desktop/" title="Docker Desktop"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/164.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Docker Desktop"/></a><div class="content"><a class="title" href="/posts/Docker-Desktop/" title="Docker Desktop">Docker Desktop</a><time datetime="2025-07-25T16:00:00.000Z" title="更新于 2025-07-26 00:00:00">2025-07-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Quick-Start-With-LangChain4j/" title="LangChain4j 快速入门"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/163.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="LangChain4j 快速入门"/></a><div class="content"><a class="title" href="/posts/Quick-Start-With-LangChain4j/" title="LangChain4j 快速入门">LangChain4j 快速入门</a><time datetime="2025-07-20T16:00:00.000Z" title="更新于 2025-07-21 00:00:00">2025-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Functors-Applicatives-And-Monads-In-Pictures/" title="Functors, Applicatives and Monads In Pictures"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/162.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Functors, Applicatives and Monads In Pictures"/></a><div class="content"><a class="title" href="/posts/Functors-Applicatives-And-Monads-In-Pictures/" title="Functors, Applicatives and Monads In Pictures">Functors, Applicatives and Monads In Pictures</a><time datetime="2025-07-04T16:00:00.000Z" title="更新于 2025-07-05 00:00:00">2025-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/DQL-Of-MySQL/" title="【MySQL 一】DQL"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/105.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="【MySQL 一】DQL"/></a><div class="content"><a class="title" href="/posts/DQL-Of-MySQL/" title="【MySQL 一】DQL">【MySQL 一】DQL</a><time datetime="2025-06-29T16:00:00.000Z" title="更新于 2025-06-30 00:00:00">2025-06-30</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2020 - 2025 By 默烦</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://testingcf.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://testingcf.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://testingcf.jsdelivr.net/npm/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://testingcf.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://npm.elemecdn.com/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources@master/js/mine.min.js"></script><script defer="defer" id="ribbon" src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-show-text" src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Azathoth,Yog-Sothoth,Shub-Niggurath,Nyarlathotep,Cthulhu,Hastur,Abhoth,Ghroth,Tsathoggua,Cthugha,Deep Ones,Dagon,Chaugnar Faugn,Mordiggian,Shoggoth,Old One,Mi-Go,Great Race of Yith,Flying Polyp,Hounds of Tindalos,Dhole" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://testingcf.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'BAFEL7A6K1',
    apiKey: '89fcb5961984c5c054bf04149f345f38',
    indexName: 'mofan212io',
    container: '#docsearch',
    placeholder: '输入关键字进行搜索',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【RPC框架】Dubbo 入门 | Mofan</title><meta name="author" content="默烦,cy.mofan@foxmail.com"><meta name="copyright" content="默烦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文介绍了 Dubbo 基本知识、配置、高可用和原理四个部分的内容。">
<meta property="og:type" content="article">
<meta property="og:title" content="【RPC框架】Dubbo 入门">
<meta property="og:url" content="https://mofan212.github.io/posts/The-Basis-Of-Dubbo/">
<meta property="og:site_name" content="Mofan">
<meta property="og:description" content="本文介绍了 Dubbo 基本知识、配置、高可用和原理四个部分的内容。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/69.png">
<meta property="article:published_time" content="2020-11-23T16:00:00.000Z">
<meta property="article:modified_time" content="2020-12-13T16:00:00.000Z">
<meta property="article:author" content="默烦">
<meta property="article:tag" content="Dubbo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/69.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【RPC框架】Dubbo 入门",
  "url": "https://mofan212.github.io/posts/The-Basis-Of-Dubbo/",
  "image": "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/69.png",
  "datePublished": "2020-11-23T16:00:00.000Z",
  "dateModified": "2020-12-13T16:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "默烦",
      "url": "https://mofan212.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/favicon.png"><link rel="canonical" href="https://mofan212.github.io/posts/The-Basis-Of-Dubbo/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 默烦","link":"链接: ","source":"来源: Mofan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://testingcf.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【RPC框架】Dubbo 入门',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><link rel="stylesheet" href="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources@master/css/myStyle.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css" /><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" /><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Mofan" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources/css/minimal.min.css"/><script src="https://testingcf.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">174</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/reward/"><i class="fa-fw fa-solid fa-coins"></i><span> 赞助</span></a></li><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/post_top_img.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Mofan</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/reward/"><i class="fa-fw fa-solid fa-coins"></i><span> 赞助</span></a></li><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【RPC框架】Dubbo 入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-23T16:00:00.000Z" title="发表于 2020-11-24 00:00:00">2020-11-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-13T16:00:00.000Z" title="更新于 2020-12-14 00:00:00">2020-12-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Microservice/">Microservice</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Microservice/Dubbo/">Dubbo</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">13.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;距离本文上次更新已经过去&quot;,&quot;messageNext&quot;:&quot;天，请注意时效性。&quot;,&quot;postUpdate&quot;:&quot;2020-12-14 00:00:00&quot;}" hidden></div><p>封面来源：碧蓝航线 铁血、音符 &amp; 誓言 活动CG</p>
<p>本文参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ns411c7jV">尚硅谷Dubbo教程(dubbo经典之作) 雷丰阳老师主讲</a></p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/">Dubbo 官方文档</a></p>
<h1 id="1-基本知识"><a class="header-anchor" href="#1-基本知识"></a>1. 基本知识</h1>
<h2 id="1-1-分布式基础理论"><a class="header-anchor" href="#1-1-分布式基础理论"></a>1.1 分布式基础理论</h2>
<blockquote>
<p>什么是分布式系统</p>
</blockquote>
<p>《分布式系统原理与范型》定义：</p>
<p>“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”。</p>
<p>分布式系统（distributed system）是建立在网络之上的软件系统。</p>
<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</p>
<blockquote>
<p>发展演变</p>
</blockquote>
<p>Dubbo官网背景介绍：<a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh/docs/v2.7/user/preface/background/">背景</a></p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/%E5%8F%91%E5%B1%95%E6%BC%94%E5%8F%98.jpg" alt="发展演变"></p>
<p><strong>单一应用架构</strong></p>
<p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架（ORM）是关键。</p>
<p><strong>垂直应用架构</strong></p>
<p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web 框架（MVC）是关键。</p>
<p>这种模式下存在以下问题：</p>
<p>1、界面和业务逻辑无法实现分离</p>
<p>2、应用不可能完全独立，大量的应用之间需要交互</p>
<p><strong>分布式服务架构</strong></p>
<p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。 <mark>此时，用于提高业务复用及整合的分布式服务框架（RPC）是关键。</mark></p>
<p><strong>流动计算架构</strong></p>
<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心（SOA）是关键。</p>
<blockquote>
<p>RPC</p>
</blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/swordfall/p/8683905.html">RPC原理解析</a>   、  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/LBSer/p/4853234.html">你应该知道的RPC原理</a></p>
<p>RPC【Remote Procedure Call】：远程过程调用，是一种进程间通信方式，是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>
<p>也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数或方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p>
<p>为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数。</p>
<p>RPC的两个核心模块：通讯、序列化。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/RPC%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.jpg" alt="RPC调用过程"></p>
<p>RPC步骤时序图：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/RPC%E6%AD%A5%E9%AA%A4%E8%A7%A3%E6%9E%90.png" alt="RPC步骤解析"></p>
<p>1、客户端（client）以本地调用方式（即以接口的方式）调用服务；</p>
<p>2、客户端存根（client stub）接收到调用后，负责将方法、参数等组装成能够进行网络传输的消息体（将消息体对象序列化为二进制）；</p>
<p>3、客户端通过 sockets 将消息发送到服务端；</p>
<p>4、服务端存根（server stub）收到消息后进行解码（将消息对象反序列化）；</p>
<p>5、服务端存根（server stub）根据解码结果调用本地的服务；</p>
<p>6、本地服务执行并将结果返回给服务端存根（server stub）；</p>
<p>7、服务端存根( server stub）将返回结果打包成消息（将结果消息对象序列化）；</p>
<p>8、服务端（server）通过 sockets 将消息发送到客户端；</p>
<p>9、客户端存根（client stub）接收到结果消息，并进行解码（将结果消息发序列化）；</p>
<p>10、客户端（client）得到最终结果。</p>
<p>RPC 的目标是要把 2、3、4、7、8、9 这些步骤都封装起来。</p>
<p>注意：无论是何种类型的数据，最终都需要转换成二进制流在网络上进行传输，数据的发送方需要将对象转换为二进制流，而数据的接收方则需要把二进制流再恢复为对象。</p>
<p><strong>影响一个 RPC 框架的性能有两点：</strong></p>
<p>1、能否快速在各个服务器之间建立起连接</p>
<p>2、能否快速序列化与反序列化</p>
<p>市面上的 RPC 框架有很多，比如：Dubbo、gRPC、Thrift、HSF（High Speed Service Framework）等。</p>
<h2 id="1-2-Dubbo-基本概念"><a class="header-anchor" href="#1-2-Dubbo-基本概念"></a>1.2 Dubbo 基本概念</h2>
<p>Dubbo |ˈdʌbəʊ| 官网：<a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh/">Dubbo</a></p>
<p>Dubbo 提供了六大核心能力：面向接口代理的高性能RPC调用，智能容错和负载均衡，服务自动注册和发现，高度可扩展能力，运行期流量调度，可视化的服务治理与运维。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/Dubbo%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88.png" alt="Dubbo特性一览"></p>
<p>Dubbo 的设计架构：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/Dubbo%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84.png" alt="Dubbo设计架构"></p>
<p><strong>服务提供者（Provider）</strong> ：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p><strong>服务消费者（Consumer）</strong> ：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p><strong>注册中心（Registry）</strong>：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p>
<p><strong>监控中心（Monitor）</strong> ：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p>
<h2 id="1-3-Dubbo-与注册中心"><a class="header-anchor" href="#1-3-Dubbo-与注册中心"></a>1.3 Dubbo 与注册中心</h2>
<p>为什么要使用 Dubbo？或者说 Dubbo 是为了解决什么呢？</p>
<p>在分布式服务架构里，A 服务器上的程序想要调用 B 服务器上的一段代码，就需要进行远程过程调用。不同服务之间如何进行通信、如何传递数据、如何调用？这就需要用到 Dubbo，而不需要我们自己解决。</p>
<p>Dubbo 可以实现服务自动注册与发现，这是什么意思呢？</p>
<p>假设网站规模已经变得很大，用户业务在服务器 1 号、2 号、3 号和 4 号上，支付业务在服务器 9 号、10 号 和 11 号。这时候前端订单 web 想要调用支付业务，那么 RPC 框架怎么知道支付业务在哪些服务器上呢？又或者，9 号服务器突然炸了，但是要调用支付业务，RPC 框架又要怎么自动发现出问题的服务器呢？</p>
<p>我们可以引入一种机制——注册中心！</p>
<p>为了能够动态感知到各个服务的状态，我们可以将所有服务都注册到注册中心里，也包括前端的程序。这个时候注册中心就相当于维护了一个清单，这个清单里有每个服务的信息（比如这些服务都在哪些服务器上）。</p>
<p>假设支付业务所在的 9 号服务器炸了，那么注册中心就会更改支付业务的信息。当需要调用支付业务时，Dubbo（或者说 RPC 框架）就要先问下注册中心，支付业务都在哪些服务器上啊。注册中心一看服务清单，就告诉 RPC 框架，这时候支付业务处在 10 号和 11 号服务器上。这时候，RPC 框架就会随机选择 10 号或 11 号服务器，或者根据负载均衡选择一个请求量较小的服务器，与这个服务器建立通信，传递数据，进行远程调用（我们可以把注册中心当成现实生活中的婚介网或者婚介所）。</p>
<hr>
<p>为了使用 Dubbo，我们得先安装一个注册中心，Dubbo 支持的注册中心有很多，我们在此选择 ZooKeeper 作为注册中心。</p>
<p><mark>具体使用与整合 SpringBoot 参考【SpringBoot 高级应用】一文。</mark></p>
<p>简单来说，使用了 Dubbo 可以利用接口在一个 Module 中调用另一个 Module 的接口实现类的方法。在项目部署后，这两个 Module 很有可能会在两个服务器上。</p>
<h1 id="2-Dubbo-配置"><a class="header-anchor" href="#2-Dubbo-配置"></a>2. Dubbo 配置</h1>
<h2 id="2-1-配置文件覆盖策略"><a class="header-anchor" href="#2-1-配置文件覆盖策略"></a>2.1 配置文件覆盖策略</h2>
<p>在使用 Dubbo 时，需要进行一些配置，这些配置都书写在配置文件中，但是具体可以书写哪些配置标签，这些标签又有什么用，标签内又有哪些属性，可以参考官方文档。</p>
<p>在官方文档中，有【配置】和【Schema 配置参考手册】 两栏，在这两栏中就可以看到相关的配置和配置解释。</p>
<p>在官方文档的【Dubbo 配置】中，有名为【属性配置】的一栏，可以看到 Dubbo 配置文件的覆盖策略（重写与优先级）：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/Dubbo%E9%85%8D%E7%BD%AE%E8%A6%86%E7%9B%96%E7%AD%96%E7%95%A5.jpg" alt="Dubbo配置覆盖策略"></p>
<p>优先级从高到低：</p>
<ul>
<li>JVM -D 参数：当你部署或者启动应用时，它可以轻易地重写配置，比如，改变 Dubbo 协议端口；</li>
<li>XML：XML 中的当前配置会重写 dubbo.properties 中的；</li>
<li>Properties：默认配置，仅仅作用于以上两者没有配置时。</li>
</ul>
<p>1、如果在 classpath 下有超过一个 dubbo.properties 文件，比如，两个 jar 包都各自包含了 dubbo.properties，dubbo 将随机选择一个加载，并且打印错误日志。</p>
<p>2、如果 <code>id</code> 没有在 <code>protocol</code> 中配置，将使用 <code>name</code> 作为默认属性。</p>
<h2 id="2-2-启动检查"><a class="header-anchor" href="#2-2-启动检查"></a>2.2 启动检查</h2>
<p>在开发中，会有一个服务提供者，还有一个服务消费者，它们都会被注册到注册中心中，消费者会从注册中心中获取提供者的调用地址。那如果注册中心中没有提供者，但是启动了消费者，那么启动期间消费者 <strong>默认</strong> 就会报错，消费者会发现它需要的服务不在注册中心中。</p>
<p>在官方文档中，【用法示例】有一栏名为【启动时检查】。</p>
<p>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，<strong>默认</strong> <code>check=&quot;true&quot;</code>，将开启检查。</p>
<p>也可以通过 <code>check=&quot;false&quot;</code> 关闭检查。比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。</p>
<p>在 SpringBoot 中可以这样配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo.reference.check</span>=<span class="string">false </span></span><br><span class="line"><span class="attr">dubbo.consumer.check</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">dubbo.registry.check</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>
<p><code>dubbo.reference.check=false</code>，强制改变所有 reference 的 check 值，就算配置中有声明，也会被覆盖。</p>
<p><code>dubbo.consumer.check=false</code>，是设置 check 的缺省值，如果配置中有显式的声明，如：<code>&lt;dubbo:reference check=&quot;true&quot;/&gt;</code>，不会受影响。</p>
<p><code>dubbo.registry.check=false</code>，前面两个都是指订阅成功，但提供者列表是否为空是否报错，如果注册订阅失败时，也允许启动，需使用此选项，将在后台定时重试。简单来说，就是检查注册中心，如果设置为 false，就算没有注册中心也不会报错，等到注册中心启动了，就会连接上注册中心。</p>
<h2 id="2-3-超时设置"><a class="header-anchor" href="#2-3-超时设置"></a>2.3 超时设置</h2>
<p>服务消费者在引用服务提供方时，可能由于网络等原因，服务提供方执行一个方法用了很长时间，导致大量线程都在此阻塞，就会引起性能下降。为了解决这个问题，我们可以指定超时设置 <code>timeout</code>。</p>
<p>指定了超时设置后，一个方法在指定的时间内没有返回，那么就会终止方法，不让线程大量阻塞。</p>
<p>超时设置的单位是毫秒。</p>
<p>在官方文档中，可以查看【schema 参考配置手册】，在 <code>&lt;dubbo:reference&gt;</code> 中的 <code>timeout</code> 属性是可选的，默认使用 <code>&lt;dubbo:consumer&gt;</code> 的 <code>timeout</code>。而 <code>&lt;dubbo:consumer&gt;</code> 的 <code>timeout</code> <strong>默认值</strong> 是 1000 毫秒，也就是 1 秒。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/consumer%E7%9A%84timeout%E9%BB%98%E8%AE%A4%E5%80%BC.png" alt="consumer的timeout默认值"></p>
<p>与启动检查一样，在 SpringBoot 中可以这样配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo.consumer.timeout</span>=<span class="string">3000</span></span><br><span class="line"><span class="attr">dubbo.registry.timeout</span>=<span class="string">3000</span></span><br><span class="line"><span class="attr">dubbo.provider.timeout</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure>
<p>如果需要配置某个接口的超时设置，可以配置 <code>@Reference</code> 的 <code>timeout</code> 属性。</p>
<hr>
<p>为了便于了解，可以看下 XML 中不同粒度配置的覆盖关系。</p>
<p>以 timeout 为例，下图显示了配置的查找顺序，其它 retries、loadbalance、actives 等类似：</p>
<ul>
<li>方法级优先，接口级次之，全局配置再次之。</li>
<li>如果级别一样，则消费方优先，提供方次之（顾客是上帝 😋）。</li>
</ul>
<p>其中，服务提供方配置，通过 URL 经由注册中心传递给消费方。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/XML%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%B2%92%E5%BA%A6%E9%85%8D%E7%BD%AE%E7%9A%84%E8%A6%86%E7%9B%96%E5%85%B3%E7%B3%BB.jpg" alt="XML中不同粒度配置的覆盖关系"></p>
<p>关于覆盖关系，简单来说就两点：精确优先和消费者优先。</p>
<p>官方文档建议由服务提供方设置超时，因为一个方法需要执行多长时间，服务提供方更清楚，如果一个消费方同时引用多个服务，就不需要关心每个服务的超时设置。</p>
<p>理论上 ReferenceConfig 中除了 <code>interface</code> 这一项，其他所有配置项都可以缺省不配置，框架会自动使用 ConsumerConfig、ServiceConfig、ProviderConfig 等提供的缺省配置。</p>
<h2 id="2-4-重试次数"><a class="header-anchor" href="#2-4-重试次数"></a>2.4 重试次数</h2>
<p>前面说了超时设置，超时设置一般会与重试次数搭配使用。</p>
<p>当某个服务由于各种原因，比如网络原因，导致了超时，造成远程调用失败，可以通过设置重试次数来多尝试几次。</p>
<p><code>retries</code> 属性表示远程服务调用重试次数，不包括第一次调用，不需要重试就设置为0，仅在 cluster 为 failback / failover时有效。</p>
<p>在官方文档中，可以查看【schema 参考配置手册】，在 <code>&lt;dubbo:reference&gt;</code> 中的 <code>retries</code> 属性是可选的，默认使用 <code>&lt;dubbo:consumer&gt;</code> 的 <code>retries</code>。而 <code>&lt;dubbo:consumer&gt;</code> 的 <code>retries</code> <strong>默认值</strong> 是 2。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/consumer%E7%9A%84retries%E9%BB%98%E8%AE%A4%E5%80%BC.png" alt="consumer的retries默认值"></p>
<p>如果设置 <code>retries = 3</code>，假设第一次调用超时了，那么 <strong>还会</strong> 尝试调用 3 次。</p>
<p>假设某一业务的服务提供者有 3 个，且设置了超时，并将重试次数设置为 3。服务消费者在调用提供者的方法时产生了超时，服务消费者不会在某一个服务提供者上“吊死”，会尝试其他几个服务提供者。</p>
<p>一般来说，我们会在幂等操作的方法上设置重试次数，而不会在非幂等操作的方法上设置重试次数。</p>
<p>那么什么是幂等，什么又是非幂等？</p>
<p>所谓幂等，就是 <strong>就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的</strong>，比如查询、删除、修改。</p>
<p>而非幂等就是一个操作，每执行一次，都会产生新的效果或返回新的结果，比如添加。</p>
<p>那要怎么实现幂等呢？可以使用 MVCC 方案、去重表、悲观锁、token 机制、全局唯一 ID 等方法，具体就不在此讨论了。</p>
<h2 id="2-5-多版本"><a class="header-anchor" href="#2-5-多版本"></a>2.5 多版本</h2>
<p>当某一个接口出现了不兼容的升级， 我们不能让系统的所有用户都用上新功能，因为新功能很有可能不稳定，进而导致整个系统不稳定。</p>
<p>可以让系统的一部分用户先用上新功能，另一部分用户仍然使用功能的老版本，当新功能的版本都稳定了，才将另一部分用户使用的老版本全部替换成新版本。</p>
<p>这也叫作灰度发布，百度百科对【灰度发布】是这样介绍的：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83.png" alt="百度百科灰度发布"></p>
<p>在 Dubbo 中，需要使用 <code>version</code> 来指定版本。官方文档是这么使用的：</p>
<p>老版本服务提供者配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>新版本服务提供者配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.0.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>老版本服务消费者配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;barService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>新版本服务消费者配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;barService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.0.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 Dubbo 2.2.0 以上版本，可以指定随机使用版本：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;barService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;*&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 SpringBoot 中，可以配置 <code>@Reference</code> 注解的 <code>version</code> 属性值。</p>
<h2 id="2-6-本地存根"><a class="header-anchor" href="#2-6-本地存根"></a>2.6 本地存根</h2>
<p>官方文档如是说：</p>
<p>远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/stub.jpg" alt="stub"></p>
<p>简单来说：消费者利用接口调用提供者的方法前，想进行一些其他操作，比如判断某些值是否符合条件，当符合条件时才调用提供者的方法，不符合条件又有另一套逻辑，这就需要用到本地存根。</p>
<p>那要怎么实现本地存根呢？</p>
<p>首先需要在编写接口的实现方法，在实现方法内要提供一个构造方法，比如像官方文档中一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.foo;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BarServiceStub</span> <span class="keyword">implements</span> <span class="title class_">BarService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BarService barService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数传入真正的远程代理对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BarServiceStub</span><span class="params">(BarService barService)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.barService = barService;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// 此代码在客户端执行, 你可以在客户端做 ThreadLocal 本地缓存，或预先验证参数是否合法，等等</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> barService.sayHello(name); <span class="comment">// 调用代理对象的方法</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 你可以容错，可以做任何AOP拦截事项</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;容错数据&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后还需要进行配置，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">stub</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">stub</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 SpringBoot 中，可以配置 <code>@Reference</code> 注解的 <code>stub</code> 属性值。</p>
<h2 id="2-7-整合-SpringBoot-的方式"><a class="header-anchor" href="#2-7-整合-SpringBoot-的方式"></a>2.7 整合 SpringBoot 的方式</h2>
<p>首先是【SpringBoot 高级应用】一文中采用的方法：导入 dubbo-starter，在 application.properties 中配置属性，使用 <code>@Service</code> 注解暴露服务，使用 <code>@Reference</code> 注解引用服务。</p>
<p>如果想要做到方法级别的精确配置，还可以继续使用 dubbo.xml，这时候就不在 application.properties 配置文件中进行配置，也不需要使用 <code>@Service</code> 注解，但是需要在主启动类上使用注解 <code>@ImportResource</code> 导入 dubbo.xml 配置文件。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ImportResource(locations = &quot;classpath:provider.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerServerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConsumerServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了以上两种方式外，还可以使用注解 API，简单来说就是编写配置类，然后将每一个组件手动创建到容器中。可以参考官方文档中【配置】一栏中的【注解配置】。</p>
<h1 id="3-高可用"><a class="header-anchor" href="#3-高可用"></a>3. 高可用</h1>
<h2 id="3-1-ZK-宕机与-Dubbo-直连"><a class="header-anchor" href="#3-1-ZK-宕机与-Dubbo-直连"></a>3.1 ZK 宕机与 Dubbo 直连</h2>
<p>现象：ZooKeeper 注册中心宕机，还可以消费 Dubbo 暴露的服务。</p>
<p>原因：</p>
<p>1、健壮性：</p>
<ul>
<li>
<p>监控中心宕掉不影响使用，只是丢失部分采样数据</p>
</li>
<li>
<p>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</p>
</li>
<li>
<p>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</p>
</li>
<li>
<p><mark>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</mark></p>
</li>
<li>
<p>服务提供者无状态，任意一台宕掉后， 不影响使用</p>
</li>
<li>
<p>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</p>
</li>
</ul>
<p>2、高可用：通过设计，减少系统不能提供服务的时间</p>
<hr>
<p>其实在使用时，可以绕过注册中心，直接使用 Dubbo 直连。也就是说，没有注册中心，Dubbo 调用也是没有问题的。</p>
<p>直连配置也很简单，只需要在  注解上进行配置 url 属性值即可，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference(url = &quot;127.0.0.1:20882&quot;)</span></span><br><span class="line">TicketService ticketService;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-负载均衡机制"><a class="header-anchor" href="#3-2-负载均衡机制"></a>3.2 负载均衡机制</h2>
<p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p>
<blockquote>
<p>负载均衡策略</p>
</blockquote>
<p><strong>Random LoadBalance</strong></p>
<p>随机，按权重设置随机概率。</p>
<p>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/Random-LoadBalance.png" alt="Random-LoadBalance" style="zoom:67%;" />
<p><strong>RoundRobin LoadBalance</strong></p>
<p>轮循，按公约后的权重设置轮循比率。</p>
<p>存在慢的提供者累积请求的问题。比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/RoundRobin-LoadBalance.png" alt="RoundRobin-LoadBalance" style="zoom:67%;" />
<p><strong>LeastActive LoadBalance</strong></p>
<p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</p>
<p>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/LeastActive-LoadBalance.png" alt="LeastActive-LoadBalance" style="zoom:67%;" />
<p><strong>ConsistentHash LoadBalance</strong></p>
<p>一致性 Hash，相同参数的请求总是发到同一提供者。<br>
当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing</p>
<p>缺省只对第一个参数 Hash，如果要修改，请配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">&quot;hash.arguments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0, 1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>缺省用 160 份虚拟节点，如果要修改，请配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">&quot;hash.nodes&quot;</span> <span class="attr">value</span>=<span class="string">&quot;320&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/ConsistentHash-LoadBalance.png" alt="ConsistentHash-LoadBalance" style="zoom:67%;" />
<p>Dubbo <strong>默认</strong> 采用的是基于权重的 <strong>随机</strong> 负载均衡机制。</p>
<p>我们搜索 <code>LoadBalance</code> 接口，可以看到 <code>@SPI</code> 接口，就明白了默认采用的什么策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;random&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadBalance</span> &#123;</span><br><span class="line">    <span class="meta">@Adaptive(&#123;&quot;loadbalance&quot;&#125;)</span></span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; var1, URL var2, Invocation var3)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搜索 <code>LoadBalance</code> 接口的实现类，可以看到一个名为 <code>AbstractLoadBalance</code> 的抽象类，再看这个抽象类的子类，就可以看到四种负载均衡机制：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/%E5%9B%9B%E7%A7%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5.png" alt="四种负载均衡策略"></p>
<p>如果想要修改 Dubbo 的负载均衡策略，可以参考官方文档【用法示例】的【负载均衡】：</p>
<p><strong>服务端服务级别</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>客户端服务级别</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>服务端方法级别</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>客户端方法级别</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 SpringBoot 中，可以设置 <code>@Reference</code> 或 <code>@Service</code> 注解的 <code>loadbalance</code> 属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference(loadbalance = &quot;roundrobin&quot;)</span></span><br></pre></td></tr></table></figure>
<h2 id="3-3-服务降级"><a class="header-anchor" href="#3-3-服务降级"></a>3.3 服务降级</h2>
<blockquote>
<p>什么是服务降级</p>
</blockquote>
<p>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</p>
<p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。</p>
<p>官方文档有：</p>
<p>向注册中心写入动态配置覆盖规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RegistryFactory</span> <span class="variable">registryFactory</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> registryFactory.getRegistry(URL.valueOf(<span class="string">&quot;zookeeper://10.20.153.10:2181&quot;</span>));</span><br><span class="line">registry.register(URL.valueOf(<span class="string">&quot;override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<p>1、<code>mock=force:return+null</code> 表示消费方对该服务的方法调用都直接返回 <code>null</code> 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。（屏蔽）</p>
<p>2、还可以改为 <code>mock=fail:return+null</code> 表示消费方对该服务的方法调用在失败后，再返回 <code>null</code> 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。（容错）</p>
<p>以上两种可以在 dubbo-admin 中服务治理的消费者中对服务进行设置。</p>
<p>服务降级在 <code>2.2.0</code> 以上版本支持。</p>
<h2 id="3-4-服务容错"><a class="header-anchor" href="#3-4-服务容错"></a>3.4 服务容错</h2>
<p>当集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>
<blockquote>
<p>集群容错模式</p>
</blockquote>
<p><strong>Failover Cluster</strong></p>
<p>失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 <code>retries=&quot;2&quot;</code> 来设置重试次数（不含第一次）。该配置为缺省配置。</p>
<p>重试次数配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;findFoo&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>Failfast Cluster</strong></p>
<p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p>
<p><strong>Failsafe Cluster</strong></p>
<p>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p>
<p><strong>Failback Cluster</strong></p>
<p>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p>
<p><strong>Forking Cluster</strong></p>
<p>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 <code>forks=&quot;2&quot;</code> 来设置最大并行数。</p>
<p><strong>Broadcast Cluster</strong></p>
<p>广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>
<p>服务容错在 <code>2.1.0</code> 开始支持。</p>
<blockquote>
<p>集群模式配置</p>
</blockquote>
<p>按照以下示例在服务提供方和消费方配置集群模式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">&quot;failsafe&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">&quot;failsafe&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-5-Hystrix"><a class="header-anchor" href="#3-5-Hystrix"></a>3.5 Hystrix</h2>
<p>要实现服务容错，我们一般与 Hystrix 进行整合。</p>
<p>Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix 具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以<br>
及监控和配置等功能。</p>
<p>1、配置 <em>spring-cloud-starter-netflix-hystrix</em></p>
<p>SpringBoot 官方提供了对 Hystrix 的集成，直接在 pom.xml 里加入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupld</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupld</span>&gt;</span>v</span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactld</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactld</span>&gt;</span>v</span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在 Application 类上增加 <code>@EnableHystrix</code> 来启用hystrix starter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderApplication</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>2、配置 Provider 端</p>
<p>在 Dubbo 的 Provider （服务提供者实现类的方法）上增加 <code>@HystrixCommand</code> 配置，这样子调用就会经过 Hystrix 代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(version = &quot;1.0.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="meta">@HystrixCommand(commandProperties = &#123;</span></span><br><span class="line"><span class="meta">     @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;),</span></span><br><span class="line"><span class="meta">     @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;2000&quot;) &#125;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;async provider received: &quot; + name);</span></span><br><span class="line">        <span class="comment">// return &quot;annotation: hello, &quot; + name;</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception to show hystrix enabled.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、在服务消费者调用服务提供者的方法上添加 <code>@HystrixCommand</code> 注解并指定 <code>fallbackMethod</code> 属性，重写 <code>fallbackMethod</code> 指定的方法。这样当出现服务容错时，就会调用指定的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference(version = &quot;1.0.0&quot;)</span></span><br><span class="line"><span class="keyword">private</span> HelloService demoService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;reliable&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doSayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reliable</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hystrix fallback value&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-Dubbo-原理"><a class="header-anchor" href="#4-Dubbo-原理"></a>4. Dubbo 原理</h1>
<h2 id="4-1-RPC-和-Netty-原理"><a class="header-anchor" href="#4-1-RPC-和-Netty-原理"></a>4.1 RPC 和 Netty 原理</h2>
<blockquote>
<p>RPC 原理</p>
</blockquote>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/RPC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png" alt="RPC基本原理"></p>
<p>1、客户端（client）以本地调用方式（即以接口的方式）调用服务；</p>
<p>2、客户端存根（client stub）接收到调用后，负责将方法、参数等组装成能够进行网络传输的消息体（将消息体对象序列化为二进制）；</p>
<p>3、客户端通过 sockets 将消息发送到服务端；</p>
<p>4、服务端存根( server stub）收到消息后进行解码（将消息对象反序列化）；</p>
<p>5、服务端存根( server stub）根据解码结果调用本地的服务；</p>
<p>6、本地服务执行并将结果返回给服务端存根( server stub）；</p>
<p>7、服务端存根( server stub）将返回结果打包成消息（将结果消息对象序列化）；</p>
<p>8、服务端（server）通过 sockets 将消息发送到客户端；</p>
<p>9、客户端存根（client stub）接收到结果消息，并进行解码（将结果消息发序列化）；</p>
<p>10、客户端（client）得到最终结果。</p>
<p>RPC的目标是要把 2、3、4、7、8、9 这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</p>
<blockquote>
<p>Netty 通信原理</p>
</blockquote>
<p>Netty 是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。它极大地简化并简化了 TCP 和 UDP 套接字服务器等网络编程。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/aeolian/p/10773786.html">Java中BIO和NIO</a></p>
<p>BIO（Blocking IO）：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/BIO.png" alt="BIO"></p>
<p>NIO（Non-Blocking IO）：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/NIO.png" alt="NIO"></p>
<p>Selector 一般称为选择器，也可以翻译为多路复用器。</p>
<p>Connect（连接就绪）、Accept（接受就绪）、Read（读就绪）、Write （写就绪）</p>
<p>Netty 基本原理：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/Netty%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png" alt="Netty基本原理"></p>
<h2 id="4-2-框架设计"><a class="header-anchor" href="#4-2-框架设计"></a>4.2 框架设计</h2>
<p>在官方文档的【开发指南】的【框架设计】一栏中，有这样一幅图：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/dubbo-framework.jpg" alt="dubbo-framework"></p>
<p>这幅图就很好的解释了 Dubbo 的整体设计。</p>
<p>官方文档对这幅图也做了很好的解释：</p>
<ul>
<li>图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。</li>
<li>图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。</li>
<li>图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。</li>
<li>图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。</li>
</ul>
<blockquote>
<p>各层说明</p>
</blockquote>
<ul>
<li><strong>config 配置层</strong>：对外配置接口，以 <code>ServiceConfig</code>, <code>ReferenceConfig</code> 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>
<li><strong>proxy 服务代理层</strong>：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 <code>ServiceProxy</code> 为中心，扩展接口为 <code>ProxyFactory</code></li>
<li><strong>registry 注册中心层</strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 <code>RegistryFactory</code>, <code>Registry</code>, <code>RegistryService</code></li>
<li><strong>cluster 路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 <code>Invoker</code> 为中心，扩展接口为 <code>Cluster</code>, <code>Directory</code>, <code>Router</code>, <code>LoadBalance</code></li>
<li><strong>monitor 监控层</strong>：RPC 调用次数和调用时间监控，以 <code>Statistics</code> 为中心，扩展接口为 <code>MonitorFactory</code>, <code>Monitor</code>, <code>MonitorService</code></li>
<li><strong>protocol 远程调用层</strong>：封装 RPC 调用，以 <code>Invocation</code>, <code>Result</code> 为中心，扩展接口为 <code>Protocol</code>, <code>Invoker</code>, <code>Exporter</code></li>
<li><strong>exchange 信息交换层</strong>：封装请求响应模式，同步转异步，以 <code>Request</code>, <code>Response</code> 为中心，扩展接口为 <code>Exchanger</code>, <code>ExchangeChannel</code>, <code>ExchangeClient</code>, <code>ExchangeServer</code></li>
<li><strong>transport 网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 <code>Message</code> 为中心，扩展接口为 <code>Channel</code>, <code>Transporter</code>, <code>Client</code>, <code>Server</code>, <code>Codec</code></li>
<li><strong>serialize 数据序列化层</strong>：可复用的一些工具，扩展接口为 <code>Serialization</code>, <code>ObjectInput</code>, <code>ObjectOutput</code>, <code>ThreadPool</code></li>
</ul>
<p>以上内容均摘自 Dubbo 官方文档【开发指南】的【框架设计】一栏，其他信息可以参考官方文档。</p>
<h2 id="4-3-标签解析"><a class="header-anchor" href="#4-3-标签解析"></a>4.3 标签解析</h2>
<p>标签解析简单来说就是配置文件（XML）的解析。</p>
<p>这个配置文件也是 Spring 的配置文件，启动的时候也是以 Spring 的方式来加载启动。Spring 在解析配置文件的标签时，都会用到一个主接口 <code>BeanDefinitionParser</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinitionParser</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    BeanDefinition <span class="title function_">parse</span><span class="params">(Element var1, ParserContext var2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看下这个接口的继承树，可以看到这样一个实现类 <code>DubboBeanDefinitionParser</code>：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/DubboBeanDefinitionParser.png" alt="DubboBeanDefinitionParser"></p>
<p>这个类就是 Dubbo 的标签解析器，在这个类中，有一个名为 <code>parse()</code> 的方法，这个方法就是用来解析标签的。</p>
<p>在解析不同的标签时，参数 <code>beanClass</code> 传入的值也不一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, </span></span><br><span class="line"><span class="params">                                    ParserContext parserContext, </span></span><br><span class="line"><span class="params">                                    Class&lt;?&gt; beanClass, <span class="type">boolean</span> required)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那为什么会这样呢？</p>
<p><code>DubboBeanDefinitionParser</code> 类有一个构造方法，构造方法有一个参数就是 <code>beanClass</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DubboBeanDefinitionParser</span><span class="params">(Class&lt;?&gt; beanClass, <span class="type">boolean</span> required)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.beanClass = beanClass;</span><br><span class="line">    <span class="built_in">this</span>.required = required;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那这个构造方法是怎么执行的呢？</p>
<p>在 <code>DubboNamespaceHandler</code> 类中执行一个初始化 <code>init()</code> 方法，真是因为执行了这个初始化方法，才导致 <code>beanClass</code> 参数的多样性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboNamespaceHandler</span> <span class="keyword">extends</span> <span class="title class_">NamespaceHandlerSupport</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DubboNamespaceHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;application&quot;</span>, <span class="keyword">new</span> <span class="title class_">DubboBeanDefinitionParser</span>(ApplicationConfig.class, <span class="literal">true</span>));</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;module&quot;</span>, <span class="keyword">new</span> <span class="title class_">DubboBeanDefinitionParser</span>(ModuleConfig.class, <span class="literal">true</span>));</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;registry&quot;</span>, <span class="keyword">new</span> <span class="title class_">DubboBeanDefinitionParser</span>(RegistryConfig.class, <span class="literal">true</span>));</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;config-center&quot;</span>, <span class="keyword">new</span> <span class="title class_">DubboBeanDefinitionParser</span>(ConfigCenterBean.class, <span class="literal">true</span>));</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;metadata-report&quot;</span>, <span class="keyword">new</span> <span class="title class_">DubboBeanDefinitionParser</span>(MetadataReportConfig.class, <span class="literal">true</span>));</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;monitor&quot;</span>, <span class="keyword">new</span> <span class="title class_">DubboBeanDefinitionParser</span>(MonitorConfig.class, <span class="literal">true</span>));</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;metrics&quot;</span>, <span class="keyword">new</span> <span class="title class_">DubboBeanDefinitionParser</span>(MetricsConfig.class, <span class="literal">true</span>));</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;provider&quot;</span>, <span class="keyword">new</span> <span class="title class_">DubboBeanDefinitionParser</span>(ProviderConfig.class, <span class="literal">true</span>));</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;consumer&quot;</span>, <span class="keyword">new</span> <span class="title class_">DubboBeanDefinitionParser</span>(ConsumerConfig.class, <span class="literal">true</span>));</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;protocol&quot;</span>, <span class="keyword">new</span> <span class="title class_">DubboBeanDefinitionParser</span>(ProtocolConfig.class, <span class="literal">true</span>));</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;service&quot;</span>, <span class="keyword">new</span> <span class="title class_">DubboBeanDefinitionParser</span>(ServiceBean.class, <span class="literal">true</span>));</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;reference&quot;</span>, <span class="keyword">new</span> <span class="title class_">DubboBeanDefinitionParser</span>(ReferenceBean.class, <span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;annotation&quot;</span>, <span class="keyword">new</span> <span class="title class_">AnnotationBeanDefinitionParser</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>简单来说：</strong></p>
</blockquote>
<p>解析配置文件的目的就是让配置文件的每个标签的每个属性值都解析出来，然后保存到标签对应的 <code>xxxConfig</code> 类中。</p>
<p>只不过需要注意的是，<code>&lt;dubbo:service&gt;</code> 和  <code>&lt;dubbo:reference&gt;</code> 标签对应的类是 <code>xxxBean</code>。</p>
<h2 id="4-4-服务暴露"><a class="header-anchor" href="#4-4-服务暴露"></a>4.4 服务暴露</h2>
<p>前面说到 <code>&lt;dubbo:service&gt;</code> 标签对应的类是 <code>ServiceBean</code>，研究研究这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceBean</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ServiceConfig</span>&lt;T&gt; <span class="keyword">implements</span> </span><br><span class="line">    <span class="title class_">InitializingBean</span>, </span><br><span class="line">    DisposableBean, </span><br><span class="line">    ApplicationContextAware, </span><br><span class="line">    ApplicationListener&lt;ContextRefreshedEvent&gt;, </span><br><span class="line">    BeanNameAware, </span><br><span class="line">    ApplicationEventPublisherAware &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类实现了很多接口，这里面有两个接口需要注意。一个名为 <code>InitializingBean</code>，另一个名为 <code>ApplicationListener</code>。</p>
<p>当组件创建完对象以后，会调用 <code>InitializingBean</code> 中的 <code>afterPropertiesSet()</code> 方法（属性设置完以后回调方法）。</p>
<p><code>ApplicationListener</code> 接口的泛型是 <code>ContextRefreshedEvent</code>，就是说当整个 IoC 容器都刷新完成（IoC 容器内所有对象都创建完以后），会回调 <code>ApplicationListener</code> 接口中的 <code>onApplicationEvent()</code> 方法。</p>
<p><strong>简单来说：</strong> <code>ServiceBean</code> 会在容器创建完对象以后调用 <code>afterPropertiesSet()</code> 方法，还会在 IoC 容器启动完以后调用 <code>onApplicationEvent()</code> 方法。</p>
<p>执行 <code>afterPropertiesSet()</code> 方法相当于将我们配置的 <code>&lt;dubbo:service&gt;</code> 内的信息都保存起来。</p>
<p>执行 <code>onApplicationEvent()</code> 方法时，如果接口的方法是需要暴露的，但还没暴露，并且不是延迟暴露，就会调用 <code>export()</code> 方法（服务暴露方法）。</p>
<p>执行 <code>export()</code> 方法时，会检查判断并获取信息，但是最后会执行一个名为 <code>doExport()</code> 方法，这个方法用来执行暴露。</p>
<p>在 <code>doExport()</code> 方法中，同样会进行检查判断并获取信息，最后会执行一个名为 <code>doExportUrls()</code> 的方法，这个方法会执行暴露 URL 地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doExportUrls</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 加载注册中心信息</span></span><br><span class="line">    List&lt;URL&gt; registryURLs = <span class="built_in">this</span>.loadRegistries(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 获取暴露的协议与端口</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">this</span>.protocols.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">        <span class="type">ProtocolConfig</span> <span class="variable">protocolConfig</span> <span class="operator">=</span> (ProtocolConfig)var2.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">pathKey</span> <span class="operator">=</span> </span><br><span class="line">            URL.buildKey((String)<span class="built_in">this</span></span><br><span class="line">                         .getContextPath(protocolConfig).map((p) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> p + <span class="string">&quot;/&quot;</span> + <span class="built_in">this</span>.path;</span><br><span class="line">        &#125;).orElse(<span class="built_in">this</span>.path), <span class="built_in">this</span>.group, <span class="built_in">this</span>.version);</span><br><span class="line">        <span class="type">ProviderModel</span> <span class="variable">providerModel</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ProviderModel</span>(pathKey, <span class="built_in">this</span>.ref, <span class="built_in">this</span>.interfaceClass);</span><br><span class="line">        ApplicationModel.initProviderModel(pathKey, providerModel);</span><br><span class="line">        <span class="built_in">this</span>.doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>doExportUrls()</code> 方法中最后有一个名为 <code>doExportUrlsFor1Protocol()</code> 的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(<span class="built_in">this</span>.ref, <span class="built_in">this</span>.interfaceClass, registryURL.addParameterAndEncoded(<span class="string">&quot;export&quot;</span>, url.toFullString()));</span><br><span class="line">            <span class="type">DelegateProviderMetaDataInvoker</span> <span class="variable">wrapperInvoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegateProviderMetaDataInvoker</span>(invoker, <span class="built_in">this</span>);</span><br><span class="line">            Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">            <span class="built_in">this</span>.exporters.add(exporter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">    Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(<span class="built_in">this</span>.ref, <span class="built_in">this</span>.interfaceClass, url);</span><br><span class="line">    <span class="type">DelegateProviderMetaDataInvoker</span> <span class="variable">wrapperInvoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegateProviderMetaDataInvoker</span>(invoker, <span class="built_in">this</span>);</span><br><span class="line">    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">    <span class="built_in">this</span>.exporters.add(exporter);</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，利用 <code>PROXY_FACTORY</code> （代理工厂）获取到包含接口和接口实现类的 <code>Invoker</code> 对象（执行者）。这个执行者其实就是相当于将实现类和 URL 包装了一下。</p>
<p>然后还会把 <code>Invoker</code> 对象包装成 <code>DelegateProviderMetaDataInvoker</code> 对象。</p>
<p>再然后会执行 <code>protocol.export(wrapperInvoker)</code> 将我们的执行者进行暴露。</p>
<p>这个 <code>protocol</code> 是啥？在源代码中有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于 Java 的 SPI 机制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Protocol</span> <span class="variable">protocol</span> <span class="operator">=</span> </span><br><span class="line">    (Protocol)ExtensionLoader</span><br><span class="line">    .getExtensionLoader(Protocol.class)</span><br><span class="line">    .getAdaptiveExtension();</span><br></pre></td></tr></table></figure>
<p>由于会将信息注册到注册中心，因此来看看 <code>RegistryProtocol</code> 类中的服务暴露方法 <code>export()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Exporter&lt;T&gt; <span class="title function_">export</span><span class="params">(Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="type">URL</span> <span class="variable">registryUrl</span> <span class="operator">=</span> <span class="built_in">this</span>.getRegistryUrl(originInvoker);</span><br><span class="line">    <span class="type">URL</span> <span class="variable">providerUrl</span> <span class="operator">=</span> <span class="built_in">this</span>.getProviderUrl(originInvoker);</span><br><span class="line">    <span class="type">URL</span> <span class="variable">overrideSubscribeUrl</span> <span class="operator">=</span> <span class="built_in">this</span>.getSubscribedOverrideUrl(providerUrl);</span><br><span class="line">    RegistryProtocol.<span class="type">OverrideListener</span> <span class="variable">overrideSubscribeListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryProtocol</span>.OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">    <span class="built_in">this</span>.overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    providerUrl = <span class="built_in">this</span>.overrideUrlWithConfig(providerUrl, overrideSubscribeListener);</span><br><span class="line">    <span class="comment">// 进行本地暴露</span></span><br><span class="line">    RegistryProtocol.ExporterChangeableWrapper&lt;T&gt; exporter = <span class="built_in">this</span>.doLocalExport(originInvoker, providerUrl);</span><br><span class="line">    <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="built_in">this</span>.getRegistry(originInvoker);</span><br><span class="line">    <span class="type">URL</span> <span class="variable">registeredProviderUrl</span> <span class="operator">=</span> <span class="built_in">this</span>.getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class="line">    <span class="comment">// 在提供者消费者注册表中注册提供者</span></span><br><span class="line">    <span class="comment">// originInvoker: 提供者 registryUrl: 注册中心地址</span></span><br><span class="line">    <span class="comment">// registeredProviderUrl: 提供者 URL 地址</span></span><br><span class="line">    ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">register</span> <span class="operator">=</span> registeredProviderUrl.getParameter(<span class="string">&quot;register&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (register) &#123;</span><br><span class="line">        <span class="built_in">this</span>.register(registryUrl, registeredProviderUrl);</span><br><span class="line">        providerInvokerWrapper.setReg(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">    exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegistryProtocol</span>.DestroyableExporter(exporter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>doLocalExport()</code> 方法中有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; RegistryProtocol.ExporterChangeableWrapper&lt;T&gt; <span class="title function_">doLocalExport</span><span class="params">(Invoker&lt;T&gt; originInvoker, URL providerUrl)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="built_in">this</span>.getCacheKey(originInvoker);</span><br><span class="line">    <span class="keyword">return</span> (RegistryProtocol.ExporterChangeableWrapper)<span class="built_in">this</span>.bounds.computeIfAbsent(key, (s) -&gt; &#123;</span><br><span class="line">        Invoker&lt;?&gt; invokerDelegate = <span class="keyword">new</span> <span class="title class_">RegistryProtocol</span>.InvokerDelegate(originInvoker, providerUrl);</span><br><span class="line">        <span class="comment">// 再进行服务暴露</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegistryProtocol</span>.ExporterChangeableWrapper(<span class="built_in">this</span>.protocol.export(invokerDelegate), originInvoker);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们使用了 Dubbo 协议，在上一步执行服务暴露时就会来到 <code>DubboProtocol</code> 类中的服务暴露方法 <code>export()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Exporter&lt;T&gt; <span class="title function_">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> invoker.getUrl();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> serviceKey(url); </span><br><span class="line">    <span class="comment">// 将 url 地址包装成 DubboExporter</span></span><br><span class="line">    DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> <span class="title class_">DubboExporter</span>(invoker, key, <span class="built_in">this</span>.exporterMap);</span><br><span class="line">    <span class="built_in">this</span>.exporterMap.put(key, exporter);</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">isStubSupportEvent</span> <span class="operator">=</span> url.getParameter(<span class="string">&quot;dubbo.stub.event&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">isCallbackservice</span> <span class="operator">=</span> url.getParameter(<span class="string">&quot;is_callback_service&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">stubServiceMethods</span> <span class="operator">=</span> url.getParameter(<span class="string">&quot;dubbo.stub.event.methods&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (stubServiceMethods != <span class="literal">null</span> &amp;&amp; stubServiceMethods.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.warn(<span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;consumer [&quot;</span> + url.getParameter(<span class="string">&quot;interface&quot;</span>) + <span class="string">&quot;], has set stubproxy support event ,but no stub methods founded.&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.openServer(url); <span class="comment">// 打开服务器</span></span><br><span class="line">    <span class="built_in">this</span>.optimizeSerialization(url);</span><br><span class="line">    <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法最后有一个 <code>openServer()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">openServer</span><span class="params">(URL url)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> url.getAddress(); <span class="comment">// 先获取 URL 地址</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isServer</span> <span class="operator">=</span> url.getParameter(<span class="string">&quot;isserver&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">        <span class="type">ExchangeServer</span> <span class="variable">server</span> <span class="operator">=</span> (ExchangeServer)<span class="built_in">this</span>.serverMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">                server = (ExchangeServer)<span class="built_in">this</span>.serverMap.get(key);</span><br><span class="line">                <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建服务器</span></span><br><span class="line">                    <span class="built_in">this</span>.serverMap.put(key, <span class="built_in">this</span>.createServer(url));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            server.reset(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一手 <code>createServer()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExchangeServer <span class="title function_">createServer</span><span class="params">(URL url)</span> &#123;</span><br><span class="line">    url = URLBuilder.from(url).addParameterIfAbsent(<span class="string">&quot;channel.readonly.sent&quot;</span>, Boolean.TRUE.toString()).addParameterIfAbsent(<span class="string">&quot;heartbeat&quot;</span>, String.valueOf(<span class="number">60000</span>)).addParameter(<span class="string">&quot;codec&quot;</span>, <span class="string">&quot;dubbo&quot;</span>).build();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> url.getParameter(<span class="string">&quot;server&quot;</span>, <span class="string">&quot;netty&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Unsupported server type: &quot;</span> + str + <span class="string">&quot;, url: &quot;</span> + url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ExchangeServer server;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 绑定服务器和请求处理器</span></span><br><span class="line">            server = Exchangers.bind(url, <span class="built_in">this</span>.requestHandler);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Fail to start server(url: &quot;</span> + url + <span class="string">&quot;) &quot;</span> + var5.getMessage(), var5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        str = url.getParameter(<span class="string">&quot;client&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="literal">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class="line">            <span class="keyword">if</span> (!supportedTypes.contains(str)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Unsupported client type: &quot;</span> + str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法出现了一个名为 <code>bind()</code> 的方法，如果我们一层一层进入这些方法，我们就会看到 Netty 的底层。</p>
<p>对于 <code>openServer()</code> 方法来说就是创建服务器暴露服务，相当于启动 Netty 服务器，然后监听 20880 端口。</p>
<p>回到 <code>RegistryProtocol</code> 类中的服务暴露方法 <code>export()</code>，这个方法中还有一个名为 <code>registerProvider()</code> 的方法，进入这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ProviderInvokerWrapper&lt;T&gt; <span class="title function_">registerProvider</span><span class="params">(Invoker&lt;T&gt; invoker, URL registryUrl, URL providerUrl)</span> &#123;</span><br><span class="line">    ProviderInvokerWrapper&lt;T&gt; wrapperInvoker = <span class="keyword">new</span> <span class="title class_">ProviderInvokerWrapper</span>(invoker, registryUrl, providerUrl);</span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceUniqueName</span> <span class="operator">=</span> providerUrl.getServiceKey();</span><br><span class="line">    ConcurrentMap&lt;Invoker, ProviderInvokerWrapper&gt; invokers = (ConcurrentMap)providerInvokers.get(serviceUniqueName);</span><br><span class="line">    <span class="keyword">if</span> (invokers == <span class="literal">null</span>) &#123;</span><br><span class="line">        providerInvokers.putIfAbsent(serviceUniqueName, <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>());</span><br><span class="line">        <span class="comment">// 服务提供者执行者</span></span><br><span class="line">        invokers = (ConcurrentMap)providerInvokers.get(serviceUniqueName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// invokers 添加真正的服务</span></span><br><span class="line">    invokers.put(invoker, wrapperInvoker);</span><br><span class="line">    <span class="keyword">return</span> wrapperInvoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法相当于保存了一些信息，在这个方法所在类中有这样两个成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderConsumerRegTable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;Invoker, ProviderInvokerWrapper&gt;&gt; providerInvokers = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, Set&lt;ConsumerInvokerWrapper&gt;&gt; consumerInvokers = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>();</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个成员变量相当于保存了每个 URL 地址对应的服务提供者执行器 <code>ProviderInvokerWrapper</code> 和服务消费者执行器 <code>ConsumerInvokerWrapper</code>。而在执行器里才有真正的服务对象，即：接口的实现类。</p>
<p>至此，服务就暴露完成了。</p>
<blockquote>
<p>Dubbo 服务暴露过程</p>
</blockquote>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/Dubbo%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2.jpg" alt="Dubbo服务暴露"></p>
<p>具体服务暴露过程可以参考这篇文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cyfonly/p/9127712.html">Dubbo原理和源码解析之服务暴露</a></p>
<h2 id="4-5-服务引用"><a class="header-anchor" href="#4-5-服务引用"></a>4.5 服务引用</h2>
<p><code>&lt;dubbo:service&gt;</code> 标签是用来做服务暴露的，而 <code>&lt;dubbo:reference&gt;</code> 标签就是用来做服务引用的（它俩也对应着注解 <code>@Service</code> 和 <code>@Reference</code>）。</p>
<p>与 <code>&lt;dubbo:service&gt;</code> 标签一样，<code>&lt;dubbo:reference&gt;</code> 标签也对应着一个解析类，名为 <code>ReferenceBean</code>。</p>
<p>这个类比较特殊，它实现了 <code>FactoryBean</code>，它是 Spring 的工厂 Bean。当我们需要获取 <code>&lt;dubbo:reference&gt;</code> 标签中配置的 <code>interface</code> 属性值时，需要通过依赖注入的方式（@Autowried）获取，这个时候会就前往 Spring 的容器中获取相关的 Bean。</p>
<p>那怎么获取呢？</p>
<p>由于 <code>ReferenceBean</code> 是一个工厂 Bean，就会调用 <code>getObject()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法返回的对象，就会作为标签配置返回的对象。</p>
<p>在 <code>get()</code> 方法中有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkAndUpdateSubConfigs();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.destroyed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The invoker of ReferenceConfig(&quot;</span> + <span class="built_in">this</span>.url + <span class="string">&quot;) has already destroyed!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.ref == <span class="literal">null</span>) &#123; <span class="comment">// 如果引用为 null</span></span><br><span class="line">            <span class="built_in">this</span>.init(); <span class="comment">// 进行初始化</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.ref;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看下 <code>init()</code> 方法是个怎样的流程。在这个方法中前面大部分都是些信息检查、获取属性等操作，但是这个方法中也有一个很重要的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="built_in">this</span>.ref = <span class="built_in">this</span>.createProxy(map); <span class="comment">// 创建代理对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceKey</span> </span><br><span class="line">        <span class="operator">=</span> URL.buildKey(<span class="built_in">this</span>.interfaceName, <span class="built_in">this</span>.group, <span class="built_in">this</span>.version);</span><br><span class="line">    ApplicationModel.initConsumerModel(serviceKey, </span><br><span class="line">                                       <span class="built_in">this</span>.buildConsumerModel(serviceKey, </span><br><span class="line">                                                               attributes));</span><br><span class="line">    <span class="built_in">this</span>.initialized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createProxy()</code> 方法就是创建代理对象的方法，源码中传入了 map，这个 map 保存了标签的配置。</p>
<p>在 <code>createProxy()</code> 方法中，有这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 引用的协议远程引用 interfaceClass 接口</span></span><br><span class="line">    <span class="built_in">this</span>.invoker = REF_PROTOCOL.refer(<span class="built_in">this</span>.interfaceClass, </span><br><span class="line">                                      (URL)<span class="built_in">this</span>.urls.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>interfaceClass</code> 接口也就是我们在标签 <code>&lt;dubbo:reference&gt;</code> 配置的 <code>interface</code> 属性值。</p>
<p><code>urls</code> 中保存了注册中心的地址，相当于会从注册中心中获取远程接口。</p>
<p>那 <code>refer()</code> 方法是怎么引用的呢？</p>
<p>调用 <code>REF_PROTOCOL.refer()</code> 方法时，会先前往注册协议类 <code>RegistryProtocol</code> 中执行 <code>refer()</code> 方法。</p>
<p>进入 <code>RegistryProtocol</code> 类中的 <code>refer()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    url = URLBuilder.from(url).setProtocol(url.getParameter(<span class="string">&quot;registry&quot;</span>, <span class="string">&quot;dubbo&quot;</span>)).removeParameter(<span class="string">&quot;registry&quot;</span>).build();</span><br><span class="line">    <span class="comment">// 根据注册中心地址得到注册中心信息</span></span><br><span class="line">    <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="built_in">this</span>.registryFactory.getRegistry(url);</span><br><span class="line">    <span class="keyword">if</span> (RegistryService.class.equals(type)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.proxyFactory.getInvoker(registry, type, url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取注册中心服务参数</span></span><br><span class="line">        Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(<span class="string">&quot;refer&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> (String)qs.get(<span class="string">&quot;group&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> group == <span class="literal">null</span> || group.length() &lt;= <span class="number">0</span> || CommonConstants.COMMA_SPLIT_PATTERN.split(group).length &lt;= <span class="number">1</span> &amp;&amp; !<span class="string">&quot;*&quot;</span>.equals(group) ? <span class="built_in">this</span>.doRefer(<span class="built_in">this</span>.cluster, registry, type, url) : <span class="built_in">this</span>.doRefer(<span class="built_in">this</span>.getMergeableCluster(), registry, type, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RegistryProtocol</code> 类中的 <code>refer()</code> 方法中还有一个名为 <code>doRefer()</code> 的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> &#123;</span><br><span class="line">    RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> <span class="title class_">RegistryDirectory</span>(type, url);</span><br><span class="line">    directory.setRegistry(registry);</span><br><span class="line">    directory.setProtocol(<span class="built_in">this</span>.protocol);</span><br><span class="line">    Map&lt;String, String&gt; parameters = <span class="keyword">new</span> <span class="title class_">HashMap</span>(directory.getUrl().getParameters());</span><br><span class="line">    <span class="type">URL</span> <span class="variable">subscribeUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;consumer&quot;</span>, (String)parameters.remove(<span class="string">&quot;register.ip&quot;</span>), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">&quot;*&quot;</span>.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(<span class="string">&quot;register&quot;</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">        directory.setRegisteredConsumerUrl(<span class="built_in">this</span>.getRegisteredConsumerUrl(subscribeUrl, url));</span><br><span class="line">        registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    directory.buildRouterChain(subscribeUrl);</span><br><span class="line">    <span class="comment">// 在注册中心中订阅服务提供者为我们提供的服务</span></span><br><span class="line">    directory.subscribe(subscribeUrl.addParameter(<span class="string">&quot;category&quot;</span>, <span class="string">&quot;providers,configurators,routers&quot;</span>));</span><br><span class="line">    <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> cluster.join(directory);</span><br><span class="line">    ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们使用了 <code>dubbo</code> 的协议，订阅服务的同时会来到 <code>DubboProtocol</code> 类中的 <code>refer()</code> 方法。但是 <code>DubboProtocol</code> 中并没有 <code>refer()</code> 方法，去它的父类看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AsyncToSyncInvoker</span>(<span class="built_in">this</span>.protocolBindingRefer(type, url));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">protocolBindingRefer</span><span class="params">(Class&lt;T&gt; var1, URL var2)</span> </span><br><span class="line">    <span class="keyword">throws</span> RpcException;</span><br></pre></td></tr></table></figure>
<p>进入 <code>DubboProtocol</code> 中看下重写的 <code>protocolBindingRefer()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">protocolBindingRefer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="built_in">this</span>.optimizeSerialization(url);</span><br><span class="line">    <span class="comment">// Dubbo 想要远程引用谁？serviceType</span></span><br><span class="line">    <span class="comment">// serviceType 在哪？url</span></span><br><span class="line">    DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> <span class="title class_">DubboInvoker</span>(serviceType, url, </span><br><span class="line">                                               <span class="built_in">this</span>.getClients(url), </span><br><span class="line">                                               <span class="built_in">this</span>.invokers);</span><br><span class="line">    <span class="built_in">this</span>.invokers.add(invoker);</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里也有一个很重要的方法 —— <code>getClients()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExchangeClient[] getClients(URL url) &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">useShareConnect</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">connections</span> <span class="operator">=</span> url.getParameter(<span class="string">&quot;connections&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    List&lt;ReferenceCountExchangeClient&gt; shareClients = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (connections == <span class="number">0</span>) &#123;</span><br><span class="line">        useShareConnect = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">shareConnectionsStr</span> <span class="operator">=</span> url.getParameter(<span class="string">&quot;shareconnections&quot;</span>, (String)<span class="literal">null</span>);</span><br><span class="line">        connections = Integer.parseInt(StringUtils.isBlank(shareConnectionsStr) ? ConfigUtils.getProperty(<span class="string">&quot;shareconnections&quot;</span>, <span class="string">&quot;1&quot;</span>) : shareConnectionsStr);</span><br><span class="line">        shareClients = <span class="built_in">this</span>.getSharedClient(url, connections);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据连接数创建客户端</span></span><br><span class="line">    ExchangeClient[] clients = <span class="keyword">new</span> <span class="title class_">ExchangeClient</span>[connections];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; clients.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (useShareConnect) &#123;</span><br><span class="line">            <span class="comment">// 获取共享的客户端</span></span><br><span class="line">            clients[i] = (ExchangeClient)shareClients.get(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clients[i] = <span class="built_in">this</span>.initClient(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clients;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看如何获取共享客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;ReferenceCountExchangeClient&gt; <span class="title function_">getSharedClient</span><span class="params">(URL url, <span class="type">int</span> connectNum)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> url.getAddress(); <span class="comment">// 获取 URL 地址</span></span><br><span class="line">    List&lt;ReferenceCountExchangeClient&gt; clients = (List)<span class="built_in">this</span>.referenceClientMap.get(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.checkClientCanUse(clients)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.batchClientRefIncr(clients);</span><br><span class="line">        <span class="keyword">return</span> clients;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.locks.putIfAbsent(key, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>.locks.get(key)) &#123;</span><br><span class="line">            clients = (List)<span class="built_in">this</span>.referenceClientMap.get(key);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.checkClientCanUse(clients)) &#123;</span><br><span class="line">                <span class="built_in">this</span>.batchClientRefIncr(clients);</span><br><span class="line">                <span class="keyword">return</span> clients;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                connectNum = Math.max(connectNum, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isEmpty(clients)) &#123;</span><br><span class="line">                    clients = <span class="built_in">this</span>.buildReferenceCountExchangeClientList(url, connectNum);</span><br><span class="line">                    <span class="built_in">this</span>.referenceClientMap.put(key, clients);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; clients.size(); ++i) &#123;</span><br><span class="line">                        <span class="type">ReferenceCountExchangeClient</span> <span class="variable">referenceCountExchangeClient</span> <span class="operator">=</span> (ReferenceCountExchangeClient)clients.get(i);</span><br><span class="line">                        <span class="keyword">if</span> (referenceCountExchangeClient != <span class="literal">null</span> &amp;&amp; !referenceCountExchangeClient.isClosed()) &#123;</span><br><span class="line">                            referenceCountExchangeClient.incrementAndGetCount();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 初始化客户端</span></span><br><span class="line">                            clients.set(i, <span class="built_in">this</span>.buildReferenceCountExchangeClient(url));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.locks.remove(key);</span><br><span class="line">                <span class="keyword">return</span> clients;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看 <code>buildReferenceCountExchangeClient()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReferenceCountExchangeClient <span class="title function_">buildReferenceCountExchangeClient</span><span class="params">(URL url)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化客户端</span></span><br><span class="line">    <span class="type">ExchangeClient</span> <span class="variable">exchangeClient</span> <span class="operator">=</span> <span class="built_in">this</span>.initClient(url);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountExchangeClient</span>(exchangeClient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看 <code>initClient()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExchangeClient <span class="title function_">initClient</span><span class="params">(URL url)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> url.getParameter(<span class="string">&quot;client&quot;</span>, url.getParameter(<span class="string">&quot;server&quot;</span>, <span class="string">&quot;netty&quot;</span>));</span><br><span class="line">    url = url.addParameter(<span class="string">&quot;codec&quot;</span>, <span class="string">&quot;dubbo&quot;</span>);</span><br><span class="line">    url = url.addParameterIfAbsent(<span class="string">&quot;heartbeat&quot;</span>, String.valueOf(<span class="number">60000</span>));</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Unsupported client type: &quot;</span> + str + <span class="string">&quot;, supported client type is &quot;</span> + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), <span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object client;</span><br><span class="line">            <span class="keyword">if</span> (url.getParameter(<span class="string">&quot;lazy&quot;</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">                client = <span class="keyword">new</span> <span class="title class_">LazyConnectExchangeClient</span>(url, <span class="built_in">this</span>.requestHandler);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 进行连接</span></span><br><span class="line">                client = Exchangers.connect(url, <span class="built_in">this</span>.requestHandler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (ExchangeClient)client;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Fail to create remoting client for service(&quot;</span> + url + <span class="string">&quot;): &quot;</span> + var5.getMessage(), var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行连接的 <code>Exchangers.connect()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeClient <span class="title function_">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException &#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;handler == null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        url = url.addParameterIfAbsent(<span class="string">&quot;codec&quot;</span>, <span class="string">&quot;exchange&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> getExchanger(url).connect(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法最后的 <code>connect()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ExchangeClient <span class="title function_">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException &#123;</span><br><span class="line">    <span class="comment">// 返回时调用传输器的连接方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HeaderExchangeClient</span>(Transporters.connect(url, <span class="keyword">new</span> <span class="title class_">ChannelHandler</span>[]&#123;<span class="keyword">new</span> <span class="title class_">DecodeHandler</span>(<span class="keyword">new</span> <span class="title class_">HeaderExchangeHandler</span>(handler))&#125;), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Transporters.connect()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Client <span class="title function_">connect</span><span class="params">(URL url, ChannelHandler... handlers)</span> <span class="keyword">throws</span> RemotingException &#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object handler;</span><br><span class="line">        <span class="keyword">if</span> (handlers != <span class="literal">null</span> &amp;&amp; handlers.length != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handlers.length == <span class="number">1</span>) &#123;</span><br><span class="line">                handler = handlers[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler = <span class="keyword">new</span> <span class="title class_">ChannelHandlerDispatcher</span>(handlers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handler = <span class="keyword">new</span> <span class="title class_">ChannelHandlerAdapter</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拿到传输器的连接</span></span><br><span class="line">        <span class="keyword">return</span> getTransporter().connect(url, (ChannelHandler)handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击最后的 <code>connect()</code> 方法可以进入一个名为 <code>Transporter</code> 的接口。</p>
<p>实现 <code>Transporter</code> 接口的类：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/Transporter%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" alt="Transporter接口实现类"></p>
<p>点击 Netty 传输器类，可以查看到 Netty 的底层：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Client <span class="title function_">connect</span><span class="params">(URL url, ChannelHandler listener)</span> <span class="keyword">throws</span> RemotingException &#123;</span><br><span class="line">    <span class="comment">// 创建 Netty 客户端，url 地址监听一个端口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NettyClient</span>(url, listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，就成功包装好了 <code>DubboInvoker</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">protocolBindingRefer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="built_in">this</span>.optimizeSerialization(url);</span><br><span class="line">    <span class="comment">// Dubbo 想要远程引用谁？serviceType</span></span><br><span class="line">    <span class="comment">// serviceType 在哪？url</span></span><br><span class="line">    DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> <span class="title class_">DubboInvoker</span>(serviceType, url, </span><br><span class="line">                                               <span class="built_in">this</span>.getClients(url), </span><br><span class="line">                                               <span class="built_in">this</span>.invokers);</span><br><span class="line">    <span class="built_in">this</span>.invokers.add(invoker);</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在类中成功获取到 <code>Invoker</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    <span class="comment">// 获取 Invoker 对象</span></span><br><span class="line">    <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> cluster.join(directory);</span><br><span class="line">    <span class="comment">// 将 invoker 注册到提供者消费者注册表</span></span><br><span class="line">    <span class="comment">// subscribeUrl：消费者消费的服务的地址</span></span><br><span class="line">    ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供者消费者注册表 <code>ProviderConsumerRegTable</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderConsumerRegTable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;Invoker, ProviderInvokerWrapper&gt;&gt; providerInvokers = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, Set&lt;ConsumerInvokerWrapper&gt;&gt; consumerInvokers = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>();</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就知道了注册表中提供者的 URL 地址对应的是什么，消费者的 URL 地址对应的又是哪个代理（代理对象 invoker）。</p>
<p>到此，<code>init()</code> 就得到了 invoker 代理对象，成功创建了对象 ref。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="built_in">this</span>.ref = <span class="built_in">this</span>.createProxy(map); <span class="comment">// 创建代理对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">serviceKey</span> </span><br><span class="line">        <span class="operator">=</span> URL.buildKey(<span class="built_in">this</span>.interfaceName, <span class="built_in">this</span>.group, <span class="built_in">this</span>.version);</span><br><span class="line">    ApplicationModel.initConsumerModel(serviceKey, </span><br><span class="line">                                       <span class="built_in">this</span>.buildConsumerModel(serviceKey, </span><br><span class="line">                                                               attributes));</span><br><span class="line">    <span class="built_in">this</span>.initialized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>流程总结</p>
</blockquote>
<p>纵观整个流程，可以得出以下这张图：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/Dubbo%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8.jpg" alt="Dubbo服务引用"></p>
<h2 id="4-6-服务调用"><a class="header-anchor" href="#4-6-服务调用"></a>4.6 服务调用</h2>
<p>前面分析了如何进行服务引用，最终会创建一个代理对象，那这个代理对象是如何进行方法调用的呢？</p>
<p>在 Dubbo 官方文档的【调用链】一栏有这样一幅图，这张图就很好地解释了调用过程：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MicroserviceImages/Dubbo%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8.jpg" alt="Dubbo服务调用"></p>
<blockquote>
<p>具体分析</p>
</blockquote>
<p>得到代理对象后，执行 <code>InvokerInvocationHandler</code> 类中的 <code>invoke()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName(); <span class="comment">// 方法信息</span></span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); <span class="comment">// 方法参数信息</span></span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>.invoker, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.invoker.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;hashCode&quot;</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.invoker.hashCode();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;equals&quot;</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">1</span> ? <span class="built_in">this</span>.invoker.equals(args[<span class="number">0</span>]) : <span class="built_in">this</span>.invoker.invoke(<span class="keyword">new</span> <span class="title class_">RpcInvocation</span>(method, args)).recreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将方法和参数封装成 <code>RpcInvocation</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RpcInvocation</span><span class="params">(Method method, Object[] arguments)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>((Method)method, (Object[])arguments, (Map)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象封装之后，执行最后的 <code>invoke()</code> 方法，这个方法有很多重写。</p>
<p>先执行 <code>MockClusterInvoker</code> 类的 <code>invoke()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.directory.getUrl().getMethodParameter(invocation.getMethodName(), <span class="string">&quot;mock&quot;</span>, Boolean.FALSE.toString()).trim();</span><br><span class="line">    <span class="keyword">if</span> (value.length() != <span class="number">0</span> &amp;&amp; !value.equalsIgnoreCase(<span class="string">&quot;false&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.startsWith(<span class="string">&quot;force&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;force-mock: &quot;</span> + invocation.getMethodName() + <span class="string">&quot; force-mock enabled , url : &quot;</span> + <span class="built_in">this</span>.directory.getUrl());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = <span class="built_in">this</span>.doMockInvoke(invocation, (RpcException)<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// no mock</span></span><br><span class="line">                result = <span class="built_in">this</span>.invoker.invoke(invocation);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RpcException var5) &#123;</span><br><span class="line">                <span class="keyword">if</span> (var5.isBiz()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> var5;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;fail-mock: &quot;</span> + invocation.getMethodName() + <span class="string">&quot; fail-mock enabled , url : &quot;</span> + <span class="built_in">this</span>.directory.getUrl(), var5);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                result = <span class="built_in">this</span>.doMockInvoke(invocation, var5);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="built_in">this</span>.invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MockClusterInvoker</code> 类的 <code>invoke()</code> 方法又会执行 <code>AbstractClusterInvoker</code> 类的 <code>invoke()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkWhetherDestroyed();</span><br><span class="line">    Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();</span><br><span class="line">    <span class="keyword">if</span> (contextAttachments != <span class="literal">null</span> &amp;&amp; contextAttachments.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        ((RpcInvocation)invocation).addAttachments(contextAttachments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// list() 在注册中心中找到我们想要执行的方法到底有几个 Invoker</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = <span class="built_in">this</span>.list(invocation);</span><br><span class="line">    <span class="comment">// 获取到负载均衡机制</span></span><br><span class="line">    <span class="type">LoadBalance</span> <span class="variable">loadbalance</span> <span class="operator">=</span> <span class="built_in">this</span>.initLoadBalance(invokers, invocation);</span><br><span class="line">    RpcUtils.attachInvocationIdIfAsync(<span class="built_in">this</span>.getUrl(), invocation);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.doInvoke(invocation, invokers, loadbalance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后执行 <code>doInvoker()</code> 方法，这个方法有很多重写。以 <code>FailoverClusterInvoker</code> 类举例，在这个类的 <code>duInvoker()</code> 方法中有这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    <span class="comment">// 根据负载均衡策略选择一个 Invoker</span></span><br><span class="line">    Invoker&lt;T&gt; invoker = <span class="built_in">this</span>.select(loadbalance, invocation, copyInvokers, invoked);</span><br><span class="line">    invoked.add(invoker);</span><br><span class="line">    RpcContext.getContext().setInvokers(invoked);</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> invoker.invoke(invocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 <code>invoke()</code> 方法会进入到各种 Filter 中，相当于各层的 Filter 进行层层过滤。</p>
<p>最终执行 <code>AbstractInvoker</code> 类中的 <code>doInvoke()</code> 方法，并来到 <code>DubboInvoker</code> 类中执行 <code>duInvoke()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Result <span class="title function_">doInvoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">RpcInvocation</span> <span class="variable">inv</span> <span class="operator">=</span> (RpcInvocation)invocation;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> RpcUtils.getMethodName(invocation);</span><br><span class="line">    inv.setAttachment(<span class="string">&quot;path&quot;</span>, <span class="built_in">this</span>.getUrl().getPath());</span><br><span class="line">    inv.setAttachment(<span class="string">&quot;version&quot;</span>, <span class="built_in">this</span>.version);</span><br><span class="line">    ExchangeClient currentClient;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取 Netty 客户端</span></span><br><span class="line">        currentClient = <span class="built_in">this</span>.clients[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentClient = <span class="built_in">this</span>.clients[<span class="built_in">this</span>.index.getAndIncrement() % <span class="built_in">this</span>.clients.length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isOneway</span> <span class="operator">=</span> RpcUtils.isOneway(<span class="built_in">this</span>.getUrl(), invocation);</span><br><span class="line">        <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="built_in">this</span>.getUrl().getMethodPositiveParameter(methodName, <span class="string">&quot;timeout&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSent</span> <span class="operator">=</span> <span class="built_in">this</span>.getUrl().getMethodParameter(methodName, <span class="string">&quot;sent&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            currentClient.send(inv, isSent);</span><br><span class="line">            <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(invocation);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">AsyncRpcResult</span> <span class="variable">asyncRpcResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncRpcResult</span>(inv);</span><br><span class="line">            <span class="comment">// 客户端发起请求，获取请求结果并返回</span></span><br><span class="line">            CompletableFuture&lt;Object&gt; responseFuture = currentClient.request(inv, timeout);</span><br><span class="line">            asyncRpcResult.subscribeTo(responseFuture);</span><br><span class="line">            FutureContext.getContext().setCompatibleFuture(responseFuture);</span><br><span class="line">            <span class="keyword">return</span> asyncRpcResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="number">2</span>, <span class="string">&quot;Invoke remote method timeout. method: &quot;</span> + invocation.getMethodName() + <span class="string">&quot;, provider: &quot;</span> + <span class="built_in">this</span>.getUrl() + <span class="string">&quot;, cause: &quot;</span> + var9.getMessage(), var9);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException var10) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="number">1</span>, <span class="string">&quot;Failed to invoke remote method: &quot;</span> + invocation.getMethodName() + <span class="string">&quot;, provider: &quot;</span> + <span class="built_in">this</span>.getUrl() + <span class="string">&quot;, cause: &quot;</span> + var10.getMessage(), var10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取请求结果时，可能会遇到超时，如果超时会默认重试一次。</p>
<p>如果最终成功获取到请求结果，执行各种 <code>invoke()</code> 方法。</p>
<p><code>DubboInvoker</code> 类的 <code>doInvoke()</code> 方法执行完之后，可以得到想要的结果，还会进行编码或解码，最终返回。</p>
<p>结果返回之后，我们的调用也就结束了！ 🎊</p>
<blockquote>
<p>结语</p>
</blockquote>
<p>到此，Dubbo 就真的入门了。</p>
<p>还有一点需要注意，Dubbo 只是一个 RPC 框架，它解决了 RPC 相关的问题，但分布式中还有其他的问题，这些其他的问题就需要用其他的框架或技术来解决了。</p>
<hr>
<p><span style="text-align: center;display:block;">RPC 框架 — Dubbo 入门完</span></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mofan212.github.io">默烦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mofan212.github.io/posts/The-Basis-Of-Dubbo/">https://mofan212.github.io/posts/The-Basis-Of-Dubbo/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://mofan212.github.io" target="_blank">Mofan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Dubbo/">Dubbo</a></div><div class="post-share"><div class="social-share" data-image="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/69.png" data-sites="wechat,qq,weibo,facebook,x"></div><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" target="_blank"><img class="post-qr-code-img" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" target="_blank"><img class="post-qr-code-img" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/FreeMarker-Template-Author's-Guide/" title="FreeMarker 模板开发"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/68.png" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">FreeMarker 模板开发</div></div><div class="info-2"><div class="info-item-1">本文介绍了 FreeMarker 模板引擎的模板开发。</div></div></div></a><a class="pagination-related" href="/posts/Ways-To-Eliminate-Bugs-1/" title="臭虫治理方案（一）"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/70.png" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">臭虫治理方案（一）</div></div><div class="info-2"><div class="info-item-1">本文作为日常学习工作总结，主要用于记录遇到的各种顽固“臭虫”。</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">默烦</div><div class="author-info-description">彩笔的打怪升级之路...</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">174</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mofan212"><i class="fab fa-github"></i><span>follow me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:cy.mofan@foxmail.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站所有博文均是博主的学习笔记与个人理解。<strong><font style="color:red">除特别注明外，</font>如需转载，请在文章头部醒目处附带原文链接并<a href="./mine/" style="color:#49B1F5;text-decoration:underline">告知我</a></strong>你将转载。😊</br><strong><font style="color:red">严禁未遵循规范的转载。</font></strong>😡</br><strong>死去的评论系统复活啦！欢迎到留言板畅所欲言！</strong>当然也可以使用更高效的<a target="_blank" href="https://space.bilibili.com/23658864/dynamic" style="color:#49B1F5;text-decoration:underline"> 哔哩哔哩私信 </a>或<a href="mailto:cy.mofan@foxmail.com" style="color:#49B1F5;text-decoration:underline" target="_blank">邮箱</a>。 😉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-text">1. 基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA"><span class="toc-text">1.1 分布式基础理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Dubbo-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.2 Dubbo 基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Dubbo-%E4%B8%8E%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-text">1.3 Dubbo 与注册中心</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Dubbo-%E9%85%8D%E7%BD%AE"><span class="toc-text">2. Dubbo 配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E7%AD%96%E7%95%A5"><span class="toc-text">2.1 配置文件覆盖策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%90%AF%E5%8A%A8%E6%A3%80%E6%9F%A5"><span class="toc-text">2.2 启动检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE"><span class="toc-text">2.3 超时设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0"><span class="toc-text">2.4 重试次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%A4%9A%E7%89%88%E6%9C%AC"><span class="toc-text">2.5 多版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E6%9C%AC%E5%9C%B0%E5%AD%98%E6%A0%B9"><span class="toc-text">2.6 本地存根</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E6%95%B4%E5%90%88-SpringBoot-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">2.7 整合 SpringBoot 的方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-text">3. 高可用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-ZK-%E5%AE%95%E6%9C%BA%E4%B8%8E-Dubbo-%E7%9B%B4%E8%BF%9E"><span class="toc-text">3.1 ZK 宕机与 Dubbo 直连</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%BA%E5%88%B6"><span class="toc-text">3.2 负载均衡机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="toc-text">3.3 服务降级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99"><span class="toc-text">3.4 服务容错</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Hystrix"><span class="toc-text">3.5 Hystrix</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Dubbo-%E5%8E%9F%E7%90%86"><span class="toc-text">4. Dubbo 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-RPC-%E5%92%8C-Netty-%E5%8E%9F%E7%90%86"><span class="toc-text">4.1 RPC 和 Netty 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1"><span class="toc-text">4.2 框架设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%A0%87%E7%AD%BE%E8%A7%A3%E6%9E%90"><span class="toc-text">4.3 标签解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2"><span class="toc-text">4.4 服务暴露</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8"><span class="toc-text">4.5 服务引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="toc-text">4.6 服务调用</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Something-About-Blog/" title="博客搭建与维护"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/42.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="博客搭建与维护"/></a><div class="content"><a class="title" href="/posts/Something-About-Blog/" title="博客搭建与维护">博客搭建与维护</a><time datetime="2026-01-24T16:00:00.000Z" title="更新于 2026-01-25 00:00:00">2026-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Memory-Model/" title="Java 内存模型"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/174.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Java 内存模型"/></a><div class="content"><a class="title" href="/posts/Java-Memory-Model/" title="Java 内存模型">Java 内存模型</a><time datetime="2026-01-02T16:00:00.000Z" title="更新于 2026-01-03 00:00:00">2026-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Bytecode-And-Class-Loading/" title="字节码与类加载"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/173.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="字节码与类加载"/></a><div class="content"><a class="title" href="/posts/Java-Bytecode-And-Class-Loading/" title="字节码与类加载">字节码与类加载</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Class-Resource-Loading-In-Java/" title="Java 的类资源加载"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/103.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Java 的类资源加载"/></a><div class="content"><a class="title" href="/posts/Class-Resource-Loading-In-Java/" title="Java 的类资源加载">Java 的类资源加载</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Annotation-And-Reflection/" title="注解、类的加载、反射"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/20.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="注解、类的加载、反射"/></a><div class="content"><a class="title" href="/posts/Annotation-And-Reflection/" title="注解、类的加载、反射">注解、类的加载、反射</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ren-zhi-jue-xing/" title="认知觉醒"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/172.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="认知觉醒"/></a><div class="content"><a class="title" href="/posts/ren-zhi-jue-xing/" title="认知觉醒">认知觉醒</a><time datetime="2025-12-28T16:00:00.000Z" title="更新于 2025-12-29 00:00:00">2025-12-29</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2020 - 2026 By 默烦</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://testingcf.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://testingcf.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://testingcf.jsdelivr.net/npm/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://testingcf.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://gcore.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources@master/js/mine.min.js"></script><script src="/js/tip_portal.js"></script><script defer="defer" id="ribbon" src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-show-text" src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Azathoth,Yog-Sothoth,Shub-Niggurath,Nyarlathotep,Cthulhu,Hastur,Abhoth,Ghroth,Tsathoggua,Cthugha,Deep Ones,Dagon,Chaugnar Faugn,Mordiggian,Shoggoth,Old One,Mi-Go,Great Race of Yith,Flying Polyp,Hounds of Tindalos,Dhole" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://testingcf.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'BAFEL7A6K1',
    apiKey: '89fcb5961984c5c054bf04149f345f38',
    indexName: 'mofan212io',
    container: '#docsearch',
    placeholder: '输入关键字进行搜索',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>
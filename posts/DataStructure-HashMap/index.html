<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构之哈希表 | Mofan</title><meta name="author" content="默烦,cy.mofan@foxmail.com"><meta name="copyright" content="默烦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文基于 Java 介绍了哈希表中的一些概念，并且动手编写了一个简单的 HashMap。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构之哈希表">
<meta property="og:url" content="https://mofan212.github.io/posts/DataStructure-HashMap/index.html">
<meta property="og:site_name" content="Mofan">
<meta property="og:description" content="本文基于 Java 介绍了哈希表中的一些概念，并且动手编写了一个简单的 HashMap。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/39.png">
<meta property="article:published_time" content="2020-08-03T16:00:00.000Z">
<meta property="article:modified_time" content="2020-11-06T16:00:00.000Z">
<meta property="article:author" content="默烦">
<meta property="article:tag" content="DataStructure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/39.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数据结构之哈希表",
  "url": "https://mofan212.github.io/posts/DataStructure-HashMap/",
  "image": "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/39.png",
  "datePublished": "2020-08-03T16:00:00.000Z",
  "dateModified": "2020-11-06T16:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "默烦",
      "url": "https://mofan212.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/favicon.png"><link rel="canonical" href="https://mofan212.github.io/posts/DataStructure-HashMap/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 默烦","link":"链接: ","source":"来源: Mofan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://fastly.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构之哈希表',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/mofan212/blog-static-resources@master/css/myStyle.min.css"><link rel="stylesheet" href="https://cdn.staticfile.net/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css" /><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Mofan" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/mofan212/blog-static-resources/css/minimal.min.css"/><script src="https://fastly.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">155</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/post_top_img.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Mofan</span></a><a class="nav-page-title" href="/"><span class="site-name">数据结构之哈希表</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">数据结构之哈希表</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-03T16:00:00.000Z" title="发表于 2020-08-04 00:00:00">2020-08-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-06T16:00:00.000Z" title="更新于 2020-11-07 00:00:00">2020-11-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/DataStructure/">DataStructure</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">22k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>83分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;距离本文上次更新已经过去&quot;,&quot;messageNext&quot;:&quot;天，请注意时效性。&quot;,&quot;postUpdate&quot;:&quot;2020-11-07 00:00:00&quot;}" hidden></div><p>封面画师：ツチヤ     封面ID：82542726</p>
<p>本文参考视频：小马哥教育(SEEMYGO) 2019年 恋上数据结构与算法（第一季）</p>
<p>源码仓库：<a target="_blank" rel="noopener" href="https://github.com/mofan212/data-structure-and-algorithm">mofan212/data-structure-and-algorithm (github.com)</a></p>
<p>辅助学习网址：<a target="_blank" rel="noopener" href="https://visualgo.net/zh">数据结构和算法动态可视化</a></p>
<h1 id="0-需求分析"><a class="header-anchor" href="#0-需求分析"></a>0. 需求分析</h1>
<h2 id="0-1-TreeMap分析"><a class="header-anchor" href="#0-1-TreeMap分析"></a>0.1 TreeMap分析</h2>
<blockquote>
<p>时间复杂度（平均）</p>
</blockquote>
<p>由于<code>TreeMap</code>底层采用的红黑树实现的，因此<code>TreeMap</code>的添加、删除、搜索的平均时间复杂度都为<code>O(logn)</code>。</p>
<blockquote>
<p>TreeMap的特点</p>
</blockquote>
<ul>
<li>Key 必须具备可比较性</li>
<li>元素的分布是有顺序的</li>
</ul>
<blockquote>
<p>实际应用</p>
</blockquote>
<p>实际应用中，很多时候的需求：</p>
<ul>
<li>Map 中存储的元素不需要讲究顺序</li>
<li>Map 中的 Key 不需要具备可比较性</li>
</ul>
<p>如果这个时候还使用底层红黑树实现的<code>TreeMap</code>就会造成不必要的“浪费”。</p>
<p>不考虑顺序、不考虑 Key 的可比较性，Map 有更好的实现方案，这个方案的平均时间复杂度可以达到<code>O(1)</code>。</p>
<p>这个方案就是采用<strong>哈希表</strong>实现Map。💪</p>
<h2 id="0-2-需求由来"><a class="header-anchor" href="#0-2-需求由来"></a>0.2 需求由来</h2>
<p>现有一个需求： 设计一个写字楼通讯录，存放所有公司的通讯信息。</p>
<p>座机号码作为 Key （假设座机号码最长为 8 位），公司详情（名称、地址等信息）作为 Value。</p>
<p>同时要求添加、删除、搜索的时间复杂度都是 <code>O(1)</code>。</p>
<p>根据上面的需求，我们可以暂时的设计如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Company[] companies = <span class="keyword">new</span> <span class="title class_">Company</span>[<span class="number">100000000</span>];</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> phone, Company company)</span>&#123;</span><br><span class="line">    companies[phone] = company;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> phone)</span>&#123;</span><br><span class="line">    companies[phone] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Company <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> conpanies[phone];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然上述的代码满足需求，但是也存在很大的问题：</p>
<ul>
<li>空间复杂度非常大</li>
<li>空间使用率极低，存在大量空间未使用，非常浪费内存空间</li>
<li>其实数组 <code>companies</code> 就是一个哈希表，是典型的【空间换时间】</li>
</ul>
<h1 id="1-基本概念"><a class="header-anchor" href="#1-基本概念"></a>1. 基本概念</h1>
<p>本节中涉及的<code>HashMap</code>均为JDK提供。</p>
<h2 id="1-1-初始哈希表"><a class="header-anchor" href="#1-1-初始哈希表"></a>1.1 初始哈希表</h2>
<p>哈希表（Hash Table），又叫散列表，其中 hash 有“剁碎”的意思。</p>
<p>那么哈希表是如何高效处理顺序的呢？</p>
<p>假设现有这样几组数据需要被放入哈希表中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">put(<span class="string">&quot;jack&quot;</span>, <span class="number">666</span>);</span><br><span class="line">put(<span class="string">&quot;Rose&quot;</span>, <span class="number">777</span>);</span><br><span class="line">put(<span class="string">&quot;Kate&quot;</span>, <span class="number">888</span>);</span><br></pre></td></tr></table></figure>
<p>这些数据由 Key 和 Value 组成，哈希表底层是数组，Key 通过哈希函数计算（<code>O(1)</code>级别的计算）后，得到数组的索引，然后在数组索引位置放入 Value。如：</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/DataStructureImages/初始哈希表.png" alt="初始哈希表" style="zoom:50%;" />
<p>在哈希表中，哈希表的长度最好是 2 的幂。原因在哈希函数中介绍~</p>
<blockquote>
<p>数据操作流程</p>
</blockquote>
<p>添加、搜索、删除的流程都是类似的：</p>
<p>1、利用哈希函数生成 key 对应的索引 index 【O(1)】</p>
<p>2、根据索引 index 操作定位数组元素【O(1)】</p>
<hr>
<p>哈希表是【空间换时间】的典型应用。</p>
<p>哈希函数，也叫作散列函数。</p>
<p>哈希表内部的数组元素，在很多地方也被叫做 Bucket （桶），整个数组叫 Buckets 或者 Buckets Array。</p>
<h2 id="1-2-哈希冲突"><a class="header-anchor" href="#1-2-哈希冲突"></a>1.2 哈希冲突</h2>
<p>哈希冲突（Hash Collision），又被叫做哈希碰撞。其含义是： 两个不同的 key，经过哈希函数计算出相同的结果（索引）。如：</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/DataStructureImages/哈希冲突.png" alt="哈希冲突" style="zoom:50%;" />
<p>那么应该如何解决哈希冲突呢？</p>
<p>1、开放定址法（Open Addressing）</p>
<ul>
<li>按照一定的规则（线性探测、平方探测）向其他地址进行探测，直到遇到空桶</li>
</ul>
<p>2、再哈希法（Re-Hashing）</p>
<ul>
<li>设计多个哈希函数</li>
</ul>
<p>3、链地址法（Separate Chaining）</p>
<ul>
<li>比如通过链表将同一个索引的元素串起来</li>
</ul>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/DataStructureImages/链地址法.png" alt="链地址法" style="zoom:50%;" />
<blockquote>
<p>JDK 1.8 解决方法</p>
</blockquote>
<p>在JDK 1.8 中，使用的是<strong>链地址法</strong> ，默认使用<mark>单向链表</mark>将元素串起来。</p>
<p>在添加元素时，可能会由<strong>单向链表</strong>转为<strong>红黑树</strong>来存储元素。</p>
<ul>
<li>比如当哈希表容量 &gt;= 64 且<mark>单向链表</mark>的节点数量大于 <code>8</code> 时，如下图所示：</li>
</ul>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/DataStructureImages/JDK8哈希冲突解决.png" alt="JDK8哈希冲突解决" style="zoom:50%;" />
<p>当红黑树节点数量少到一定程度时，又会转为单向链表。</p>
<p>所以，JDK 1.8 中的哈希表是使用 <strong>链表 + 红黑树</strong> 解决哈希冲突的。</p>
<hr>
<p><mark>思考：</mark>  这里为啥使用单向链表，而不是双向链表？</p>
<p>假设现在向一个哈希表中插入以下数据，同时这些数据的 key 通过哈希函数计算后得到的 index 是一样的，又假设都是 01 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">put(<span class="string">&quot;a&quot;</span>, <span class="number">40</span>);</span><br><span class="line">put(<span class="string">&quot;b&quot;</span>, <span class="number">50</span>);</span><br><span class="line">put(<span class="string">&quot;c&quot;</span>, <span class="number">60</span>);</span><br></pre></td></tr></table></figure>
<p>为防止哈希冲突，会采用<strong>链地址法</strong>，结构和上图一样。</p>
<p>假设我这时再插入一个数据：<code>put(&quot;b&quot;, 70);</code>，显然新插入数据的 Key 在原哈希表中已经存在，也会产生哈希冲突。这个时候要怎么做呢？</p>
<p>将新插入的数据与原本的数据从链表头一个一个进行比较（比较 Key）：先与节点 40 进行 Key 值比较，发现不一样，然后跳到下一个；再与节点 50 进行 Key 值比较，Key值一样，用新数据覆盖旧数据；如果比较到链表尾都没找到相同的 Key 值，那么直接在链表尾插入添加数据。</p>
<p>使用单链表的主要原因有：</p>
<ul>
<li>每次都是从头结点开始遍历的</li>
<li>单向链表比双向链表少一个指针，可以节约内存空间</li>
</ul>
<hr>
<p>我们又会发现一个问题：不是说使用哈希表不考虑顺序、 Key值的比较性吗？这下又需要使用红黑树，就必须要使节点有可比较性，那么是否矛盾呢？</p>
<p>这个问题后续编码时解决，暂时不急。😜</p>
<h2 id="1-3-哈希函数"><a class="header-anchor" href="#1-3-哈希函数"></a>1.3 哈希函数</h2>
<p>哈希表中哈希函数的实现步骤大致如下：</p>
<p>1、先生成 <span style="color:darkorange ">Key 的哈希值</span>（必须是<mark>整数</mark>）</p>
<p>2、再让 <span style="color:darkorange ">Key 的哈希值</span>跟<span style="color:darkorange ">数组的大小</span>进行相关运算，生成一个<span style="color:darkorange ">索引值</span> ，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">index</span><span class="params">(Object key)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash_code(key) % table.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了提高效率，可以使用 <strong>&amp;</strong> 位运算取代 <strong>%</strong> （模）运算【前提：<strong>将数组的长度设计为 2 的幂</strong>（2<sup>n</sup>）】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">index</span><span class="params">(Object key)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash_code(key) &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【&amp; 位运算规则：同为1取1，否则取0。即： 1011 &amp; 1010 = 1010】</p>
<hr>
<p>那么使用&amp; 位运算后的代码为什么是这样的呢？</p>
<p>首先我们要明白数的二进制表示，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1			2^0</span><br><span class="line">10			2^1</span><br><span class="line">100			2^2</span><br><span class="line">1000			2^3</span><br></pre></td></tr></table></figure>
<p>如果我们对上面的数减一后，二进制又是怎样的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0			2^0 - 1</span><br><span class="line">01			2^1 - 1</span><br><span class="line">011			2^2 - 1</span><br><span class="line">0111			2^3 - 1</span><br></pre></td></tr></table></figure>
<p>二进制表示的数中，前面的 0 可以省略。</p>
<p>然后我们用一个二进制的数与全 1 的数进行 &amp; 位运算会得到什么结果呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  101101011</span><br><span class="line">&amp; 111111111</span><br><span class="line">--------------</span><br><span class="line">  101101011</span><br></pre></td></tr></table></figure>
<p>我们发现进行 &amp; 位运算后得到的结果与原来的数一样。但这只是最浅显的特点，还有一个更加重要的特点： <mark>得到的结果一定不大于进行 &amp; 位运算中全 1 的数。</mark></p>
<p>11001010 &amp; 1111 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  11001010</span><br><span class="line">&amp; 00001111</span><br><span class="line">-----------</span><br><span class="line">  00001010</span><br></pre></td></tr></table></figure>
<p>位数不足用 0 填充。我们发现得到的结果 1010 比 1111 要小，如果是 11001111 与 1111 进行 &amp; 位运算，得到的结果为 1111 ，两者相同。这也证明了我们前面所说的。</p>
<p>正是因为这个特点，我们可以使用 &amp; 位运算来代替模运算以提高效率。</p>
<hr>
<p>如果需要我们自己设计一个哈希函数，应该怎么设计一个良好的哈希函数呢？</p>
<p>让哈希值更加均匀分布，减少哈希冲突次数，从而提升哈希表的性能。</p>
<h2 id="1-4-哈希值计算"><a class="header-anchor" href="#1-4-哈希值计算"></a>1.4 哈希值计算</h2>
<blockquote>
<p>如何生成key的哈希值</p>
</blockquote>
<p>key的常见种类有很多，比如： 整数、浮点数、字符串、自定义对象</p>
<p>不同种类的 key ，哈希值的生成方式是不一样的，但目标是一致的</p>
<ul>
<li>尽量让每个 key 的哈希值是唯一的</li>
<li>尽量让 key 的所有信息参与运算</li>
</ul>
<p>在 Java 中， HashMap 的 key 必须实现 <code>hashCode()</code>、 <code>equals()</code> 方法，也允许 key 为 <code>null</code>。</p>
<p>在 Java 中，哈希值必须是 int 类型的。</p>
<blockquote>
<p>int与float的哈希值</p>
</blockquote>
<p>key 为整数时： 整数值就当作哈希值，比如 10 的哈希值就是 10</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>key 为单精度浮点数时： 将存储的二进制格式转为整数值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(<span class="type">float</span> value)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> floatToIntBits(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>long与double的哈希值</p>
</blockquote>
<p>int 类型占 4 个字节，即： 32位。但是 long 类型是占 8 个字节的，即： 64 位。在 Java 中，哈希值必须是 int 类型的，就是说 long 类型的哈希值只能是 32 位，那应该咋办？</p>
<p>有一种方法是选择 long 类型的前 32 位 或者后 32 位作为哈希值。但是这种方法有一个问题，因为我们前面所说：“<strong>尽量让 key 的所有信息参与运算</strong>”。那我们应该怎么做？现给出一种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(<span class="type">long</span> value)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(value ^ (value &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，double 类型也是是占 8 个字节的，即： 64 位。现给出一种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(<span class="type">double</span> value)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">bits</span> <span class="operator">=</span> doubleToLongBits(value);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(bits ^ (bits &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这两段代码中， <code>&gt;&gt;&gt;</code> （无符号右移）与 <code>^</code> （异或）的作用是什么呢？</p>
<ul>
<li>高 32 bit 和低 32 bit 混合计算出 32 bit 的哈希值</li>
<li>充分利用所有信息计算出的哈希值</li>
</ul>
<p>PS ： 异或运算：相同为 0 ，不同为 1。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/DataStructureImages/Long%E4%B8%8EDouble%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC.png" alt="Long与Double的哈希值"></p>
<p>通过上面的图示，我们可以看到 64 bit 都参与了运算。</p>
<p>那为什么运算的时候用异或？而不是与运算或者或运算？</p>
<p>如果使用其他运算，得到的结果没有意义，都是参加计算的数据，而不是得到的不同的数据。</p>
<blockquote>
<p>字符串的哈希值</p>
</blockquote>
<p>整数 5489 是如何计算出来的？</p>
<p>通过： 5 * 10<sup>3</sup> + 4 * 10<sup>2</sup> + 8 * 10<sup>1</sup> + 9 * 10<sup>0</sup></p>
<p>而字符串是由若干个字符组成的，比如字符串<code>jack</code>， 由 j、a、c、k 四个字符组成（字符的本质就是一个整数）。因此，jack 的哈希值可以表示为：</p>
<p>j * n<sup>3</sup> + a * n<sup>2</sup> + c * n<sup>1</sup> + k * n<sup>0</sup> ，这个等价于[ (j * n + a) * n + c ] * n + k</p>
<p>那么这个 n 是多少呢？在JDK中，乘数 n 为 31 ，那又为什么是 31 呢？</p>
<p>31 是个神奇的数字。它是一个奇素数， JVM 会将 <code>31 * i</code> 优化成 <code>(i &lt;&lt; 5) - i </code> 。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;jack&quot;</span>; <span class="comment">// 3254239</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> string.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> string.charAt(i);</span><br><span class="line">            hashCode = hashCode * <span class="number">31</span> + c;</span><br><span class="line"><span class="comment">//            hashCode = (hashCode &lt;&lt; 5) - hashCode + c;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(hashCode); <span class="comment">// 3254239</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们在编写Java代码计算字符串的哈希值时，每次都要书写上面的代码吗？</p>
<p>其实不用，JDK已经给我们提供了计算字符串哈希值的方法：<code>string.hashCode()</code>，其内部实现与我们上面书写的代码是一样的。</p>
<hr>
<p>31 的探讨：</p>
<p>JVM优化原理： 31 * i = (2<sup>5</sup> - 1) * i = i * 2<sup>5</sup> - i = (i &lt;&lt; 5) - i</p>
<p>31 不仅仅是符合 2<sup>n</sup> - 1，它还是一个奇素数（既是奇数，又是素数）。素数和其他树相乘的结果比其他方式更容易产生唯一性，减少哈希冲突。</p>
<p>最终选择 31 是经过观测分布结果后的选择。</p>
<blockquote>
<p>常见类型计算总结</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">110</span>;</span><br><span class="line">    <span class="type">Float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10.6f</span>;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">156l</span>;</span><br><span class="line">    <span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">10.9</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> <span class="string">&quot;mofan&quot;</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(a.hashCode()); <span class="comment">// 110</span></span><br><span class="line">    System.out.println(b.hashCode()); <span class="comment">// 1093245338</span></span><br><span class="line">    System.out.println(c.hashCode()); <span class="comment">// 156</span></span><br><span class="line">    System.out.println(d.hashCode()); <span class="comment">// -1930887167</span></span><br><span class="line">    System.out.println(e.hashCode()); <span class="comment">// 104071729</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就是使用JDK中提供的方法求一些数据的哈希值。在倒数第二个输出中可以看到，求得结果是负数，那么计算索引时会出现负数吗？</p>
<p>其实是不会的，因为求索引进行的位运算。无视符号，数值直接运算。😉（如果有计算机组成原理的知识就十分好理解了）</p>
<blockquote>
<p>自定义对象</p>
</blockquote>
<p>假设现在有一个自定义对象<code>Person</code>，其属性与构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> height;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, <span class="type">float</span> height, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以尝试实例化这个对象，并打印出哈希值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">20</span>, <span class="number">1.76f</span>, <span class="string">&quot;mofan&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">20</span>, <span class="number">1.76f</span>, <span class="string">&quot;mofan&quot;</span>);</span><br><span class="line">    <span class="comment">// 和内存地址有关 因此两个输出并不相等</span></span><br><span class="line">    System.out.println(p1.hashCode());</span><br><span class="line">    System.out.println(p2.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终打印出来的两个哈希值是不一样的。因为我们直接使用自定义对象的<code>hashCode()</code>方法算出的哈希值和内存地址有关，显然这两个对象不是同一个内存地址，因此它俩也就不相等。</p>
<p>但是在实际开发中，就实例化的<code>Person</code>对象而言，当年龄、身高、姓名都相等时，我们将这两个对象视为同一个对象，而它们打印出的哈希值应该是相等的。那么我们应该怎么做？</p>
<p>我们需要在<code>Person</code>类中重写<code>hashCode()</code>方法，自定义计算方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> Integer.hashCode(age);</span><br><span class="line">    hashCode = hashCode * <span class="number">31</span> + Float.hashCode(height);</span><br><span class="line">    hashCode = hashCode * <span class="number">31</span> + (name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再进行打印，得到的结果是：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/DataStructureImages/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E5%93%88%E5%B8%8C%E5%80%BC.png" alt="自定义对象哈希值"></p>
<p>这下我们得到的哈希值就是一样的了！ 🎉🎊</p>
<blockquote>
<p>Q &amp; A</p>
</blockquote>
<p>Q 1: 哈希值太大，整型溢出怎么办？</p>
<p>A1 : 不做任何处理。我们计算哈希值就是为了得到一个整型的数据，溢出就溢出，无所谓~</p>
<p>Q 2: 不重写 <code>hashCode()</code> 方法有什么后果？</p>
<p>A 2: 如果不重写，就会按照默认的方式进行计算，计算结果与内存有关。即使是属性值都相等的两个对象，由于内存分配不同，最终得到的哈希值也往往不同。</p>
<h2 id="1-5-equals-方法"><a class="header-anchor" href="#1-5-equals-方法"></a>1.5 equals()方法</h2>
<p>在上一节中，已经说明： 在 Java 中， HashMap 的 key 必须实现 <code>hashCode()</code>、 <code>equals()</code> 方法，也允许 key 为 <code>null</code>。还是在上一节中，我们解释了为什么要重写<code>hashCode()</code>方法，那么为什么还要重写<code>equals()</code>方法呢？</p>
<p>假设哈希表中索引为 01 的位置已经发送哈希冲突，在这个位置使用链地址法解决哈希冲突（再次假设这个位置有 3 个数据）。然后我们再向哈希表插入一个数据，这个数据的 key 经过哈希函数计算后得到的索引又是 01，发生哈希冲突，使用链地址法解决。</p>
<p>然后获取新插入元素的 key 与原来索引 01 位置的其他数据的 key 进行相等比较，如果原来的数据中存在一个数据与新插入数据的 key 相等，那么就会用新插入数据覆盖原有数据，如果不存在这样一个数据，那么就在使用链地址法的链表尾插入新添加元素。</p>
<p>上述描述涉及到一个相等比较，而且是 key 值的相等比较，那为什么是 key 值比较，不能用哈希值进行比较吗？</p>
<p>答案是不行的。因为有可能几种完全不相干的数据（比如数据类型不同）计算出的哈希值是一样的，如果采用哈希值进行相等比较，难道这个时候要用完全不相干的数据覆盖原数据吗？显然还是不行的。而且针对同一个实体类的不同实例化，计算得到的哈希值可能是一样的，我们也不能认为这些对象就相等了（属性值可能不同）。同时，我们应当明白发生哈希冲突并不是指计算出的哈希值一样就发生了哈希冲突，哈希冲突是由哈希函数计算出的哈希表索引 index 相同而产生的。（可以参考前面<strong>哈希函数</strong>中的代码理解）</p>
<p>说了这么多，就是说明了我们必须要在实体类（HashMap 中的 key）中重写 <code>equals()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 内存地址相等时</span></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="built_in">this</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 传递对象为 null 时，传递对象与调用对象类型不同时</span></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span> || obj.getClass() != getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// if (obj == null || !(obj instanceof Person)) return false;</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> ((Person) obj);</span><br><span class="line">    <span class="keyword">return</span> person.age == age &amp;&amp; person.height == height</span><br><span class="line">        &amp;&amp; valueEquals(person.name, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">valueEquals</span><span class="params">(Object v1, Object v2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 == <span class="literal">null</span> ? v2 == <span class="literal">null</span> : v1.equals(v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>上述代码给出了两种比较类型的方式：</p>
<ul>
<li><code>obj.getClass() != getClass()</code></li>
<li><code>!(obj instanceof Person)</code></li>
</ul>
<p>假设有一个类叫<code>Person</code>，它有一个子类叫<code>Student</code>。</p>
<p>如果这时候<code>obj</code>的类型是<code>Student</code>，对于第一种方式的结果是<strong>true</strong>，而对于第二种方式的结果是<strong>false</strong> 。显然，第一种得到的结果才是我们想要的，因此建议使用第一种比较类型的方式。</p>
<p>PS : 如果 <code>obj</code> 是 <code>Person</code> 的子类，采取 <code>obj instanceof Person</code> 进行类型判断，得到的结果是 <strong>true</strong> 。</p>
<h2 id="1-6-阶段性总结"><a class="header-anchor" href="#1-6-阶段性总结"></a>1.6 阶段性总结</h2>
<p>在 Java 中， HashMap 的 key 必须实现 <code>hashCode()</code>、 <code>equals()</code> 方法，也允许 key 为 <code>null</code>。</p>
<blockquote>
<p>实现两个方法</p>
</blockquote>
<p>其中，<code>hashCode()</code>方法是在生成索引的时候使用；而<code>equals()</code>方法是在发生哈希冲突后，将新插入数据与进行了链地址法生成的数据链（单向链表或红黑树）中的数据挨个进行相等性比较，如果存在相等元素，使用新插入数据覆盖原数据，否则在数据链尾添加新插入数据。</p>
<blockquote>
<p>两个方法都没实现</p>
</blockquote>
<p>在正常情况下，对于 HashMap 的 key 都会实现 <code>hashCode()</code>、 <code>equals()</code> 方法，如果对 key 这两个方法都没有实现呢？</p>
<p>对于非自定义类型的数据就按照我们前面所说的方法计算哈希值，而对于自定义类型的数据计算哈希值得到的结果与内存有关。同时，没有实现<code>equals()</code>时进行相等性比较，会默认比较内存地址。假设向一个 HashMap 插入下列三组数据，Person类中没有实现 <code>hashCode()</code>、 <code>equals()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">20</span>, <span class="number">1.76f</span>, <span class="string">&quot;mofan&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">20</span>, <span class="number">1.76f</span>, <span class="string">&quot;mofan&quot;</span>);</span><br><span class="line">    <span class="comment">// 和内存地址有关 因此两个输出并不相等</span></span><br><span class="line">    System.out.println(p1.hashCode());</span><br><span class="line">    System.out.println(p2.hashCode());</span><br><span class="line"></span><br><span class="line">    Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(p1,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">    map.put(p2,<span class="string">&quot;bcd&quot;</span>);</span><br><span class="line">    System.out.println(map.size()); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又假设即使 p1 、p2 算出的哈希值不一样，但是经过哈希函数的运算后， p1 、p2 、 “test” 的索引是一样的（假设！），但最终输出 HashMap 的长度还是 3 。虽然会发生哈希冲突，但是没实现<code>equals()</code>，相等性比较时使用的是内存地址进行比较，显然这三者的内存地址是不一样的，因此得到的 HashMap 长度也就是 3 。</p>
<blockquote>
<p>只实现equals()方法</p>
</blockquote>
<p>如果只实现<code>equals()</code>方法，而不实现<code>hashCode()</code>方法，那么计算哈希值时就会采用默认方式。对于自定义的类型，算出的哈希值与内存地址有关。</p>
<p>还是以上述的代码，这个时候显然 p1、p2 计算得到哈希值不是同一个，key 为 “test” 的数据计算出的哈希值也大概率和它们不同（类型都不一样）。</p>
<p>三者计算得到的哈希值不一样，但是经过哈希函数计算得到的索引可能是一样，可能不一样。如果索引一样，一般是 p1 与 p2 的索引一样，这时候发生哈希冲突，使用链地址法解决，又因为重写了<code>equals()</code>方法，很显然 p1 与 p2 是相等的，因此得到的 HashMap 长度是 2 。如果三者的索引都不一样，不会发生哈希冲突，那么得到的 HashMap 长度是 3 。</p>
<p>根据上面的说明，我们发现一个问题：没有实现<code>hashCode()</code>会导致不稳定。所谓不稳定指的就是两个对象的属性值是一样的，但是会不会覆盖是不一定的，可能覆盖也可能不覆盖。</p>
<blockquote>
<p>只实现hashCode()方法</p>
</blockquote>
<p>如果只实现<code>hashCode()</code>方法，而不实现<code>equals()</code>方法，那么进行相等性比较时会采取默认的方法。对于自定义的类型，比较的是内存地址，因此对于不同同一对象的不同示例，它们是不相等的。</p>
<p>依旧采用上述代码，因为实现了<code>hashCode()</code>方法，因此 p1、p2 计算得到的哈希值是一样的，那么通过哈希函数计算得到的索引也是一样的，而对于 key 为 “test” 的数据就有两种情况：</p>
<ul>
<li>哈希函数计算后得到的索引与 p1、p2 一样</li>
<li>哈希函数计算后得到的索引与 p1、p2 不一样</li>
</ul>
<p>当 key 为 “test” 的数据通过哈希函数计算后得到的索引与 p1、p2 一样时，这三个数据会发生哈希冲突，但是因为没实现<code>equals()</code>方法，使用内存地址进行相等性比较，它们三个的内存地址是不相等的，因此不存在覆盖，那么得到的 HashMap 长度是 3 。</p>
<p>当 key 为 “test” 的数据通过哈希函数计算后得到的索引与 p1、p2 不一样时，p1、p2 会发生哈希冲突，它俩的内存地址不同，也不会进行覆盖，最终得到的 HashMap 长度还是 3 。</p>
<blockquote>
<p>联系</p>
</blockquote>
<p>自定义对象作为 Key 时，最好同时重写 <code>hashCode()</code>、 <code>equals()</code> 方法。</p>
<p><code>equals()</code>：用以判断 2 个 Key 是否为同一个 Key</p>
<p><code>hashCode()</code>：必须保证<code>equals()</code>为 true 的2 个 Key 的哈希值一样</p>
<p>反过来，<code>hashCode()</code>相等的 Key，不一定<code>equals()</code>为 true</p>
<blockquote>
<p>总结</p>
</blockquote>
<p>在 Java 中， 如果一个对象要作为HashMap 的 key ，那么必须实现 <code>hashCode()</code>、 <code>equals()</code> 方法。</p>
<p>对于自定义类型的<code>Person</code>，有三个成员变量： <code>age</code> 、 <code>name</code>  和 <code>height</code>。假设我们认为两个对象的 age 和 name 相等时，它们就相等，因此在重写的<code>hashCode()</code>、 <code>equals()</code> 方法中必须包含 age 和 name 。</p>
<p>如果要 age、name、height都相等时才相等，那么在重写的<code>hashCode()</code>、 <code>equals()</code> 方法中必须包含 age 、 name 和 height。</p>
<p>重写的<code>hashCode()</code>、 <code>equals()</code> 方法中包含哪些成员变量是根据需求而定的。</p>
<h1 id="2-初步实现"><a class="header-anchor" href="#2-初步实现"></a>2. 初步实现</h1>
<p>在前文，我们已经介绍了 JDK8 中 HashMap 的实现，接下来我们也将自己实现一个 HashMap 。</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/DataStructureImages/JDK8哈希冲突解决.png" alt="JDK8哈希冲突解决" style="zoom:50%;" />
<p>我们首先要声明几点，为了便于编写：</p>
<ul>
<li>发生哈希冲突后，使用链地址法解决，其中使用红黑树，不再使用单链表</li>
<li>在哈希表中，每个桶内不存放红黑树对象，而是存放红黑树的根节点</li>
</ul>
<p>如果在哈希表中存放的红黑树节点，那么就不需要红黑树中的<code>size</code>成员变量。这个成员变量对于我们来说也确实是没用的，我们需要的是哈希表的 size ，而非每个桶内红黑树的的 size。</p>
<p>接下来，我们自己实现一个简单的 HashMap ！😎</p>
<h2 id="2-1-清空映射"><a class="header-anchor" href="#2-1-清空映射"></a>2.1 清空映射</h2>
<blockquote>
<p>简单方法实现</p>
</blockquote>
<p>先创建一个类，名为<code>HashMap</code>，然后实现<code>Map</code>接口（这个<code>Map</code>接口是<mark>集合与映射</mark>一文中编写的接口，在此不再提供代码）。</p>
<p>在完善<code>clear()</code>方法之前，我们可以先完善几个简单的方法。在实现 HashMap 时，肯定需要一个表示 Map 长度的成员变量，我们定这个成员变量为 size。根据这个成员变量，可以只实现两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实现清空 Map</p>
</blockquote>
<p>在实现<code>clear()</code>方法之前，可以先设置几个与红黑树有关的常量，再定义一个用于存储红黑树根节点的数组。既然需要存储红黑树根节点，自然少不了需要一个表示节点的类，我们把这个类命名为<code>Node</code>，并设置为内部类，最后可以完善一些构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">BLACK</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt;[] table; <span class="comment">// 存储的红黑树根节点</span></span><br><span class="line">    <span class="comment">// 哈希表数组默认容量 16</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Node</span>[DEFAULT_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略实现方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> RED;</span><br><span class="line">        Node&lt;K, V&gt; left;   <span class="comment">// 左节点</span></span><br><span class="line">        Node&lt;K, V&gt; right;  <span class="comment">// 右节点</span></span><br><span class="line">        Node&lt;K, V&gt; parent; <span class="comment">// 父节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value, Node&lt;K, V&gt; parent)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasTwoChildren</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前节点是否是其父节点的左子节点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeftChild</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parent != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span> == parent.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前节点是否是其父节点的右子节点</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRightChild</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parent != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span> == parent.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取兄弟节点</span></span><br><span class="line">        <span class="keyword">public</span> Node&lt;K, V&gt; <span class="title function_">sibling</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLeftChild()) &#123;</span><br><span class="line">                <span class="keyword">return</span> parent.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isRightChild()) &#123;</span><br><span class="line">                <span class="keyword">return</span> parent.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>编写<code>clear()</code>方法之前，明白它的一些步骤：</p>
<p>1、如果当前 Map 长度为 0 ，直接返回；</p>
<p>2、清空哈希表中每个桶存储的红黑树根节点；</p>
<p>3、令 Map 长度为 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">        table[i] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-添加元素"><a class="header-anchor" href="#2-2-添加元素"></a>2.2 添加元素</h2>
<p>添加元素方法，即：<code>put()</code>方法。该方法与<code>TreeMap</code>中的添加方法是一样的，但是在这次编写时，对其中部分代码进行了优化：当红黑树根节点不为空时（发生哈希冲突时），将原来的 <code>while</code> 循环变成 <code>do...while</code> 循环，这样做可以减少一次判断。因为这个时候的 root 节点一定不为 null ，同时又将 root 赋值给 node ，那么这个时候 node 一定不为 null ，可以直接进入循环以减少判断次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> index(key);</span><br><span class="line">    <span class="comment">// 取出 index 位置的红黑树根节点</span></span><br><span class="line">    Node&lt;K, V&gt; root = table[index];</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">        table[index] = root;</span><br><span class="line">        size++;</span><br><span class="line">        afterPut(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根节点不为空时，产生哈希冲突</span></span><br><span class="line">    <span class="comment">// 添加新的节点到红黑树</span></span><br><span class="line">    Node&lt;K, V&gt; parent = root;</span><br><span class="line">    Node&lt;K, V&gt; node = root;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环方式从 while 变为 do...while</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cmp = compare(key, node.key);</span><br><span class="line">        parent = node;  <span class="comment">// 保存父节点</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 相等</span></span><br><span class="line">            node.key = key; <span class="comment">// 相等时覆盖</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> node.value;</span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 到这一步时，是两个 key equals</span></span><br><span class="line"><span class="comment">                 * 表明两个 key 的哈希值一定相等</span></span><br><span class="line"><span class="comment">                 * 因此，可以不覆盖哈希值：</span></span><br><span class="line"><span class="comment">                 * node.hash = h1;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span> (node != <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 看看插入到父节点的哪个位置</span></span><br><span class="line">    Node&lt;K, V&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 添加节点后的处理 传入参数类型为Node</span></span><br><span class="line">    afterPut(newNode);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法第一步，我们使用方法<code>index()</code>获取哈希表 key 位置的红黑树根节点的索引，用于获取该索引下的红黑树跟节点，但我们还没有编写这个方法，该方法具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">index</span><span class="params">(K key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 高低16位混合运算再次生成哈希值</span></span><br><span class="line"><span class="comment">     * 因为 hashCode() 是用户实现，无法保证是否均匀使用了高低16位运算</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">return</span> (hash ^ (hash &gt;&gt;&gt; <span class="number">16</span>)) &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，我们还要将一些在红黑树中常用的方法复制到当前类中，比如：</p>
<ul>
<li><code>compare()</code> ：用于对产生哈希冲突而要添加至红黑树的节点的 key 和原红黑树节点 key 进行比较（不能直接使用复制过来的代码，在后续进行调整）</li>
<li><code>afterPut()</code> ： 向红黑树中添加元素后进行的调整</li>
<li><code>rotateLeft()</code> ： 左旋转</li>
<li><code>rotateRight()</code> ：右旋转</li>
<li><code>afterRotate()</code> ： 旋转之后的调整（该方法直接复制会出错，在后续进行调整）</li>
<li><code>color()</code> ： 给节点染色</li>
<li><code>red()</code> ： 使节点染红</li>
<li><code>black()</code> ： 使节点染黑</li>
<li><code>colorOf()</code> ：获取节点的颜色</li>
<li><code>isBlack()</code> ： 判断当前节点是否为黑色</li>
<li><code>isRed()</code> ： 判断当前节点是否为红色</li>
</ul>
<p>由于这些方法代码过多，再次不再列出，可以前往以前的博文查看。同时部分方法也存在出入，将会在下面的内容进行介绍~</p>
<h2 id="2-3-节点比较"><a class="header-anchor" href="#2-3-节点比较"></a>2.3 节点比较</h2>
<p>首先得强调： 用户向 HashMap 中添加数据是可以不考虑顺序、不考虑 Key 的可比较性。但是由于哈希冲突，我们选用了链地址法来解决，并引入了红黑树，而这需要对节点的 key 进行比较，但这也不是说必须具有可比较性，HashMap 有自己的比较方式，并不需要用户考虑。</p>
<p>我们得先理一下添加节点会进行覆盖的情况：哈希值一样，就会发生哈希冲突，使用<code>equals()</code>方法得到<code>true</code>后，新元素就会覆盖旧元素。</p>
<p>然后理一下比较的方式：</p>
<p>1、先比较哈希值，哈希值不相等时，返回减法运算结果</p>
<p>2、哈希值相等时，使用 <code>equals()</code> 进行比较，<code>equasl()</code>比较相等时，返回 0 ，进行覆盖</p>
<p>3、<code>equasl()</code>比较不相等时，对类名进行比较，类名不等时，返回较大的类名</p>
<p>4、类名相等时，如果具有可比较性，使用自己定义的方式进行比较</p>
<p>5、同一种类型，哈希值一样，但又不具备可比较性，使用内存地址的哈希值进行比较</p>
<p><mark>注意上面列出的方式是层层递进的！</mark></p>
<p>为了便于计算，也为了避免多次计算同一个节点的哈希值，我们可以在<code>Node</code>类中添加一个表示当前节点哈希值的成员变量，并修改构造方法，让节点在创建时就自动计算出 key 的哈希值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="type">int</span> hash; <span class="comment">// key 的哈希值</span></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> RED;</span><br><span class="line">    Node&lt;K, V&gt; left;   <span class="comment">// 左节点</span></span><br><span class="line">    Node&lt;K, V&gt; right;  <span class="comment">// 右节点</span></span><br><span class="line">    Node&lt;K, V&gt; parent; <span class="comment">// 父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value, Node&lt;K, V&gt; parent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.hash = key == <span class="literal">null</span> ? <span class="number">0</span> : key.hashCode();</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们修改从<code>TreeMap</code>中复制过来的<code>compare()</code>方法，并给它增加两个参数，这两个参数表示前两个参数的哈希值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h1 k1 的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h2 k2 的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(K k1, K k2, <span class="type">int</span> h1, <span class="type">int</span> h2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为增加了参数，对于<code>put()</code>方法也需要进行修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> index(key);</span><br><span class="line">    <span class="comment">// 取出 index 位置的红黑树根节点</span></span><br><span class="line">    Node&lt;K, V&gt; root = table[index];</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">        table[index] = root;</span><br><span class="line">        size++;</span><br><span class="line">        afterPut(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根节点不为空时，产生哈希冲突</span></span><br><span class="line">    <span class="comment">// 添加新的节点到红黑树</span></span><br><span class="line">    Node&lt;K, V&gt; parent = root;</span><br><span class="line">    Node&lt;K, V&gt; node = root;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h1</span> <span class="operator">=</span> key == <span class="literal">null</span> ? <span class="number">0</span> : key.hashCode();</span><br><span class="line">    <span class="comment">// 循环方式从 while 变为 do...while</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cmp = compare(key, node.key, h1,node.hash);</span><br><span class="line">        parent = node;  <span class="comment">// 保存父节点</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 相等</span></span><br><span class="line">            node.key = key; <span class="comment">// 相等时覆盖</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> node.value;</span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span> (node != <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 看看插入到父节点的哪个位置</span></span><br><span class="line">    Node&lt;K, V&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 添加节点后的处理 传入参数类型为Node</span></span><br><span class="line">    afterPut(newNode);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的<code>compare()</code>方法代码如下（仍有不足，稍后进行修改）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h1 k1 的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h2 k2 的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回值大于 0，表示 k1更大</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(K k1, K k2, <span class="type">int</span> h1, <span class="type">int</span> h2)</span>&#123;</span><br><span class="line">    <span class="comment">// 比较哈希值 且 不相等</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> h1 - h2;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">// 哈希值相等时，比较 equals()</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(k1, k2)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 哈希值相等，但并不 equals</span></span><br><span class="line">    <span class="comment">// 比较类名</span></span><br><span class="line">    <span class="keyword">if</span> (k1 != <span class="literal">null</span> &amp;&amp; k2 != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">k1Cls</span> <span class="operator">=</span> k1.getClass().getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">k2Cls</span> <span class="operator">=</span> k2.getClass().getName();</span><br><span class="line">        result = k1Cls.compareTo(k2Cls);</span><br><span class="line">        <span class="comment">// 类名不等时</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">// 同一种类型 判断是否具有可比较性</span></span><br><span class="line">        <span class="keyword">if</span> (k1 <span class="keyword">instanceof</span> Comparable)&#123;</span><br><span class="line">            <span class="keyword">return</span> ((Comparable) k1).compareTo(k2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同一种类型，哈希值一样，但不具备可比较性</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不为 null的对象哈希值也有可能为 0</span></span><br><span class="line"><span class="comment">     * 1. k1 不为 null，k2 为 null</span></span><br><span class="line"><span class="comment">     * 2. k1 为 null，k2 不为 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 利用内存地址算出的哈希值</span></span><br><span class="line">    <span class="keyword">return</span> System.identityHashCode(k1) - System.identityHashCode(k2); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于<code>compare()</code>方法，不能一开始就使用内存地址计算出哈希值进行比较，因为用户可能会自定义一些比较规则，我们必须在“走投无路”，实在没法的时候才使用内存地址计算出的哈希值进行比较。</p>
<p>写好<code>compare()</code>方法后，也代表<code>put()</code>方法写好了，我们可以编写一个测试方法。</p>
<hr>
<p>在编写测试方法前，我们需要先解决当前类中的一些错误。我们从<code>TreeMap</code>中复制到当前类的<code>afterRotate()</code>方法是有错的，因为当前类是一个<code>HashMap</code>，并没有红黑树的根节点<code>root</code>成员变量。但是哈希表的桶中存储的就是红黑树的根节点，我们可以编写一个方法，这个方法可以根据红黑树节点来获取哈希表的索引：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">index</span><span class="params">(Node&lt;K, V&gt; node)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (node.hash ^ (node.hash &gt;&gt;&gt; <span class="number">16</span>)) &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：上面的<code>index()</code>方法其实是方法的重载。</p>
<p>然后我们可以使用<code>index()</code>方法来修改<code>afterRotate()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">afterRotate</span><span class="params">(Node&lt;K, V&gt; grand, Node&lt;K, V&gt; parent, Node&lt;K, V&gt; child)</span> &#123;</span><br><span class="line">    <span class="comment">// 让 parent 成为根节点</span></span><br><span class="line">    parent.parent = grand.parent;</span><br><span class="line">    <span class="keyword">if</span> (grand.isLeftChild()) &#123;</span><br><span class="line">        grand.parent.left = parent;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grand.isRightChild()) &#123;</span><br><span class="line">        grand.parent.right = parent;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有父节点， grand是根节点</span></span><br><span class="line">        <span class="comment">// 修改前： root = parent </span></span><br><span class="line">        table[index(grand)] = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新其他节点的父节点</span></span><br><span class="line">    <span class="keyword">if</span> (child != <span class="literal">null</span>) &#123;</span><br><span class="line">        child.parent = grand;</span><br><span class="line">    &#125;</span><br><span class="line">    grand.parent = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发生了哈希冲突后才会在红黑树中添加非根节点的节点，也正是因为发生了哈希冲突，这些节点的索引是一样的。因此在<code>afterRotate()</code>方法中，获取红黑树的根节点时，<code>index()</code>方法类的参数可以是<code>afterRotate()</code>方法三个参数的任意一个： grand、parent、child，他们仨的索引都是一样的。</p>
<hr>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">20</span>, <span class="number">1.76f</span>, <span class="string">&quot;mofan&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">20</span>, <span class="number">1.76f</span>, <span class="string">&quot;mofan&quot;</span>);</span><br><span class="line">    Map&lt;Object, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(p1, <span class="number">1</span>);</span><br><span class="line">    map.put(p2, <span class="number">3</span>);</span><br><span class="line">    map.put(<span class="string">&quot;jack&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">&quot;rose&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">&quot;jack&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(map.size()); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-获取元素"><a class="header-anchor" href="#2-4-获取元素"></a>2.4 获取元素</h2>
<p>获取方法<code>get()</code>是根据一个 key 获取 HashMap 中的值，我们可以编写一个方法<code>node()</code>，这个方法可以根据 key 来获取节点。根据方法<code>node()</code>就可以很轻松地实现<code>get()</code>方法。</p>
<p><code>node()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">node</span><span class="params">(K key)</span> &#123;</span><br><span class="line">    Node&lt;K, V&gt; node = table[index(key)];</span><br><span class="line">    <span class="type">int</span> <span class="variable">h1</span> <span class="operator">=</span> key == <span class="literal">null</span> ? <span class="number">0</span> : key.hashCode();</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> compare(key, node.key, h1, node.hash);</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后轻松地实现<code>get()</code>方法，并且还可以实现<code>containsKey()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">    Node&lt;K, V&gt; node = node(key);</span><br><span class="line">    <span class="keyword">return</span> node != <span class="literal">null</span> ? node.value : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(K key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> node(key) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-删除元素"><a class="header-anchor" href="#2-5-删除元素"></a>2.5 删除元素</h2>
<p><code>Map</code>接口中的删除元素方法<code>remove(K key)</code>是根据 key 来进行删除的，而我们在自己编写的时候需要根据节点来进行删除，因此我们需要对原删除方法进行重载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">remove</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> node.value;</span><br><span class="line">    <span class="keyword">if</span> (node.hasTwoChildren()) &#123; <span class="comment">// 度为2的节点</span></span><br><span class="line">        <span class="comment">// 找到后继节点</span></span><br><span class="line">        Node&lt;K, V&gt; s = successor(node);</span><br><span class="line">        <span class="comment">// 用后继节点的值覆盖被删除节点的值</span></span><br><span class="line">        node.key = s.key;</span><br><span class="line">        node.value = s.value;</span><br><span class="line">        <span class="comment">// 节点的哈希值也要覆盖，不然还是以前节点的哈希值</span></span><br><span class="line">        node.hash = s.hash;</span><br><span class="line">        <span class="comment">// 变量node指向其后继节点，等待后续删除</span></span><br><span class="line">        node = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除node节点（node的度必然为1或0）</span></span><br><span class="line">    Node&lt;K, V&gt; replacement = node.left != <span class="literal">null</span> ? node.left : node.right;</span><br><span class="line">    <span class="comment">// 获取红黑树节点在哈希表中的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> index(node);</span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="literal">null</span>) &#123;   <span class="comment">// node度为1</span></span><br><span class="line">        <span class="comment">// 更改parent</span></span><br><span class="line">        replacement.parent = node.parent;</span><br><span class="line">        <span class="comment">// 更改node的parent的left、right的指向</span></span><br><span class="line">        <span class="keyword">if</span> (node.parent == <span class="literal">null</span>) &#123; <span class="comment">// node度为1，且为根节点</span></span><br><span class="line">            table[index] = replacement;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">            node.parent.left = replacement;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// node == node.parent.right</span></span><br><span class="line">            node.parent.right = replacement;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        afterRemove(replacement);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.parent == <span class="literal">null</span>) &#123; <span class="comment">// node度为0，是叶子节点，并且是根节点</span></span><br><span class="line">        table[index] = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 被删除的节点</span></span><br><span class="line">        afterRemove(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// node是叶子节点，但不是根节点</span></span><br><span class="line">        <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">            node.parent.left = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.parent.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 被删除的节点</span></span><br><span class="line">        afterRemove(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在重载方法中用到了获取后继节点的方法，因此我们需要将获取后继节点的方法<code>successor()</code>复制到当前类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">successor</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 后继节点在右子树中</span></span><br><span class="line">    Node&lt;K, V&gt; p = node.right;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从“祖宗节点”中寻找后继节点</span></span><br><span class="line">    <span class="keyword">while</span> (node.parent != <span class="literal">null</span> &amp;&amp; node == node.parent.right) &#123;</span><br><span class="line">        node = node.parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// node.parent == null || node == node.parent.left</span></span><br><span class="line">    <span class="keyword">return</span> node.parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在原删除方法中调用重载的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(K key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> remove(node(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-6-发现问题"><a class="header-anchor" href="#2-6-发现问题"></a>2.6 发现问题</h2>
<p><mark>注意： 以下测试涉及到内存地址，不同的测试环境输出不同。</mark></p>
<p>到此，我们已经实现了HashMap的所有接口，并进行了简单的测试，我们发现似乎都没有问题，其实非也，我们再进行一下测试。</p>
<p>先编写一个模型类<code>Key</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Key</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Key</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value / <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="built_in">this</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || obj.getClass() != getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> ((Key) obj).value == value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;v(&quot;</span> + value + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后编写一个测试类，使用刚刚新创建的模型类进行测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    Map&lt;Object, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">19</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 这 19 个元素都在同一个红黑树上</span></span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Key</span>(i), i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(map.size()); <span class="comment">// 应该输出 19 </span></span><br><span class="line">    System.out.println(map.get(<span class="keyword">new</span> <span class="title class_">Key</span>(<span class="number">8</span>))); <span class="comment">// 应该输出 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际输出结果为： 19 和 null ，与我们的预想不一致。😥</p>
<p>可以在这个方法中让 map 调用<code>traversal()</code>方法看一下红黑树的节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map.traversal(<span class="keyword">new</span> <span class="title class_">Map</span>.Visitor&lt;Object, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">visit</span><span class="params">(Object key, Integer value)</span> &#123;</span><br><span class="line">        System.out.println(key + <span class="string">&quot;_&quot;</span> + value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然后查看结果，我们发现从 1 到 19 都是有的，但是为什么获取 8 的时候却打印的 <code>null</code> 呢？</p>
<p>这下换一个数字，假设我们获取 1，看看能否获取成功，结果发现 1 又可以被打印出现。</p>
<p>这就出现了一个问题： 不稳定！</p>
<p>为什么会出现这种情况呢？其主要原因就是<code>compare()</code>方法的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(K k1, K k2, <span class="type">int</span> h1, <span class="type">int</span> h2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> h1 - h2;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(k1, k2)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k1 != <span class="literal">null</span> &amp;&amp; k2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">k1Cls</span> <span class="operator">=</span> k1.getClass().getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">k2Cls</span> <span class="operator">=</span> k2.getClass().getName();</span><br><span class="line">        result = k1Cls.compareTo(k2Cls);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">if</span> (k1 <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Comparable) k1).compareTo(k2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> System.identityHashCode(k1) - System.identityHashCode(k2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在比较两个 value（差值小于20） 不同的 Key 对象时，这两个 Key 对象的哈希值是一样的，但又不 equals ，也没有比较性，因此在比较时就会到<code>compare()</code>方法的最后一步，使用内存地址进行比较，也就是使用了内存地址进行比较，导致出现不稳定的现象。</p>
<p>为什么说使用内存地址比较会出现不稳定的现象呢？假设在哈希表的桶中已经存放了一棵红黑树，同时在红黑树的左子树中有一个 Key 对象，名叫 A ，A 的 value 为 1。这时候我新创建一个 Key 对象，名叫 B，B 的 value 也是 1 ，并且我想要查询当前 HashMap 中是否存在以 B 为 key 的数据。由于<code>Key</code>类中定义了哈希值的计算方法， A 和 B 的哈希值都是一样的。根据前面的分析， 会在 A 所在的红黑树中进行搜索查找。</p>
<p>假设运气好， B 的内存地址的哈希值比根节点的内存地址的哈希值要小，然后又一路比较，最后恰好与 A 进行比较，A 和 B 的哈希值一样，进行 equals 比较，他们的 value 又一样，表明它俩 equals 。就是说，当前 HashMap 中<mark>存在</mark>以 B 为 key 的数据。😁</p>
<p>假设运气不好， B 的内存地址的哈希值比根节点的内存地址的哈希值要大，或者比根节点的内存地址的哈希值要小，但在一路向下比较的时候出了岔子，导致找到叶子节点（非空，不是指红黑树中假想的叶子节点）时，也没有发现一个节点的 value 与 B 的 value 相等。就是说，当前 HashMap 中<mark>不存在</mark>以 B 为 key 的数据。😔</p>
<p>这也太离谱了吧？合着我比较节点还得靠运气？运气好就能找到，运气不好还找不到了？😡</p>
<p>这就是因为比较内存地址的哈希值带来的危害，我们需要对其进行修复。</p>
<h2 id="2-7-方法修改"><a class="header-anchor" href="#2-7-方法修改"></a>2.7 方法修改</h2>
<p>由于比较方法<code>compare()</code>出现的问题，我们放弃该方法的使用，但是代码中多处使用了<code>compare()</code>方法，我们需要对使用了<code>compare()</code>方法的地方进行改写。有两个地方使用了<code>compare()</code>方法：</p>
<p>1、根据 key 获取值<code>get()</code> （查询当前映射是否存在某个 key<code>containsKey()</code>）</p>
<p>2、添加元素<code>put()</code></p>
<blockquote>
<p>修改优化node()方法</p>
</blockquote>
<p>在第一种情况里，主要使用了<code>node()</code>方法，该方法是<strong>查询映射中以 key 为键的节点</strong> ，如果存在返回那个节点，否则返回 null 。</p>
<p>以前的<code>node()</code>方法中，使用了<code>compare()</code>方法来对两个节点进行比较。</p>
<p>这里简单说一下为什么要使用<code>compare()</code>方法进行比较：因为我们需要根据 key 来获取值，知道 key 就可以知道求得 key 的哈希值，然后自然地得到这个 key 对应的哈希表索引。但是并不是这个索引对应的值就是我们需要的，因为可能发生哈希冲突，这个索引对应的桶内有一棵红黑树，我们需要用当前的 key 与红黑树中节点的 key 进行比较，然后遍历红黑树查询是否存在当前 key 对应的值（value）。</p>
<p>因为<code>compare()</code>方法存在弊端，放弃使用该方法，需要改写<code>node()</code>方法，达成上面的描述。</p>
<p>实现也很简单，基本相当于将<code>compare()</code>中的代码复制过来，但是在两个 key 存在：“ 哈希值相等，不具备可比较性，也不equals ”的情况下，不能使用内存地址进行比较，而是采取扫描整棵红黑树的方式进行比较，在这其中就会使用到递归。</p>
<hr>
<p><strong>方法优化：</strong></p>
<p>使用扫描后，我们引进了递归的方式进行扫描。当我们先扫描 node.right 未得到满意的结果时，进而扫描 node.left ，其实在扫描 node.left 时就是将 node.left 传入了方法<code>node(Node&lt;K, V&gt; node, K k1)</code>中。根据这个原理，我们可以对方法进行优化，直接使 <code>node = node.left</code> 以减少递归次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要使用的方法</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">node</span><span class="params">(K key)</span> &#123;</span><br><span class="line">    Node&lt;K, V&gt; root = table[index(key)];</span><br><span class="line">    <span class="comment">// 递归查找</span></span><br><span class="line">    <span class="keyword">return</span> root == <span class="literal">null</span> ? <span class="literal">null</span> : node(root, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归的方法</span></span><br><span class="line"><span class="comment">// 根据 key 查询节点</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">node</span><span class="params">(Node&lt;K, V&gt; node, K k1)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h1</span> <span class="operator">=</span> k1 == <span class="literal">null</span> ? <span class="number">0</span> : k1.hashCode();</span><br><span class="line">    <span class="comment">// 存储查找结果</span></span><br><span class="line">    Node&lt;K, V&gt; result = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h2</span> <span class="operator">=</span> node.hash;</span><br><span class="line">        <span class="type">K</span> <span class="variable">k2</span> <span class="operator">=</span> node.key;</span><br><span class="line">        <span class="comment">// 先比较哈希值</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * int cmp = h1 - h2;</span></span><br><span class="line"><span class="comment">             * 使用减法比较大小是不靠谱的，因为 int 可能会溢出，减去一个负数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">if</span> (h1 &gt; h2) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h1 &lt; h2) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">            <span class="comment">// 哈希值相等，是否 equals</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Objects.equals(k1, k2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">            <span class="comment">// 哈希值相等，但不equals，是否有可比较性</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k1 != <span class="literal">null</span> &amp;&amp; k2 != <span class="literal">null</span></span><br><span class="line">                   &amp;&amp; k1.getClass() == k2.getClass()</span><br><span class="line">                   &amp;&amp; k1 <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> ((Comparable) k1).compareTo(k2);</span><br><span class="line">            <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 哈希值相等，不equals，也不具备可比较性，使用扫描（递归）</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right != <span class="literal">null</span></span><br><span class="line">                   &amp;&amp; (result = node(node.right, k1)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只能往左边找</span></span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//            &#125; else if (node.left != null</span></span><br><span class="line">        <span class="comment">//                    &amp;&amp; (result = node(node.left, k1)) != null) &#123;</span></span><br><span class="line">        <span class="comment">//                return result;</span></span><br><span class="line">        <span class="comment">//            &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//                return null;</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>修改优化put()方法</p>
</blockquote>
<p><code>put()</code>方法中也使用了<code>compare()</code>方法，放弃使用<code>compare()</code>方法，并对<code>put()</code>进行改写。改写使用的方式与原来的<code>compare()</code>方法差不多，但是也有些变化。如果不存在参数中传递的 key 时，还是只能使用内存地址比较。</p>
<p>为了不过多的修改代码，还需要注意修改的方式，注意理解代码中局部变量<code>node</code>与<code>result</code>的关系和区别。</p>
<hr>
<p><strong>代码优化：</strong></p>
<p>由于舍弃<code>compare()</code>方法，引入扫描的机制，但需要注意的是，直接像<code>node(Node&lt;K, V&gt; node, K k1)</code>方法一样进行扫描时会存在重复扫描的情况。</p>
<p>假设我新插入一个映射 A，A 会与当前映射中其他映射发生哈希冲突，且发生冲突的桶中的红黑树节点的 key 的哈希值相等，但不 equals ，它们也没有可比较性，映射 A 的 key 亦是如此。这时就会扫描整棵红黑树查看是否存在节点的 key 与 A 的 key 相等，如果存在就覆盖，不存在就比较当前红黑树根节点 key 与A的 key 内存地址的哈希值，确定 A 的插入位置。</p>
<p>又假设根节点 key 内存地址的哈希值较大，那么 A 的插入位置就会在当前红黑树的左子树。但这只是第一步，还要充分确定A的插入位置。由于循环，又会进行一系列判断，并扫描当前红黑树的左子树，扫描当然是无果的，因为我们最开始已经扫描了一遍，最后会比较根节点的左子节点的 key 与 A 的 key 内存地址的哈希值，进一步确定 A 的插入位置。</p>
<p>重复以上操作，直到确定 A 的插入位置。在确定位置的过程中，我们发现对这棵红黑树进行了多次且不必要的扫描，而降低了效率。其实我们只需要进行一次扫描，后续比较内存地址的哈希值即可。因此可以引入一个成员变量<code>searched</code>来表示是否扫描了红黑树搜索了 A 的 key，以达到增加效率的目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> index(key);</span><br><span class="line">    <span class="comment">// 取出 index 位置的红黑树根节点</span></span><br><span class="line">    Node&lt;K, V&gt; root = table[index];</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">        table[index] = root;</span><br><span class="line">        size++;</span><br><span class="line">        afterPut(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根节点不为空时，产生哈希冲突</span></span><br><span class="line">    <span class="comment">// 添加新的节点到红黑树</span></span><br><span class="line">    Node&lt;K, V&gt; parent = root;</span><br><span class="line">    Node&lt;K, V&gt; node = root;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">K</span> <span class="variable">k1</span> <span class="operator">=</span> key;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h1</span> <span class="operator">=</span> k1 == <span class="literal">null</span> ? <span class="number">0</span> : k1.hashCode();</span><br><span class="line">    Node&lt;K, V&gt; result = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否已经搜索过 key</span></span><br><span class="line">    <span class="comment">// 循环方式从 while 变为 do...while</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = node;  <span class="comment">// 保存父节点</span></span><br><span class="line">        <span class="type">K</span> <span class="variable">k2</span> <span class="operator">=</span> node.key;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h2</span> <span class="operator">=</span> node.hash;</span><br><span class="line">        <span class="keyword">if</span> (h1 &gt; h2) &#123;</span><br><span class="line">            cmp = <span class="number">1</span>; <span class="comment">// cmp &gt; 0，向右遍历</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h1 &lt; h2) &#123;</span><br><span class="line">            cmp = -<span class="number">1</span>; <span class="comment">// cmp &lt; 0，向左遍历</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Objects.equals(k1, k2)) &#123;</span><br><span class="line">            cmp = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k1 != <span class="literal">null</span> &amp;&amp; k2 != <span class="literal">null</span></span><br><span class="line">                   &amp;&amp; k1.getClass() == k2.getClass()</span><br><span class="line">                   &amp;&amp; k1 <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">            cmp = ((Comparable) k1).compareTo(k2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (searched) &#123; <span class="comment">// 已经扫描了</span></span><br><span class="line">            cmp = System.identityHashCode(k1) - System.identityHashCode(k2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// searched == false 还没扫描，先扫描再根据内存地址大小左右</span></span><br><span class="line">            <span class="keyword">if</span> ((node.left != <span class="literal">null</span></span><br><span class="line">                 &amp;&amp; (result = node(node.left, k1)) != <span class="literal">null</span>)</span><br><span class="line">                || (node.right != <span class="literal">null</span></span><br><span class="line">                    &amp;&amp; (result = node(node.right, k1)) != <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// 已经存在这个 key ，进行覆盖</span></span><br><span class="line">                <span class="comment">// 需要覆盖的是 result，为了代码复用，使 node = result</span></span><br><span class="line">                node = result;</span><br><span class="line">                cmp = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不存在这个 key 时，使用内存地址比较</span></span><br><span class="line">                searched = <span class="literal">true</span>;</span><br><span class="line">                cmp = System.identityHashCode(k1) - System.identityHashCode(k2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 相等</span></span><br><span class="line">            node.key = key; <span class="comment">// 相等时覆盖</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> node.value;</span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 到这一步时，是两个 key equals</span></span><br><span class="line"><span class="comment">                 * 表明两个 key 的哈希值一定相等</span></span><br><span class="line"><span class="comment">                 * 因此，可以不覆盖哈希值：</span></span><br><span class="line"><span class="comment">                 * node.hash = h1;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node != <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 看看插入到父节点的哪个位置</span></span><br><span class="line">    Node&lt;K, V&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 添加节点后的处理 传入参数类型为Node</span></span><br><span class="line">    afterPut(newNode);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-8-compareTo"><a class="header-anchor" href="#2-8-compareTo"></a>2.8 compareTo</h2>
<p>尽管我们放弃使用<code>compare()</code>方法，并对<code>node()</code>方法和<code>put()</code>方法进行了改写、优化，但是这其中依旧存在着问题。</p>
<blockquote>
<p>发现问题</p>
</blockquote>
<p>假设现在又有一个模型类<code>Person</code>，这个类不仅重写<code>equals()</code>方法，还实现了<code>Comparable</code>接口，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> height;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, <span class="type">float</span> height, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> Integer.hashCode(age);</span><br><span class="line">        hashCode = hashCode * <span class="number">31</span> + Float.hashCode(height);</span><br><span class="line">        hashCode = hashCode * <span class="number">31</span> + (name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123; <span class="comment">// 是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="built_in">this</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || obj.getClass() != getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> ((Person) obj);</span><br><span class="line">        <span class="keyword">return</span> person.age == age &amp;&amp; person.height == height</span><br><span class="line">                &amp;&amp; valueEquals(person.name, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">valueEquals</span><span class="params">(Object v1, Object v2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 == <span class="literal">null</span> ? v2 == <span class="literal">null</span> : v1.equals(v2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// age 较大的对象更大</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123; <span class="comment">// 比大小</span></span><br><span class="line">        <span class="keyword">return</span> age - o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>equals()</code>方法用于判断这个实体类实例化的对象们是否相等，而<code>compareTo()</code>方法用于比较这个实体类实例化的对象们的大小。当大小相等，并不代表这两个对象相等，就像给出的示例代码一样，大小相等只表示这两个对象的 age 相等，但是它们其他的属性可能不相等。</p>
<p>在二叉搜索树中，节点一定是具有可比较性的，要么实体类实现<code>Comparable</code>接口，要么自定义了比较器，因此可以仅靠比较大小就确定节点的位置（大小相等就可以覆盖）。但是在 HashMap 中不是这样的，对于 HashMap 中的节点，它们的可比较性并不是必须的，这就表明对象的大小相等时是不能覆盖的，有且仅当两个对象 equals 时才可以进行覆盖。</p>
<p>现有一段测试代码，输出结果已经注释出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">10</span>, <span class="number">1.7f</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">10</span>, <span class="number">1.8f</span>, <span class="string">&quot;rose&quot;</span>);</span><br><span class="line">    System.out.println(p1.equals(p2)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(p1.compareTo(p2)); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 p1、p2 对象作为 Map 的 key，value任取先后存入 HashMap 中。根据先前编写的代码，先回判断 p1、p2 是否 equals，显然是不 equals 的。然后发现两个具有可比较性，就使用<code>compareTo()</code>方法进行比较，由于<code>Person</code>实体类中重写的方法，这一比较，p1 和 p2 的大小是相等的，就会令<code>cmp = 0</code>，从而使用 p2 覆盖 p1 ，这显然不是我们想要的。</p>
<p>因此，我们<mark>需要排除当两个 key 大小相等就进行覆盖的操作</mark> 。</p>
<blockquote>
<p>问题解决</p>
</blockquote>
<p>上述所说的情况在<code>node()</code>方法和<code>put()</code>方法中都存在，我们都需要进行解决。</p>
<p>解决方法就是当两个 key 大小相等时，不进行覆盖操作，也不进行其他操作，即：不进行任何操作，但是会落入下一个判断，进行全树扫描。</p>
<p>修改代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(k1, k2)) &#123;</span><br><span class="line">        cmp = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k1 != <span class="literal">null</span> &amp;&amp; k2 != <span class="literal">null</span></span><br><span class="line">               &amp;&amp; k1.getClass() == k2.getClass()</span><br><span class="line">               &amp;&amp; k1 <span class="keyword">instanceof</span> Comparable</span><br><span class="line">               &amp;&amp; (cmp = ((Comparable) k1).compareTo(k2)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 此时 k1、k2一定不为同一个对象，因此在这进行比大小</span></span><br><span class="line">        <span class="comment">// cmp 结果 &gt; 0 &lt; 0 == 0</span></span><br><span class="line">        <span class="comment">// cmp == 0 时，不进行操作，直接前往下一个判断</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (searched) &#123; <span class="comment">// 已经扫描了</span></span><br><span class="line">        cmp = System.identityHashCode(k1) - System.identityHashCode(k2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// searched == false 还没扫描，先扫描再根据内存地址大小左右</span></span><br><span class="line">        <span class="keyword">if</span> ((node.left != <span class="literal">null</span></span><br><span class="line">             &amp;&amp; (result = node(node.left, k1)) != <span class="literal">null</span>)</span><br><span class="line">            || (node.right != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; (result = node(node.right, k1)) != <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 已经存在这个 key ，进行覆盖</span></span><br><span class="line">            <span class="comment">// 需要覆盖的是 result，为了代码复用，使 node = result</span></span><br><span class="line">            node = result;</span><br><span class="line">            cmp = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不存在这个 key 时，使用内存地址比较</span></span><br><span class="line">            searched = <span class="literal">true</span>;</span><br><span class="line">            cmp = System.identityHashCode(k1) - System.identityHashCode(k2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">node</span><span class="params">(Node&lt;K, V&gt; node, K k1)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(k1, k2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">            <span class="comment">// 哈希值相等，但不equals，是否有可比较性</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k1 != <span class="literal">null</span> &amp;&amp; k2 != <span class="literal">null</span></span><br><span class="line">                   &amp;&amp; k1.getClass() == k2.getClass()</span><br><span class="line">                   &amp;&amp; k1 <span class="keyword">instanceof</span> Comparable</span><br><span class="line">                   &amp;&amp; (cmp = ((Comparable) k1).compareTo(k2)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 此时已排除 cmp == 0 的情况</span></span><br><span class="line">            node = cmp &gt; <span class="number">0</span> ? node.right : node.left;</span><br><span class="line">            <span class="comment">// cmp == 0 时，不进行操作，直接前往下一个判断</span></span><br><span class="line">            <span class="comment">// 哈希值相等，不equals，也不具备可比较性，使用扫描（递归）</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right != <span class="literal">null</span></span><br><span class="line">                   &amp;&amp; (result = node(node.right, k1)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只能往左边找</span></span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-9-深度理解"><a class="header-anchor" href="#2-9-深度理解"></a>2.9 深度理解</h2>
<p>在前几节，我们花了大量的精力编写、优化<code>node()</code>方法和<code>put()</code>方法，在这两个方法中出现了许多情况，同时也产生了很多的 <code>if</code> 判断，由此就可以产生一些疑问：那么多的判断有必要吗？如果有必要又有什么用呢？</p>
<p>我们首先要清楚进行了那些判断：</p>
<p>1、哈希值的比较</p>
<p>2、哈希值相等的情况下，进行 equals 判断</p>
<p>3、前两种比较无果的情况下，判断k1、k2有无可比较性，然后使用 <code>compareTo()</code> 进行比较</p>
<p>4、前三种比较无果的情况下，在红黑树中进行 k1 的扫描</p>
<p>我们可以在<code>put()</code>方法中去掉第一种和第三种判断，只使用第二种和第四种的判断，同时在<code>node()</code>方法中也要移除第一种和第三种判断。那这又是为什么呢？😦</p>
<p>我们在前面编写代码时，<code>put()</code>方法和<code>node()</code>方法存在相似的逻辑判断，这是有意为之的，使用相似的逻辑判断可以减少判断次数。如果判断逻辑不一样， 比如<code>node()</code>方法中先进行 equals 判断，再进行哈希值的比较，在<code>put()</code>方法中恰好在第一步哈希值的比较中就得出结果，那么后续获取元素时就会多进行一次判断。</p>
<p>我们重回主题，去掉两种判断后是不影响 HashMap 的功能的，依旧可以正常插入元素、获取元素，但是会带来效率的损失，比如我使用 HashMap 来统计单词数（共1072799个存在重复的单词）：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/DataStructureImages/%E5%8F%AA%E6%9C%89equals.png" alt="只有equals"></p>
<p>耗时两分钟，最终统计结果：共有514483个不同的单词。</p>
<p>然后我们在<code>put()</code>方法和<code>node()</code>中重新添加哈希值的比较，再次进行统计（共1072799个存在重复的单词）：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/DataStructureImages/%E5%A2%9E%E5%8A%A0%E5%93%88%E5%B8%8C%E5%80%BC%E6%AF%94%E8%BE%83.png" alt="增加哈希值比较"></p>
<p>耗时只用了半秒钟，效率得到了巨大的提升。</p>
<p>这是因为单词数量巨大，大量的单词之间并不 equals ，如果没有哈希值的比较进行判断，最终就会进行全节点扫描，而扫描会消耗大量的时间；如果一开始就有哈希值的比较，直接使用单词的哈希值就可以减少一半的搜索量，从而使效率得到巨大的提升。😳</p>
<p>最后我们将第三种判断也添加上去，再次进行测试时，发现耗时可能出现耗时增加的情况。不要慌张！ 这是正常情况！😎 耗时增加时，可能只是数据量不够多的原因，如果数据量足够大，可以看出耗时的减少。当我们增加判断规则时，就会减少全节点扫描的情况，效率会得到增加。</p>
<p>下图是我添加第三种判断后的耗时（开始忘记截图，后面才发现，不要吐槽为啥时间差那么多😂）：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/DataStructureImages/%E6%B7%BB%E5%8A%A0%E5%8F%AF%E6%AF%94%E8%BE%83%E6%80%A7%E8%A7%84%E5%88%99.png" alt="添加可比较性规则"></p>
<blockquote>
<p>Q &amp; A</p>
</blockquote>
<p><strong>Q1</strong>： 为什么要先比较哈希值，再进行 equals 判断？</p>
<p><strong>A1</strong>：当我们元素数量很多时(10w个)，这个时候新添加一个元素，而这个元素的 key_1 在现在的HashMap 中并不存在，因此哈希表中不存在与新添加元素的 key_1 equals 的 key_2 。如果先 equals 会多进行一次判断，一般的场景的，添加进去的大多数 key 与原 HashMap 中的 key 都不是不 equals 的，因此先比较哈希值就可以排除一大半的元素比较。</p>
<hr>
<p><strong>Q2</strong>：在<code>put()</code>方法中最后的判断会使用 key 的内存地址进行比较，但是在<code>node()</code>方法中又没有使用内存地址进行查询，那么使用内存地址进行比较是否显得多余？</p>
<p><strong>A2</strong>：首先需要说明为什么<code>node()</code>方法中没有使用内存地址进行查询，并不是不使用，而是不能使用，因为内存地址在不同的环境中可能是不一样的，如果使用内存地址进行查询可能会造成无法预料的结果，因此在<code>node()</code>方法中使用的是全节点扫描。回到正题，<code>put()</code>方法中最后确实可以不使用 key 的内存地址进行比较，甚至可以写死 cmp，直接使<code>cmp = 1;</code>或者<code>cmp = -1;</code>，但是这样做会使红黑树插入节点后的调整（经常调用<code>afterPut()</code>方法）变得频繁，进而降低效率。因此，是需要在这里指定一个规则的。</p>
<p>那么使用随机数来指定可以吗？<code>cmp = Math.random() &gt; 0.5 ? -1 : 1;</code>，单从实现的角度讲是可以的，但是为了方便使用人员调试，还是使用一种明确、显式的规则更好，因此就选择使用内存地址进行比较。</p>
<h2 id="2-10-哈希调整"><a class="header-anchor" href="#2-10-哈希调整"></a>2.10 哈希调整</h2>
<p>在之前编写代码中有这样两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">index</span><span class="params">(K key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="keyword">return</span> (hash ^ (hash &gt;&gt;&gt; <span class="number">16</span>)) &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">index</span><span class="params">(Node&lt;K, V&gt; node)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (node.hash ^ (node.hash &gt;&gt;&gt; <span class="number">16</span>)) &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这两个方法中，<code>node.hash ^ (node.hash &gt;&gt;&gt; 16)</code>被我们成为“ <strong>扰动计算</strong> ”，而这两个方法中都书写了扰动计算，使代码显得很臃肿、复杂，我们可以对代码进行优化、提取公共代码。</p>
<p>当 key 已经确定时，那么它的哈希值也已经确定了。因此，我们可以在创建节点对象<code>Node</code>的时候就将经过扰动计算的哈希值作为对象的属性值，因此可以改写静态嵌套类 <code>Node&lt;K, V&gt;</code> 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value, Node&lt;K, V&gt; parent)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.key = key;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key == <span class="literal">null</span> ? <span class="number">0</span> : key.hashCode();</span><br><span class="line">    <span class="comment">// 扰动计算</span></span><br><span class="line">    <span class="built_in">this</span>.hash = hash ^ (hash &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.parent = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然哈希值是确定的，而哈希表容量也是确定的，为什么不直接计算出索引呢？直接计算出索引岂不是更好？在这 是不能直接计算出索引的，因为哈希表的容量在一定条件下是要进行扩容的，就是说<code>table.length</code>是会改变的。具体是怎么扩容的将会在下面的内容介绍！ 😜</p>
<p>然后我们可以编写一个私有的方法<code>hash(K key)</code>，这个方法通过传递一个参数 key ，然后返回经过扰动计算后的哈希值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(K key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="keyword">return</span> hash ^ (hash &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再然后，对<code>index()</code>方法进行改写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">index</span><span class="params">(K key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> hash(key) &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">index</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">    <span class="comment">//        return (node.hash ^ (node.hash &gt;&gt;&gt; 16)) &amp; (table.length - 1);</span></span><br><span class="line">    <span class="keyword">return</span> node.hash &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，对一些使用到<code>Node</code>的<code>hash</code>属性值的代码进行改写：</p>
<p>⚠️ <mark>警告！以下涉及大量代码，请注意折叠！</mark> ⚠️</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 key 查询节点</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">node</span><span class="params">(Node&lt;K, V&gt; node, K k1)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h1</span> <span class="operator">=</span> hash(k1); <span class="comment">// 对 k1 进行扰动计算</span></span><br><span class="line">    <span class="comment">// 存储查找结果</span></span><br><span class="line">    Node&lt;K, V&gt; result = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h2</span> <span class="operator">=</span> node.hash;</span><br><span class="line">        <span class="type">K</span> <span class="variable">k2</span> <span class="operator">=</span> node.key;</span><br><span class="line">        <span class="comment">// 先比较哈希值</span></span><br><span class="line">        <span class="keyword">if</span> (h1 &gt; h2) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h1 &lt; h2) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Objects.equals(k1, k2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k1 != <span class="literal">null</span> &amp;&amp; k2 != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; k1 <span class="keyword">instanceof</span> Comparable</span><br><span class="line">                &amp;&amp; k1.getClass() == k2.getClass()</span><br><span class="line">                &amp;&amp; (cmp = ((Comparable) k1).compareTo(k2)) != <span class="number">0</span>) &#123;</span><br><span class="line">            node = cmp &gt; <span class="number">0</span> ? node.right : node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; (result = node(node.right, k1)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只能往左边找</span></span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> index(key);</span><br><span class="line">    <span class="comment">// 取出 index 位置的红黑树根节点</span></span><br><span class="line">    Node&lt;K, V&gt; root = table[index];</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">        table[index] = root;</span><br><span class="line">        size++;</span><br><span class="line">        afterPut(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根节点不为空时，产生哈希冲突</span></span><br><span class="line">    <span class="comment">// 添加新的节点到红黑树</span></span><br><span class="line">    Node&lt;K, V&gt; parent = root;</span><br><span class="line">    Node&lt;K, V&gt; node = root;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">K</span> <span class="variable">k1</span> <span class="operator">=</span> key;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h1</span> <span class="operator">=</span> hash(k1); <span class="comment">// 对 k1 进行扰动计算</span></span><br><span class="line">    Node&lt;K, V&gt; result = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否已经搜索过 key</span></span><br><span class="line">    <span class="comment">// 循环方式从 while 变为 do...while</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = node;  <span class="comment">// 保存父节点</span></span><br><span class="line">        <span class="type">K</span> <span class="variable">k2</span> <span class="operator">=</span> node.key;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h2</span> <span class="operator">=</span> node.hash;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 先比较哈希值，再进行 equals</span></span><br><span class="line"><span class="comment">             * 当我们元素数量很多时(10w个)，这个时候新添加一个元素</span></span><br><span class="line"><span class="comment">             * 这个元素的key在现在的HashMap中并不存在</span></span><br><span class="line"><span class="comment">             * 如果先 equals 会多进行一次判断</span></span><br><span class="line"><span class="comment">             * 一般的场景的，添加进去的大多数 key 也都是不equals的</span></span><br><span class="line"><span class="comment">             * 因此先比较哈希值就可以排除一大半的元素比较</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">if</span> (h1 &gt; h2) &#123;</span><br><span class="line">            cmp = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h1 &lt; h2) &#123;</span><br><span class="line">            cmp = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Objects.equals(k1, k2)) &#123;</span><br><span class="line">            cmp = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k1 != <span class="literal">null</span> &amp;&amp; k2 != <span class="literal">null</span></span><br><span class="line">                   &amp;&amp; k1 <span class="keyword">instanceof</span> Comparable</span><br><span class="line">                   &amp;&amp; k1.getClass() == k2.getClass()</span><br><span class="line">                   &amp;&amp; (cmp = ((Comparable) k1).compareTo(k2)) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (searched) &#123; <span class="comment">// 已经扫描了</span></span><br><span class="line">            cmp = System.identityHashCode(k1) - System.identityHashCode(k2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// searched == false 还没扫描，先扫描再根据内存地址大小左右</span></span><br><span class="line">            <span class="keyword">if</span> ((node.left != <span class="literal">null</span></span><br><span class="line">                 &amp;&amp; (result = node(node.left, k1)) != <span class="literal">null</span>)</span><br><span class="line">                || (node.right != <span class="literal">null</span></span><br><span class="line">                    &amp;&amp; (result = node(node.right, k1)) != <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// 已经存在这个 key ，进行覆盖</span></span><br><span class="line">                <span class="comment">// 需要覆盖的是 result，为了代码复用，使 node = result</span></span><br><span class="line">                node = result;</span><br><span class="line">                cmp = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不存在这个 key 时，使用内存地址比较</span></span><br><span class="line">                searched = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//                    cmp = Math.random() &gt; 0.5 ? -1 : 1;</span></span><br><span class="line">                cmp = System.identityHashCode(k1) - System.identityHashCode(k2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 相等</span></span><br><span class="line">            node.key = key; <span class="comment">// 相等时覆盖</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> node.value;</span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 到这一步时，是两个 key equals</span></span><br><span class="line"><span class="comment">                 * 表明两个 key 的哈希值一定相等</span></span><br><span class="line"><span class="comment">                 * 因此，可以不覆盖哈希值：</span></span><br><span class="line"><span class="comment">                 * node.hash = h1;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node != <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 看看插入到父节点的哪个位置</span></span><br><span class="line">    Node&lt;K, V&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">// 添加节点后的处理 传入参数类型为Node</span></span><br><span class="line">    afterPut(newNode);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（又是这两大串代码😖）</p>
<p>到此， HashMap 的基本实现就完成了，功能测试也基本没有问题。</p>
<p>但是仍有可以优化的地方！ 👇</p>
<h1 id="3-优化完善"><a class="header-anchor" href="#3-优化完善"></a>3. 优化完善</h1>
<h2 id="3-1-装填因子"><a class="header-anchor" href="#3-1-装填因子"></a>3.1 装填因子</h2>
<blockquote>
<p>问题由来</p>
</blockquote>
<p>当需要向我们设计的HashMap中插入大量的数据（10w？或100w）时，因为哈希函数的计算方式以及哈希表的默认容量（默认容量 16 ），会导致频繁出现哈希冲突，并在每个桶中的红黑树也会存在大量节点，导致红黑树的高度变得异常地高。</p>
<p>我们需要规避这种情况，不能让桶中的红黑树高度变得很高，因为在高度很高而又要进行全节点扫描时，会造成效率的巨大损失。</p>
<p>因此，我们需要指定一个标准，在数据量达到一定值时，对哈希表进行扩容，从而让红黑树的高度不那么高，提高搜索效率。</p>
<p>那这个标准是什么？</p>
<blockquote>
<p>装填因子</p>
</blockquote>
<p><strong>装填因子</strong>（Load Factor）：节点总数量 / 哈希表桶数组的长度，也叫作<strong>负载因子</strong>。</p>
<p>在JDK 1.8 的 HashMap 中，如果装填因子超过 0.75，就会扩容为原来的两倍。</p>
<p>至于为什么选择0.75作为装填因子，网上有说是因为通过泊松分布计算出来的，其实这是不对的，两者没有必然联系，真实原因是：通过时间和空间上的权衡后，选择装填因子为 0.75。（可查看JDK中HashMap的注释）</p>
<h2 id="3-2-扩容思路"><a class="header-anchor" href="#3-2-扩容思路"></a>3.2 扩容思路</h2>
<p>既然需要扩容，那么在创建了新的桶数组后，就要将原来桶数组中的数据搬到新的桶数组中。</p>
<p>我们首先会想到一种方式：</p>
<p>遍历原桶数组中的每个元素，其中的每个元素都是红黑树的根节点，然后我们根据这些根节点使用层序遍历来遍历整个红黑树，将遍历的节点使用<code>put()</code>方法插入到新的桶数组中（size记得清零）。</p>
<p>但是！这是一个<strong>极其煞笔的做法</strong> ！为什么？</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/meme/煞笔.jpg" alt="煞笔" style="zoom:67%;" />
<p>效率极低！因为将旧桶数组中的元素使用<code>put()</code>方法重新添加到新创建的新桶数组中，就需要重新 new 新的 Node 节点对象，这样会浪费大量的内存。为什么不重新利用以前的 Node 节点对象呢？👀</p>
<p>那么应该怎么挪动数据呢？直接将整棵树挪到新的桶数组中（将根节点放到新的桶数组中）？这种做法是肯定不行的，我们需要<strong>将红黑树中每个节点都挪过去</strong> 。因为进行扩容后，<code>table.length</code>会发生变化，节点的索引值可能会发生变化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">index</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">    <span class="comment">// 重复利用原先的节点</span></span><br><span class="line">    <span class="comment">// node.hash 不会发生变化，但table.length会发生变化</span></span><br><span class="line">    <span class="comment">// 最终结果就有可能发生变化</span></span><br><span class="line">    <span class="keyword">return</span> node.hash &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那又是怎样的变化呢？👇</p>
<blockquote>
<p>索引的变化</p>
</blockquote>
<p>前文已经分析过，<code>table.length</code>需要是 2 的次幂，然后进行减 1 运算后，<code>table.length - 1</code>的二进制数全是 1 。</p>
<p>假设最开始时<code>table.length - 1</code>的二进制数为 11，即：桶数组容量为 2<sup>2</sup> = 4 ，<code>node.hash</code>的二进制数为1010：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1010</span><br><span class="line">&amp; 11</span><br><span class="line">-----</span><br><span class="line">  10</span><br></pre></td></tr></table></figure>
<p>然后桶数组容量扩容为 2<sup>3</sup> = 8后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1010</span><br><span class="line">&amp;111</span><br><span class="line">----</span><br><span class="line"> 010</span><br></pre></td></tr></table></figure>
<p>我们发现扩容后重新计算的索引并没有发生变化。那我们再举一个例：</p>
<p><code>node.hash</code>的二进制数发生变化，为1110，最开始还未发生扩容时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1110</span><br><span class="line">&amp; 11</span><br><span class="line">----</span><br><span class="line">  10</span><br></pre></td></tr></table></figure>
<p>然后桶数组容量扩容为 8 时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1110</span><br><span class="line">&amp;111</span><br><span class="line">----</span><br><span class="line"> 110</span><br></pre></td></tr></table></figure>
<p>这下扩容后重新计算的索引就发生了变化。</p>
<hr>
<p><strong>当扩容为原来容量的2倍时，节点的索引变化有两种情况：</strong></p>
<p>1、保持不变</p>
<p>2、新的索引 = 旧索引 + 旧容量</p>
<h2 id="3-3-扩容实现"><a class="header-anchor" href="#3-3-扩容实现"></a>3.3 扩容实现</h2>
<p>我们进行扩容时，需要将原哈希表中桶内的每一个红黑树节点都挪到新的哈希表中，那有个小疑问：每个节点都要挪到新的哈希表中，那效率岂不是会很差？</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/meme/小朋友你是否有很多问号.jpg" alt="小朋友你是否有很多问号" style="zoom:67%;" />
<p>效率是会降低，但是扩容后，桶数组容量增加，发生哈希冲突的概率减小，这样的挪动是为了以后的效率，而这是值得的。</p>
<blockquote>
<p>调整大小</p>
</blockquote>
<p>前面提到了装填因子的概念，因此我们需要在<code>HashMap</code>类中添加一个常量，表示<strong>默认装填因子</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="comment">// 默认装填因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就可以编写调整大小的方法<code>resize()</code>：</p>
<p>1、计算的填装因子小于等于默认的填装因子时，直接返回；</p>
<p>2、创建一个新的桶数组，容量是原来的两倍（为啥是两倍？ 容量是 2 次幂没忘吧😒）</p>
<p>3、将原数组的每个节点进行层序遍历然后挪动</p>
<hr>
<p><code>resize()</code>方法具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 装填因子 &lt;= 0.75</span></span><br><span class="line">    <span class="keyword">if</span> (size / table.length &lt;= DEFAULT_LOAD_FACTOR) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;K, V&gt;[] oldTable = table;</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Node</span>[oldTable.length &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    Queue&lt;Node&lt;K, V&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; oldTable.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldTable[i] == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        queue.offer(oldTable[i]);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node&lt;K, V&gt; node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 节点挪动，可以思考下为啥要把挪动方法放在这里</span></span><br><span class="line">            moveNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>节点挪动</p>
</blockquote>
<p>在调整大小的代码中使用了节点挪动方法<code>moveNode()</code>，在当前<code>HashMap</code>类中是没有这个方法的，因此我们需要编写这个方法：</p>
<p>1、因为是从原桶数组将节点挪动到新的数组中，所以需要<strong>将节点的属性重置</strong> 。真是因为这里重置了节点属性，因此在<code>resize()</code>方法中将挪动方法放到了最后。</p>
<p>2、接下来的代码与<code>put()</code>方法中的代码类似，但也存在着些许差异：</p>
<ul>
<li>部分赋值语句、参数名进行修改</li>
<li>由于是挪动数据，当前映射的<code>size</code>并<mark>不需要</mark>像<code>put()</code>方法中一样进行加一</li>
<li>由于是挪动数据，也不需要新创建<code>Node</code>对象，直接使用传递的数据即可</li>
<li>删除 equals 判断，因为节点原来就是存在于映射中的，原映射中不可能存在两个相互 equals 的节点</li>
<li>删除递归搜索，原因与上一条一样</li>
<li>删除 <code>cmp = 0</code> 时进行的覆盖，在挪动节点时，cmp 不可能等于 0，原因同上</li>
<li>最后记得设置一下挪动节点的 <code>parent</code> 属性</li>
</ul>
<p>总结一下，<code>moveNode()</code>方法与<code>put()</code>方法类似，但是由于挪动的是原本就存在于映射中的节点，因此在新桶数组中不可能出现节点相互 equals 或者 cmp = 0 的情况，我们只需要确定挪动节点在新桶数组中的位置即可。基于此，需要删除一些代码以减少判断，提高效率。</p>
<hr>
<p><code>moveNode()</code>方法具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveNode</span><span class="params">(Node&lt;K, V&gt; newNode)</span> &#123;</span><br><span class="line">    <span class="comment">// 重置清空</span></span><br><span class="line">    newNode.parent = <span class="literal">null</span>;</span><br><span class="line">    newNode.left = <span class="literal">null</span>;</span><br><span class="line">    newNode.right = <span class="literal">null</span>;</span><br><span class="line">    newNode.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> index(newNode);</span><br><span class="line">    <span class="comment">// 取出 index 位置的红黑树根节点</span></span><br><span class="line">    Node&lt;K, V&gt; root = table[index];</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = newNode;</span><br><span class="line">        table[index] = root;</span><br><span class="line">        afterPut(root);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加新的节点到红黑树</span></span><br><span class="line">    Node&lt;K, V&gt; parent = root;</span><br><span class="line">    Node&lt;K, V&gt; node = root;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">K</span> <span class="variable">k1</span> <span class="operator">=</span> newNode.key;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h1</span> <span class="operator">=</span> newNode.hash;</span><br><span class="line">    <span class="comment">// 循环方式从 while 变为 do...while</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = node;  <span class="comment">// 保存父节点</span></span><br><span class="line">        <span class="type">K</span> <span class="variable">k2</span> <span class="operator">=</span> node.key;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h2</span> <span class="operator">=</span> node.hash;</span><br><span class="line">        <span class="keyword">if</span> (h1 &gt; h2) &#123;</span><br><span class="line">            cmp = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h1 &lt; h2) &#123;</span><br><span class="line">            cmp = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 删除 equals，不可能存在相互 equals 的 key</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k1 != <span class="literal">null</span> &amp;&amp; k2 != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; k1 <span class="keyword">instanceof</span> Comparable</span><br><span class="line">                &amp;&amp; k1.getClass() == k2.getClass()</span><br><span class="line">                &amp;&amp; (cmp = ((Comparable) k1).compareTo(k2)) != <span class="number">0</span>) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 删除搜索，因为原桶数组的数据挪动过来不可能存在相等的</span></span><br><span class="line">            cmp = System.identityHashCode(k1) - System.identityHashCode(k2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除 cmp = 0 的情况，因为挪动过来的元素不能相等</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看插入到父节点的哪个位置</span></span><br><span class="line">    newNode.parent = parent;</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        parent.right = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent.left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加节点后的处理 传入参数类型为Node</span></span><br><span class="line">    afterPut(newNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩容后单词统计耗时：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/DataStructureImages/%E6%89%A9%E5%AE%B9%E5%90%8E%E8%80%97%E6%97%B6.png" alt="扩容后耗时"></p>
<hr>
<p>其实我们编写的 HashMap 中还有可以优化的地方：比如减少函数调用（染色的函数）等。</p>
<h2 id="3-4-equals的规范"><a class="header-anchor" href="#3-4-equals的规范"></a>3.4 equals的规范</h2>
<p>假设我现在有两个实体类，分别叫做 Key1 和 Key2 ，在这两个实体类中重写了<code>equals()</code>方法，但是<strong>重写的方法存在差异</strong>。然后我在一个测试方法中实例化这两个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Key1</span> <span class="variable">k1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Key1</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Key2</span> <span class="variable">k2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Key2</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>然后调用 <code>equals()</code> 方法得到以下结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k1.equals(k2); <span class="comment">// true</span></span><br><span class="line">k2.equals(k2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>真是因为重写方法存在的问题，导致了这样的结果。如果我们要使用这两个自定义对象作为 HashMap 的 key 时，就会出现不稳定的现象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Object, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(k1,<span class="number">1</span>);</span><br><span class="line">map.put(k2,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>在这种情况下，后添加的数据<mark>不会</mark>覆盖先添加的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Object, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(k2,<span class="number">1</span>);</span><br><span class="line">map.put(k1,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>在这种情况下，后添加的数据<mark>会</mark>覆盖先添加的。</p>
<p>这就是不稳定的现象，既然会出现不稳定的现象，难道是我们自己写的 HashMap 有问题？</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/meme/%E6%88%91%E6%80%80%E7%96%91%E4%BD%A0%E8%84%91%E5%AD%90%E6%9C%89%E9%97%AE%E9%A2%98.jpg" alt="我怀疑你脑子有问题"></p>
<p>当然没有问题，这是使用者的问题，是使用者自定义对象的<code>equals()</code>方法出了问题！😤</p>
<p>因此我们自己在重写<code>equals()</code>方法时一定要遵循一些规范！😒</p>
<blockquote>
<p>equals的规范</p>
</blockquote>
<p>在前文中已经说明，自定义对象作为 key 时，需要重写<code>hashcode()</code>和<code>equals()</code>方法。</p>
<p><code>equals()</code>：用以判断 2 个 key 是否为同一个 key，重写<code>equals()</code>方法时需要遵守以下规范：</p>
<ul>
<li>自反性： 对于任何非 <strong>null</strong> 的 x，x.equals(x) 必须返回 <code>true</code></li>
<li>对称性： 对于任何非 <strong>null</strong> 的x、y，如果 y.equals(x) 返回 <code>true</code> ，x.equals(y) 也必须返回 <code>true</code></li>
<li>传递性：对于任何非 <strong>null</strong> 的x、y、z，如果 x.equlas(y)、y.equals(z) 返回 <code>true</code>，那么 x.equals(z) 必须返回 <code>true</code></li>
<li>一致性： 对于任何非 <strong>null</strong> 的x、y，只要 equals 的比较操作在对象中所用的信息没有被修改，多次调用 x.equals(y) 就会一致地返回 <code>true</code> ，或者一致地返回 <code>false</code> 。就是说，假设我现在有一个实体类名为Person，其中重写了 <code>equals()</code> 方法，通过属性 name 进行 equals 判断，只要我 name 的属性值没有发生改变，那么<code>equals()</code>方法返回的结果就不能改变。</li>
<li>对于任何非 <strong>null</strong> 的x，x.euqals(null) <strong>必须</strong>返回 <code>false</code></li>
</ul>
<h2 id="3-5-选择与对比"><a class="header-anchor" href="#3-5-选择与对比"></a>3.5 选择与对比</h2>
<p>我们使用自己编写的<code>TreeMap</code>和<code>HashMap</code>来统计一下单词数，比较一下两者的耗时：</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/DataStructureImages/TreeMap与HashMap的耗时对比.png" alt="TreeMap与HashMap的耗时对比" style="zoom:50%;" />
<p>结果很明显，两者的耗时相差很远，<code>HashMap</code>的效率、性能远好于<code>TreeMap</code>。</p>
<p>从时间复杂度来说，TreeMap 的增删改查都是 O(logn) 级别的，而使用哈希表实现的映射 HashMap 可以认定为 O(1) 级别的（装填因子的原因）。</p>
<blockquote>
<p>二者抉择</p>
</blockquote>
<p><code>HashMap</code>的效率、性能远好于<code>TreeMap</code>，难道<code>TreeMap</code>就没用了吗？😕</p>
<p>当然不是！😎</p>
<p>以下情况可以选择<code>TreeMap</code>：元素具备可比较性且要求升序遍历（按照元素从小到大）</p>
<p>以下情况可以选择<code>HashMap</code>： 只要要求无序遍历就选择 HashMap</p>
<h2 id="3-6-取模运算"><a class="header-anchor" href="#3-6-取模运算"></a>3.6 取模运算</h2>
<p>在编写哈希函数的时候，我们建议使用位运算 &amp; 来计算以求得索引值。</p>
<p>如果我们执意要使用取模运算 % 来计算索引：建议<strong>把哈希表的长度设计为素数</strong>（质数），就像我们使用位运算要将哈希表的长度设计为 2 的次幂一样。</p>
<p>这样可以大大减小哈希冲突：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10 % 8 = 2			10 % 7 = 3</span><br><span class="line">20 % 8 = 4			20 % 7 = 6</span><br><span class="line">30 % 8 = 6			30 % 7 = 2</span><br><span class="line">40 % 8 = 0			40 % 7 = 5</span><br><span class="line">50 % 8 = 2			50 % 7 = 1</span><br><span class="line">60 % 8 = 4			60 % 7 = 4</span><br><span class="line">70 % 8 = 6			70 % 7 = 0</span><br></pre></td></tr></table></figure>
<p>那要扩容应该怎么办呢？</p>
<p>下图列出了不同数据规模对应的最佳素数：</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/DataStructureImages/取模运算容量建议表.png" alt="取模运算容量建议表" style="zoom:50%;" />
<p>我们发现：每个素数略小于前一个素数的 2 倍，每个素数尽可能接近 2 的次幂（2<sup>n</sup>）</p>
<p>我们在设计时，可以把素数一栏的数据放到一个数组中，如果数据规模发生改变时，就可以启用数组中下一个数据作为桶数组的容量。</p>
<h1 id="4-LinkedHashMap"><a class="header-anchor" href="#4-LinkedHashMap"></a>4. LinkedHashMap</h1>
<p>在 HashMap 的基础上维护元素的添加顺序，使得遍历的结果是遵从添加顺序的。</p>
<p>比如，添加顺序为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;jack&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;rose&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;jim&quot;</span>, <span class="number">3</span>);</span><br><span class="line">map.put(<span class="string">&quot;tom&quot;</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>遍历结果的顺序是按照 jack — rose — jim — tom 的顺序遍历出来的。</p>
<h2 id="4-1-节点创建"><a class="header-anchor" href="#4-1-节点创建"></a>4.1 节点创建</h2>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/DataStructureImages/LinkedHashMap.png" alt="LinkedHashMap" style="zoom:50%;" />
<p>假设添加顺序为： 37、21、31、41、97、95、52、42、83</p>
<p>由于我们要实现<code>LinkedHashMap</code>，使遍历顺序按照添加顺序，那么必须要在原节点类<code>Node</code>上增加几个属性。</p>
<p>创建<code>LinkedHashMap</code>类，继承<code>HashMap</code>，然后在当前类中创建内部类<code>LinkedNode</code>，继承<code>Node</code>：</p>
<p>PS：记得前往<code>HashMap</code>类中将节点类<code>Node</code>的访问修饰符修改为<code>protected</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LinkedNode</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K, V&gt;&#123;</span><br><span class="line">        LinkedNode&lt;K, V&gt; prev;</span><br><span class="line">        LinkedNode&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LinkedNode</span><span class="params">(K key, V value, Node&lt;K, V&gt; parent)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(key, value, parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在<code>HashMap</code>中使用的某些方法中创建节点是通过 <code>new Node()</code> 完成的，无法在<code>LinkedHashMap</code>创建我们想要的<code>LinkedNode</code>。</p>
<p>针对这个原因，我们可以在<code>HashMap</code>中提供一个创建节点的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Node&lt;K, V&gt; <span class="title function_">createNode</span><span class="params">(K key, V value, Node&lt;K, V&gt; parent)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将<code>HashMap</code>中创建节点的方法都改为调用这个方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改前</span></span><br><span class="line">root = <span class="keyword">new</span> <span class="title class_">Node</span>(key, value, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line">root = createNode(key, value, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>最后，在<code>LinkedHashMap</code>重写<code>createNode()</code>方法，就可以实现使用<code>LinkedHashMap</code>时创建的节点都是<code>LinkedNode</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Node <span class="title function_">createNode</span><span class="params">(Object key, Object value, Node parent)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedNode</span>(key, value, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-方法改写"><a class="header-anchor" href="#4-2-方法改写"></a>4.2 方法改写</h2>
<p>实现<code>LinkedHashMap</code>时，可以采用双向链表（对于单向链表访问效率更高）将节点串起来，因此需要在当前类中增加两个指针，分别表示头指针和尾指针：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedNode&lt;K, V&gt; first;</span><br><span class="line">    <span class="keyword">private</span> LinkedNode&lt;K, V&gt; last;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>串线</p>
</blockquote>
<p>我们在上一步中已经把准备工作做得差不多了，接下来需要将节点们串在一起，方便后续遍历。</p>
<p>我们可以在创建节点的时候就将线串起来：</p>
<ul>
<li>当创建的节点<strong>是第一个节点</strong>时，使头指针、尾指针都指向它。</li>
<li>当创建的节点<strong>不是第一个节点</strong>时，该节点就是最后一个节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Node <span class="title function_">createNode</span><span class="params">(Object key, Object value, Node parent)</span> &#123;</span><br><span class="line">    <span class="type">LinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedNode</span>(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = last = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last.next = node;</span><br><span class="line">        node.prev = last;</span><br><span class="line">        last = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>清空</p>
</blockquote>
<p>因为引入了头尾指针，可以使用双向链表将添加的数据串起来，那么在清空映射时需要将头尾指针设置为<code>null</code>，不然映射无法被清空：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.clear();</span><br><span class="line">    first = <span class="literal">null</span>;</span><br><span class="line">    last = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>遍历</p>
</blockquote>
<p>节点也串了起来，访问的时候就可以顺着链表访问即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(Visitor&lt;K, V&gt; visitor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (visitor == <span class="literal">null</span>)  <span class="keyword">return</span>;</span><br><span class="line">    LinkedNode&lt;K, V&gt; node = first;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (visitor.visit(node.key, node.value)) <span class="keyword">return</span>;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>存在</p>
</blockquote>
<p>判断某个 value 是否存在也可以采取和遍历一样的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(V value)</span> &#123;</span><br><span class="line">    LinkedNode&lt;K, V&gt; node = first;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(value, node.value)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-节点删除"><a class="header-anchor" href="#4-3-节点删除"></a>4.3 节点删除</h2>
<p>节点添加很简单，只需要将创建节点的方法修改为调用<code>createNode()</code>方法创建即可。但是对于删除就不一样了，我们可以直接使用HashMap中删除节点的方法吗？</p>
<p>答案是否定的！ 因为我们在添加节点时按照添加顺序使用双向链表将节点都串了起来，使用 HashMap 中删除节点的方法时，只会删除红黑树中的节点，对于双向链表的节点并无作为。因此，我们还需要将双向链表的节点删除。</p>
<p>PS：前往HashMap中将<code>remove(Node&lt;K, V&gt; node)</code>方法的访问修饰符修改为<code>protected</code>。</p>
<p>然后在<code>LinkedHashMap</code>类中重写<code>remove(Node&lt;K, V&gt; node)</code>方法，删除双向链表中的节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> V <span class="title function_">remove</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    LinkedNode&lt;K, V&gt; linkedNode = ((LinkedNode&lt;K, V&gt;) node);</span><br><span class="line"></span><br><span class="line">    LinkedNode&lt;K, V&gt; prev = linkedNode.prev;</span><br><span class="line">    LinkedNode&lt;K, V&gt; next = linkedNode.next;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123; <span class="comment">// 删除双向链表的头结点时</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123; <span class="comment">// 删除双向链表尾节点时</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.remove(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就把删除方法写好了？😳</p>
<p>当然不可能啦，这么简单就写好了我还会开新的一节吗？😏</p>
<p>因为我们删除度为2的节点时，实际上真正删除的是它的前驱或后继节点，而传递的参数是被删除节点，我们所做的是将被删除节点在双向链表中的指向断开了，实际上应该断开其前驱或后继节点的指向。</p>
<p>因此我们还需要对代码进行修改。为了方便命名，我们将添加节点后修复红黑树的方法<code>afterPut()</code>重命名为<code>fixAfterPut()</code>，将删除节点后修复红黑树的方法<code>afterRemove()</code>重命名为<code>fixAfterRemove()</code>。</p>
<p>然后在HashMap中新编写一个方法<code>afterRemove()</code>，内部不书写任何代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterRemove</span><span class="params">(Node&lt;K, V&gt; removeNode)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>将这个方法放在<code>remove()</code>方法最后，用于在 HashMap 的子类中重写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> V <span class="title function_">remove</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他的代码</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 交给子类处理的代码</span></span><br><span class="line">    afterRemove(node);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回至<code>LinkedHashMap</code>中，删除前面重写的<code>remove(Node&lt;K, V&gt; node)</code>方法，重写<code>afterRemove()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterRemove</span><span class="params">(Node&lt;K, V&gt; removeNode)</span> &#123;</span><br><span class="line">    LinkedNode&lt;K, V&gt; linkedNode = ((LinkedNode&lt;K, V&gt;) removeNode);</span><br><span class="line"></span><br><span class="line">    LinkedNode&lt;K, V&gt; prev = linkedNode.prev;</span><br><span class="line">    LinkedNode&lt;K, V&gt; next = linkedNode.next;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123; <span class="comment">// 删除双向链表的头结点时</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123; <span class="comment">// 删除双向链表尾节点时</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你以为这样又完了？</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/meme/你还是太年轻啊.gif" alt="你还是太年轻啊" style="zoom:80%;" />
<p>当我们删除节点后，虽然将双向链表的引用正确删除了，但是访问顺序又发生了改变。比如在下图中，我们删除节点 31 后，37 会覆盖 31 ，原本 37 的内存会被销毁，但是这样访问顺序又发生了改变。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/DataStructureImages/LinkedHashMap%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%89%8D%E5%90%8E%E5%AF%B9%E6%AF%94.png" alt="LinkedHashMap删除节点前后对比"></p>
<p>那么我们应该怎么做呢？<strong>交换一下链表中数据的位置</strong>就可以了：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/DataStructureImages/%E4%BA%A4%E6%8D%A2LinkedHashMap%E4%B8%AD%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%8D%E7%BD%AE.png" alt="交换LinkedHashMap中链表数据的位置"></p>
<p><mark>注意：当删除度为2的节点node时，需要注意更换 node 与前驱 \ 后继节点的连接位置。</mark></p>
<p>那么应该怎么交换呢？其实很简单，看下图： 👇</p>
<img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/DataStructureImages/LinkedHashMap交换链表数据位置逻辑.png" alt="LinkedHashMap交换链表数据位置逻辑" style="zoom: 67%;" />
<p>为了不重复书写代码，我们可以在 HashMap 给方法<code>afterRemove()</code>再添加一个参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> willNode   要被删除的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> removeNode 真正被删除的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterRemove</span><span class="params">(Node&lt;K, V&gt; willNode, Node&lt;K, V&gt; removeNode)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>remove(Node&lt;K, V&gt; node)</code>方法中也给出调整，定义一个局部变量<code>willNode</code>表示要被删除的节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> V <span class="title function_">remove</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 定义一个局部变量 willNode</span></span><br><span class="line">    Node&lt;K, V&gt; willNode = node;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> node.value;</span><br><span class="line">    <span class="keyword">if</span> (node.hasTwoChildren()) &#123; <span class="comment">// 度为2的节点</span></span><br><span class="line">        <span class="comment">// 找到后继节点</span></span><br><span class="line">        Node&lt;K, V&gt; s = successor(node);</span><br><span class="line">        <span class="comment">// 用后继节点的值覆盖被删除节点的值</span></span><br><span class="line">        node.key = s.key;</span><br><span class="line">        node.value = s.value;</span><br><span class="line">        <span class="comment">// 节点的哈希值也要覆盖，不然还是以前节点的哈希值</span></span><br><span class="line">        node.hash = s.hash;</span><br><span class="line">        <span class="comment">// 变量node指向其后继节点，等待后续删除</span></span><br><span class="line">        node = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除node节点（node的度必然为1或0）</span></span><br><span class="line">    Node&lt;K, V&gt; replacement = node.left != <span class="literal">null</span> ? node.left : node.right;</span><br><span class="line">    <span class="comment">// 获取红黑树节点在哈希表中的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> index(node);</span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="literal">null</span>) &#123;   <span class="comment">// node度为1</span></span><br><span class="line">        <span class="comment">// 更改parent</span></span><br><span class="line">        replacement.parent = node.parent;</span><br><span class="line">        <span class="comment">// 更改node的parent的left、right的指向</span></span><br><span class="line">        <span class="keyword">if</span> (node.parent == <span class="literal">null</span>) &#123; <span class="comment">// node度为1，且为根节点</span></span><br><span class="line">            table[index] = replacement;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">            node.parent.left = replacement;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// node == node.parent.right</span></span><br><span class="line">            node.parent.right = replacement;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fixAfterRemove(replacement);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.parent == <span class="literal">null</span>) &#123; <span class="comment">// node度为0，是叶子节点，并且是根节点</span></span><br><span class="line">        table[index] = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 被删除的节点</span></span><br><span class="line">        fixAfterRemove(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// node是叶子节点，但不是根节点</span></span><br><span class="line">        <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">            node.parent.left = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.parent.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 被删除的节点</span></span><br><span class="line">        fixAfterRemove(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交给子类处理的代码</span></span><br><span class="line">    afterRemove(willNode, node);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在<code>LinkedHashMap</code>中，重写<code>afterRemove()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterRemove</span><span class="params">(Node&lt;K, V&gt; willNode, Node&lt;K, V&gt; removeNode)</span> &#123;</span><br><span class="line">    LinkedNode&lt;K, V&gt; node1 = ((LinkedNode&lt;K, V&gt;) willNode);</span><br><span class="line">    LinkedNode&lt;K, V&gt; node2 = ((LinkedNode&lt;K, V&gt;) removeNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node1 != node2)&#123; <span class="comment">// 删除节点度为 2</span></span><br><span class="line">        <span class="comment">// 交换node1和node2在链表中的位置</span></span><br><span class="line">        <span class="comment">// 交换 prev</span></span><br><span class="line">        LinkedNode&lt;K, V&gt; tmp = node1.prev;</span><br><span class="line">        node1.prev = node2.prev;</span><br><span class="line">        node2.prev = tmp;</span><br><span class="line">        <span class="keyword">if</span> (node1.prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            first = node1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node1.prev.next = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node2.prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            first = node2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node2.prev.next = node2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换 next</span></span><br><span class="line">        tmp = node1.next;</span><br><span class="line">        node1.next = node2.next;</span><br><span class="line">        node2.next = tmp;</span><br><span class="line">        <span class="keyword">if</span> (node1.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            last = node1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node1.next.prev = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node2.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            last = node2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node2.next.prev = node2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkedNode&lt;K, V&gt; prev = node2.prev;</span><br><span class="line">    LinkedNode&lt;K, V&gt; next = node2.next;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123; <span class="comment">// 删除双向链表的头结点时</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123; <span class="comment">// 删除双向链表尾节点时</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，<code>LinkedHashMap</code>就基本完成了，其他的方法可以参考 HashMap 代码实现即可。</p>
<h1 id="5-HashSet"><a class="header-anchor" href="#5-HashSet"></a>5. HashSet</h1>
<p>HashMap都实现了，HashSet还不容易实现吗？</p>
<p>先创建一个类，名为<code>HashSet</code>，然后实现<code>Set</code>接口（这个<code>Set</code>接口是<mark>集合与映射</mark>一文中编写的接口，在此不再提供代码）。</p>
<p>然后使用 HashMap 实现即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 默烦</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;E, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E element)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span> &#123;</span><br><span class="line">        map.put(element,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E element)</span> &#123;</span><br><span class="line">        map.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(Visitor&lt;E&gt; visitor)</span> &#123;</span><br><span class="line">        map.traversal(<span class="keyword">new</span> <span class="title class_">Map</span>.Visitor&lt;E, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">visit</span><span class="params">(E key, Object value)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> visitor.visit(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那对于<code>LinkedHashSet</code>呢？那就是分分钟的事了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;E, Object&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E element)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span> &#123;</span><br><span class="line">        map.put(element,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E element)</span> &#123;</span><br><span class="line">        map.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(Visitor&lt;E&gt; visitor)</span> &#123;</span><br><span class="line">        map.traversal(<span class="keyword">new</span> <span class="title class_">Map</span>.Visitor&lt;E, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">visit</span><span class="params">(E key, Object value)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> visitor.visit(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>到此，哈希表就介绍完了！🎉🎊</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mofan212.github.io">默烦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mofan212.github.io/posts/DataStructure-HashMap/">https://mofan212.github.io/posts/DataStructure-HashMap/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://mofan212.github.io" target="_blank">Mofan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DataStructure/">DataStructure</a></div><div class="post-share"><div class="social-share" data-image="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/39.png" data-sites="wechat,qq,weibo,facebook,twitter"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" target="_blank"><img class="post-qr-code-img" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" target="_blank"><img class="post-qr-code-img" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/DataStructure-Basic-Knowledge-Of-Graphs/" title="高级数据结构之图"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/51.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2020-08-24</div><div class="info-item-2">高级数据结构之图</div></div><div class="info-2"><div class="info-item-1">本文基于一种新型数据结构——图，介绍了一些相关的概念，并在最后进行编码实现与测试。</div></div></div></a><a class="pagination-related" href="/posts/DataStructure-Union-Find/" title="高级数据结构之并查集"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/50.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-01-02</div><div class="info-item-2">高级数据结构之并查集</div></div><div class="info-2"><div class="info-item-1">本文从一个需求出发，介绍了一种新型数据结构——并查集，然后围绕并查集，对其进行了多种优化。</div></div></div></a><a class="pagination-related" href="/posts/DataStructure-B+Tree/" title="高级数据结构之B+树"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/119.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2022-12-11</div><div class="info-item-2">高级数据结构之B+树</div></div><div class="info-2"><div class="info-item-1">B+ 树是 B 树的变体，常用于数据库和操作系统的文件系统中。</div></div></div></a><a class="pagination-related" href="/posts/DataStructure-AVLTree/" title="数据结构之“艾薇儿”树"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/35.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2020-07-20</div><div class="info-item-2">数据结构之“艾薇儿”树</div></div><div class="info-2"><div class="info-item-1">AVL 树继承至 BST，但是在添加、删除之后做了调整，本文重点介绍了 AVL 树中的旋转。</div></div></div></a><a class="pagination-related" href="/posts/DataStructure-Trie/" title="数据结构之Trie"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/43.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2024-08-29</div><div class="info-item-2">数据结构之Trie</div></div><div class="info-2"><div class="info-item-1">Trie 又名字典树、前缀树。本文从一个需求入手，介绍了 Trie 的基本概念与结构，并实现了 Trie。</div></div></div></a><a class="pagination-related" href="/posts/DataStructure-BinarySearchTree/" title="数据结构之二叉搜索树"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/34.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2023-04-09</div><div class="info-item-2">数据结构之二叉搜索树</div></div><div class="info-2"><div class="info-item-1">本文介绍了实现二叉搜索树的基本接口，并对二叉树的遍历，获取前驱节点、后驱节点进行了重点介绍。</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">默烦</div><div class="author-info-description">彩笔的打怪升级之路...</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">155</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mofan212"><i class="fab fa-github"></i><span>follow me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:cy.mofan@foxmail.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a><a class="social-icon" href="https://www.travellings.cn/go.html" target="_blank" title="开往"><i class="fas fa-subway"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站所有博文均是博主的学习笔记与个人理解。<strong><font style="color:red">除特别注明外，</font>如需转载，请在文章头部醒目处附带原文链接并<a target="_blank" rel="noopener" href="https://mofan212.gitee.io/mine/" style="color:#49B1F5;text-decoration:underline">告知我</a></strong>你将转载。😊</br><strong><font style="color:red">严禁未遵循规范的转载。</font></strong>😡</br><strong>死去的评论系统复活啦！欢迎到留言板畅所欲言！</strong>当然也可以使用更高效的<a target="_blank" href="https://space.bilibili.com/23658864/dynamic" style="color:#49B1F5;text-decoration:underline"> 哔哩哔哩私信 </a>或<a href="mailto:cy.mofan@foxmail.com" style="color:#49B1F5;text-decoration:underline" target="_blank">邮箱</a>。 😉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-text">0. 需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1-TreeMap%E5%88%86%E6%9E%90"><span class="toc-text">0.1 TreeMap分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-2-%E9%9C%80%E6%B1%82%E7%94%B1%E6%9D%A5"><span class="toc-text">0.2 需求由来</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1. 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%88%9D%E5%A7%8B%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">1.1 初始哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-text">1.2 哈希冲突</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-text">1.3 哈希函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%93%88%E5%B8%8C%E5%80%BC%E8%AE%A1%E7%AE%97"><span class="toc-text">1.4 哈希值计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-equals-%E6%96%B9%E6%B3%95"><span class="toc-text">1.5 equals()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93"><span class="toc-text">1.6 阶段性总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0"><span class="toc-text">2. 初步实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%B8%85%E7%A9%BA%E6%98%A0%E5%B0%84"><span class="toc-text">2.1 清空映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text">2.2 添加元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E8%8A%82%E7%82%B9%E6%AF%94%E8%BE%83"><span class="toc-text">2.3 节点比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0"><span class="toc-text">2.4 获取元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">2.5 删除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%8F%91%E7%8E%B0%E9%97%AE%E9%A2%98"><span class="toc-text">2.6 发现问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E6%96%B9%E6%B3%95%E4%BF%AE%E6%94%B9"><span class="toc-text">2.7 方法修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-compareTo"><span class="toc-text">2.8 compareTo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3"><span class="toc-text">2.9 深度理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-%E5%93%88%E5%B8%8C%E8%B0%83%E6%95%B4"><span class="toc-text">2.10 哈希调整</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%BC%98%E5%8C%96%E5%AE%8C%E5%96%84"><span class="toc-text">3. 优化完善</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E8%A3%85%E5%A1%AB%E5%9B%A0%E5%AD%90"><span class="toc-text">3.1 装填因子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%89%A9%E5%AE%B9%E6%80%9D%E8%B7%AF"><span class="toc-text">3.2 扩容思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%89%A9%E5%AE%B9%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.3 扩容实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-equals%E7%9A%84%E8%A7%84%E8%8C%83"><span class="toc-text">3.4 equals的规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E9%80%89%E6%8B%A9%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="toc-text">3.5 选择与对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97"><span class="toc-text">3.6 取模运算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-LinkedHashMap"><span class="toc-text">4. LinkedHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E8%8A%82%E7%82%B9%E5%88%9B%E5%BB%BA"><span class="toc-text">4.1 节点创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%96%B9%E6%B3%95%E6%94%B9%E5%86%99"><span class="toc-text">4.2 方法改写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4"><span class="toc-text">4.3 节点删除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-HashSet"><span class="toc-text">5. HashSet</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/DataStructure-Union-Find/" title="高级数据结构之并查集"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/50.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="高级数据结构之并查集"/></a><div class="content"><a class="title" href="/posts/DataStructure-Union-Find/" title="高级数据结构之并查集">高级数据结构之并查集</a><time datetime="2025-01-01T16:00:00.000Z" title="更新于 2025-01-02 00:00:00">2025-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/FreeMarker-Template-Author's-Guide/" title="FreeMarker 模板开发"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/68.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="FreeMarker 模板开发"/></a><div class="content"><a class="title" href="/posts/FreeMarker-Template-Author's-Guide/" title="FreeMarker 模板开发">FreeMarker 模板开发</a><time datetime="2024-12-26T16:00:00.000Z" title="更新于 2024-12-27 00:00:00">2024-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/How-To-Install-Rust-On-Windows/" title="如何在 Windows 下安装 Rust"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/155.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="如何在 Windows 下安装 Rust"/></a><div class="content"><a class="title" href="/posts/How-To-Install-Rust-On-Windows/" title="如何在 Windows 下安装 Rust">如何在 Windows 下安装 Rust</a><time datetime="2024-11-22T16:00:00.000Z" title="更新于 2024-11-23 00:00:00">2024-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Algorithm-Shortest-Path/" title="【算法】图的最短路径"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/53.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="【算法】图的最短路径"/></a><div class="content"><a class="title" href="/posts/Algorithm-Shortest-Path/" title="【算法】图的最短路径">【算法】图的最短路径</a><time datetime="2024-10-27T16:00:00.000Z" title="更新于 2024-10-28 00:00:00">2024-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/How-To-Parse-Spring-Configuration-Classes/" title="Spring 配置类的解析"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/154.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Spring 配置类的解析"/></a><div class="content"><a class="title" href="/posts/How-To-Parse-Spring-Configuration-Classes/" title="Spring 配置类的解析">Spring 配置类的解析</a><time datetime="2024-10-25T16:00:00.000Z" title="更新于 2024-10-26 00:00:00">2024-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Something-About-Blog/" title="博客搭建与维护"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/42.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="博客搭建与维护"/></a><div class="content"><a class="title" href="/posts/Something-About-Blog/" title="博客搭建与维护">博客搭建与维护</a><time datetime="2024-10-06T16:00:00.000Z" title="更新于 2024-10-07 00:00:00">2024-10-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 默烦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://fastly.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://fastly.jsdelivr.net/npm/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://npm.elemecdn.com/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://fastly.jsdelivr.net/gh/mofan212/blog-static-resources@master/js/mine.min.js"></script><script defer="defer" id="ribbon" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-show-text" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Azathoth,Yog-Sothoth,Shub-Niggurath,Nyarlathotep,Cthulhu,Hastur,Abhoth,Ghroth,Tsathoggua,Cthugha,Deep Ones,Dagon,Chaugnar Faugn,Mordiggian,Shoggoth,Old One,Mi-Go,Great Race of Yith,Flying Polyp,Hounds of Tindalos,Dhole" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://fastly.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'BAFEL7A6K1',
    apiKey: '89fcb5961984c5c054bf04149f345f38',
    indexName: 'mofan212io',
    container: '#docsearch',
    placeholder: '输入关键字进行搜索',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【上篇】Redis 基础篇 | Mofan</title><meta name="author" content="默烦,cy.mofan@foxmail.com"><meta name="copyright" content="默烦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文主要介绍了 Redis 的五大数据类型、配置文件解析和两种持久化。">
<meta property="og:type" content="article">
<meta property="og:title" content="【上篇】Redis 基础篇">
<meta property="og:url" content="https://mofan212.github.io/posts/The-Basics-Of-Redis-Part-One/">
<meta property="og:site_name" content="Mofan">
<meta property="og:description" content="本文主要介绍了 Redis 的五大数据类型、配置文件解析和两种持久化。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/72.png">
<meta property="article:published_time" content="2020-12-04T16:00:00.000Z">
<meta property="article:modified_time" content="2022-03-26T16:00:00.000Z">
<meta property="article:author" content="默烦">
<meta property="article:tag" content="Middleware">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/72.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【上篇】Redis 基础篇",
  "url": "https://mofan212.github.io/posts/The-Basics-Of-Redis-Part-One/",
  "image": "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/72.png",
  "datePublished": "2020-12-04T16:00:00.000Z",
  "dateModified": "2022-03-26T16:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "默烦",
      "url": "https://mofan212.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/favicon.png"><link rel="canonical" href="https://mofan212.github.io/posts/The-Basics-Of-Redis-Part-One/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 默烦","link":"链接: ","source":"来源: Mofan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://testingcf.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【上篇】Redis 基础篇',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><link rel="stylesheet" href="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources@master/css/myStyle.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css" /><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" /><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Mofan" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources/css/minimal.min.css"/><script src="https://testingcf.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">174</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/reward/"><i class="fa-fw fa-solid fa-coins"></i><span> 赞助</span></a></li><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/post_top_img.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Mofan</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/reward/"><i class="fa-fw fa-solid fa-coins"></i><span> 赞助</span></a></li><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【上篇】Redis 基础篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-04T16:00:00.000Z" title="发表于 2020-12-05 00:00:00">2020-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-26T16:00:00.000Z" title="更新于 2022-03-27 00:00:00">2022-03-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Middleware/">Middleware</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">21.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>79分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;距离本文上次更新已经过去&quot;,&quot;messageNext&quot;:&quot;天，请注意时效性。&quot;,&quot;postUpdate&quot;:&quot;2022-03-27 00:00:00&quot;}" hidden></div>
    <style>
      .highlight-tools {
        background: #262931 !important;
      }
    </style>
    <html><head></head><body><p>封面来源：碧蓝航线 永夜幻光 活动CG</p>
<p>Redis 命令参考：<a target="_blank" rel="noopener" href="http://doc.redisfans.com/">Redis 命令参考</a></p>
<p>本文参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1oW411u75R">尚硅谷超经典Redis教程,redis实战,阳哥版从入门到精通</a></p>
<h1 id="1-NoSQL-入门与概述（上）"><a class="header-anchor" href="#1-NoSQL-入门与概述（上）"></a>1. NoSQL 入门与概述（上）</h1>
<h2 id="1-1-为什么要有-NoSQL"><a class="header-anchor" href="#1-1-为什么要有-NoSQL"></a>1.1 为什么要有 NoSQL</h2>
<blockquote>
<p>单机 MySQL 的美好年代</p>
</blockquote>
<p>在 90 年代，一个网站的访问量一般都不大，用单个数据库完全可以轻松应付。</p>
<p>在那个时候，更多的都是静态网站，动态交互类型的网站并不多。</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/单机MySQL架构.png" alt="单机MySQL架构" style="zoom:67%;">
<p>上述架构下，可以清楚地看到数据存储的瓶颈：</p>
<p>1、数据量总大小：一个机器放不下时</p>
<p>2、数据的索引（B+ Tree）：一个机器的内存放不下时</p>
<p>3、访问量（读写混合）：一个实例不能承受</p>
<blockquote>
<p>Memcached（缓存）+ MySQL + 垂直拆分</p>
</blockquote>
<p>随着访问量的上升，几乎大部分使用 MySQL 架构的网站在数据库上都开始出现了性能问题，web 程序不再仅仅专注在功能上，同时也在追求性能。程序员们开始大量的使用缓存技术来缓解数据库的压力，优化数据库的结构和索引。开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续增大的时候，多台 web 机器通过文件缓存不能共享，大量的小文件缓存也带了了比较高的 IO 压力。在这个时候，Memcached 就自然的成为一个非常时尚的技术产品。</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/垂直拆分架构.png" alt="垂直拆分架构" style="zoom:67%;">
<blockquote>
<p>MySQL 主从读写分离</p>
</blockquote>
<p>由于数据库的写入压力增加， Memcached 只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。MySQL 的 master-slave 模式成为这个时候的网站标配了。</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/主从读写分离架构.png" alt="主从读写分离架构" style="zoom:67%;">
<blockquote>
<p>分库分表 + 水平拆分 + MySQL 集群</p>
</blockquote>
<p>在 Memcached 的高速缓存，MySQL 的主从复制， 读写分离的基础之上，这时 MySQL 主库的写压力开始出现瓶颈，而数据量的持续猛增，由于 MyISAM 使用表锁， 在高并发下会出现严重的锁问题，大量的高并发 MySQL 应用开始使用 InnoDB 引擎代替 MyISAM。</p>
<p>同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题。这个时候，分表分库成了一个热门技术，是面试的热门问题也是业界讨论的热门技术问题。也就在这个时候，MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然 MySQL 推出了 MySQL Cluster 集群， 但性能也不能很好满足互联网的要求，只是在高可靠性上提供了非常大的保证。</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/分库分表架构.png" alt="分库分表架构" style="zoom:67%;">
<blockquote>
<p>MySQL 的扩展性瓶颈</p>
</blockquote>
<p>MySQL 数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如 1000 万 4KB 大小的文本就接近40GB的大小，如果能把这些数据从 MySQL 省去，MySQL 将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL 的扩展性差（需要复杂的技术来实现），大数据下 IO 压力大，表结构更改困难，正是当前使用 MySQL 的开发人员面临的问题。</p>
<blockquote>
<p>现在是什么样子？</p>
</blockquote>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E7%8E%B0%E5%9C%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84.png" alt="现在的数据库架构"></p>
<blockquote>
<p>为什么要使用 NoSQL</p>
</blockquote>
<p>今天我们可以通过第三方平台（如：Google，Facebook等）可以很容易获取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那 SQL 数据库已经不适合这些应用了，NoSQL 数据库的发展也却能很好的处理这些大的数据。</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/Web-Applications-Driving-Data-Growth.png" alt="Web-Applications-Driving-Data-Growth" style="zoom:67%;">
<h2 id="1-2-什么是-NoSQL"><a class="header-anchor" href="#1-2-什么是-NoSQL"></a>1.2 什么是 NoSQL</h2>
<p>NoSQL（NoSQL = Not Only SQL），意即“不仅仅是SQL”，<mark>泛指非关系型的数据库</mark>。随着互联网web 2.0 网站的兴起，传统的关系数据库在应付 web 2.0 网站，特别是超大规模和高并发的 SNS 类型的 web 2.0 纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL 数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。</p>
<p>例如谷歌或 Facebook 每天为他们的用户收集万亿比特的数据。 <mark>这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</mark></p>
<h2 id="1-3-NoSQL-特性"><a class="header-anchor" href="#1-3-NoSQL-特性"></a>1.3 NoSQL 特性</h2>
<blockquote>
<p>易扩展</p>
</blockquote>
<p>NoSQL 数据库种类繁多，但是一个共同的特点是都去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。</p>
<blockquote>
<p>大数据量高性能</p>
</blockquote>
<p>NoSQL 数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。</p>
<p>这得益于它的无关系性，数据库的结构简单。</p>
<p>一般 MySQL 使用 Query Cache，每次表的更新 Cache 就失效，是一种大粒度的 Cache，在针对 web 2.0 的交互频繁的应用，Cache 性能不高。而 NoSQL 的 Cache 是记录级的，是一种细粒度的 Cache，所以 NoSQL 在这个层面上来说就要性能高很多了。</p>
<blockquote>
<p>多样灵活的数据模型</p>
</blockquote>
<p>NoSQL 无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。</p>
<blockquote>
<p>传统 RDBMS VS NOSQL</p>
</blockquote>
<p><strong>RDBMS</strong> （关系数据库管理系统）</p>
<ul>
<li>高度组织化结构化数据</li>
<li>结构化查询语言（SQL）</li>
<li>数据和关系都存储在单独的表中</li>
<li>数据操纵语言，数据定义语言</li>
<li>严格的一致性</li>
<li>基础事务</li>
</ul>
<p><strong>NoSQL</strong></p>
<ul>
<li>代表着不仅仅是 SQL</li>
<li>没有声明性查询语言</li>
<li>没有预定义的模式</li>
<li>键值对存储，列存储，文档存储，图形数据库</li>
<li>最终一致性，而非 ACID 属性</li>
<li>非结构化和不可预知的数据:</li>
<li>CAP 定理</li>
<li>高性能，高可用性和可伸缩性</li>
</ul>
<h2 id="1-4-有哪些-NoSQL-数据库"><a class="header-anchor" href="#1-4-有哪些-NoSQL-数据库"></a>1.4 有哪些 NoSQL 数据库</h2>
<ul>
<li>Redis</li>
<li>Memcached</li>
<li>MongDB</li>
</ul>
<h2 id="1-5-有什么用"><a class="header-anchor" href="#1-5-有什么用"></a>1.5 有什么用</h2>
<ul>
<li>
<p>KV</p>
</li>
<li>
<p>Cache</p>
</li>
<li>
<p>Persistence</p>
</li>
<li>
<p>…</p>
</li>
</ul>
<h1 id="2-NoSQL-入门与概述（下）"><a class="header-anchor" href="#2-NoSQL-入门与概述（下）"></a>2. NoSQL 入门与概述（下）</h1>
<h2 id="2-1-3V-3-高"><a class="header-anchor" href="#2-1-3V-3-高"></a>2.1 3V + 3 高</h2>
<blockquote>
<p>大数据时代的 3V</p>
</blockquote>
<ul>
<li>
<p>海量 Volume</p>
</li>
<li>
<p>多样 Variety</p>
</li>
<li>
<p>实时 Velocity</p>
</li>
</ul>
<blockquote>
<p>互联网需求的 3 高</p>
</blockquote>
<ul>
<li>
<p>高并发</p>
</li>
<li>
<p>高可括</p>
</li>
<li>
<p>高性能</p>
</li>
</ul>
<h2 id="2-2-当下的-NoSQL-经典应用"><a class="header-anchor" href="#2-2-当下的-NoSQL-经典应用"></a>2.2 当下的 NoSQL 经典应用</h2>
<p>当下的应用是 SQL 和 NoSQL 一起使用，了解一下阿里巴巴中文站商品信息如何存放。</p>
<p>阿里巴巴架构发展历程：</p>
<blockquote>
<p>演变过程</p>
</blockquote>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B8%AD%E6%96%87%E7%AB%99%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B.png" alt="阿里巴巴中文站架构发展历程"></p>
<blockquote>
<p>第五代网站架构</p>
</blockquote>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%AC%AC%E4%BA%94%E4%BB%A3%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84.png" alt="阿里巴巴第五代网站架构"></p>
<blockquote>
<p>第五代架构使命</p>
</blockquote>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%AC%AC%E4%BA%94%E4%BB%A3%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BD%BF%E5%91%BD.png" alt="阿里巴巴第五代网站架构的使命"></p>
<blockquote>
<p>和我们相关的</p>
</blockquote>
<p><strong>和我们相关的，多数据源类型的存储问题</strong></p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E7%8E%B0%E7%8A%B6.png" alt="数据架构现状"></p>
<blockquote>
<p>信息的存储方案</p>
</blockquote>
<p>以阿里巴巴中文站商品信息存储为例：</p>
<p>1、商品基本信息</p>
<ul>
<li>名称、价格，出厂日期，生产厂商等</li>
<li>关系型数据库，MySQL / Oracle 目前淘宝在去 O 化（也即拿掉 Oracle），注意，淘宝内部用的 MySQL 是里面的大牛自己改造过的。为什么去 IOE（在IT建设过程中，去除 IBM 小型机、Oracle 数据库及 EMC 存储设备） 简而意之，可不用穿脚链跳舞。</li>
</ul>
<p>2、商品描述、详情、评价信息（多文字类）</p>
<ul>
<li>多文字信息描述类，IO 读写性能变差</li>
<li>文档数据库 MongDB</li>
</ul>
<p>3、商品的图片</p>
<ul>
<li>商品图片展现类</li>
<li>分布式的文件系统中，比如：淘宝自家 TFS、Google 的 GFS、Hadoop 的 HDFS</li>
</ul>
<p>4、商品的关键字</p>
<ul>
<li>淘宝自家</li>
<li>ISearch</li>
</ul>
<p>5、商品的波段性的热点高频信息（如，情人节的玫瑰、巧克力）</p>
<ul>
<li>内存数据库</li>
<li>Tair、Redis、Memcache</li>
</ul>
<p>6、商品的交易、价格计算、积分累计</p>
<ul>
<li>外部系统，外部第 3 方支付接口</li>
<li>支付宝</li>
</ul>
<p><strong>总结大型互联网应用(大数据、高并发、多样数据类型)的难点和解决方案</strong></p>
<p>1、难点：</p>
<ul>
<li>数据类型多样性</li>
<li>数据源多样性和变化重构</li>
<li>数据源改造而数据服务平台不需要大面积重构</li>
</ul>
<p>2、解决方法</p>
<ul>
<li>EAI</li>
<li>UDSL 统一数据平台服务层</li>
</ul>
<blockquote>
<p>UDSL</p>
</blockquote>
<p><strong>什么是 UDSL？</strong></p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E4%BB%80%E4%B9%88%E6%98%AFUDSL.png" alt="什么是UDSL"></p>
<p><strong>UDSL 是什么样的？</strong></p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/UDSL%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7.png" alt="UDSL是什么样"></p>
<p><strong>UDSL 映射：</strong></p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/UDSL%E6%98%A0%E5%B0%84.png" alt="UDSL映射"></p>
<p><strong>UDSL API：</strong></p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/UDSL-API.png" alt="UDSL-API"></p>
<p><strong>UDSL 热点缓存：</strong></p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/UDSL%E7%83%AD%E7%82%B9%E7%BC%93%E5%AD%98.png" alt="UDSL热点缓存"></p>
<h2 id="2-3-NoSQL-数据模型简介"><a class="header-anchor" href="#2-3-NoSQL-数据模型简介"></a>2.3 NoSQL 数据模型简介</h2>
<p>以一个电商客户、订单、订购、地址模型来对比关系型数据库和非关系型数据库。</p>
<p>传统关系型数据库如何设计？可以画好 ER 图进行设计（其中 1:1 / 1:N / N:N，主外键很常见）。</p>
<p>那么 NoSQL 又该怎么设计？</p>
<p>首先需要了解什么是 BSON：BSON 是一种类 JSON 的二进制形式的存储格式，简称 Binary JSON，它和 JSON 一样，支持内嵌的文档对象和数组对象。比如：</p>
<figure class="highlight json line-numbers" data-language="JSON">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#ABB2BF">{</span></span>
<span class="line"><span style="color:#FFFFFF">    name</span><span style="color:#ABB2BF">:</span><span style="color:#98C379">"mofan"</span><span style="color:#ABB2BF">,</span></span>
<span class="line"><span style="color:#FFFFFF">    age</span><span style="color:#ABB2BF">:</span><span style="color:#98C379">"18"</span><span style="color:#ABB2BF">,</span></span>
<span class="line"><span style="color:#FFFFFF">    address</span><span style="color:#ABB2BF">:{</span></span>
<span class="line"><span style="color:#FFFFFF">        city</span><span style="color:#ABB2BF">:</span><span style="color:#98C379">"sichuan"</span><span style="color:#ABB2BF">,</span></span>
<span class="line"><span style="color:#FFFFFF">        country</span><span style="color:#ABB2BF">:</span><span style="color:#98C379">"china"</span><span style="color:#ABB2BF">,</span></span>
<span class="line"><span style="color:#FFFFFF">        code</span><span style="color:#ABB2BF">:</span><span style="color:#D19A66">610000</span></span>
<span class="line"><span style="color:#ABB2BF">    } ,</span></span>
<span class="line"><span style="color:#FFFFFF">    scores</span><span style="color:#ABB2BF">:[</span></span>
<span class="line"><span style="color:#ABB2BF">        {</span><span style="color:#E06C75">"name"</span><span style="color:#ABB2BF">:</span><span style="color:#98C379">"english"</span><span style="color:#ABB2BF">,</span><span style="color:#E06C75">"grade"</span><span style="color:#ABB2BF">:</span><span style="color:#D19A66">3.0</span><span style="color:#ABB2BF">},</span></span>
<span class="line"><span style="color:#ABB2BF">        {</span><span style="color:#E06C75">"name"</span><span style="color:#ABB2BF">:</span><span style="color:#98C379">"chinese"</span><span style="color:#ABB2BF">,</span><span style="color:#E06C75">"grade"</span><span style="color:#ABB2BF">:</span><span style="color:#D19A66">2.0</span><span style="color:#ABB2BF">}</span></span>
<span class="line"><span style="color:#ABB2BF">    ]</span></span>
<span class="line"><span style="color:#ABB2BF">}</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>针对开头提出的业务需求，我们应该使用聚合模型来处理。</p>
<p>那为什么要使用聚合模型来处理？</p>
<ul>
<li>高并发的操作是不太建议用关联查询的，互联网公司用冗余数据来避免关联查询</li>
<li>分布式事务是支持不了太多的并发的</li>
</ul>
<p>那什么聚合模型又是什么？</p>
<ul>
<li>K-V 键值对</li>
<li>BSON</li>
<li>列族：顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一 列或者某几列的查询有非常大的 IO 优势。比如：</li>
</ul>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E5%88%97%E6%97%8F%E7%A4%BA%E4%BE%8B.png" alt="列族示例"></p>
<ul>
<li>图形：比如现实的人际关系图中是很复杂的，仅仅试试二维的行列关系图也是很难表示的，这个时候就需要使用到图。比如：</li>
</ul>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E5%9B%BE%E5%BD%A2%E7%A4%BA%E4%BE%8B.png" alt="图形示例"></p>
<h2 id="3-3-NoSQL-数据库的四大分类"><a class="header-anchor" href="#3-3-NoSQL-数据库的四大分类"></a>3.3 NoSQL 数据库的四大分类</h2>
<blockquote>
<p>K-V 键值对 NoSQL 数据库</p>
</blockquote>
<ul>
<li>新浪：BerkeleyDB + Redis</li>
<li>美团：Redis + Tair</li>
<li>阿里、百度：Memcache + Redis</li>
</ul>
<blockquote>
<p>文档型数据库（BSON 格式居多）</p>
</blockquote>
<ul>
<li>
<p>CouchDB</p>
</li>
<li>
<p>MongoDB</p>
</li>
</ul>
<p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p>
<blockquote>
<p>列存储数据库</p>
</blockquote>
<ul>
<li>
<p>Cassandra</p>
</li>
<li>
<p>HBase</p>
</li>
</ul>
<blockquote>
<p>图关系数据库</p>
</blockquote>
<p>图关系数据库不是放图形的，放的是关系，比如：朋友圈社交网络、广告推荐系统社交网络、推荐系统等，它专注于构建关系图谱。常见的图关系数据库有：Neo4j、InfoGrid。</p>
<blockquote>
<p>四者的对比</p>
</blockquote>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E5%9B%9B%E5%A4%A7NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E6%AF%94.png" alt="四大NoSQL数据库对比"></p>
<h2 id="3-4-分布式数据库中-CAP-原理"><a class="header-anchor" href="#3-4-分布式数据库中-CAP-原理"></a>3.4 分布式数据库中 CAP 原理</h2>
<blockquote>
<p>回顾 ACID</p>
</blockquote>
<p>先说说传统关系型数据库的 ACID 特性，这也是事务的四大特征：</p>
<p>1、原子性（atomicity）：事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用</p>
<p>2、一致性（consistency）：一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中</p>
<p>3、隔离性（isolation）：可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏</p>
<p>4、持久性（durability）：事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中</p>
<p>而在 NoSQL 数据库中，没有了 ACID，取而代之的是 CAP。</p>
<blockquote>
<p>什么是 CAP？</p>
</blockquote>
<ul>
<li>C：Consistency（强一致性）</li>
<li>A：Availability（可用性）</li>
<li>P：Partition tolerance（分区容错性）</li>
</ul>
<p>CAP 理论的核心是：一个分布式系统不可能同时很好的满足一致性、可用性和分区容错性这三个要求，最多只能同时满足其中的两个。</p>
<p>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三大类：</p>
<ul>
<li>CA：单点集群，满足一致性、可用性的系统，通常在可扩展性上不太强大</li>
<li>CP：满足一致性、分区容错性的系统，通常性能不是特别高</li>
<li>AP：满足可用性、分区容错性的系统，通常可能对一致性要求低一点</li>
</ul>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/CAP-Theorem.png" alt="CAP-Theorem" style="zoom:50%;">
<p>而由于当前的网络硬件肯定会出现延迟丢包等问题，所以 <strong>分区容错性</strong> 是我们必须需要实现的。所以我们只能在 <strong>一致性</strong> 和 <strong>可用性</strong> 之间进行权衡，<strong>没有</strong> NoSQL系统能同时保证这三点。</p>
<p>特点的选择：</p>
<ul>
<li>CA：传统Oracle数据库</li>
<li>AP：大多数网站架构的选择</li>
<li>CP：Redis、MongoDB</li>
</ul>
<p>注意：分布式架构的时候必须做出取舍。</p>
<p>一致性和可用性之间取一个平衡。多余大多数 WEB 应用，其实并不需要强一致性。因此牺牲 C 换取 P，这是目前分布式数据库产品的方向。</p>
<blockquote>
<p>一致性与可用性的抉择</p>
</blockquote>
<p>对于 WEB 2.0 网站来说，关系数据库的很多主要特性却往往无用武之地</p>
<p><strong>数据库事务一致性需求</strong></p>
<p>很多 WEB 实时系统并不要求严格的数据库事务，对读一致性的要求很低，有些场合对写一致性要求并不高，允许实现最终一致性。</p>
<p><strong>数据库的写实时性和读实时性需求</strong></p>
<p>对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多 WEB 应用来说，并不要求这么高的实时性。比方说在微博发一条消息之后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。</p>
<p><strong>对复杂的SQL查询，特别是多表关联查询的需求</strong></p>
<p>任何大数据量的 WEB 系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特别是 SNS 类型的网站，从需求以及产品设计角度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL 的功能被极大的弱化了。</p>
<blockquote>
<p>什么是 BASE</p>
</blockquote>
<p>BASE 就是为了解决关系数据库强一致性引起的可用性降低而提出的解决方案。</p>
<p>BASE 其实是下面三个术语的缩写：</p>
<ul>
<li>基本可用（Basically Available）</li>
<li>软状态（Soft State）</li>
<li>最终一致（Eventually Consistent）</li>
</ul>
<p>它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里 BASE 就是解决这个问题的办法。</p>
<blockquote>
<p>简单了解一下分布式与集群</p>
</blockquote>
<p>分布式系统（Distributed System）由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。分布式系统可以应用在在不同的平台上如：PC、工作站、局域网和广域网上等。</p>
<p>简单来讲：</p>
<p>1、分布式：不同的多台服务器上面部署<strong>不同</strong>的服务模块（工程），他们之间通过 RPC / RMI 之间通信和调用，对外提供服务和组内协作。</p>
<p>2、集群：不同的多台服务器上面部署<strong>相同</strong>的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和连接。</p>
<h1 id="3-Redis-入门概述"><a class="header-anchor" href="#3-Redis-入门概述"></a>3. Redis 入门概述</h1>
<h2 id="3-1-入门概述"><a class="header-anchor" href="#3-1-入门概述"></a>3.1 入门概述</h2>
<blockquote>
<p>什么是 Redis</p>
</blockquote>
<p>Redis 不是一个单词，它是几个单词的缩写。<mark>Re</mark>mote <mark>Di</mark>ctionary <mark>S</mark>erver（远程字典服务器）是完全开源免费的，用 C 语言编写的，遵守 BSD 协议，是一个高性能的 Key / Value 分布式内存数据库，基于内存运行并支持持久化的 NoSQL 数据库，是当下最热门的 NoSQL 数据库之一，也被人们称为数据结构服务器。</p>
<p>Redis 与其他 key - value 缓存产品相比有以下三个特点：</p>
<p>1、Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用</p>
<p>2、Redis 不仅仅支持简单的 Key - Value 类型的数据，同时还提供 List，Set，Zset，Hash 等数据结构的存储</p>
<p>3、Redis 支持数据的备份，即 master-slave 模式的数据备份</p>
<blockquote>
<p>Redis 能干什么</p>
</blockquote>
<p>1、内存存储和持久化：Redis 支持异步将内存中的数据写到硬盘上，同时不影响继续服务</p>
<p>2、取最新 N 个数据的操作，如：可以将最新的 10 条评论的 ID 放在 Redis 的 List 集合里面</p>
<p>3、模拟类似于 HttpSession 这种需要设定过期时间的功能</p>
<p>4、发布、订阅消息系统</p>
<p>5、定时器、计数器</p>
<blockquote>
<p>去哪里下 Redis</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://redis.io/">Redis官网</a></p>
<p><a target="_blank" rel="noopener" href="http://www.redis.cn/">Redis中文网</a></p>
<blockquote>
<p>Redis 怎么玩</p>
</blockquote>
<p>1、数据类型、基本操作和配置</p>
<p>2、持久化和复制，RDB / AOF</p>
<p>3、事务的控制</p>
<p>4、复制</p>
<p>5、…</p>
<h2 id="3-2-Redis-的安装"><a class="header-anchor" href="#3-2-Redis-的安装"></a>3.2 Redis 的安装</h2>
<p>本节基于 Linux 下安装 Redis。</p>
<p>首先进入管理员权限（以后的每一步操作都请使用管理员进行操作）：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#ABB2BF">[mofan@cheny ~]$ su</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>切换至根目录，并创建文件夹 Redis 用于放置 Redis 安装包，同时修改 Redis 文件夹权限：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#56B6C2">cd</span><span style="color:#98C379"> /</span></span>
<span class="line"><span style="color:#61AFEF">mkdir</span><span style="color:#98C379"> Redis</span></span>
<span class="line"><span style="color:#61AFEF">chmod</span><span style="color:#D19A66"> 777</span><span style="color:#98C379"> Redis</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>然后将 Windows 下的 redis-6.0.8.tar.gz 安装包复制到 Linux 的 Redis 目录下（复制时不要使用直接拖拽的方式）。</p>
<p>解压 redis-6.0.8.tar.gz 至路径 /usr/local，并检查是否解压成功：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">tar</span><span style="color:#D19A66"> -zxvf</span><span style="color:#98C379"> redis-6.0.8.tar.gz</span><span style="color:#D19A66"> -C</span><span style="color:#98C379"> /usr/local</span></span>
<span class="line"><span style="color:#56B6C2">cd</span><span style="color:#98C379"> /usr/local</span></span>
<span class="line"><span style="color:#61AFEF">ls</span><span style="color:#D19A66"> -l</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E8%A7%A3%E5%8E%8BRedis.png" alt="解压Redis"></p>
<p>将解压文件名 redis-6.0.8 修改为 redis（方便以后操作），并查看是否修改成功：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">mv</span><span style="color:#98C379"> ./redis-6.0.8</span><span style="color:#98C379"> ./redis</span></span>
<span class="line"><span style="color:#61AFEF">ls</span><span style="color:#D19A66"> -l</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>把 redis 目录权限赋予给 mofan（这是我的用户名，你可以赋予你自己的用户）用户：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">chown</span><span style="color:#D19A66"> -R</span><span style="color:#98C379"> mofan</span><span style="color:#98C379"> ./redis</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>进入 redis 目录，安装 Redis：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#56B6C2">cd</span><span style="color:#98C379"> redis</span></span>
<span class="line"><span style="color:#61AFEF">ls</span><span style="color:#D19A66"> -l</span></span>
<span class="line"><span style="color:#61AFEF">make</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>但是在执行 <code>make</code> 命令的时候就出现了问题，提示未找到命令：</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/未找到gcc命令.png" alt="未找到gcc命令" style="zoom: 67%;">
<p>这时候需要安装 gcc（确保我们的虚拟机能够联网）：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#ABB2BF">[root@cheny redis]# yum install gcc-c++</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>但是这个时候又提示镜像的地址找不到，正在尝试其他镜像，并报错： <strong>Couldn’t resolve host</strong></p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/424879095">linux的yum下载不了，老是出现尝试其他镜像该怎么解决？</a></p>
<p>一般来说这是 DNS 的问题，更换一下 DNS：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">vi</span><span style="color:#98C379"> /etc/resolv.conf</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>我的 DNS 配置是这样的：</p>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>nameserver 8.8.8.8</span></span>
<span class="line"><span>nameserver 180.76.76.76</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>然后备份原配置文件：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">mv</span><span style="color:#98C379"> /etc/yum.repos.d/CentOS-Base.repo</span><span style="color:#98C379"> /etc/yum.repos.d/CentOS-Base.repo.backup</span><span style="color:#ABB2BF"> </span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>下载镜像源，我们选择阿里云的镜像：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">wget</span><span style="color:#D19A66"> -O</span><span style="color:#98C379"> /etc/yum.repos.d/CentOS-Base.repo</span><span style="color:#98C379"> http://mirrors.aliyun.com/repo/Centos-6.repo</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>生成源缓存：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">yum</span><span style="color:#98C379"> makecache</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>更新源信息：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">yum</span><span style="color:#98C379"> update</span><span style="color:#D19A66"> -y</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>如果网络不是太好，这个命令很耗时，可以出个饭再来看看。</p>
<p>然后再来安装 gcc：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">yum</span><span style="color:#98C379"> install</span><span style="color:#98C379"> gcc-c++</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>由于我们使用的是 Redis 6.0，它需要 gcc 5及其以上的版本，因此还需要升级 gcc，否则是无法安装成功的。依次执行：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">yum</span><span style="color:#98C379"> install</span><span style="color:#98C379"> centos-release-scl</span></span>
<span class="line"><span style="color:#61AFEF">yum</span><span style="color:#98C379"> install</span><span style="color:#98C379"> devtoolset-7-gcc</span><span style="color:#E5C07B">*</span></span>
<span class="line"><span style="color:#61AFEF">scl</span><span style="color:#98C379"> enable</span><span style="color:#98C379"> devtoolset-7</span><span style="color:#98C379"> bash</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>上述命令可能会执行失败，如果失败多试几次。</p>
<p>输入以下命令，查看 gcc 版本：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">gcc</span><span style="color:#D19A66"> -v</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>如果 gcc 版本大于了 5，这时候前往对应目录依次执行以下的目录完成 Redis 的安装：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#56B6C2">cd</span><span style="color:#98C379"> /usr/local/redis</span><span style="color:#7F848E;font-style:italic"> # Redis 的解压目录</span></span>
<span class="line"><span style="color:#61AFEF">make</span></span>
<span class="line"><span style="color:#61AFEF">make</span><span style="color:#98C379"> install</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>如果执行 <code>make</code> 和 <code>make install</code> 没有出现错误提示（警告无所谓），就像下图所示的这样，就表示我们的 Redis 安装成功了：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E6%89%A7%E8%A1%8Cmake%E5%91%BD%E4%BB%A4.png" alt="执行make命令"></p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E6%89%A7%E8%A1%8Cmakeinstall%E5%91%BD%E4%BB%A4.png" alt="执行makeinstall命令"></p>
<blockquote>
<p>没有联网安装 gcc</p>
</blockquote>
<p>没有联网的安装就是使用光驱安装 gcc。</p>
<p>但这种安装方式只支持安装 Redis 6 以下的版本，因为 Redis 6 以上的版本需要 gcc 5及其以上的版本，而光驱内的 gcc 一般是 4.8 的。</p>
<p>打开虚拟机后，右击虚拟机，打开虚拟机设置：</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/虚拟机设置.png" alt="虚拟机设置" style="zoom:50%;">
<p>指定 ISO 映像文件的位置，并将设备状态一栏都勾上。这时候，我们 CentOS 桌面上会出现一个“光盘”：</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/桌面上的光驱文件.png" alt="桌面上的光驱文件" style="zoom: 67%;">
<p>双击这个“光盘”，找到一个名为 <code>Packages</code> 的目录（可能目录名会不一样），进入这个目录，这个目录里有很多的 rpm 文件，这些文件就是光驱给我们提供的，这里面也有 gcc 相关的 rpm 文件。</p>
<p>在这个目录内用鼠标右击，点击 <strong>在终端打开</strong>，在终端打开这个目录，然后执行一下命令进行安装：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">rpm</span><span style="color:#D19A66"> -ivh</span><span style="color:#98C379"> cpp-4.8.5-36.el7.x86_64.rpm</span></span>
<span class="line"><span style="color:#61AFEF">rpm</span><span style="color:#D19A66"> -ivh</span><span style="color:#98C379"> kernel-headers-3.10.0-957.el7.x86_64.rpm</span></span>
<span class="line"><span style="color:#61AFEF">rpm</span><span style="color:#D19A66"> -ivh</span><span style="color:#98C379"> libgomp-4.8.5-36.el7.x86_64.rpm</span></span>
<span class="line"><span style="color:#61AFEF">rpm</span><span style="color:#D19A66"> -ivh</span><span style="color:#98C379"> glibc-headers-2.17-260.el7.x86_64.rpm</span></span>
<span class="line"><span style="color:#61AFEF">rpm</span><span style="color:#D19A66"> -ivh</span><span style="color:#98C379"> glibc-devel-2.17-260.el7.x86_64.rpm</span></span>
<span class="line"><span style="color:#61AFEF">rpm</span><span style="color:#D19A66"> -ivh</span><span style="color:#98C379"> gcc-4.8.5-36.el7.x86_64.rpm</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>需要注意的是，不同的光驱里的 rpm 文件版本可能不一样，如果不一样，找到自己光驱内对应的版本执行命令即可（可以通过 <code>ls -l</code> 命令寻找，列举出的文件按英文字母排序）。</p>
<p>执行命令 <code>gcc -v</code> 查看 gcc 版本。</p>
<p>前往 Redis 解压目录执行 <code>make</code> 命令进行安装，这时候又会出现以下问题：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/jemalloc%E6%96%87%E4%BB%B6%E4%B8%8D%E5%AD%98%E5%9C%A8.jpg" alt="jemalloc文件不存在"></p>
<p>运行以下命令再次安装：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">make</span><span style="color:#98C379"> distclean</span><span style="color:#ABB2BF"> </span></span>
<span class="line"><span style="color:#61AFEF">make</span></span>
<span class="line"><span style="color:#61AFEF">make</span><span style="color:#98C379"> install</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>基本是到此就完成了 Redis 的安装。</p>
<blockquote>
<p>拓展：配置 ISO 镜像作为 yum 源</p>
</blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/hqwang4/article/details/81333995">CentOS 本地iso挂载并配置iso镜像作为yum源安装软件</a></p>
<p>执行命令行挂载 ISO 镜像：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">ls</span><span style="color:#D19A66"> -l</span><span style="color:#98C379"> /dev</span><span style="color:#ABB2BF"> | </span><span style="color:#61AFEF">grep</span><span style="color:#98C379"> cdrom</span><span style="color:#7F848E;font-style:italic"> # 找到光盘的完整路径</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E6%89%BE%E5%88%B0%E5%85%89%E7%9B%98%E7%9A%84%E5%AE%8C%E6%95%B4%E8%B7%AF%E5%BE%84.png" alt="找到光盘的完整路径"></p>
<p>使用命令挂载：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">mount</span><span style="color:#98C379"> /dev/cdrom</span><span style="color:#98C379"> /mnt/</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>执行命令查看挂载状态：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">df</span><span style="color:#D19A66"> -h</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E6%9F%A5%E7%9C%8B%E6%8C%82%E8%BD%BD%E7%8A%B6%E6%80%81.png" alt="查看挂载状态"></p>
<p>使用本地 ISO 做 yum 源：</p>
 <figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#56B6C2">cd</span><span style="color:#98C379"> /etc/yum.repos.d</span></span>
<span class="line"><span style="color:#61AFEF">mv</span><span style="color:#98C379"> CentOS-Base.repo</span><span style="color:#98C379"> CentOS-Base.repo.bak</span></span>
<span class="line"><span style="color:#61AFEF">cp</span><span style="color:#98C379"> CentOS-Media.repo</span><span style="color:#98C379"> CentOS-Media.repo.bak</span></span>
<span class="line"><span style="color:#61AFEF">vi</span><span style="color:#98C379"> CentOS-Media.repo</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>原本内容为：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/CentOS-Media.repo%E4%BF%AE%E6%94%B9%E5%89%8D.jpg" alt="CentOS-Media.repo修改前"></p>
<p>修改后：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/CentOS-Media.repo%E4%BF%AE%E6%94%B9%E5%90%8E.png" alt="CentOS-Media.repo修改后"></p>
<p>这样，CentOS 本地 ISO 挂载并配置 ISO 镜像作为 yum 源就设置完成了。</p>
<p>如果想要恢复使用网络上的源，再次把 CentOS-Base.repo.bak 重命名为 CentOS-Base.repo 就可以了，并把 CentOS-Media.repo 文件内容改回去就可以了。</p>
<h2 id="3-3-Hello-World"><a class="header-anchor" href="#3-3-Hello-World"></a>3.3 Hello World</h2>
<p>那我们的 Redis 安装在哪呢？</p>
<p>执行以下命令查看：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#56B6C2">cd</span><span style="color:#98C379"> /usr/local/bin</span></span>
<span class="line"><span style="color:#61AFEF">ls</span><span style="color:#D19A66"> -l</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E6%9F%A5%E7%9C%8BRedis%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95.png" alt="查看Redis安装目录"></p>
<p>我们可以修改一下 Redis 的配置文件，进入 Redis 的解压目录，复制 redis.conf 配置文件到 /Redis 目录下：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#56B6C2">cd</span><span style="color:#98C379"> /usr/local/redis</span></span>
<span class="line"><span style="color:#61AFEF">ls</span><span style="color:#D19A66"> -l</span></span>
<span class="line"><span style="color:#61AFEF">cp</span><span style="color:#98C379"> redis.conf</span><span style="color:#98C379"> /Redis</span></span>
<span class="line"><span style="color:#56B6C2">cd</span><span style="color:#98C379"> /</span></span>
<span class="line"><span style="color:#56B6C2">cd</span><span style="color:#98C379"> Redis</span></span>
<span class="line"><span style="color:#61AFEF">ls</span><span style="color:#D19A66"> -l</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E6%9F%A5%E7%9C%8BRedis%E7%9B%AE%E5%BD%95.png" alt="查看Redis目录"></p>
<p>然后修改 GENERAL 下的配置，使 Redis 可以作为 daemon 运行：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">vi</span><span style="color:#98C379"> redis.conf</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E8%AE%BE%E7%BD%AEdaemonize.png" alt="设置daemonize"></p>
<p>修改好了后，前往目录 <code>/usr/local/bin</code> 启动 Redis：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#56B6C2">cd</span><span style="color:#98C379"> /usr/local/bin</span></span>
<span class="line"><span style="color:#61AFEF">ps</span><span style="color:#D19A66"> -ef</span><span style="color:#ABB2BF">|</span><span style="color:#61AFEF">grep</span><span style="color:#98C379"> redis</span><span style="color:#7F848E;font-style:italic"> # 查看 Redis 服务进程是否启动</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>这个时候的 Redis 服务是没用启动的。那我们就来启动：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-server</span><span style="color:#98C379"> /Redis/redis.conf</span></span>
<span class="line"><span style="color:#61AFEF">redis-cli</span><span style="color:#D19A66"> -p</span><span style="color:#D19A66"> 6379</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>这时候的提示符会发生变化，我们可以测试下 Redis 是否启动成功（pingpong）:</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E6%B5%8B%E8%AF%95Redis%E7%9A%84%E5%90%AF%E5%8A%A8.png" alt="测试Redis的启动"></p>
<p>我们输入 <code>ping</code>，界面回答了 <code>PONG</code>，证明 Redis 服务启动成功。还可以新开一个终端通过以下命令查看：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">ps</span><span style="color:#D19A66"> -ef</span><span style="color:#ABB2BF">|</span><span style="color:#61AFEF">grep</span><span style="color:#98C379"> redis</span><span style="color:#7F848E;font-style:italic"> # 查看 Redis 服务进程是否启动</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E6%9F%A5%E7%9C%8BRedis%E6%9C%8D%E5%8A%A1%E6%98%AF%E5%90%A6%E5%90%AF%E5%8A%A8.png" alt="查看Redis服务是否启动"></p>
<p>我们知道 Redis 是 K-V 型的 NoSQL 数据库，可以来尝试存入数据并获取：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RedisHelloWorld.png" alt="RedisHelloWorld"></p>
<p>如果要退出，可以这样：</p>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>127.0.0.1:6379&gt; SHUTDOWN</span></span>
<span class="line"><span>not connected&gt; exit</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>如果再次查看服务进程，会发现 Redis 的服务进程已经消失，就和最开始未启动服务一样：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E5%85%B3%E9%97%ADRedis%E5%90%8E%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B.png" alt="关闭Redis后查看服务进程"></p>
<h2 id="3-4-启动后的杂项知识"><a class="header-anchor" href="#3-4-启动后的杂项知识"></a>3.4 启动后的杂项知识</h2>
<blockquote>
<p>Redis 自测</p>
</blockquote>
<p>在 <code>/usr/local/bin</code> 目录下还有一个 <code>redis-benchmark</code>，我们可以运行一下，就可以让 Redis 进行自测（或许也是一种电脑跑分？）。当然，运行它必须让 Redis 处于启动状态：</p>
<figure class="highlight plaintext line-numbers" data-language="PLAINTEXT">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span>redis-benchmark</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>根据官网所说，Redis 写数据每秒 8W，读数据每秒 11W。你的电脑达到平均水平了吗？我的反正没达到。😭</p>
<p>命令语法：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-benchmark</span><span style="color:#ABB2BF"> [option] [option value]</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p><strong>注意</strong>：该命令是在 redis 的目录下执行的，而不是 redis 客户端的内部指令。</p>
<p>可选参数如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">选项</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><strong>-h</strong></td>
<td style="text-align:center">指定服务器主机名</td>
<td style="text-align:center">127.0.0.1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><strong>-p</strong></td>
<td style="text-align:center">指定服务器端口</td>
<td style="text-align:center">6379</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><strong>-s</strong></td>
<td style="text-align:center">指定服务器 socket</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"><strong>-c</strong></td>
<td style="text-align:center">指定并发连接数</td>
<td style="text-align:center">50</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"><strong>-n</strong></td>
<td style="text-align:center">指定请求数</td>
<td style="text-align:center">10000</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center"><strong>-d</strong></td>
<td style="text-align:center">以字节的形式指定 SET/GET 值的数据大小</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center"><strong>-k</strong></td>
<td style="text-align:center">1=keep alive 0=reconnect</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center"><strong>-r</strong></td>
<td style="text-align:center">SET/GET/INCR 使用随机 key, SADD 使用随机值</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center"><strong>-P</strong></td>
<td style="text-align:center">通过管道传输 <numreq> 请求</numreq></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center"><strong>-q</strong></td>
<td style="text-align:center">强制退出 redis。仅显示 query/sec 值</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center"><strong>–csv</strong></td>
<td style="text-align:center">以 CSV 格式输出</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center"><strong>-l</strong></td>
<td style="text-align:center">生成循环，永久执行测试</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center"><strong>-t</strong></td>
<td style="text-align:center">仅运行以逗号分隔的测试命令列表。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center"><strong>-I</strong></td>
<td style="text-align:center">Idle 模式。仅打开 N 个 idle 连接并等待。</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>比如：</p>
<figure class="highlight bash line-numbers" data-language="BASH">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-benchmark</span><span style="color:#D19A66"> -h</span><span style="color:#D19A66"> 127.0.0.1</span><span style="color:#D19A66"> -p</span><span style="color:#D19A66"> 6379</span><span style="color:#D19A66"> -t</span><span style="color:#98C379"> set,lpush</span><span style="color:#D19A66"> -n</span><span style="color:#D19A66"> 10000</span><span style="color:#D19A66"> -q</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>表示：主机为 127.0.0.1，端口号为 6379，执行的命令为 set 和 lpush，请求数为 10000，通过 -q 参数让结果只显示每秒执行的请求数。</p>
<blockquote>
<p>其他杂项知识</p>
</blockquote>
<p>Redis 是单进程的。单进程模型来处理客户端的请求。对读写等事件的响应是通过对 epoll 函数的包装来做到的。Redis 的实际处理速度完全依靠主进程的执行效率</p>
<p>Epoll 是 Linux 内核为处理大批量文件描述符而作了改进的 epoll，是 Linux 下多路复用 IO 接口 select / poll 的增强版本， 它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。</p>
<p>Redis 默认 16 个数据库，类似数组下表从零开始，初始默认使用零号库，可在配置文件配置。可以通过以下命令对 Redis 数据库进行操作：</p>
<p><code>select</code>：命令切换数据库</p>
<p><code>dbsize</code>查看当前数据库的 key的数量</p>
<p><code>flushdb</code>：清空当前库</p>
<p><code>flushall</code>：通杀全部库</p>
<p><code>keys</code>：查找所有符合给定模式 pattern 的 key。比如：<code>keys *</code> 或者 <code>keys k*</code>，第一种会查找到当前库下所有的 key，第二种则会查找到当前库下以 k 开头的所有 key。</p>
<p>Redis 拥有统一密码管理，16个库都是同样密码，要么都连上要么一个也连接不上。</p>
<p>Redis 索引都是从零开始。</p>
<p>Redis 的默认端口是 6379，至于为啥可以自行了解。</p>
<h2 id="3-5-Windows-下安装-Redis"><a class="header-anchor" href="#3-5-Windows-下安装-Redis"></a>3.5 Windows 下安装 Redis</h2>
<p>有些情况下会有这样的应用场景：在 Windows 本地搭建 Redis，添加到本地计算机的服务中，保证每次开机自动启动服务。</p>
<p>首先下载 Windows 环境下的 Redis，下载地址：<a target="_blank" rel="noopener" href="https://github.com/microsoftarchive/redis/releases">Redis-x64-3.2.100.zip</a></p>
<p>然后选择一个你喜欢的路径，在该路径下解压下载的压缩包。</p>
<p>在 Redis 的根目录下运行以下命令以打开 Redis 服务：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-server.exe</span><span style="color:#98C379"> redis.windows.conf</span><span style="color:#D19A66"> --maxmemory</span><span style="color:#98C379"> 200M</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>再在此路径下启一个命令行窗口，输入以下命令以打开 Redis 客户端：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-cli.exe</span><span style="color:#D19A66"> -h</span><span style="color:#D19A66"> 127.0.0.1</span><span style="color:#D19A66"> -p</span><span style="color:#D19A66"> 6379</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>如果想要偷懒，也可以直接运行 <code>redis-cli.exe</code>。</p>
<p>成功打开客户端后，试试能不能正常添加数据，具体操作见下文。</p>
<p>我们还可以给客户端设置密码，先查看密码（如果没设置过的话，因为设置过肯定得先输入密码）：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">CONFIG</span><span style="color:#98C379"> GET</span><span style="color:#98C379"> requirepass</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>会看到默认密码为空，来设置一下密码：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">CONFIG</span><span style="color:#98C379"> SET</span><span style="color:#98C379"> requirepass</span><span style="color:#D19A66"> 123456</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>这样就将密码设置成 123456，如果这个时候再查看密码，就会提示没有权限，得先使用密码：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">AUTH</span><span style="color:#D19A66"> 123456</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>这样就相当于输入了密码，然后就可以进行其他的操作了！😁</p>
<p>接下来注册开机自启动 Redis 服务，当然要到安装 Redis 的根目录下执行下面的命令：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">redis-server</span><span style="color:#D19A66"> --service-install</span><span style="color:#98C379"> redis.windows.conf</span><span style="color:#D19A66"> --loglevel</span><span style="color:#98C379"> verbose</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>打开 Windows 服务，找到 Redis 服务，这个时候的 Redis 服务是未启动的。可以先将它启动，下次开机时 Redis 服务就会自启动了。</p>
<p>如果一直要求 Redis 使用密码，可以修改 Redis 安装目录下 <code>redis.windows.conf</code> 配置文件，配置 <code>requirepass</code> 项：</p>
<pre>requirepass 123456
</pre>
<p>为了更好地进行操作，建议在 Windows 下安装可视化界面管理 Redis 工具 RedisDesktopManager，具体下载与安装自行搜索。</p>
<blockquote>
<p>Windows 下 Redis 服务无法启动，错误 1067 进程意外终止解决方案</p>
</blockquote>
<p>在启动 Redis 服务时可能会出现这种情况，怎么办呢？</p>
<p>先看下默认端口 6379 是否被占用。以管理员身份运行 CMD，然后执行以下命令：</p>
<figure class="highlight shell line-numbers" data-language="SHELL">
        <table style="background-color: #282c34"><tbody><tr><td class="gutter" style="background-color: #282c34"><pre style="background-color: #282c34"><span class="line">1</span><br></pre></td><td class="code" style="background-color: #282c34"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf" tabindex="0"><code><span class="line"><span style="color:#61AFEF">netstat</span><span style="color:#D19A66"> -ano</span><span style="color:#ABB2BF"> | </span><span style="color:#61AFEF">findstr</span><span style="color:#98C379"> :6379</span></span></code></pre></td></tr></tbody></table>
      </figure>
<p>看看有没有内容。</p>
<p>如果有，LISTENING 后边的数字就是进程的 ID（PID）。使用 <strong>任务管理器</strong> 可以查询到具体是哪个进程，看看是否已经运行了 redis-server.exe 程序。如果是其他程序，可以退出后重新启动服务。</p>
<p>如果还是不行，想想是否对 Redis 配置文件 <code>redis.windows-service.conf</code>  进行过大修改，如果有，可以还原到默认配置。怎么还原？</p>
<p>同目录下的 <code>redis.windows.conf</code> 文件就是默认的配置，复制一份改个名就完事了。</p>
<p>如果还是不行，看看 Windows 服务里的 Redis 服务是否是网络服务。如果是网络服务，直接双击此服务，修改为本地系统服务：</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/修改Redis服务为本地系统服务.png" alt="修改Redis服务为本地系统服务" style="zoom:50%;">
<h1 id="4-Redis-数据类型"><a class="header-anchor" href="#4-Redis-数据类型"></a>4. Redis 数据类型</h1>
<h2 id="4-1-Redis-的五大数据类型"><a class="header-anchor" href="#4-1-Redis-的五大数据类型"></a>4.1 Redis 的五大数据类型</h2>
<blockquote>
<p>String（字符串）</p>
</blockquote>
<p>String 是 Redis 中最基本的类型，可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p>
<p>String 类型是二进制安全的。意思是 Redis 的 String 可以包含任何数据。比如 jpg 图片或者序列化的对象。</p>
<p>String 类型是 Redis 最基本的数据类型，一个 Redis 中字符串 value <strong>最多</strong> 可以是 512M。</p>
<blockquote>
<p>Hash（哈希，类似 Java 里的 Map）</p>
</blockquote>
<p>Redis Hash 是一个键值对集合。</p>
<p>Redis Hash 是一个 String 类型的 field 和 value 的映射表，Hash 特别适合用于存储对象。</p>
<p>类似 Java 里面的 <code>Map&lt;String, Object&gt;</code></p>
<blockquote>
<p>List（列表）</p>
</blockquote>
<p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。</p>
<p>它的底层就是个链表。</p>
<blockquote>
<p>Set（集合）</p>
</blockquote>
<p>Redis 的 Set 是 String 类型的无序集合，它是通过 HashTable 实现实现的。</p>
<blockquote>
<p>Zset（sorted set：有序集合）</p>
</blockquote>
<p>Redis Zset 和 Set 一样也是 String 类型元素的集合，且 <mark>不允许重复</mark> 的成员。</p>
<p>不同的是每个元素都会关联一个 double 类型的分数。</p>
<p>Redis 正是通过分数来为集合中的成员进行从小到大的排序。Zset 的成员是唯一的，但分数（score）是可以重复的。</p>
<hr>
<p>那么去哪里获得 Redis 常见数据类型操作命令？</p>
<p><a target="_blank" rel="noopener" href="http://redisdoc.com/">Redis 命令参考</a></p>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands">Redis 官网命令参考</a></p>
<h2 id="4-2-Key-关键字"><a class="header-anchor" href="#4-2-Key-关键字"></a>4.2 Key 关键字</h2>
<blockquote>
<p>常用的一些命令</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DEL key</td>
<td style="text-align:center">该命令用于在 key 存在时删除 key</td>
</tr>
<tr>
<td style="text-align:center">DUMP key</td>
<td style="text-align:center">序列化给定 key，并返回被序列化的值</td>
</tr>
<tr>
<td style="text-align:center">EXISTS key</td>
<td style="text-align:center">检查给定 key 是否存在</td>
</tr>
<tr>
<td style="text-align:center">EXPIRE key seconds</td>
<td style="text-align:center">为给定 key 设置过期时间，以秒计</td>
</tr>
<tr>
<td style="text-align:center">EXPIREAT key timestamp</td>
<td style="text-align:center">EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳（unix timestamp）</td>
</tr>
<tr>
<td style="text-align:center">PEXPIRE key milliseconds</td>
<td style="text-align:center">设置 key 的过期时间以毫秒计</td>
</tr>
<tr>
<td style="text-align:center">PEXPIREAT key milliseconds-timestamp</td>
<td style="text-align:center">设置 key 过期时间的时间戳（unix timestamp）以毫秒计</td>
</tr>
<tr>
<td style="text-align:center">KEYS pattern</td>
<td style="text-align:center">查找所有符合给定模式（pattern）的 key</td>
</tr>
<tr>
<td style="text-align:center">MOVE key db</td>
<td style="text-align:center">将当前数据库的 key 移动到给定的数据库 db 当中</td>
</tr>
<tr>
<td style="text-align:center">PERSIST key</td>
<td style="text-align:center">移除 key 的过期时间，key 将持久保持</td>
</tr>
<tr>
<td style="text-align:center">PTTL key</td>
<td style="text-align:center">以毫秒为单位返回 key 的剩余的过期时间</td>
</tr>
<tr>
<td style="text-align:center">TTL key</td>
<td style="text-align:center">以秒为单位，返回给定 key 的剩余生存时间（TTL，time to live）</td>
</tr>
<tr>
<td style="text-align:center">RANDOMKEY</td>
<td style="text-align:center">从当前数据库中随机返回一个 key</td>
</tr>
<tr>
<td style="text-align:center">RENAME key newkey</td>
<td style="text-align:center">修改 key 的名称</td>
</tr>
<tr>
<td style="text-align:center">RENAMENX key newkey</td>
<td style="text-align:center">仅当 newkey 不存在时，将 key 改名为 newkey</td>
</tr>
<tr>
<td style="text-align:center">SCAN cursor [MATCH pattern] [COUNT count]</td>
<td style="text-align:center">迭代数据库中的数据库键</td>
</tr>
<tr>
<td style="text-align:center">TYPE key</td>
<td style="text-align:center">返回 key 所储存的值的类型</td>
</tr>
</tbody>
</table>
<blockquote>
<p>命令示例</p>
</blockquote>
<p><code>keys *</code>：查找到当前库下所有的 key</p>
<p><code>exists key</code>：判断 key 在当前库是否存在</p>
<p><code>move key db</code>：将当前库的 key 移动到 db 库中，比如：</p>
<pre>127.0.0.1:6379&gt; set k1 v1
OK
127.0.0.1:6379&gt; set k2 v2
OK
127.0.0.1:6379&gt; set k3 v3
OK
127.0.0.1:6379&gt; move k1 2
(integer) 1
127.0.0.1:6379&gt; select 2
OK
127.0.0.1:6379[2]&gt; get k1
"v1"
127.0.0.1:6379[2]&gt; select 0
OK
127.0.0.1:6379&gt; get k1
(nil)
</pre>
<p><code>expire key 秒钟</code>：为给定的 key 设置过期时间</p>
<p><code>ttl key</code>：查看 key 还有多少秒过期，-1 表示永不过期，-2 表示已过期</p>
<pre>127.0.0.1:6379&gt; EXPIRE k2 10
(integer) 1
127.0.0.1:6379&gt; ttl k2 # 10 秒内
(integer) 7
127.0.0.1:6379&gt; get k2 # 10 秒内
"v2"
127.0.0.1:6379&gt; ttl k2 # 10 秒后
(integer) -2
127.0.0.1:6379&gt; get k2 # 10 秒后
(nil)
127.0.0.1:6379&gt; keys *
1) "k3"
</pre>
<p>key 达到生命周期的时候后，就会从内存中移除。</p>
<p><code>type key</code>：查看 key 是什么类型</p>
<pre>127.0.0.1:6379&gt; keys *
1) "k3"
127.0.0.1:6379&gt; get k3
"v3"
127.0.0.1:6379&gt; set k3 mofan
OK
127.0.0.1:6379&gt; get k3
"mofan"
127.0.0.1:6379&gt; type k3
string
</pre>
<h2 id="4-3-String-字符串"><a class="header-anchor" href="#4-3-String-字符串"></a>4.3 String 字符串</h2>
<blockquote>
<p>常用的一些命令</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SET key value</td>
<td style="text-align:center">设置指定 key 的值</td>
</tr>
<tr>
<td style="text-align:center">GET key</td>
<td style="text-align:center">获取指定 key 的值</td>
</tr>
<tr>
<td style="text-align:center">GETRANGE key start end</td>
<td style="text-align:center">返回 key 中字符串值的子字符</td>
</tr>
<tr>
<td style="text-align:center">GETSET key value</td>
<td style="text-align:center">将给定 key 的值设为 value ，并返回 key 的旧值（old value）</td>
</tr>
<tr>
<td style="text-align:center">GETBIT key offset</td>
<td style="text-align:center">对 key 所储存的字符串值，获取指定偏移量上的位（bit）</td>
</tr>
<tr>
<td style="text-align:center">MGET key1 [key2…]</td>
<td style="text-align:center">获取所有(一个或多个)给定 key 的值</td>
</tr>
<tr>
<td style="text-align:center">SETBIT key offset value</td>
<td style="text-align:center">对 key 所储存的字符串值，设置或清除指定偏移量上的位（bit）</td>
</tr>
<tr>
<td style="text-align:center">SETEX key seconds value</td>
<td style="text-align:center">将值 value 关联到 key ，并将 key 的过期时间设为 seconds（以秒为单位）</td>
</tr>
<tr>
<td style="text-align:center">SETNX key value</td>
<td style="text-align:center">只有在 key 不存在时设置 key 的值</td>
</tr>
<tr>
<td style="text-align:center">SETRANGE key offset value</td>
<td style="text-align:center">用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始</td>
</tr>
<tr>
<td style="text-align:center">STRLEN key</td>
<td style="text-align:center">返回 key 所储存的字符串值的长度</td>
</tr>
<tr>
<td style="text-align:center">MSET key value [key value …]</td>
<td style="text-align:center">同时设置一个或多个 key-value 对</td>
</tr>
<tr>
<td style="text-align:center">MSETNX key value [key value …]</td>
<td style="text-align:center">同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在</td>
</tr>
<tr>
<td style="text-align:center">PSETEX key milliseconds value</td>
<td style="text-align:center">这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位</td>
</tr>
<tr>
<td style="text-align:center">INCR key</td>
<td style="text-align:center">将 key 中储存的数字值增一</td>
</tr>
<tr>
<td style="text-align:center">INCRBY key increment</td>
<td style="text-align:center">将 key 所储存的值加上给定的增量值（increment）</td>
</tr>
<tr>
<td style="text-align:center">INCRBYFLOAT key increment</td>
<td style="text-align:center">将 key 所储存的值加上给定的浮点增量值（increment）</td>
</tr>
<tr>
<td style="text-align:center">DECR key</td>
<td style="text-align:center">将 key 中储存的数字值减一</td>
</tr>
<tr>
<td style="text-align:center">DECRBY key decrement</td>
<td style="text-align:center">key 所储存的值减去给定的减量值（decrement）</td>
</tr>
<tr>
<td style="text-align:center">APPEND key value</td>
<td style="text-align:center">如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾</td>
</tr>
</tbody>
</table>
<blockquote>
<p>命令示例</p>
</blockquote>
<p>String 简单来说就是单值单 value。</p>
<p><strong>1、set / get / del / append / strlen</strong></p>
<pre>127.0.0.1:6379&gt; set k4 v4
OK
127.0.0.1:6379&gt; get k4
"v4"
127.0.0.1:6379&gt; del k4
(integer) 1
127.0.0.1:6379&gt; KEYS *
1) "k3"
127.0.0.1:6379&gt; APPEND k3 qwer
(integer) 9
127.0.0.1:6379&gt; get k3
"mofanqwer"
127.0.0.1:6379&gt; STRLEN k3
(integer) 9
</pre>
<p><strong>2、Incr / decr / incrby / decrby，</strong> <mark>一定要是数字才能进行加减</mark></p>
<pre>127.0.0.1:6379&gt; set k2 2
OK
127.0.0.1:6379&gt; set k1 v1
OK
127.0.0.1:6379&gt; INCR k2
(integer) 3
127.0.0.1:6379&gt; INCR k2
(integer) 4
127.0.0.1:6379&gt; get k2
"4"
127.0.0.1:6379&gt; DECR k2
(integer) 3
127.0.0.1:6379&gt; DECR k2
(integer) 2
127.0.0.1:6379&gt; get k2
"2"
127.0.0.1:6379&gt; DECRBY k2 5
(integer) -3
127.0.0.1:6379&gt; INCRBY k2 10
(integer) 7
</pre>
<p><strong>3、getrange 获取指定区间范围内的值， 类似 between…and 的关系，从零到负一表示全部，比如：</strong></p>
<pre>127.0.0.1:6379&gt; GETRANGE k3 0 -1
"mofanqwer"
127.0.0.1:6379&gt; GETRANGE k3 0 5
"mofanq"
</pre>
<p><strong>4、setrange 设置指定区间范围内的值， 格式是 <code>setrange key 值 具体值</code>，比如：</strong></p>
<pre>127.0.0.1:6379&gt; SETRANGE k3 0 cheny
(integer) 9
127.0.0.1:6379&gt; get k3
"chenyqwer"</pre>
<p><strong>5、setex(set with expire)，格式是 <code>setex key 秒数 value</code>，意思是设置一个 key 和 value，且指定了它们的存活时间。比如：</strong></p>
<pre>127.0.0.1:6379&gt; SETEX k4 15 v4
OK
127.0.0.1:6379&gt; keys *
1) "k1"
2) "k3"
3) "k4"
4) "k2"
127.0.0.1:6379&gt; get k4
"v4"
127.0.0.1:6379&gt; ttl k4 # 15 秒前
(integer) 7
127.0.0.1:6379&gt; ttl k4
(integer) -2
127.0.0.1:6379&gt; get k4
(nil)
</pre>
<p><strong>6、setnx(set if not exist)， 格式是 <code>setnx key value</code>，意思是当前库中如果不存在 key，就添加 key 和 value，否则不添加，而不会覆写。比如：</strong></p>
<pre>127.0.0.1:6379&gt; SETNX k3 v333333
(integer) 0
127.0.0.1:6379&gt; get k3
"chenyqwer"
127.0.0.1:6379&gt; SETNX k4 v4444444
(integer) 1
127.0.0.1:6379&gt; get k4
"v4444444"
</pre>
<p><strong>7、mset / mget / msetnx，使用示例：</strong></p>
<pre>127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3
OK
127.0.0.1:6379&gt; mget k1 k2 k3
1) "v1"
2) "v2"
3) "v3"
127.0.0.1:6379&gt; KEYS *
1) "k1"
2) "k3"
3) "k4"
4) "k2"
127.0.0.1:6379&gt; MSETNX k4 v4 k5 v5
(integer) 0
127.0.0.1:6379&gt; get k5
(nil)
127.0.0.1:6379&gt; MSETNX k5 v5 k6 v6
(integer) 1
127.0.0.1:6379&gt; keys *
1) "k3"
2) "k2"
3) "k1"
4) "k6"
5) "k4"
6) "k5"
</pre>
<p>使用 <code>mset</code> 批量添加时，如果添加的 key 在库中已经存在，那么新添加的 value 会覆盖原来的 value。使用 <code>msetnx</code> 批量添加时，如果添加的 key 在库中已经存在，那么所有的数据都不会添加成功。</p>
<p><strong>8、getset(先get再set)</strong></p>
<h2 id="4-4-List-列表"><a class="header-anchor" href="#4-4-List-列表"></a>4.4 List 列表</h2>
<blockquote>
<p>常用的一些命令</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">BLPOP key1 [key2 ] timeout</td>
<td style="text-align:center">移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td>
</tr>
<tr>
<td style="text-align:center">BRPOP key1 [key2 ] timeout</td>
<td style="text-align:center">移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td>
</tr>
<tr>
<td style="text-align:center">BRPOPLPUSH source destination timeout</td>
<td style="text-align:center">从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td>
</tr>
<tr>
<td style="text-align:center">LINDEX key index</td>
<td style="text-align:center">通过索引获取列表中的元素</td>
</tr>
<tr>
<td style="text-align:center">LINSERT key BEFORE/AFTER pivot value</td>
<td style="text-align:center">在列表的元素前或者后插入元素</td>
</tr>
<tr>
<td style="text-align:center">LLEN key</td>
<td style="text-align:center">获取列表长度</td>
</tr>
<tr>
<td style="text-align:center">LPOP key</td>
<td style="text-align:center">移出并获取列表的第一个元素</td>
</tr>
<tr>
<td style="text-align:center">LPUSH key value1 [value2]</td>
<td style="text-align:center">将一个或多个值插入到列表（不存在就创建）头部</td>
</tr>
<tr>
<td style="text-align:center">LPUSHX key value</td>
<td style="text-align:center">将一个值插入到已存在的列表头部。列表不存在，操作无效</td>
</tr>
<tr>
<td style="text-align:center">LRANGE key start stop</td>
<td style="text-align:center">获取列表指定范围内的元素</td>
</tr>
<tr>
<td style="text-align:center">LREM key count value</td>
<td style="text-align:center">移除列表元素</td>
</tr>
<tr>
<td style="text-align:center">LSET key index value</td>
<td style="text-align:center">通过索引设置列表元素的值</td>
</tr>
<tr>
<td style="text-align:center">LTRIM key start stop</td>
<td style="text-align:center">对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除</td>
</tr>
<tr>
<td style="text-align:center">RPOP key</td>
<td style="text-align:center">移除列表的最后一个元素，返回值为移除的元素</td>
</tr>
<tr>
<td style="text-align:center">RPOPLPUSH source destination</td>
<td style="text-align:center">移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td>
</tr>
<tr>
<td style="text-align:center">RPUSH key value1 [value2]</td>
<td style="text-align:center">将一个或多个值插入到列表（不存在就创建）的尾部（最右边）</td>
</tr>
<tr>
<td style="text-align:center">RPUSHX key value</td>
<td style="text-align:center">将一个值插入到已存在的列表尾部（最右边）。列表不存在，操作无效</td>
</tr>
</tbody>
</table>
<blockquote>
<p>命令示例</p>
</blockquote>
<p>List 简单来说就是单值多 value。</p>
<p>记性测试之前先执行 <code>FLUSHDB</code> 命令清空当前库。</p>
<p><strong>1、lpush / rpush / lrange</strong></p>
<pre>127.0.0.1:6379&gt; keys *
(empty array)
127.0.0.1:6379&gt; LPUSH list01 1 2 3 4 5
(integer) 5
127.0.0.1:6379&gt; LRANGE list01 0 -1
1) "5"
2) "4"
3) "3"
4) "2"
5) "1"
127.0.0.1:6379&gt; RPUSH list02 1 2 3 4 5
(integer) 5
127.0.0.1:6379&gt; LRANGE list02 0 -1
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"</pre>
<p>LPUSH （相当于栈）数据后，进行 LRANGE 获取数据时，按照先进后出的规则获取；RPUSH （相当于队列）数据后，进行 LRANGE 获取数据时，按照先进先出的规则获取。</p>
<p><strong>2、lpop / rpop</strong></p>
<pre>127.0.0.1:6379&gt; LPUSH list01 1 2 3 4 5
(integer) 5
127.0.0.1:6379&gt; RPUSH list02 1 2 3 4 5
(integer) 5
127.0.0.1:6379&gt; lpop list01
"5"
127.0.0.1:6379&gt; lpop list02
"1"
127.0.0.1:6379&gt; rpop list01
"1"
127.0.0.1:6379&gt; rpop list02
"5"
127.0.0.1:6379&gt; LRANGE list01 0 -1
1) "4"
2) "3"
3) "2"
127.0.0.1:6379&gt; LRANGE list02 0 -1
1) "2"
2) "3"
3) "4"
</pre>
<p>LPOP 相当于移除列表第一个元素，RPOP 相当于移除列表最后一个元素。</p>
<p><strong>3、lindex，按照索引下标获得元素（从上到下）</strong></p>
<pre>127.0.0.1:6379&gt; LRANGE list01 0 -1
1) "4"
2) "3"
3) "2"
127.0.0.1:6379&gt; LRANGE list02 0 -1
1) "2"
2) "3"
3) "4"
127.0.0.1:6379&gt; LINDEX list01 3
(nil)
127.0.0.1:6379&gt; LINDEX list01 2
"2"
127.0.0.1:6379&gt; LINDEX list02 2
"4"
</pre>
<p><strong>4、llen（获取列表的长度）</strong></p>
<pre>127.0.0.1:6379&gt; LLEN list01
(integer) 3
127.0.0.1:6379&gt; LLEN list02
(integer) 3
</pre>
<p><strong>5、lrem key 删 N 个 value</strong></p>
<pre>127.0.0.1:6379&gt; RPUSH list03 1 1 1 2 2 2 3 3 3 4 4 4 5 6 7
(integer) 15
127.0.0.1:6379&gt; LREM list03 2 3
(integer) 2
127.0.0.1:6379&gt; LRANGE list03 0 -1
 1) "1"
 2) "1"
 3) "1"
 4) "2"
 5) "2"
 6) "2"
 7) "3"
 8) "4"
 9) "4"
10) "4"
11) "5"
12) "6"
13) "7"
</pre>
<p><strong>6、<code>ltrim key 开始索引 结束索引</code>，可以截取指定范围的值后再赋值给 key</strong></p>
<pre>127.0.0.1:6379&gt; del list01
(integer) 1
127.0.0.1:6379&gt; LPUSH list01 1 2 3 4 5 6 7 8
(integer) 8
127.0.0.1:6379&gt; LTRIM list01 0 4
OK
127.0.0.1:6379&gt; LRANGE list01 0 -1
1) "8"
2) "7"
3) "6"
4) "5"
5) "4"
</pre>
<p><strong>7、<code>rpoplpush 源列表 目的列表</code></strong></p>
<pre>127.0.0.1:6379&gt; LRANGE list01 0 -1
1) "8"
2) "7"
3) "6"
4) "5"
5) "4"
127.0.0.1:6379&gt; LRANGE list02 0 -1
1) "2"
2) "3"
3) "4"
127.0.0.1:6379&gt; RPOPLPUSH list01 list02
"4"
127.0.0.1:6379&gt; LRANGE list02 0 -1
1) "4"
2) "2"
3) "3"
4) "4"</pre>
<p><strong>8、<code>lset key index value</code>，把 index 索引位置的值设置成 value</strong></p>
<pre>127.0.0.1:6379&gt; LRANGE list01 0 -1
1) "8"
2) "7"
3) "6"
4) "5"
127.0.0.1:6379&gt; LSET list01 1 x
OK
127.0.0.1:6379&gt; LRANGE list01 0 -1
1) "8"
2) "x"
3) "6"
4) "5"
</pre>
<p><strong>9、<code>linsert key before/after 值1 值2</code>，给值 1 的前或后位置添加一个值 2</strong></p>
<pre>127.0.0.1:6379&gt; LRANGE list01 0 -1
1) "8"
2) "x"
3) "6"
4) "5"
127.0.0.1:6379&gt; LINSERT list01 before x Java
(integer) 5
127.0.0.1:6379&gt; LRANGE list01 0 -1
1) "8"
2) "Java"
3) "x"
4) "6"
5) "5"
127.0.0.1:6379&gt; LINSERT list01 after x Oracle
(integer) 6
127.0.0.1:6379&gt; LRANGE list01 0 -1
1) "8"
2) "Java"
3) "x"
4) "Oracle"
5) "6"
6) "5"
</pre>
<blockquote>
<p>性能总结</p>
</blockquote>
<p>1、它是一个字符串链表，left、right 都可以插入添加；</p>
<p>2、如果键不存在，创建新的链表；</p>
<p>3、如果键已存在，新增内容；</p>
<p>4、如果值全移除，对应的键也就消失了。</p>
<p>5、链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</p>
<p>6、注意区别命令前的 l 和 r，并理解其中的区别。</p>
<h2 id="4-5-Set-集合"><a class="header-anchor" href="#4-5-Set-集合"></a>4.5 Set 集合</h2>
<blockquote>
<p>常用的一些命令</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SADD key member1 [member2]</td>
<td style="text-align:center">向集合添加一个或多个成员</td>
</tr>
<tr>
<td style="text-align:center">SCARD key</td>
<td style="text-align:center">获取集合的成员数</td>
</tr>
<tr>
<td style="text-align:center">SDIFF key1 [key2]</td>
<td style="text-align:center">返回给定所有集合的差集</td>
</tr>
<tr>
<td style="text-align:center">SDIFFSTORE destination key1 [key2]</td>
<td style="text-align:center">返回给定所有集合的差集并存储在 destination 中</td>
</tr>
<tr>
<td style="text-align:center">SINTER key1 [key2]</td>
<td style="text-align:center">返回给定所有集合的交集</td>
</tr>
<tr>
<td style="text-align:center">SINTERSTORE destination key1 [key2]</td>
<td style="text-align:center">返回给定所有集合的交集并存储在 destination 中</td>
</tr>
<tr>
<td style="text-align:center">SISMEMBER key member</td>
<td style="text-align:center">判断 member 元素是否是集合 key 的成员</td>
</tr>
<tr>
<td style="text-align:center">SMEMBERS key</td>
<td style="text-align:center">返回集合中的所有成员</td>
</tr>
<tr>
<td style="text-align:center">SMOVE source destination member</td>
<td style="text-align:center">将 member 元素从 source 集合移动到 destination 集合</td>
</tr>
<tr>
<td style="text-align:center">SPOP key</td>
<td style="text-align:center">移除并返回集合中的一个随机元素</td>
</tr>
<tr>
<td style="text-align:center">SRANDMEMBER key [count]</td>
<td style="text-align:center">返回集合中一个或多个随机数</td>
</tr>
<tr>
<td style="text-align:center">SREM key member1 [member2]</td>
<td style="text-align:center">移除集合中一个或多个成员</td>
</tr>
<tr>
<td style="text-align:center">SUNION key1 [key2]</td>
<td style="text-align:center">返回所有给定集合的并集</td>
</tr>
<tr>
<td style="text-align:center">SUNIONSTORE destination key1 [key2]</td>
<td style="text-align:center">所有给定集合的并集存储在 destination 集合中</td>
</tr>
<tr>
<td style="text-align:center">SSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td style="text-align:center">迭代集合中的元素</td>
</tr>
</tbody>
</table>
<blockquote>
<p>命令示例</p>
</blockquote>
<p>Set 简单来说就是单值多 value。</p>
<p><strong>1、sadd / smembers / sismember</strong></p>
<pre>127.0.0.1:6379&gt; SADD set01 1 1 2 2 3 3
(integer) 3
127.0.0.1:6379&gt; SMEMBERS set01
1) "1"
2) "2"
3) "3"
127.0.0.1:6379&gt; SISMEMBER set01 1
(integer) 1
127.0.0.1:6379&gt; SISMEMBER set01 x
(integer) 0
</pre>
<p><strong>2、<code>scard key</code>，获取集合里面的元素个数</strong></p>
<pre>127.0.0.1:6379&gt; SCARD set01
(integer) 3
</pre>
<p><strong>3、<code>srem key value</code>，删除集合中元素</strong></p>
<pre>127.0.0.1:6379&gt; SREM set01 2
(integer) 1
127.0.0.1:6379&gt; SMEMBERS set01
1) "1"
2) "3"
</pre>
<p><strong>4、<code>srandmember key 某个整数</code>，从集合中随机获取几个数</strong></p>
<pre>127.0.0.1:6379&gt; sadd set02 1 2 3 4 5 6 7 8
(integer) 8
127.0.0.1:6379&gt; SRANDMEMBER set02 3
1) "7"
2) "8"
3) "2"
127.0.0.1:6379&gt; SRANDMEMBER set02 3
1) "6"
2) "8"
3) "2"
</pre>
<p><strong>5、<code>spop key</code>，随机移除集合中的某个元素</strong></p>
<pre>127.0.0.1:6379&gt; SMEMBERS set02
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
7) "7"
8) "8"
127.0.0.1:6379&gt; SPOP set02
"5"
127.0.0.1:6379&gt; SPOP set02
"6"
127.0.0.1:6379&gt; SMEMBERS set02
1) "1"
2) "2"
3) "3"
4) "4"
5) "7"
6) "8"
</pre>
<p><strong>6、<code>smove key1 key2 在key1里某个值</code> ，作用是将 key1 里的某个值赋给 key2</strong></p>
<pre>127.0.0.1:6379&gt; DEL set01
(integer) 1
127.0.0.1:6379&gt; DEL set02
(integer) 1
127.0.0.1:6379&gt; SADD set01 1 2 3 
(integer) 3
127.0.0.1:6379&gt; SADD set02 x y z
(integer) 3
127.0.0.1:6379&gt; SMOVE set01 set02 2
(integer) 1
127.0.0.1:6379&gt; SMEMBERS set01
1) "1"
2) "3"
127.0.0.1:6379&gt; SMEMBERS set02
1) "2"
2) "y"
3) "x"
4) "z"
</pre>
<p><strong>7、数学集合类：差集（sdiff）交集（sinter）并集（sunion）</strong></p>
<p>所谓 <strong>差集</strong> 就是在第一个 Set 里面而不在后面任何一个 Set 里面的项。</p>
<pre>127.0.0.1:6379&gt; DEL set01
(integer) 1
127.0.0.1:6379&gt; DEL set02
(integer) 1
127.0.0.1:6379&gt; SADD set01 1 2 3 4 5
(integer) 5
127.0.0.1:6379&gt; SADD set02 1 2 3 a b
(integer) 5
127.0.0.1:6379&gt; SDIFF set01 set02
1) "4"
2) "5"
127.0.0.1:6379&gt; SINTER set01 set02
1) "1"
2) "2"
3) "3"
127.0.0.1:6379&gt; SUNION set01 set02
1) "1"
2) "4"
3) "a"
4) "5"
5) "b"
6) "3"
7) "2"
</pre>
<h2 id="4-6-Hash-哈希"><a class="header-anchor" href="#4-6-Hash-哈希"></a>4.6 Hash 哈希</h2>
<blockquote>
<p>常用的一些命令</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">HDEL key field1 [field2]</td>
<td style="text-align:center">删除一个或多个哈希表字段</td>
</tr>
<tr>
<td style="text-align:center">HEXISTS key field</td>
<td style="text-align:center">查看哈希表 key 中，指定的字段是否存在</td>
</tr>
<tr>
<td style="text-align:center">HGET key field</td>
<td style="text-align:center">获取存储在哈希表中指定字段的值</td>
</tr>
<tr>
<td style="text-align:center">HGETALL key</td>
<td style="text-align:center">获取在哈希表中指定 key 的所有字段和值</td>
</tr>
<tr>
<td style="text-align:center">HINCRBY key field increment</td>
<td style="text-align:center">为哈希表 key 中的指定字段的整数值加上增量 increment</td>
</tr>
<tr>
<td style="text-align:center">HINCRBYFLOAT key field increment</td>
<td style="text-align:center">为哈希表 key 中的指定字段的浮点数值加上增量 increment</td>
</tr>
<tr>
<td style="text-align:center">HKEYS key</td>
<td style="text-align:center">获取所有哈希表中的字段</td>
</tr>
<tr>
<td style="text-align:center">HLEN key</td>
<td style="text-align:center">获取哈希表中字段的数量</td>
</tr>
<tr>
<td style="text-align:center">HMGET key field1 [field2]</td>
<td style="text-align:center">获取所有给定字段的值</td>
</tr>
<tr>
<td style="text-align:center">HMSET key field1 value1 [field2 value2 ]</td>
<td style="text-align:center">同时将多个 field-value (域-值)对设置到哈希表 key 中</td>
</tr>
<tr>
<td style="text-align:center">HSET key field value</td>
<td style="text-align:center">将哈希表 key 中的字段 field 的值设为 value</td>
</tr>
<tr>
<td style="text-align:center">HSETNX key field value</td>
<td style="text-align:center">只有在字段 field 不存在时，设置哈希表字段的值</td>
</tr>
<tr>
<td style="text-align:center">HVALS key</td>
<td style="text-align:center">获取哈希表中所有值</td>
</tr>
<tr>
<td style="text-align:center">HSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td style="text-align:center">迭代哈希表中的键值对</td>
</tr>
</tbody>
</table>
<blockquote>
<p>命令示例</p>
</blockquote>
<p>哈希简单来说就是 KV 模式不变，但 V 是一个键值对。</p>
<p><mark>1、hset / hget / hmset / hmget / hgetall / hdel</mark></p>
<pre>127.0.0.1:6379&gt; HSET user id 11
(integer) 1
127.0.0.1:6379&gt; HGET user id
"11"
127.0.0.1:6379&gt; HMSET customer id 212 name mofan age 18
OK
127.0.0.1:6379&gt; HMGET customer id name age
1) "212"
2) "mofan"
3) "18"
127.0.0.1:6379&gt; HGETALL customer
1) "id"
2) "212"
3) "name"
4) "mofan"
5) "age"
6) "18"
127.0.0.1:6379&gt; HSET user name z3
(integer) 1
127.0.0.1:6379&gt; HDEL user id
(integer) 1
127.0.0.1:6379&gt; HGET user name
"z3"
</pre>
<p><strong>2、hlen，获取哈希的长度</strong></p>
<pre>127.0.0.1:6379&gt; HLEN user
(integer) 1
127.0.0.1:6379&gt; HLEN customer
(integer) 3
</pre>
<p><strong>3、<code>hexists key 在key里面的某个值的key</code>，判断哈希里面某个 key 是否存在</strong></p>
<pre>127.0.0.1:6379&gt; HEXISTS customer name
(integer) 1
127.0.0.1:6379&gt; HEXISTS customer gender
(integer) 0
</pre>
<p><mark>4、hkeys / hvals</mark></p>
<pre>127.0.0.1:6379&gt; HKEYS customer
1) "id"
2) "name"
3) "age"
127.0.0.1:6379&gt; HVALS customer
1) "212"
2) "mofan"
3) "18"
</pre>
<p><strong>5、hincrby / hincrbyfloat，第一个表示增加整数值，第二个表示增加小数值</strong></p>
<pre>127.0.0.1:6379&gt; HINCRBY customer age 2
(integer) 20
127.0.0.1:6379&gt; HINCRBY customer age 2
(integer) 22
127.0.0.1:6379&gt; HGET customer age
"22"
127.0.0.1:6379&gt; HSET customer score 91.5
(integer) 1
127.0.0.1:6379&gt; HINCRBYFLOAT customer score 0.6
"92.1"
127.0.0.1:6379&gt; HGET customer score
"92.1"
</pre>
<p><strong>6、hsetnx，如果哈希中不存在添加的 key 就成功添加，如果存在就添加失败</strong></p>
<pre>127.0.0.1:6379&gt; HSETNX customer age 100
(integer) 0
127.0.0.1:6379&gt; HSETNX customer email cy.mofan@qq.com
(integer) 1
127.0.0.1:6379&gt; HGET customer email
"cy.mofan@qq.com"
127.0.0.1:6379&gt; HGET customer age
"22"
</pre>
<h2 id="4-7-ZSet-有序集合"><a class="header-anchor" href="#4-7-ZSet-有序集合"></a>4.7 ZSet 有序集合</h2>
<blockquote>
<p>常用的一些命令</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ZADD key score1 member1 [score2 member2]</td>
<td style="text-align:center">向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr>
<td style="text-align:center">ZCARD key</td>
<td style="text-align:center">获取有序集合的成员数</td>
</tr>
<tr>
<td style="text-align:center">ZCOUNT key min max</td>
<td style="text-align:center">计算在有序集合中指定区间分数的成员数</td>
</tr>
<tr>
<td style="text-align:center">ZINCRBY key increment member</td>
<td style="text-align:center">有序集合中对指定成员的分数加上增量 increment</td>
</tr>
<tr>
<td style="text-align:center">ZINTERSTORE destination numkeys key [key …]</td>
<td style="text-align:center">计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td>
</tr>
<tr>
<td style="text-align:center">ZLEXCOUNT key min max</td>
<td style="text-align:center">在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr>
<td style="text-align:center">ZRANGE key start stop [WITHSCORES]</td>
<td style="text-align:center">通过索引区间返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td style="text-align:center">ZRANGEBYLEX key min max [LIMIT offset count]</td>
<td style="text-align:center">通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td style="text-align:center">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</td>
<td style="text-align:center">通过分数返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td style="text-align:center">ZRANK key member</td>
<td style="text-align:center">返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td style="text-align:center">ZREM key member [member …]</td>
<td style="text-align:center">移除有序集合中的一个或多个成员</td>
</tr>
<tr>
<td style="text-align:center">ZREMRANGEBYLEX key min max</td>
<td style="text-align:center">移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td style="text-align:center">ZREMRANGEBYRANK key start stop</td>
<td style="text-align:center">移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td style="text-align:center">ZREMRANGEBYSCORE key min max</td>
<td style="text-align:center">移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td style="text-align:center">ZREVRANGE key start stop [WITHSCORES]</td>
<td style="text-align:center">返回有序集中指定区间内的成员，通过索引，分数从高到低</td>
</tr>
<tr>
<td style="text-align:center">ZREVRANGEBYSCORE key max min [WITHSCORES]</td>
<td style="text-align:center">返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr>
<td style="text-align:center">ZREVRANK key member</td>
<td style="text-align:center">返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr>
<td style="text-align:center">ZSCORE key member</td>
<td style="text-align:center">返回有序集中，成员的分数值</td>
</tr>
<tr>
<td style="text-align:center">ZUNIONSTORE destination numkeys key [key …]</td>
<td style="text-align:center">计算给定的一个或多个有序集的并集，并存储在新的 key 中</td>
</tr>
<tr>
<td style="text-align:center">ZSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td style="text-align:center">迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>命令示例</p>
</blockquote>
<p>Zset 是在 Set 基础上，加一个 score 值。 之前 Set 是<code>k1 v1 v2 v3</code>， 现在 Zset 是<code>k1 score1 v1 score2 v2</code>。</p>
<p><strong>1、zadd / zrange(withscores)</strong></p>
<pre>127.0.0.1:6379&gt; ZADD zset01 60 v1 70 v2 80 v3 90 v4 100 v5
(integer) 5
127.0.0.1:6379&gt; ZRANGE zset01 0 -1
1) "v1"
2) "v2"
3) "v3"
4) "v4"
5) "v5"
127.0.0.1:6379&gt; ZRANGE zset01 0 -1 withscores
 1) "v1"
 2) "60"
 3) "v2"
 4) "70"
 5) "v3"
 6) "80"
 7) "v4"
 8) "90"
 9) "v5"
10) "100"</pre>
<p><strong>2、<code>zrangebyscore key 开始score 结束score</code></strong></p>
<ul>
<li>withscores</li>
<li>如果 score 带上 <code>(</code> 表示不包含指定的 score</li>
<li>后面还可以使用 limit 用来限制返回（类似分页），使用方法是：<code>limit 开始下标步 多少步</code></li>
</ul>
<pre>127.0.0.1:6379&gt; ZRANGEBYSCORE zset01 60 90
1) "v1"
2) "v2"
3) "v3"
4) "v4"
127.0.0.1:6379&gt; ZRANGEBYSCORE zset01 60 (90
1) "v1"
2) "v2"
3) "v3"
127.0.0.1:6379&gt; ZRANGEBYSCORE zset01 (60 (90
1) "v2"
2) "v3"
127.0.0.1:6379&gt; ZRANGEBYSCORE zset01 60 90
1) "v1"
2) "v2"
3) "v3"
4) "v4"
127.0.0.1:6379&gt; ZRANGEBYSCORE zset01 60 90 limit 2 2
1) "v3"
2) "v4"
127.0.0.1:6379&gt; ZRANGEBYSCORE zset01 60 90 limit 2 2 withscores
1) "v3"
2) "80"
3) "v4"
4) "90"</pre>
<p><strong>3、<code>zrem key 某score下对应的value值</code>，作用是删除元素</strong></p>
<pre>127.0.0.1:6379&gt; ZREM zset01 v5
(integer) 1
127.0.0.1:6379&gt; ZRANGE zset01 0 -1 withscores
1) "v1"
2) "60"
3) "v2"
4) "70"
5) "v3"
6) "80"
7) "v4"
8) "90"
</pre>
<p><strong>4、计算个数、获取下标和获得分数：</strong></p>
<ul>
<li><code>zcard key</code>：获取 Zset 的元素个数</li>
<li><code>zcount key score区间</code>：获得区间范围内的元素个数</li>
<li><code>zrank key score值</code>：获取 score 值对应的下标</li>
<li><code>zscore key 对应值</code>：获得 对应值的分数</li>
</ul>
<pre>127.0.0.1:6379&gt; ZCARD zset01
(integer) 4
127.0.0.1:6379&gt; ZCOUNT zset01 60 80
(integer) 3
127.0.0.1:6379&gt; ZRANK zset01 v4
(integer) 3
127.0.0.1:6379&gt; ZSCORE zset01 v4
"90"
</pre>
<p><strong>5、<code>zrevrank key values值</code>，逆序获得下标值</strong></p>
<pre>127.0.0.1:6379&gt; ZRANGE zset01 0 -1
1) "v1"
2) "v2"
3) "v3"
4) "v4"
127.0.0.1:6379&gt; ZREVRANK zset01 v4
(integer) 0
</pre>
<p><strong>6、zrevrange 可以逆序遍历 Zset 中的值</strong></p>
<pre>127.0.0.1:6379&gt; ZRANGE zset01 0 -1
1) "v1"
2) "v2"
3) "v3"
4) "v4"
127.0.0.1:6379&gt; ZREVRANGE zset01 0 -1
1) "v4"
2) "v3"
3) "v2"
4) "v1"</pre>
<p><strong>7、<code>zrevrangebyscore key 结束score 开始score</code>，逆序根据 score 返回获取对应的值</strong></p>
<pre>127.0.0.1:6379&gt; ZREVRANGEBYSCORE zset01 90 60
1) "v4"
2) "v3"
3) "v2"
4) "v1"
127.0.0.1:6379&gt; ZREVRANGEBYSCORE zset01 80 50
1) "v3"
2) "v2"
3) "v1"
127.0.0.1:6379&gt; ZREVRANGEBYSCORE zset01 80 70
1) "v3"
2) "v2"
</pre>
<h1 id="5-配置文件解析"><a class="header-anchor" href="#5-配置文件解析"></a>5. 配置文件解析</h1>
<h2 id="5-1-配置文件在哪"><a class="header-anchor" href="#5-1-配置文件在哪"></a>5.1 配置文件在哪</h2>
<p>Redis 的配置文件位于 Redis 安装目录下，其名为 redis.conf，我们在前文安装 Redis 的时候就将这份配置文件进行了拷贝并将拷贝文件移动到其他目录，而没有修改原配置文件。</p>
<p>我们 Redis 的安装目录在 <code>/usr/local/redis</code> 下，在 Linux 中使用命令查看一下：</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/Redis的配置文件位置.png" alt="Redis的配置文件位置" style="zoom:67%;">
<p>Redis 那么多配置项，我们可以根据 <code>config get</code> 命令来获取配置项，比如：</p>
<pre>127.0.0.1:6379&gt; config get port
1) "port"
2) "6379"
</pre>
<p><mark>注意：本节配置项基于旧版本的 Redis，新版本 Redis 在部分配置项的所处位置或是否保留可能存在差异。</mark></p>
<h2 id="5-2-Redis-常见配置项"><a class="header-anchor" href="#5-2-Redis-常见配置项"></a>5.2 Redis 常见配置项</h2>
<table>
<thead>
<tr>
<th style="text-align:center">配置项</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>daemonize no</code></td>
<td style="text-align:center">Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td>
</tr>
<tr>
<td style="text-align:center"><code>protected-mode yes</code></td>
<td style="text-align:center">开启保护模式，需要配置 bind ip 或设置访问密码</td>
</tr>
<tr>
<td style="text-align:center"><code>pidfile /var/run/redis_6379.pid</code></td>
<td style="text-align:center">当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis_6379.pid 文件，可以通过 pidfile 指定</td>
</tr>
<tr>
<td style="text-align:center"><code>port 6379</code></td>
<td style="text-align:center">指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字</td>
</tr>
<tr>
<td style="text-align:center"><code>bind 127.0.0.1</code></td>
<td style="text-align:center">绑定的主机地址</td>
</tr>
<tr>
<td style="text-align:center"><code>timeout 300</code></td>
<td style="text-align:center">当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能</td>
</tr>
<tr>
<td style="text-align:center"><code>loglevel notice</code></td>
<td style="text-align:center">指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td>
</tr>
<tr>
<td style="text-align:center"><code>logfile ""</code></td>
<td style="text-align:center">日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null</td>
</tr>
<tr>
<td style="text-align:center"><code>databases 16</code></td>
<td style="text-align:center">设置数据库的数量，默认数据库为 0，可以使用 SELECT 命令在连接上指定数据库 id</td>
</tr>
<tr>
<td style="text-align:center"><code>save &lt;seconds&gt; &lt;changes&gt;</code>Redis 默认配置文件中提供了三个条件：<code>save 900 1</code> <code>save 300 10</code> <code>save 60 10000</code></td>
<td style="text-align:center">分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</td>
</tr>
<tr>
<td style="text-align:center"><code>rdbcompression yes</code></td>
<td style="text-align:center">指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td>
</tr>
<tr>
<td style="text-align:center"><code>dbfilename dump.rdb</code></td>
<td style="text-align:center">指定本地数据库文件名，默认值为 dump.rdb</td>
</tr>
<tr>
<td style="text-align:center"><code>dir ./</code></td>
<td style="text-align:center">指定本地数据库文件的存放目录</td>
</tr>
<tr>
<td style="text-align:center"><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></td>
<td style="text-align:center">设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</td>
</tr>
<tr>
<td style="text-align:center"><code>masterauth &lt;master-password&gt;</code></td>
<td style="text-align:center">当 master 服务设置了密码保护时，slav 服务连接 master 的密码</td>
</tr>
<tr>
<td style="text-align:center"><code>requirepass foobared</code></td>
<td style="text-align:center">设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <code>&lt;password&gt; </code> 命令提供密码，默认关闭</td>
</tr>
<tr>
<td style="text-align:center"><code>maxclients 128</code></td>
<td style="text-align:center">设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td>
</tr>
<tr>
<td style="text-align:center"><code>maxmemory &lt;bytes&gt;</code></td>
<td style="text-align:center">指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</td>
</tr>
<tr>
<td style="text-align:center"><code>appendonly no</code></td>
<td style="text-align:center">指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td>
</tr>
<tr>
<td style="text-align:center"><code>appendfilename appendonly.aof</code></td>
<td style="text-align:center">指定更新日志文件名，默认为 appendonly.aof</td>
</tr>
<tr>
<td style="text-align:center"><code>appendfsync everysec</code></td>
<td style="text-align:center">指定更新日志条件，共有 3 个可选值：<br>no：表示等操作系统进行数据缓存同步到磁盘（快）<br>always：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）<br>everysec：表示每秒同步一次（折中，默认值）<br></td>
</tr>
<tr>
<td style="text-align:center"><code>vm-enabled no</code></td>
<td style="text-align:center">指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将浏览量较少的页即冷数据 swap 到磁盘上，浏览多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）</td>
</tr>
<tr>
<td style="text-align:center"><code>vm-swap-file /tmp/redis.swap</code></td>
<td style="text-align:center">虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享</td>
</tr>
<tr>
<td style="text-align:center"><code>vm-max-memory 0</code></td>
<td style="text-align:center">将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td>
</tr>
<tr>
<td style="text-align:center"><code>vm-page-size 32</code></td>
<td style="text-align:center">Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td>
</tr>
<tr>
<td style="text-align:center"><code>vm-pages 134217728</code></td>
<td style="text-align:center">设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td>
</tr>
<tr>
<td style="text-align:center"><code>vm-max-threads 4</code></td>
<td style="text-align:center">设置连接swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</td>
</tr>
<tr>
<td style="text-align:center"><code>glueoutputbuf yes</code></td>
<td style="text-align:center">设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</td>
</tr>
<tr>
<td style="text-align:center"><code>hash-max-zipmap-entries 64</code><br><code>hash-max-zipmap-value 512</code></td>
<td style="text-align:center">指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</td>
</tr>
<tr>
<td style="text-align:center"><code>activerehashing yes</code></td>
<td style="text-align:center">指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）</td>
</tr>
<tr>
<td style="text-align:center"><code>include /path/to/local.conf</code></td>
<td style="text-align:center">指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</td>
</tr>
</tbody>
</table>
<h2 id="5-3-Units-单位"><a class="header-anchor" href="#5-3-Units-单位"></a>5.3 Units 单位</h2>
<p>在配置文件开头有这样一段字：</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/Units单位.png" alt="Units单位" style="zoom:67%;">
<p>这是配置文件大小单位，开头定义了一些基本的度量单位，只支持 bytes，不支持 bit。</p>
<p>注意单位 <mark>带有</mark> 字母 b 和 <mark>不带有</mark> 字母 b 的区别。</p>
<p>单位对大小写不敏感。</p>
<h2 id="5-4-INCLUDES-包含"><a class="header-anchor" href="#5-4-INCLUDES-包含"></a>5.4 INCLUDES 包含</h2>
<p>在配置文件中，有一栏名为 INCLUDES：</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/INCLUDES栏.png" alt="INCLUDES栏" style="zoom:67%;">
<p>这个很好理解，和我们的 MyBatis、Spring 等配置文件类似，可以通过 includes 包含，redis.conf 可以作为总闸，包含其他配置文件。</p>
<h2 id="5-5-GENERAL-通用"><a class="header-anchor" href="#5-5-GENERAL-通用"></a>5.5 GENERAL 通用</h2>
<blockquote>
<p>tcp-backlog 配置项</p>
</blockquote>
<p>默认值：511，在 Redis 6.0.8 版本中该项位于 NETWORK 中。</p>
<p>设置 Tcp 的 backlog，backlog 其实是一个连接队列，backlog 队列总和 = 未完成三次握手队列 + 已经完成三次握手队列。</p>
<p>在高并发环境下你需要一个高 backlog 值来避免慢客户端连接问题。注意 Linux 内核会将这个值减小到 <code>/proc/sys/net/core/somaxconn</code> 的值，所以需要确认增大 somaxconn 和 tcp_max_syn_backlog 两个值来达到想要的效果。</p>
<blockquote>
<p>tcp-keepalive 配置项</p>
</blockquote>
<p>默认值：300，在 Redis 6.0.8 版本中该项位于 NETWORK 中。</p>
<p>单位为秒，如果设置为 0，这不会进行 KeepAlive 检测，建议设置成 60。</p>
<blockquote>
<p>系统日志项</p>
</blockquote>
<pre># To enable logging to the system logger, just set 'syslog-enabled' to yes,
# and optionally update the other syslog parameters to suit your needs.
# syslog-enabled no<br>
# Specify the syslog identity.
# syslog-ident redis<br>
# Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.
# syslog-facility local0
</pre>
<p>系统日志默认是关闭的，配置项为 <code>syslog-enabled</code>，表示是否把日志输出到 syslog 中</p>
<p>如果将系统日志打开，那么日志将会以 redis 开头，配置项为 <code>syslog-ident</code>，表示指定 syslog 里的日志标志</p>
<p>还可以指定 syslog 设置，值可以是 USER 或 LOCAL0 - LOCAL7，配置项是 <code>syslog-facility</code></p>
<h2 id="5-6-SNAPSHOTTING-快照"><a class="header-anchor" href="#5-6-SNAPSHOTTING-快照"></a>5.6 SNAPSHOTTING 快照</h2>
<p>这个配置通常与持久化 RDB 配合使用。</p>
<p>RDB 是整个内存的压缩过的 Snapshot，由于 RDB 的数据结构，可以配置符合的快照触发条件。</p>
<p>配置方式是：<code>save 秒数 写操作次数</code>，Redis 的配置文件中提供了默认的配置：</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/Redis默认SNAPSHOTTING配置.png" alt="Redis默认SNAPSHOTTING配置" style="zoom:67%;">
<p>表示 15 分钟内修改了 1 次，或 5 分钟内修改了 10 次，或 1 分钟内修改了 1 万次。</p>
<p>如果想禁用 RDB 持久化的策略，只要不设置任何 save 指令，或者给 save 传入一个空字符串参数也可以，比如 <code>save ""</code>。</p>
<p>如果遇到特别敏感或重要的数据想要立即持久化，可以直接执行 <code>save</code> 命令。</p>
<p>当执行 SHUTDOWN 和 FLUSHALL 命令时就会生成 dump.rdb 文件，这个 rdb 文件就存储了我们的数据信息，等到再次启动的时候就会使用这个文件恢复数据。</p>
<p>但是需要注意的是，执行 SHUTDOWN 和 FLUSHALL 命令生成的 rdb 文件内容是执行命令后的库中的数据。也就是说，执行 FLUSHALL 命令会生成 rdb 文件，但是由于清空了库，生成的 rdb 文件内是没有任何内容的，再次启动 Redis 会使用这个文件恢复数据，但由于文件内没有数据，因此也就恢复不了什么数据。</p>
<p>一般情况下，我们会对 dump.rdb 文件进行备份，且备份在另一台机器上，如果执行 FLUSHALL  了，只需要将另一台机器备份的 rdb 文件转移到本机上，并将名字修改为 dump.rdb，再次启动 Redis，那么还是可以恢复数据的。</p>
<blockquote>
<p>其他相关配置</p>
</blockquote>
<p>在这一栏中还有一些配置项，比如：</p>
<p>1、<code>stop-writes-on-bgsave-error</code>，这个配置项默认值是 yes。如果配置成no，表示你不在乎数据不一致或者有其他的手段发现和控制。</p>
<p>2、<code>rdbcompression</code>，这个配置项默认值是 yes。它表示对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果设置为 yes，Redis 会采用 LZF 算法进行压缩。如果你不想消耗 CPU 来进行压缩的话，可以设置为 no 关闭此功能。</p>
<p>3、<code>rdbchecksum</code>，这个配置项默认值是 yes。它表示在存储快照后，还可以让 Redis 使用 CRC64 算法来进行数据校验，但是这样做会增加大约 10% 的性能消耗，如果希望获取到最大的性能提升，可以设置为 no 关闭此功能。</p>
<p>4、<code>dbfilename</code>，这个配置项默认值是 dump.rdb。它指定了本地数据库文件名，默认值为 dump.rdb，也就是我们用来进行数据恢复的文件名。</p>
<p>5、<code>dir</code>，这个配置项的默认值是 <code>./</code>。它指定本地数据库文件的存放目录，也就是 dump.rdb 的存放位置，默认是存放在 Redis 启动位置的。如果在默认值的情况下，我现在 <code>/usr/local/bin</code> 目录下启动了 Redis，然后添加了一些数据，最后关闭 Redis，并在目录下生成 dump.rdb 文件。之后我在 <code>/</code> 目录下启动 Redis，执行 <code>keys *</code> 是获取不到上次添加的数据的，因为当前目录下没有上次生成 的 dump.rdb 文件。可以对这个配置项进行配置，指定存放目录，这样就不会出现这种情况了。</p>
<h2 id="5-7-REPLICATION-复制"><a class="header-anchor" href="#5-7-REPLICATION-复制"></a>5.7 REPLICATION 复制</h2>
<p>与主从复制相关，参考【Redis 基础 下篇】一文。</p>
<h2 id="5-8-SECURITY-安全"><a class="header-anchor" href="#5-8-SECURITY-安全"></a>5.8 SECURITY 安全</h2>
<p>在这一栏可以进行访问密码的查看、设置和取消。</p>
<p>当我们启动了 Redis 并连接 Redis 时，只需要输入两个命令就可以了，而不用输入密码，但是根据 MySQL 的使用经验，MySQL 连接是需要输入密码的，当然也可以通过设置而不输入密码。</p>
<p>Redis连接动默认是不需要输入密码的，当然也可以设置输入密码。</p>
<p>我们连接 Redis 使用命令 <code>config get requirepass</code> 来看看 Redis 的连接密码：</p>
<pre>127.0.0.1:6379&gt; config get requirepass
1) "requirepass"
2) ""
</pre>
<p>既然可以 get 获取配置，那也可以通过 set 来设置配置：</p>
<pre>127.0.0.1:6379&gt; config set requirepass "mofan212"
OK
127.0.0.1:6379&gt; config get requirepass
1) "requirepass"
2) "mofan212"
</pre>
<p>然后重启 Redis，如果我们再次 ping，就无法显示 PONG，需要在输入命令前执行 <code>auth 设置的密码</code>。</p>
<p>如果需要恢复原来的设置，需要执行 <code>config set requirepass ''</code></p>
<h2 id="5-9-LIMITS-限制"><a class="header-anchor" href="#5-9-LIMITS-限制"></a>5.9 LIMITS 限制</h2>
<p>在 Redis 6.0.8 版本中该栏已经被删除，其配置项分布在其他栏中。</p>
<p>maxclients 配置项分布在 <code>CLIENTS</code> 栏中，表示 Redis 客户端最大连接数。</p>
<p>maxmemory 配置项分布在 <code>MEMORY MANAGEMENT</code> 栏中，表示 Redis 的最大占用内存，默认是没被设置的。</p>
<p>maxmemory-policy 配置项分布在 <code>MEMORY MANAGEMENT</code> 栏中。</p>
<p>maxmemory-samples 配置项分布在 <code>MEMORY MANAGEMENT</code> 栏中。</p>
<p>我们可以使用命令查看一下这些配置项的默认值：</p>
<pre>127.0.0.1:6379&gt; config get maxclients
1) "maxclients"
2) "10000"
127.0.0.1:6379&gt; config get maxmemory
1) "maxmemory"
2) "0"
127.0.0.1:6379&gt; config get maxmemory-policy
1) "maxmemory-policy"
2) "noeviction"
127.0.0.1:6379&gt; config get maxmemory-samples
1) "maxmemory-samples"
2) "5"
</pre>
<p>配置文件中说明的缓存过期策略（<code>maxmemory-policy</code>）：</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/Redis缓存过期策略.png" alt="Redis缓存过期策略" style="zoom:67%;">
<p>默认是永不过期（noeviction）的。对上述内容翻译一下：</p>
<p>volatile-lru：只对设置了过期时间的键使用 LRU 算法移除key。</p>
<p>allkeys-lru：使用 LRU 算法移除 key。</p>
<p>volatile-lfu：只对设置了过期时间的键使用 LFU 算法移除key。</p>
<p>allkeys-lfu：使用 LFU 算法移除 key。</p>
<p>volatile-random：只对设置了过期时间的键在过期集合中移除随机的 key</p>
<p>allkeys-random：移除随机的 key。</p>
<p>volatile-ttl：移除那些 TTL 值最小的 key，即那些最近要过期的 key。</p>
<p>noeviction：不进行移除。针对写操作，只是返回错误信息。</p>
<p>其中：</p>
<ul>
<li>
<p>LRU：最近最久未使用</p>
</li>
<li>
<p>LFU：最近最少使用</p>
</li>
<li>
<p>TTL：Time To Live，生存时间值</p>
</li>
</ul>
<p><code>maxmemory-samples</code> 表示设置样本数量，LRU 算法和最小 TTL 算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，Redis 默认会检查这么多个 key 并选择其中 LRU 的那个</p>
<h2 id="5-10-APPEND-ONLY-MODE-追加"><a class="header-anchor" href="#5-10-APPEND-ONLY-MODE-追加"></a>5.10 APPEND ONLY MODE 追加</h2>
<p>这个配置通常与持久化 AOF 配合使用。</p>
<p>在配置文件 redis.conf 中可以看到，append only 默认是关闭的：</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/append-only配置.png" alt="append-only配置" style="zoom:67%;">
<p>执行 <code>cp redis.conf redis_aof.conf</code> 命令，将配置文件拷贝一份，修改拷贝的文件，将 appendonly 打开，修改为 yes 就行。</p>
<p>在这个配置项的下面几行就可以看到 <code>appendfilename "appendonly.aof" </code> 配置项，它指定了保存的文件名，不做修改，使用默认的就行。</p>
<blockquote>
<p>AOF 与 RDB</p>
</blockquote>
<p>接下里前往 <code>/usr/local/bin</code> 目录删除生成的 rdb 文件： <code>rm -f dump.rdb</code></p>
<p>然后在此目录下启动 Redis，就像：</p>
<pre>[root@cheny bin]# redis-server /Redis/redis_aof.conf
[root@cheny bin]# redis-cli -p 6379
127.0.0.1:6379&gt; keys *
(empty array)
</pre>
<p>启动 Redis 后，就会在当前目录下生成 appendonly.aof 文件。然后添加一些数据，并执行 <code>FLUSHALL</code> 命令，关闭 Redis：</p>
<pre>127.0.0.1:6379&gt; set k1 v1
OK
127.0.0.1:6379&gt; set k2 v2
OK
127.0.0.1:6379&gt; set k3 v3
OK
127.0.0.1:6379&gt; set k4 v4
OK
127.0.0.1:6379&gt; FLUSHALL
OK
127.0.0.1:6379&gt; SHUTDOWN
not connected&gt; exit
</pre>
<p>这之后还会在当前目录下生成 dump.rdb 文件，为了不必要的误会，我们干掉它：<code>rm -f dump.rdb</code></p>
<p>我们可以执行 <code>cat appendonly.aof</code> 命令，看看这个文件中的内容，可以看到这个文件里记录了我们刚才所做的一些操作，同时也记录了最后的 <code>FLUSHALL</code> 操作。</p>
<p>因此当我们再次按照上述方式启动 Redis，并执行 <code>ksys *</code> 命令查看库中的 key 时，会读取 aof 文件进行数据恢复，但由于记录了 <code>FLUSHALL</code> 操作，因此库中还是空的。</p>
<p>既然如此，可以编辑一下 <code>appendonly.aof</code> 文件，将最后记录的 <code>FLUSHALL</code> 操作给删了（删除光标所在行的命令是 <code>dd</code>）。</p>
<p>最后还是像前面的操作一样启动 Redis，执行 <code>keys *</code> 命令，可以看到库中有数据了：</p>
<pre>[root@cheny bin]# redis-server /Redis/redis_aof.conf
[root@cheny bin]# redis-cli -p 6379
127.0.0.1:6379&gt; KEYS *
1) "k3"
2) "k1"
3) "k4"
4) "k2"
</pre>
<p>我们退出 Redis，然后修改 <code>appendonly.aof</code> 文件，在最后胡乱添加一些数据，模拟文件损坏。</p>
<p>然后再启动 Redis，接下来能够成功启动 Redis 吗？</p>
<pre>[root@cheny bin]# redis-server /Redis/redis_aof.conf
[root@cheny bin]# ps -ef|grep redis
root      25428  23535  0 20:39 pts/1    00:00:00 grep --color=auto <font color="#EF2929"><b>redis</b></font>
[root@cheny bin]# redis-cli -p 6379
Could not connect to Redis at 127.0.0.1:6379: Connection refused
</pre>
<p>可以看到是无法启动 Redis 的，这验证了 aof 文件和 rdb 文件是可以共存的，并且会优先加载 aof 文件。</p>
<p>在配置文件中也可以看到，RDB 和 AOF 是可以共存的：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/AOF%E4%B8%8ERDB%E5%8F%AF%E4%BB%A5%E5%85%B1%E5%AD%98.png" alt="AOF与RDB可以共存"></p>
<p>由于 aof 文件损坏，因此是无法启动 Redis 的，那么可以修复吗？</p>
<p>那当然是可以的，只需要执行命令 <code>redis-check-aof --fix appendonly.aof</code>，就像：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/%E4%BF%AE%E5%A4%8Daof%E6%96%87%E4%BB%B6.png" alt="修复aof文件"></p>
<p>然后再启动 Redis，就能够成功启动了，并且还能够查询到前面添加的数据。🐮</p>
<p>如果查看 <code>appendonly.aof</code> 文件，甚至可以看到我们胡乱添加的数据已经被干掉了。</p>
<blockquote>
<p>其他相关配置</p>
</blockquote>
<p>1、<code>appendfsync</code> 表示追加同步，Redis 给定了三种方式：</p>
<ul>
<li>always：同步持久化。每次发生数据变更都会被立即记录到磁盘，性能较差但数据完整性比较好。</li>
<li>everysec：出厂 <strong>默认</strong> 推荐，异步操作，每秒记录，如果一秒内宕机，会有数据丢失。</li>
<li>no：从不同步</li>
</ul>
<p>2、<code>no-appendfsync-on-rewrite</code>：默认值是 no，表示重写时是否可以运用 appendfsync，用默认即可，保证数据安全性。</p>
<p>3、<code>auto-aof-rewrite-min-size</code>：默认是 64 mb，用于设置重写的基准值</p>
<p>4、<code>auto-aof-rewrite-percentage</code>：默认是 100，用于设置重写的基准值</p>
<h1 id="6-持久化之-RDB"><a class="header-anchor" href="#6-持久化之-RDB"></a>6. 持久化之 RDB</h1>
<h2 id="6-1-什么是-RDB"><a class="header-anchor" href="#6-1-什么是-RDB"></a>6.1 什么是 RDB</h2>
<p>RDB 全称是 Redis DataBase。</p>
<p>它就是在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的 Snapshot 快照，它恢复时是将快照文件直接读到内存里。</p>
<p>Redis 会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何 IO 操作的，这就确保了极高的性能。</p>
<p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。</p>
<p>RDB 的缺点是最后一次持久化后的数据可能丢失。</p>
<p>Fork 的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</p>
<p>RDB 保存的是 dump.rdb 文件。</p>
<p>那在哪里进行配置呢？在 Redis 的配置文件 redis.conf 搜索 <code>SNAPSHOTTING</code>，参考本文 5.6。</p>
<p>RDB 产生的快照文件是临时文件，当 Redis 关闭后，快照文件也会一并删除。因此常常需要将快照文件修改名称后并备份，等 Redis 重新启动后，再把名称改为 dump.rdb，此时备份数据会直接加载。</p>
<h2 id="6-2-如何触发-RDB-快照"><a class="header-anchor" href="#6-2-如何触发-RDB-快照"></a>6.2 如何触发 RDB 快照</h2>
<p>触发 RDB 快照有以下几种方式：</p>
<p>1、配置文件中 <code>SNAPSHOTTING </code> 一栏的默认的快照配置。<code>dbfilename dump.rdb</code> 指定了数据库文件名，一般会冷拷贝后重新使用，可以使用 <code>cp dump.rdb dump_new.rdb</code> 进行拷贝。</p>
<p>2、执行命令 save 或者是 bgsave 后：</p>
<ul>
<li>SAVE：save 时只管保存，其它不管，全部阻塞</li>
<li>BGSAVE：Redis 会在后台异步进行快照操作， 快照同时还可以响应客户端请求。可以通过lastsave 命令获取最后一次成功执行快照的时间</li>
</ul>
<p>3、执行 flushall 命令，也会产生 dump.rdb 文件，但里面是空的，无意义。</p>
<p>4、SHUTDOWN（正常关闭）时，如果没有开启 AOF，会触发 RDB。<code>kill -9</code> 意外宕机不会触发 RDB 持久化。</p>
<p>第一点属于自动触发，后面三点属于手动触发。</p>
<h2 id="6-3-如何恢复数据"><a class="header-anchor" href="#6-3-如何恢复数据"></a>6.3 如何恢复数据</h2>
<p>将备份文件（dump.rdb）移动到 Redis 安装目录并启动服务即可，可以使用 <code>CONFIG GET dir</code> 命令获取目录。</p>
<h2 id="6-4-优势与劣势"><a class="header-anchor" href="#6-4-优势与劣势"></a>6.4 优势与劣势</h2>
<blockquote>
<p>优势</p>
</blockquote>
<ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高</li>
<li>节省磁盘空间</li>
<li>恢复速度快</li>
</ul>
<blockquote>
<p>劣势</p>
</blockquote>
<ul>
<li>在一定间隔时间做一次备份，所以如果 Redis 意外宕掉的话，就会丢失最后一次快照后的所有修改</li>
<li>fork 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑</li>
<li>虽然 Redis 在 fork 时使用了写时拷贝技术，但如果数据过于庞大时还是比较消耗性能</li>
</ul>
<h2 id="6-5-如何停止"><a class="header-anchor" href="#6-5-如何停止"></a>6.5 如何停止</h2>
<p>动态所有停止 RDB 保存规则的方法：<code>redis-cli config set save ""</code></p>
<h2 id="6-6-小结"><a class="header-anchor" href="#6-6-小结"></a>6.6 小结</h2>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/RDB%E6%8C%81%E4%B9%85%E5%8C%96%E5%B0%8F%E7%BB%93.png" alt="RDB持久化小结"></p>
<ul>
<li>RDB 是一个非常紧凑的文件。</li>
<li>RDB 在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以 RDB 持久化方式可以最大化 Redis 的性能。</li>
<li>与 AOF 相比，在恢复大的数据集的时候，RDB 方式会更快一一些。</li>
<li>数据丢失风险大。</li>
<li>RDB 需要经常 fork 子进程来保存数据集到硬盘上，当数据集比较大的时候 fork 的过程是非常耗时的吗，可能会导致 Redis 在一些毫秒级不能回应客户端请求。</li>
</ul>
<h1 id="7-持久化之-AOF"><a class="header-anchor" href="#7-持久化之-AOF"></a>7. 持久化之 AOF</h1>
<h2 id="7-1-什么是-AOF"><a class="header-anchor" href="#7-1-什么是-AOF"></a>7.1 什么是 AOF</h2>
<p>既然有了 RDB 为什么还要有 AOF 呢？AOF 作为新技术解决了 RDB 不能解决的什么问题？如果同时存在 RDB 和 AOF，它们会发生冲突，还是进行协作？</p>
<p>AOF 全称是 Append Only File。</p>
<p>它是以日志的形式来记录每个写操作，将 Redis 执行过的所有写指令记录下来（读操作不记录）， 只许追加文件但不可以改写文件，Redis 启动之初会读取该文件重新构建数据，换言之，Redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<p>AOF 保存的是 appendonly.aof 文件（可以在配置文件可修改文件名，就像 RDB 一样）</p>
<p>那在哪里进行配置呢？ 在 Redis 的配置文件 redis.conf 搜索 <code>APPEND ONLY MODE</code>，参考本文 5.10。</p>
<p>默认 AOF 是关闭的，只需修改 <code>appendonly</code>  配置项为 yes 就行。</p>
<p>AOF 的备份并恢复操作和 RDB 是一样的，都是拷贝备份文件，进行数据恢复时拷贝到 Redis 工作目录下，系统启动时自动加载。</p>
<h2 id="7-2-启动、修复和恢复"><a class="header-anchor" href="#7-2-启动、修复和恢复"></a>7.2 启动、修复和恢复</h2>
<blockquote>
<p>正常恢复</p>
</blockquote>
<p>启动：设置 yes。修改默认的 appendonly no，改为 yes 即可。</p>
<p>一般来说会对 aof 文件进行备份，将有数据的 aof 文件复制一份保存到对应目录（<code>config get dir</code>）。</p>
<p>恢复：重启 Redis 然后重新加载。</p>
<blockquote>
<p>异常恢复</p>
</blockquote>
<p>启动：与正常恢复一样，设置 yes。修改默认的 <code>appendonly no</code>，改为 yes 即可。</p>
<p>先备份被写坏的 aof 文件，然后执行 <code>Redis-check-aof --fix aof文件</code> 进行修复。</p>
<p>恢复：重启 Redis 然后重新加载。</p>
<h2 id="7-3-Rewrite"><a class="header-anchor" href="#7-3-Rewrite"></a>7.3 Rewrite</h2>
<blockquote>
<p>什么是 rewrite</p>
</blockquote>
<p>AOF 采用文件追加方式，文件会越来越大。为避免出现此种情况，新增了重写机制， 当 AOF 文件的大小超过所设定的阈值时，Redis 就会启动 AOF 文件的内容压缩， 只保留可以恢复数据的最小指令集。可以使用命令 <code>bgrewriteaof</code>。</p>
<blockquote>
<p>重写原理</p>
</blockquote>
<p>AOF 文件持续增长而过大时，会 fork 出一条新进程来将文件重写（也是先写临时文件最后再 rename）， 遍历新进程的内存中数据，每条记录有一条的 set 语句。重写 aof 文件的操作，并没有读取旧的 aof 文件， 而是将整个内存中的数据库内容用命令的方式重写了一个新的 aof 文件，这点和快照有点类似。</p>
<blockquote>
<p>触发机制</p>
</blockquote>
<p>Redis 会记录上次重写时的 aof 大小，默认配置是当 aof 文件大小是上次 rewrite 后大小的一倍且文件大于 64M 时触发。</p>
<p>配置文件 APPEND ONLY MODE 一栏中的配置项：</p>
<p><code>auto-aof-rewrite-min-size</code>：默认是 64 mb，rewrite 触发时 aof 文件的最小值</p>
<p><code>auto-aof-rewrite-percentage</code>：默认是 100，表示 100%，即一倍</p>
<h2 id="7-4-优势与劣势"><a class="header-anchor" href="#7-4-优势与劣势"></a>7.4 优势与劣势</h2>
<blockquote>
<p>优势</p>
</blockquote>
<ul>
<li>每秒同步：appendfsync always（同步持久化）每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</li>
<li>每修改同步：appendfsync everysec（异步操作，每秒记录）默认方式。如果一秒内宕机，有数据丢失</li>
<li>不同步：appendfsync no （从不同步）</li>
</ul>
<blockquote>
<p>劣势</p>
</blockquote>
<ul>
<li>相同数据集的数据而言 aof 文件要远大于 rdb 文件，恢复速度慢于 rdb</li>
<li>AOF 运行效率要慢于 RDB，每秒同步策略效率较好，不同步效率和 RDB 相同</li>
</ul>
<h2 id="7-5-小结"><a class="header-anchor" href="#7-5-小结"></a>7.5 小结</h2>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/MiddlewareImages/AOF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B0%8F%E7%BB%93.png" alt="AOF持久化小结"></p>
<ul>
<li>aof 文件是一个只进行追加的日志文件</li>
<li>Redis 可以在 aof 文件体积变得过大时，自动地在后台对 aof 进行重写</li>
<li>aof 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存，因此 aof 文件的内容非常容易被人读懂，对文件进行分析也很轻松</li>
<li>对于相同的数据集来说，aof 文件的体积通常要大于 rdb 文件的体积</li>
<li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB</li>
</ul>
<h2 id="7-6-持久化总结"><a class="header-anchor" href="#7-6-持久化总结"></a>7.6 持久化总结</h2>
<p>两种持久化策略到底该选哪一种呢？</p>
<p>RDB 持久化方式能够在指定的时间间隔能对数据进行快照存储</p>
<p>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF 命令以 Redis 协议追加保存每次写的操作到文件末尾</p>
<p>Redis 还能对 aof 文件进行后台重写，使得 aof 文件的体积不至于过大</p>
<p>只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式</p>
<blockquote>
<p>同时开启两种持久化方式</p>
</blockquote>
<p>这样会先加载 aof 文件。</p>
<p>在这种情况下，当 Redis 重启的时候会优先载入 aof 文件来恢复原始的数据，因为在通常情况下 aof 文件保存的数据集要比 rdb 文件保存的数据集更完整。</p>
<p>RDB 的数据不实时，同时使用两者时服务器重启也只会找 aof 文件。那要不要只使用 AOF 呢？</p>
<p>Redis 作者建议不要，因为 RDB 更适合用于备份数据库（ AOF 在不断变化不好备份），快速重启，而且不会有 AOF 可能潜在的 bug， 留着作为一个万一的手段。</p>
<blockquote>
<p>性能建议</p>
</blockquote>
<p>因为 rdb 文件只用作后备用途，建议只在 slave 上持久化 rdb 文件，而且只要 15 分钟备份一次就够了，只保留 <code>save 900 1</code>这条规则。</p>
<p>如果使用 AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只加载自己的 aof 文件就可以了。代价一是带来了持续的 IO，二是 AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少 AOF rewrite 的频率，AOF 重写的基础大小默认值 64M 太小了，可以设到 5G 以上。默认是超过原文件大小 100% 时进行重写可以修改到适当的数值。</p>
<p>如果不使用 AOF，仅靠 Master-Slave Replication （主从复制）实现高可用性也可以。能省掉一大笔 IO 也减少了 rewrite 时带来的系统波 动。代价是如果 Master / Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master / Slave 中的 rdb 文件，并载入较新的那个。新浪微博就选用了这种架构。</p>
</body></html></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mofan212.github.io">默烦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mofan212.github.io/posts/The-Basics-Of-Redis-Part-One/">https://mofan212.github.io/posts/The-Basics-Of-Redis-Part-One/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://mofan212.github.io" target="_blank">Mofan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Middleware/">Middleware</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post-share"><div class="social-share" data-image="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/72.png" data-sites="wechat,qq,weibo,facebook,x"></div><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" target="_blank"><img class="post-qr-code-img" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" target="_blank"><img class="post-qr-code-img" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/Record-A-Test/" title="【随笔】记一次入职测试"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/71.jpg" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">【随笔】记一次入职测试</div></div><div class="info-2"><div class="info-item-1">虚心学习，加油努力。自己要走的路还有很远，要学习的知识还有很多。</div></div></div></a><a class="pagination-related" href="/posts/The-Basics-Of-Redis-Part-Two/" title="【下篇】Redis 基础篇"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/73.png" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">【下篇】Redis 基础篇</div></div><div class="info-2"><div class="info-item-1">本文主要介绍了 Redis 事务、发布订阅、Redis 的复制以及如何整合 SpringBoot。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/Redis-Cluster-And-Distributed-Locks/" title="Redis 集群与分布式锁"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/102.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-28</div><div class="info-item-2">Redis 集群与分布式锁</div></div><div class="info-2"><div class="info-item-1">本文介绍了 Redis 集群的模拟搭建、故障恢复、利用 Redis 实现简单的分布式锁和 Redis 6 中的新特性。</div></div></div></a><a class="pagination-related" href="/posts/The-Basics-Of-Redis-Part-Two/" title="【下篇】Redis 基础篇"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/73.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-08</div><div class="info-item-2">【下篇】Redis 基础篇</div></div><div class="info-2"><div class="info-item-1">本文主要介绍了 Redis 事务、发布订阅、Redis 的复制以及如何整合 SpringBoot。</div></div></div></a><a class="pagination-related" href="/posts/Distributed-Message-Queue-RocketMQ-Part-Two/" title="【下篇】分布式消息队列 RocketMQ"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/95.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-19</div><div class="info-item-2">【下篇】分布式消息队列 RocketMQ</div></div><div class="info-2"><div class="info-item-1">本文介绍了 RocketMQ 的工作原理与应用。</div></div></div></a><a class="pagination-related" href="/posts/Distributed-Message-Queue-RocketMQ-Part-One/" title="【上篇】分布式消息队列 RocketMQ"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/90.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-04</div><div class="info-item-2">【上篇】分布式消息队列 RocketMQ</div></div><div class="info-2"><div class="info-item-1">本文介绍了 RocketMQ 的安装与启动以及围绕它们进行拓展的相关知识点。</div></div></div></a><a class="pagination-related" href="/posts/Install-HBase/" title="HBase的安装"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/9.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-29</div><div class="info-item-2">HBase的安装</div></div><div class="info-2"><div class="info-item-1">本文基于Hadoop 3.2.1 对虚拟机上HBase的安装与安装过程中可能出现的问题进行了讲解。</div></div></div></a><a class="pagination-related" href="/posts/Advanced-HBase/" title="HBase原理"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/7.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-29</div><div class="info-item-2">HBase原理</div></div><div class="info-2"><div class="info-item-1">本文简单介绍了 HBase 的原理包括架构原理、读写流程、读写拓展、数据删除时间等内容。</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">默烦</div><div class="author-info-description">彩笔的打怪升级之路...</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">174</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mofan212"><i class="fab fa-github"></i><span>follow me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:cy.mofan@foxmail.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站所有博文均是博主的学习笔记与个人理解。<strong><font style="color:red">除特别注明外，</font>如需转载，请在文章头部醒目处附带原文链接并<a href="./mine/" style="color:#49B1F5;text-decoration:underline">告知我</a></strong>你将转载。😊</br><strong><font style="color:red">严禁未遵循规范的转载。</font></strong>😡</br><strong>死去的评论系统复活啦！欢迎到留言板畅所欲言！</strong>当然也可以使用更高效的<a target="_blank" href="https://space.bilibili.com/23658864/dynamic" style="color:#49B1F5;text-decoration:underline"> 哔哩哔哩私信 </a>或<a href="mailto:cy.mofan@foxmail.com" style="color:#49B1F5;text-decoration:underline" target="_blank">邮箱</a>。 😉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-NoSQL-%E5%85%A5%E9%97%A8%E4%B8%8E%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="toc-text">1. NoSQL 入门与概述（上）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-NoSQL"><span class="toc-text">1.1 为什么要有 NoSQL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E4%BB%80%E4%B9%88%E6%98%AF-NoSQL"><span class="toc-text">1.2 什么是 NoSQL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-NoSQL-%E7%89%B9%E6%80%A7"><span class="toc-text">1.3 NoSQL 特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%9C%89%E5%93%AA%E4%BA%9B-NoSQL-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">1.4 有哪些 NoSQL 数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-text">1.5 有什么用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-NoSQL-%E5%85%A5%E9%97%A8%E4%B8%8E%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-text">2. NoSQL 入门与概述（下）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-3V-3-%E9%AB%98"><span class="toc-text">2.1 3V + 3 高</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%BD%93%E4%B8%8B%E7%9A%84-NoSQL-%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8"><span class="toc-text">2.2 当下的 NoSQL 经典应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-NoSQL-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B"><span class="toc-text">2.3 NoSQL 数据模型简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-NoSQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%88%86%E7%B1%BB"><span class="toc-text">3.3 NoSQL 数据库的四大分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD-CAP-%E5%8E%9F%E7%90%86"><span class="toc-text">3.4 分布式数据库中 CAP 原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Redis-%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0"><span class="toc-text">3. Redis 入门概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0"><span class="toc-text">3.1 入门概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Redis-%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-text">3.2 Redis 的安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Hello-World"><span class="toc-text">3.3 Hello World</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%90%AF%E5%8A%A8%E5%90%8E%E7%9A%84%E6%9D%82%E9%A1%B9%E7%9F%A5%E8%AF%86"><span class="toc-text">3.4 启动后的杂项知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Windows-%E4%B8%8B%E5%AE%89%E8%A3%85-Redis"><span class="toc-text">3.5 Windows 下安装 Redis</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">4. Redis 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Redis-%E7%9A%84%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.1 Redis 的五大数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Key-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">4.2 Key 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-String-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">4.3 String 字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-List-%E5%88%97%E8%A1%A8"><span class="toc-text">4.4 List 列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-Set-%E9%9B%86%E5%90%88"><span class="toc-text">4.5 Set 集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-Hash-%E5%93%88%E5%B8%8C"><span class="toc-text">4.6 Hash 哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-ZSet-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-text">4.7 ZSet 有序集合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90"><span class="toc-text">5. 配置文件解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%9C%A8%E5%93%AA"><span class="toc-text">5.1 配置文件在哪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Redis-%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-text">5.2 Redis 常见配置项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Units-%E5%8D%95%E4%BD%8D"><span class="toc-text">5.3 Units 单位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-INCLUDES-%E5%8C%85%E5%90%AB"><span class="toc-text">5.4 INCLUDES 包含</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-GENERAL-%E9%80%9A%E7%94%A8"><span class="toc-text">5.5 GENERAL 通用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-SNAPSHOTTING-%E5%BF%AB%E7%85%A7"><span class="toc-text">5.6 SNAPSHOTTING 快照</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-REPLICATION-%E5%A4%8D%E5%88%B6"><span class="toc-text">5.7 REPLICATION 复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-SECURITY-%E5%AE%89%E5%85%A8"><span class="toc-text">5.8 SECURITY 安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-LIMITS-%E9%99%90%E5%88%B6"><span class="toc-text">5.9 LIMITS 限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-10-APPEND-ONLY-MODE-%E8%BF%BD%E5%8A%A0"><span class="toc-text">5.10 APPEND ONLY MODE 追加</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8B-RDB"><span class="toc-text">6. 持久化之 RDB</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E4%BB%80%E4%B9%88%E6%98%AF-RDB"><span class="toc-text">6.1 什么是 RDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91-RDB-%E5%BF%AB%E7%85%A7"><span class="toc-text">6.2 如何触发 RDB 快照</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="toc-text">6.3 如何恢复数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="toc-text">6.4 优势与劣势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2"><span class="toc-text">6.5 如何停止</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E5%B0%8F%E7%BB%93"><span class="toc-text">6.6 小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8B-AOF"><span class="toc-text">7. 持久化之 AOF</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E4%BB%80%E4%B9%88%E6%98%AF-AOF"><span class="toc-text">7.1 什么是 AOF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E5%90%AF%E5%8A%A8%E3%80%81%E4%BF%AE%E5%A4%8D%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="toc-text">7.2 启动、修复和恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-Rewrite"><span class="toc-text">7.3 Rewrite</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="toc-text">7.4 优势与劣势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E5%B0%8F%E7%BB%93"><span class="toc-text">7.5 小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E6%8C%81%E4%B9%85%E5%8C%96%E6%80%BB%E7%BB%93"><span class="toc-text">7.6 持久化总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Git/" title="Git理论与使用"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/3.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Git理论与使用"/></a><div class="content"><a class="title" href="/posts/Git/" title="Git理论与使用">Git理论与使用</a><time datetime="2026-01-25T16:00:00.000Z" title="更新于 2026-01-26 00:00:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Something-About-Blog/" title="博客搭建与维护"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/42.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="博客搭建与维护"/></a><div class="content"><a class="title" href="/posts/Something-About-Blog/" title="博客搭建与维护">博客搭建与维护</a><time datetime="2026-01-24T16:00:00.000Z" title="更新于 2026-01-25 00:00:00">2026-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Memory-Model/" title="Java 内存模型"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/174.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Java 内存模型"/></a><div class="content"><a class="title" href="/posts/Java-Memory-Model/" title="Java 内存模型">Java 内存模型</a><time datetime="2026-01-02T16:00:00.000Z" title="更新于 2026-01-03 00:00:00">2026-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Bytecode-And-Class-Loading/" title="字节码与类加载"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/173.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="字节码与类加载"/></a><div class="content"><a class="title" href="/posts/Java-Bytecode-And-Class-Loading/" title="字节码与类加载">字节码与类加载</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Class-Resource-Loading-In-Java/" title="Java 的类资源加载"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/103.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Java 的类资源加载"/></a><div class="content"><a class="title" href="/posts/Class-Resource-Loading-In-Java/" title="Java 的类资源加载">Java 的类资源加载</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Annotation-And-Reflection/" title="注解、类的加载、反射"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/20.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="注解、类的加载、反射"/></a><div class="content"><a class="title" href="/posts/Annotation-And-Reflection/" title="注解、类的加载、反射">注解、类的加载、反射</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2020 - 2026 By 默烦</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.4</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://testingcf.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://testingcf.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://testingcf.jsdelivr.net/npm/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://testingcf.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://gcore.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources@master/js/mine.min.js"></script><script src="/js/tip_portal.js"></script><script defer="defer" id="ribbon" src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-show-text" src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Azathoth,Yog-Sothoth,Shub-Niggurath,Nyarlathotep,Cthulhu,Hastur,Abhoth,Ghroth,Tsathoggua,Cthugha,Deep Ones,Dagon,Chaugnar Faugn,Mordiggian,Shoggoth,Old One,Mi-Go,Great Race of Yith,Flying Polyp,Hounds of Tindalos,Dhole" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://testingcf.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'BAFEL7A6K1',
    apiKey: '89fcb5961984c5c054bf04149f345f38',
    indexName: 'mofan212io',
    container: '#docsearch',
    placeholder: '输入关键字进行搜索',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>
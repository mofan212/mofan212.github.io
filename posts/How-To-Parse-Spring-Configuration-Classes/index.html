<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring 配置类的解析 | Mofan</title><meta name="author" content="默烦,cy.mofan@foxmail.com"><meta name="copyright" content="默烦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="深入理解 ConfigurationClassPostProcessor，理清 Spring 配置类的解析。">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring 配置类的解析">
<meta property="og:url" content="https://mofan212.github.io/posts/How-To-Parse-Spring-Configuration-Classes/index.html">
<meta property="og:site_name" content="Mofan">
<meta property="og:description" content="深入理解 ConfigurationClassPostProcessor，理清 Spring 配置类的解析。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/154.webp">
<meta property="article:published_time" content="2024-10-25T16:00:00.000Z">
<meta property="article:modified_time" content="2024-10-25T16:00:00.000Z">
<meta property="article:author" content="默烦">
<meta property="article:tag" content="SpringBoot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/154.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Spring 配置类的解析",
  "url": "https://mofan212.github.io/posts/How-To-Parse-Spring-Configuration-Classes/",
  "image": "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/154.webp",
  "datePublished": "2024-10-25T16:00:00.000Z",
  "dateModified": "2024-10-25T16:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "默烦",
      "url": "https://mofan212.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/favicon.png"><link rel="canonical" href="https://mofan212.github.io/posts/How-To-Parse-Spring-Configuration-Classes/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 默烦","link":"链接: ","source":"来源: Mofan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://fastly.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring 配置类的解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/mofan212/blog-static-resources@master/css/myStyle.min.css"><link rel="stylesheet" href="https://cdn.staticfile.net/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css" /><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Mofan" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/mofan212/blog-static-resources/css/minimal.min.css"/><script src="https://fastly.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">158</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">30</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/post_top_img.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Mofan</span></a><a class="nav-page-title" href="/"><span class="site-name">Spring 配置类的解析</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Spring 配置类的解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-25T16:00:00.000Z" title="发表于 2024-10-26 00:00:00">2024-10-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-25T16:00:00.000Z" title="更新于 2024-10-26 00:00:00">2024-10-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SpringBoot/">SpringBoot</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">14k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>55分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;距离本文上次更新已经过去&quot;,&quot;messageNext&quot;:&quot;天，请注意时效性。&quot;,&quot;postUpdate&quot;:&quot;2024-10-26 00:00:00&quot;}" hidden></div><p>封面来源：碧蓝航线 飓风与沉眠之海 活动CG</p>
<h1 id="0-前言"><a class="header-anchor" href="#0-前言"></a>0. 前言</h1>
<h2 id="0-1-我的近况"><a class="header-anchor" href="#0-1-我的近况"></a>0.1 我的近况</h2>
<p>转眼间，又到八月底。最近两个月我一直想在一个月内完成 4 次周更，实际情况是仅仅依靠周末两天完成一篇博客还是太难。一方面，我自己也是“半桶水”，写的过程中也是在学习，反复地查阅各种资料是不可避免的，在这个过程，不仅要验证它们，还要把它们转换成自己的内容；另一方面，自己多年来的坏习惯也让我得到了反噬，坐立不安、心率加快时长发生，担心自己下一秒就会因此丧命，每当此时只得放下手中任何娱乐与学习，静躺在床上试图保持镇静以便缓解症状。</p>
<p>这周去了一趟华西，医师似乎对我这种症状见怪不怪，告知我应当每天花费一定的时间去运动，然后就开了一系列检查，这些检查也是需要预约的，运气还不错的我约到了第二天。我记得有个段子，一位外地游客到成都游玩，上了出租车后便让司机带他去成都最热闹的地方，而后司机把他带到了华西，这足以证明华西在西南人民心中的地位。尽管我去的并不是华西本部（但也是影分身），检查当天也早早到了医院，但几乎每项检查都要进行一段时间的排队。</p>
<p>昨晚查阅了检查的电子报告，似乎没有多大问题，但情况究竟如何还要在下周二复查后才能得知。</p>
<p>朋友，衷心祝愿你能够时刻保持身体健康，对了，不要忘记勤加运动、拒绝熬夜。（2024-08-18 记）</p>
<h2 id="0-2-内容概述"><a class="header-anchor" href="#0-2-内容概述"></a>0.2 内容概述</h2>
<p>言归正传，在 <a href="../Spring-BeanDefinition/">上一篇</a> 中熟悉了 <code>BeanDefinition</code> 中的相关 API，<code>BeanDefinition</code> 是 Spring 中绕不开的一个类，熟悉它的 API 对后续的源码阅读是非常有帮助的，甚至我认为阅读 Spring 源码的第一步就应该是了解 <code>BeanDefinition</code> 中 API 的使用。</p>
<p>经历 <code>BeanDefinition</code> 这个插曲，本文将按计划完成讲解 SpringBoot 自动配置前的最后一块拼图 —— Spring 配置类的解析。</p>
<p>开门见山，Spring 配置类的解析涉及到 <code>ConfigurationClassPostProcessor</code> 类，这个类也与 SpringBoot 的自动配置机制密切相关，因此决定单独成文，深入理解 <code>ConfigurationClassPostProcessor</code> 的作用。</p>
<p>除此之外，先前已经介绍过 <code>@Configuration</code> 注解的 Full 模式和 Lite 模式，其实现也是由 <code>ConfigurationClassPostProcessor</code> 完成的，因此本文在涉及到这些内容时会直接跳过，详情参考 <a href="../Configuration-Annotation/">@Configuration 注解的那些事</a>。</p>
<h2 id="0-3-阅读建议"><a class="header-anchor" href="#0-3-阅读建议"></a>0.3 阅读建议</h2>
<p>Spring 配置类的解析步骤涉及的类与方法的数量非常多，本文行文过程中经常会跳转到主线以外的类或方法，之后经过一番介绍后又回归主线，仅通过对阅读本文难以把握主线，因此推荐将本文作为阅读源码的辅助资料，结合对示例的 Debug 摸清行文逻辑，最终完成对 <code>ConfigurationClassPostProcessor</code> 类的进一步理解。</p>
<h2 id="0-4-术语解释"><a class="header-anchor" href="#0-4-术语解释"></a>0.4 术语解释</h2>
<p>为了行文的精简，对文中使用的部分术语解释如下：</p>
<ul>
<li>配置类：被 <code>@Configuration</code> 注解标记的类</li>
<li><code>@Bean</code> 方法、Bean 方法：被 <code>@Bean</code> 注解标记的方法</li>
</ul>
<h1 id="1-用法与示例"><a class="header-anchor" href="#1-用法与示例"></a>1. 用法与示例</h1>
<h2 id="1-1-Conditional-注解"><a class="header-anchor" href="#1-1-Conditional-注解"></a>1.1 @Conditional 注解</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Conditional &#123;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Condition</span>&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Conditional</code> 只能够作用在类和方法上，并且在使用时需要指定一个 <code>Condition</code> 的 <code>Class</code> 数组。</p>
<p>只有当所有 <code>Condition</code> 指定的条件都满足时，对应的 Bean 才会被注册到 Spring 容器中。</p>
<p>可以通过以下方式来使用 <code>@Conditional</code> 注解：</p>
<ul>
<li>作为类级别的注解，应用于任何直接或间接使用 <code>@Component</code> 注解的类，也包括配置类；</li>
<li>作为元注解，用于组合自定义原型注解；</li>
<li>作为方法级别的注解，作用在任何 <code>@Bean</code> 方法上</li>
</ul>
<p>如果一个配置类也被 <code>@Conditional</code> 注解标记，与该类关联的所有的 <code>@Bean</code> 方法、<code>@Import</code> 注解和 <code>@ComponentScan</code> 注解都将受到这些条件的约束。</p>
<p><mark>注意：</mark> 不支持 <code>@Conditional</code> 注解的继承。来自父类或 <strong>被</strong> 重写方法的任何条件都不会被考虑。为了强制执行这些语义，<code>@Conditional</code> 注解为被元注解 <code>@Inherited</code> 修饰，此外，任何使用 <code>@Conditional</code> 作为元注解的自定义组合注解也不得被 <code>@Inherited</code> 修饰。</p>
<h2 id="1-2-Condition-接口"><a class="header-anchor" href="#1-2-Condition-接口"></a>1.2 Condition 接口</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Condition</code> 是一个函数式接口，内部的 <code>matches()</code> 方法用于确定条件是否匹配，该方法接收两个参数，并返回一个 <code>boolean</code> 值。</p>
<p>如果返回 <code>true</code>，对应的 Bean 将会被注册到 Spring 容器中，否则会跳过该 Bean 的注册。</p>
<p>接收的两个参数的含义如下：</p>
<ul>
<li><code>context</code>：条件上下文，通过该参数可以获取到一些 Spring 容器等相关信息</li>
<li><code>metadata</code>：用于获取正在校验的类或方法的元数据</li>
</ul>
<p><code>Condition</code> 的使用必须遵循与 <code>BeanFactoryPostProcessor</code> 相同的限制（简单来说就是 <code>matches()</code> 方法会在 <code>BeanFactoryPostProcessor</code> 所在的阶段执行），并且注意绝不能与 Bean 实例进行交互（重写的 <code>matches()</code> 方法内部不能与 Bean 实例交互，因为 <code>matches()</code> 方法的调用时机往往在 Bean 实例化之前）。如果要对配置类的注册条件进行更细粒度的控制，可以考虑实现 <code>ConfigurationCondition</code> 接口。</p>
<p>对于给定类或方法上的多个 <code>Condition</code>，将根据实现的 <code>Ordered</code> 接口和使用 <code>@Order</code> 注解进行排序，排序规则参阅 <code>AnnotationAwareOrderComparator</code>。</p>
<h2 id="1-3-使用示例"><a class="header-anchor" href="#1-3-使用示例"></a>1.3 使用示例</h2>
<p>示例参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7204121228017451069">超详细分析Spring的@Conditional注解</a></p>
<p>项目结构如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">D:.</span><br><span class="line">│   pom.xml</span><br><span class="line">│   </span><br><span class="line">└───src</span><br><span class="line">    ├───main</span><br><span class="line">    │   ├───java</span><br><span class="line">    │   │   └───indi</span><br><span class="line">    │   │       └───mofan</span><br><span class="line">    │   │           │   Config.java</span><br><span class="line">    │   │           │   </span><br><span class="line">    │   │           ├───component</span><br><span class="line">    │   │           │       MyBean.java</span><br><span class="line">    │   │           │       MyController.java</span><br><span class="line">    │   │           │       MyDao.java</span><br><span class="line">    │   │           │       MyRepository.java</span><br><span class="line">    │   │           │       MyService.java</span><br><span class="line">    │   │           │       </span><br><span class="line">    │   │           ├───condition</span><br><span class="line">    │   │           │       ControllerCondition.java</span><br><span class="line">    │   │           │       DaoCondition.java</span><br><span class="line">    │   │           │       FurtherCondition.java</span><br><span class="line">    │   │           │       RepositoryCondition.java</span><br><span class="line">    │   │           │       ServiceCondition.java</span><br><span class="line">    │   │           │       </span><br><span class="line">    │   │           └───config</span><br><span class="line">    │   │                   MyFurtherConfig.java</span><br><span class="line">    │   │</span><br><span class="line">    │   └───resources</span><br><span class="line">    └───test</span><br><span class="line">        └───java</span><br><span class="line">                ConditionalTest.java</span><br></pre></td></tr></table></figure>
<p>也可以通过 <a target="_blank" rel="noopener" href="https://github.com/mofan212/springboot-study/tree/master/conditional">链接</a> 在 GitHub 上获取代码文件。</p>
<blockquote>
<p>首先定义一系列 <code>Condition</code> 的实现类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControllerCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        log.info(<span class="built_in">this</span>.getClass().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        log.info(<span class="built_in">this</span>.getClass().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FurtherCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        log.info(<span class="built_in">this</span>.getClass().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepositoryCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        log.info(<span class="built_in">this</span>.getClass().getName());</span><br><span class="line">        <span class="comment">// 这里是 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        log.info(<span class="built_in">this</span>.getClass().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了 <code>RepositoryCondition</code> 返回 <code>false</code> 外，其余实现都是返回 <code>true</code>。</p>
<blockquote>
<p>通过 <code>@Conditional</code> 注解使用 <code>Condition</code> 的实现类：</p>
</blockquote>
<p>作为类级别的注解，作用于使用了 <code>@Component</code> 派生注解的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Conditional(ControllerCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为类级别的注解，作用在配置类上，观察内部的 <code>@Bean</code> 方法能够成功注册 Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional(FurtherCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFurtherConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样是在配置类中使用，作用在 <code>@Import</code> 的类上、<code>@Bean</code> 方法上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyDao.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional(ServiceCondition.class)</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyService</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyRepository <span class="title function_">myRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyRepository</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Conditional(DaoCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDao</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Conditional(RepositoryCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRepository</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作用在 <code>@Bean</code> 方法上有两种情况：</p>
<ol>
<li>直接作用在对应的 <code>@Bean</code> 方法上，比如 <code>myService()</code> 方法</li>
<li>作用在 <code>@Bean</code> 注册的类上，比如 <code>MyRepository</code> 类</li>
</ol>
<p><code>RepositoryCondition</code> 实现的 <code>matches()</code> 方法返回的是 <code>false</code>，那么 Spring 容器中应该不存在 <code>MyRepository</code> 类型的 Bean？</p>
<blockquote>
<p>测试一下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConditional</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Config.class);</span><br><span class="line">    <span class="type">MyRepository</span> <span class="variable">repository</span> <span class="operator">=</span> context.getBean(MyRepository.class);</span><br><span class="line">    <span class="comment">// 尽管 Condition 返回了 false，但是容器中还是有对应的 Bean</span></span><br><span class="line">    assertThat(repository).isNotNull();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre>
indi.mofan.condition.ControllerCondition
indi.mofan.condition.FurtherCondition
indi.mofan.condition.ControllerCondition
indi.mofan.condition.FurtherCondition
indi.mofan.condition.DaoCondition
indi.mofan.condition.ControllerCondition
indi.mofan.condition.FurtherCondition
indi.mofan.condition.DaoCondition
indi.mofan.condition.ServiceCondition
</pre>
<p>运行测试方法后，发现 Spring 容器中存在 <code>MyRepository</code> 类型的 Bean，并且打印的日志中不存在 <code>RepositoryCondition</code> 的相关信息，也就是说，程序运行时，没有执行 <code>RepositoryCondition</code> 重写的 <code>matches()</code> 方法。在控制 <code>@Bean</code> 方法注册 Bean 时，在目标类上使用 <code>@Conditional</code> 注解是无效的，应当直接在 <code>@Bean</code> 方法上使用 <code>@Conditional</code> 注解。</p>
<h1 id="2-源码剖析"><a class="header-anchor" href="#2-源码剖析"></a>2. 源码剖析</h1>
<h2 id="2-1-开门见山地说"><a class="header-anchor" href="#2-1-开门见山地说"></a>2.1 开门见山地说</h2>
<p>Spring 配置类的解析由 <code>ConfigurationClassPostProcessor</code> 实现，除此之外，<code>@Conditional</code>、<code>@Component</code> 及其派生注解、<code>@Import</code>、<code>@ComponentScan</code>、<code>@Configuration</code>、<code>@Bean</code> 等与 Bean 注册相关的注解的实现都会在 <code>ConfigurationClassPostProcessor</code> 中完成。</p>
<p>简单回顾下 <a href="../Configuration-Annotation/">@Configuration 注解的那些事</a> 中对 <code>ConfigurationClassPostProcessor</code> 的讲解：</p>
<ul>
<li><code>ConfigurationClassPostProcessor</code> 实现了 <code>BeanDefinitionRegistryPostProcessor</code> 接口，后者是 <code>BeanFactoryPostProcessor</code> 的子接口；</li>
<li><code>BeanDefinitionRegistryPostProcessor</code> 提供了动态注册新的 <code>BeanDefinition</code> 的能力，与 <code>BeanFactoryPostProcessor</code> 相比，它更早被调用；</li>
<li>无论是对 <code>BeanDefinitionRegistryPostProcessor</code> 中独有方法的实现，还是对 <code>BeanFactoryPostProcessor</code> 中方法的实现，内部都会调用名为 <code>processConfigBeanDefinitions()</code> 的方法。</li>
</ul>
<p><code>processConfigBeanDefinitions()</code> 方法完成了各种与 Bean 注册相关注解的解析，该方法的实现较长，在 <a href="../Configuration-Annotation/">@Configuration 注解的那些事</a> 一文中只对其中获取配置类信息的小部分代码进行了分析，而那剩下的部分则是本文的主要内容。</p>
<h2 id="2-2-processConfigBeanDefinitions"><a class="header-anchor" href="#2-2-processConfigBeanDefinitions"></a>2.2 processConfigBeanDefinitions</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>processConfigBeanDefinitions()</code> 方法首先会遍历当前 Spring 容器中所有的 <code>BeanDefinition</code>，从中找出配置类相关的 <code>BeanDefinition</code>，如果没找到，就立即返回。这些内容在 <a href="../Configuration-Annotation/">@Configuration 注解的那些事</a> 一文中已经详细介绍过了，不再过多分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sort by previously determined @Order value, if applicable</span></span><br><span class="line">    configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">    <span class="type">SingletonBeanRegistry</span> <span class="variable">singletonRegistry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry sbr) &#123;</span><br><span class="line">        singletonRegistry = sbr;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">            <span class="type">BeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> (BeanNameGenerator) singletonRegistry.getSingleton(</span><br><span class="line">                AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">            <span class="keyword">if</span> (generator != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">                <span class="built_in">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.environment == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.environment = <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与配置相关的 <code>BeanDefinition</code> 可能有多个，将它们按照 <code>@Order</code> 的值进行排序。</p>
<p>之后还会探测在 <code>ApplicationContext</code>（代码实现中使用的是 <code>SingletonBeanRegistry</code>）内部是否存在自定义的 <code>Bean</code> 名称生成策略（bean name generation strategy），如果有的话，将它们设置给某些成员变量。</p>
<p>如果 <code>environment</code> 的值未被显式设置，会默认初始化为 <code>StandardEnvironment</code>。</p>
<p>上面这些内容并不是重点，接下里的才是重头戏：<strong>解析每个配置类。</strong> 💣</p>
<h2 id="2-3-解析每个配置类"><a class="header-anchor" href="#2-3-解析每个配置类"></a>2.3 解析每个配置类</h2>
<p>继续阅读 <code>processConfigBeanDefinitions()</code> 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse each @Configuration class</span></span><br><span class="line">    <span class="type">ConfigurationClassParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassParser</span>(</span><br><span class="line">        <span class="built_in">this</span>.metadataReaderFactory, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.environment,</span><br><span class="line">        <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置类的候选项，初始化为先前解析出的配置类</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(configCandidates);</span><br><span class="line">    <span class="comment">// 已经解析过的配置类</span></span><br><span class="line">    Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(configCandidates.size());</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">StartupStep</span> <span class="variable">processConfig</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.config-classes.parse&quot;</span>);</span><br><span class="line">        parser.parse(candidates);</span><br><span class="line">        parser.validate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化一个 <code>ConfigurationClassParser</code> 对象，将先前得到的配置类信息传入其 <code>parse()</code> 方法中完成配置类的解析。</p>
<p>进入 <code>parse()</code> 方法内部：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> holder.getBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition annotatedBeanDef) &#123;</span><br><span class="line">                parse(annotatedBeanDef.getMetadata(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// --snip--</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 省略异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟处理 ImportSelector，这与 @Import 注解相关，后文会说到</span></span><br><span class="line">    <span class="built_in">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过判断配置类对应的 <code>BeanDefinition</code> 是哪种类型，然后调用不同的、重载的 <code>parse()</code> 方法。</p>
<p>在先前的示例代码中，配置类是通过 <code>@Configuration</code> 注解实现的，对应 <code>AnnotatedBeanDefinition</code>，因此会直接进入第一个分支：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(AnnotationMetadata metadata, String beanName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    processConfigurationClass(<span class="keyword">new</span> <span class="title class_">ConfigurationClass</span>(metadata, beanName), DEFAULT_EXCLUSION_FILTER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将配置类的元数据信息和对应的 <code>beanName</code> 包装成 <code>ConfigurationClass</code> 实例，然后又调用了 <code>processConfigurationClass()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processConfigurationClass</span><span class="params">(ConfigurationClass configClass, Predicate&lt;String&gt; filter)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 判断是否需要跳过当前配置类的解析，@Conditional 注解的实现</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否解析过相同的配置类</span></span><br><span class="line">    <span class="type">ConfigurationClass</span> <span class="variable">existingClass</span> <span class="operator">=</span> <span class="built_in">this</span>.configurationClasses.get(configClass);</span><br><span class="line">    <span class="keyword">if</span> (existingClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前解析的配置类是否是被导入的</span></span><br><span class="line">        <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">            <span class="comment">// 先前解析的配置类也是被导入的</span></span><br><span class="line">            <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">                <span class="comment">// 合并两个被导入的配置类</span></span><br><span class="line">                existingClass.mergeImportedBy(configClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则忽略现在正在解析的配置类</span></span><br><span class="line">            <span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line">            <span class="comment">// Let&#x27;s remove the old one and go with the new one.</span></span><br><span class="line">            <span class="comment">// 当前解析的配置类不是被导入的，那么移除以前解析过的，重新解析</span></span><br><span class="line">            <span class="built_in">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">            <span class="built_in">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively process the configuration class and its superclass hierarchy.</span></span><br><span class="line">    <span class="comment">// 递归处理配置类及其超类</span></span><br><span class="line">    <span class="type">SourceClass</span> <span class="variable">sourceClass</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sourceClass = asSourceClass(configClass, filter);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (sourceClass != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">            <span class="string">&quot;I/O failure while processing configuration class [&quot;</span> + sourceClass + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存下解析过的配置类</span></span><br><span class="line">    <span class="built_in">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>processConfigurationClass()</code> 方法共有四步：</p>
<ol>
<li><strong>判断是否需要跳过当前配置类的解析，</strong> 这也是 <code>@Conditional</code> 注解的实现；</li>
<li>如果已经解析过当前配置类，判断当前解析的配置类是否是被导入的：
<ul>
<li>如果不是被导入的，证明现在解析的配置类更加明确，移除先前解析过的同名配置类并重新解析；</li>
<li>如果当前配置类是被导入的，并且先前解析的配置类也是被导入的，那么合并这同名配置类；</li>
<li>如果当前配置类是被导入的，但是先前解析的配置类却不是被导入的，先前解析的配置类更加明确，直接 <code>return</code>，忽略对当前配置类的解析。</li>
</ul>
</li>
<li><strong>递归处理配置类及其超类；</strong></li>
<li>保存解析过的配置类信息。</li>
</ol>
<p>重点放在第一步和第三步，其中：</p>
<ul>
<li>第一步调用 <code>conditionEvaluator</code> 成员变量的 <code>shouldSkip()</code> 方法来判断是否跳过配置类的解析</li>
<li>第三步的重点放在调用 <code>doProcessConfigurationClass()</code> 方法完成对配置类的解析</li>
</ul>
<h2 id="2-4-shouldSkip"><a class="header-anchor" href="#2-4-shouldSkip"></a>2.4 shouldSkip</h2>
<p><code>@Conditional</code> 注解的实现由 <code>ConditionEvaluator#shouldSkip()</code> 方法完成，成员变量 <code>conditionEvaluator</code> 的值是在实例化当前对象时一并实例化的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConfigurationClassParser</span><span class="params">(MetadataReaderFactory metadataReaderFactory,</span></span><br><span class="line"><span class="params">                                ProblemReporter problemReporter, </span></span><br><span class="line"><span class="params">                                Environment environment, </span></span><br><span class="line"><span class="params">                                ResourceLoader resourceLoader,</span></span><br><span class="line"><span class="params">                                BeanNameGenerator componentScanBeanNameGenerator, </span></span><br><span class="line"><span class="params">                                BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="built_in">this</span>.conditionEvaluator = <span class="keyword">new</span> <span class="title class_">ConditionEvaluator</span>(registry, environment, resourceLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到 <code>shouldSkip()</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldSkip</span><span class="params">(<span class="meta">@Nullable</span> AnnotatedTypeMetadata metadata,</span></span><br><span class="line"><span class="params">                          <span class="meta">@Nullable</span> ConfigurationPhase phase)</span> &#123;</span><br><span class="line">    <span class="comment">// 配置类上注解的元数据为空，即 metadata == null 时，返回 false，不跳过解析</span></span><br><span class="line">    <span class="comment">// 配置类未被 @Conditional 注解标记时，也不跳过解析</span></span><br><span class="line">    <span class="keyword">if</span> (metadata == <span class="literal">null</span> || !metadata.isAnnotated(Conditional.class.getName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般来说，调用时应该传个 phase 的值，当然，也可以不传 </span></span><br><span class="line">    <span class="keyword">if</span> (phase == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没传 phase，并且目标类是候选的配置类，递归调用 shouldSkip() 方法</span></span><br><span class="line">        <span class="comment">// 其实相当于令 phase == PARSE_CONFIGURATION</span></span><br><span class="line">        <span class="keyword">if</span> (metadata <span class="keyword">instanceof</span> AnnotationMetadata annotationMetadata &amp;&amp;</span><br><span class="line">            ConfigurationClassUtils.isConfigurationCandidate(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则相当于令 phase == REGISTER_BEAN</span></span><br><span class="line">        <span class="keyword">return</span> shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射，获取 @Conditional 注解的 value 指定的 Condition 实例</span></span><br><span class="line">    List&lt;Condition&gt; conditions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String[] conditionClasses : getConditionClasses(metadata)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String conditionClass : conditionClasses) &#123;</span><br><span class="line">            <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> getCondition(conditionClass, <span class="built_in">this</span>.context.getClassLoader());</span><br><span class="line">            conditions.add(condition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给 Condition 实例排个序</span></span><br><span class="line">    AnnotationAwareOrderComparator.sort(conditions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环每个 Condition，只要有一个不满足，就返回 true，表示跳过解析</span></span><br><span class="line">    <span class="keyword">for</span> (Condition condition : conditions) &#123;</span><br><span class="line">        <span class="type">ConfigurationPhase</span> <span class="variable">requiredPhase</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (condition <span class="keyword">instanceof</span> ConfigurationCondition configurationCondition) &#123;</span><br><span class="line">            requiredPhase = configurationCondition.getConfigurationPhase();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((requiredPhase == <span class="literal">null</span> || requiredPhase == phase) &amp;&amp; !condition.matches(<span class="built_in">this</span>.context, metadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有 Condition 都满足，返回 false，不跳过解析</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>shouldSkip()</code> 方法的实现很简单，可以概括为三步：</p>
<ol>
<li>通过反射获取 <code>@Conditional</code> 注解的 <code>value</code> 属性对应的 <code>Condition</code> 实例；</li>
<li>对获取到的 <code>Condition</code> 实例排个序；</li>
<li>遍历 <code>Condition</code> 实例，如果有一个条件不满足，就直接返回 <code>true</code>，表示跳过解析。</li>
</ol>
<h2 id="2-5-processConfigurationClass"><a class="header-anchor" href="#2-5-processConfigurationClass"></a>2.5 processConfigurationClass</h2>
<p>回到 <code>ConfigurationClassParser#processConfigurationClass()</code> 方法中，配置类的解析由以下代码完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processConfigurationClass</span><span class="params">(ConfigurationClass configClass, </span></span><br><span class="line"><span class="params">                                         Predicate&lt;String&gt; filter)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively process the configuration class and its superclass hierarchy.</span></span><br><span class="line">    <span class="type">SourceClass</span> <span class="variable">sourceClass</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       sourceClass = asSourceClass(configClass, filter);</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">          sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (sourceClass != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">             <span class="string">&quot;I/O failure while processing configuration class [&quot;</span> + sourceClass + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先利用 <code>asSourceClass()</code> 方法通过 <code>ConfigurationClass</code> 实例和过滤规则 <code>filter</code> 获取到 <code>SourceClass</code> 对象，解析配置类则是由 <code>doProcessConfigurationClass()</code> 方法完成。</p>
<blockquote>
<p><code>asSourceClass()</code> 方法</p>
</blockquote>
<p>不详解 <code>asSourceClass()</code> 的实现，知道它是获取 <code>SourceClass</code> 实例的一个工厂方法就行了。</p>
<p>简单介绍下 <code>SourceClass</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SourceClass</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object source;  <span class="comment">// Class or MetadataReader</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AnnotationMetadata metadata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SourceClass</code> 对类信息（类信息被封装到 <code>Class</code> 或 <code>MetadataReader</code> 中）进行了包装，使得带注解（注解信息被封装到 <code>AnnotationMetadata</code> 中）的类能够以统一的方式被处理，而不必关心这些类是怎么被加载的。</p>
<blockquote>
<p><code>doProcessConfigurationClass()</code> 方法</p>
</blockquote>
<p>利用 <code>asSourceClass()</code> 构造出 <code>SourceClass</code> 对象后，会立即执行 <code>doProcessConfigurationClass()</code> 方法处理 <code>SourceClass</code> 对象（也就是配置类），而这个方法也会返回一个 <code>SourceClass</code> 对象，之后会判断返回值是否为 <code>null</code>，如果不为 <code>null</code>，又会执行该方法处理新返回的 <code>SourceClass</code> 对象。</p>
<p>在先前贴出的代码片段前有这样一段注释：</p>
<pre>
Recursively process the configuration class and its superclass hierarchy.
</pre>
<p>这段注释明确概括了这段代码的核心：<strong>递归</strong> 处理配置类和其超类层级结构（hierarchy 一词译为层级结构）。</p>
<p>也就是说 <code>doProcessConfigurationClass()</code> 返回的是当前处理类的超类对应的 <code>SourceClass</code> 对象？</p>
<p>该方法的源码的很长，每种处理前都有表明具体作用的注释，不如跟随这些注释来窥探其中的奥秘：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">    <span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">    <span class="comment">// 1. 首先递归处理嵌套类</span></span><br><span class="line">    processMemberClasses(configClass, sourceClass, filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line"><span class="comment">// 2. 处理 @PropertySource 注解，也包括组合的 @PropertySources 注解</span></span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes propertySource : <span class="comment">/***/</span> ) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Search for locally declared @ComponentScan annotations first.</span></span><br><span class="line"><span class="comment">// 3. 搜索本地声明的 @ComponentScan 注解</span></span><br><span class="line"><span class="comment">// 所谓本地声明的，其实就是直接存在、明确声明的 @ComponentScan 注解</span></span><br><span class="line">Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">       sourceClass.getMetadata(), ComponentScan.class, ComponentScans.class,</span><br><span class="line">       MergedAnnotation::isDirectlyPresent);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fall back to searching for @ComponentScan meta-annotations (which indirectly</span></span><br><span class="line"><span class="comment">// includes locally declared composed annotations).</span></span><br><span class="line"><span class="comment">// 4. 搜索 @ComponentScan 元注解，间接包括本地声明的组合注解</span></span><br><span class="line"><span class="keyword">if</span> (componentScans.isEmpty()) &#123;</span><br><span class="line">    componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(),</span><br><span class="line">          ComponentScan.class, ComponentScans.class, MergedAnnotation::isMetaPresent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5. 存在 @ComponentScan 注解，并且配置类在注册 Bean 期间不会被跳过</span></span><br><span class="line"><span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">    !<span class="built_in">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">    <span class="comment">// 遍历所有 @ComponentScan 注解</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">        <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">        <span class="comment">// 配置类被 @ComponentScan 注解标记，立即执行扫描</span></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">            <span class="built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">        <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">        <span class="comment">// 检查扫描出的 BeanDefinition，以获取更多的配置类，并在需要时进行递归解析</span></span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">            <span class="comment">// --snip--</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process any @Import annotations</span></span><br><span class="line"><span class="comment">// 6. 处理 @Import 注解</span></span><br><span class="line">processImports(configClass, sourceClass, getImports(sourceClass), filter, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line"><span class="comment">// 7. 处理 @ImportResource 注解</span></span><br><span class="line"><span class="type">AnnotationAttributes</span> <span class="variable">importResource</span> <span class="operator">=</span></span><br><span class="line">       AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line"><span class="keyword">if</span> (importResource != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process individual @Bean methods</span></span><br><span class="line"><span class="comment">// 8. 处理配置类里的 @Bean 方法</span></span><br><span class="line">Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line"><span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">    configClass.addBeanMethod(<span class="keyword">new</span> <span class="title class_">BeanMethod</span>(methodMetadata, configClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process default methods on interfaces</span></span><br><span class="line"><span class="comment">// 9. 处理接口中的 default 方法</span></span><br><span class="line">processInterfaces(configClass, sourceClass);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process superclass, if any</span></span><br><span class="line"><span class="comment">// 10. 处理超类，如果有的话</span></span><br><span class="line"><span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">superclass</span> <span class="operator">=</span> sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">    <span class="keyword">if</span> (superclass != <span class="literal">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp;</span><br><span class="line">        !<span class="built_in">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">        <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">        <span class="comment">// 找到了超类，返回它的注解元数据，并递归处理</span></span><br><span class="line">        <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line"><span class="comment">// 11. 没有超类，那就完成对配置类的解析</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p><code>doProcessConfigurationClass()</code> 的主要作用就是完成配置类的解析，包括配置类里的嵌套类、声明的各种注解、内部的各种方法，甚至是超类中的信息。</p>
<p>本节对 <code>doProcessConfigurationClass()</code> 的认识只是管中窥豹，并不涉及具体的解析逻辑，这会在后文补充。</p>
<h2 id="2-6-校验每个配置类"><a class="header-anchor" href="#2-6-校验每个配置类"></a>2.6 校验每个配置类</h2>
<p>再回到 <code>ConfigurationClassPostProcessor#processConfigBeanDefinitions()</code> 方法中，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(configCandidates);</span><br><span class="line">Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(configCandidates.size());</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">StartupStep</span> <span class="variable">processConfig</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.config-classes.parse&quot;</span>);</span><br><span class="line">    parser.parse(candidates);</span><br><span class="line">    parser.validate();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>
<p>先前解析出的配置类信息通过调用 <code>parser.parse(candidates)</code> 方法完成解析，前三节内容深入这个方法，大致介绍了其中的解析逻辑。</p>
<p>而后调用 <code>parser.validate()</code> 方法，对每个配置类（包括通过解析先前配置类得到的更多的配置类）进行校验。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.context.annotation.ConfigurationClassParser#validate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ConfigurationClass configClass : <span class="built_in">this</span>.configurationClasses.keySet()) &#123;</span><br><span class="line">       configClass.validate(<span class="built_in">this</span>.problemReporter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>problemReporter</code>，顾名思义，用来汇报问题的。调用其内部的方法时，可能直接抛出异常，也可能打印一些日志，比如这里使用的默认实现 <code>FailFastProblemReporter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FailFastProblemReporter</span> <span class="keyword">implements</span> <span class="title class_">ProblemReporter</span> &#123;</span><br><span class="line">   	<span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fatal</span><span class="params">(Problem problem)</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionParsingException</span>(problem);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(Problem problem)</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionParsingException</span>(problem);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">warning</span><span class="params">(Problem problem)</span> &#123;</span><br><span class="line">		logger.warn(problem, problem.getRootCause());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到 <code>configClass.validate(this.problemReporter)</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(ProblemReporter problemReporter)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取配置类上的 @Configuration 注解信息</span></span><br><span class="line">    Map&lt;String, Object&gt; attributes = <span class="built_in">this</span>.metadata.getAnnotationAttributes(Configuration.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A configuration class may not be final (CGLIB limitation) unless it declares proxyBeanMethods=false</span></span><br><span class="line">    <span class="comment">// 配置类不能是 final 的（CGLIB 的限制），除非设置了 proxyBeanMethods = false</span></span><br><span class="line">    <span class="keyword">if</span> (attributes != <span class="literal">null</span> &amp;&amp; (Boolean) attributes.get(<span class="string">&quot;proxyBeanMethods&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 校验配置类是不是 final 的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.metadata.isFinal()) &#123;</span><br><span class="line">            problemReporter.error(<span class="keyword">new</span> <span class="title class_">FinalConfigurationProblem</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验配置类中的 Bean 方法</span></span><br><span class="line">        <span class="keyword">for</span> (BeanMethod beanMethod : <span class="built_in">this</span>.beanMethods) &#123;</span><br><span class="line">            beanMethod.validate(problemReporter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A configuration class may not contain overloaded bean methods unless it declares enforceUniqueMethods=false</span></span><br><span class="line">    <span class="comment">// 配置类不能包含重载的 Bean 方法，除非设置了 enforceUniqueMethods = false</span></span><br><span class="line">    <span class="keyword">if</span> (attributes != <span class="literal">null</span> &amp;&amp; (Boolean) attributes.get(<span class="string">&quot;enforceUniqueMethods&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，根据配置类上的 <code>@Configuration</code> 注解对配置类进行了校验，同时还校验了配置类中的 Bean 方法。</p>
<p>对 Bean 方法的校验如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(ProblemReporter problemReporter)</span> &#123;</span><br><span class="line">    <span class="comment">// Bean 方法被声明为 void 返回值类型</span></span><br><span class="line">    <span class="comment">// 可能是误用了 @Bean 注解，这个方法可能是作为 init 方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;void&quot;</span>.equals(getMetadata().getReturnTypeName())) &#123;</span><br><span class="line">        <span class="comment">// declared as void: potential misuse of @Bean, maybe meant as init method instead?</span></span><br><span class="line">        problemReporter.error(<span class="keyword">new</span> <span class="title class_">VoidDeclaredMethodError</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的 Bean 方法没有更多的限制，立即返回</span></span><br><span class="line">    <span class="keyword">if</span> (getMetadata().isStatic()) &#123;</span><br><span class="line">        <span class="comment">// static @Bean methods have no further constraints to validate -&gt; return immediately</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.configurationClass.getMetadata().isAnnotated(Configuration.class.getName())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!getMetadata().isOverridable()) &#123;</span><br><span class="line">            <span class="comment">// instance @Bean methods within @Configuration classes must be overridable to accommodate CGLIB</span></span><br><span class="line">            <span class="comment">// 配置类中的 Bean 方法必须可以被重写，以适应 CGLIB</span></span><br><span class="line">            <span class="comment">// 所谓可被重写，即方法未被标记为 static、final 或 private</span></span><br><span class="line">            problemReporter.error(<span class="keyword">new</span> <span class="title class_">NonOverridableMethodError</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-7-源源不断地解析"><a class="header-anchor" href="#2-7-源源不断地解析"></a>2.7 源源不断地解析</h2>
<p>继续回到 <code>ConfigurationClassPostProcessor#processConfigBeanDefinitions()</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(configCandidates);</span><br><span class="line">Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(configCandidates.size());</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 候选配置类的解析</span></span><br><span class="line">    <span class="type">StartupStep</span> <span class="variable">processConfig</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.config-classes.parse&quot;</span>);</span><br><span class="line">    parser.parse(candidates);</span><br><span class="line">    parser.validate();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!candidates.isEmpty());</span><br></pre></td></tr></table></figure>
<p><code>parser.parse()</code> 方法是对候选配置类的解析，之后调用 <code>parser.validate()</code> 对配置类、Bean 方法进行校验，如果校验不过，就抛出异常。</p>
<p>到目前为止，还仅仅是解析了单个配置类，以前文中的使用示例来说，现在只解析了 <code>Config</code> 配置类。</p>
<p>在 <code>Config</code> 配置类上使用了 <code>@ComponentScan</code> 注解，这会扫描 <code>Config</code> 类所在的包及其子包下的 <code>@Component</code> 注解和它的派生注解，并把那些类交由 Spring 管理。在扫描的范围内，<code>MyController</code> 类被 <code>@Controller</code> 标记，<code>MyFurtherConfig</code> 类被 <code>@Configuration</code> 标记，并且它们都满足配置的 <code>@Conditional</code> 条件。也就是说，当执行完 <code>parser.parse()</code> 方法后，当前 Spring 容器中有以下名称的 <code>BeanDefinition</code>（不包括 Spring 内置的）：</p>
<ul>
<li><code>config</code></li>
<li><code>myController</code></li>
<li><code>myFurtherConfig</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">configClasses.removeAll(alreadyParsed);</span><br></pre></td></tr></table></figure>
<p>接下来，通过 <code>parser.getConfigurationClasses()</code> 获取解析得到的配置类信息，注意，这和 Spring 容器中的 <code>BeanDefinition</code> 不一定相同。比如就示例而言，获取到的配置类信息中还额外包含 <code>MyDao</code> 类，这个类是在 <code>Config</code> 上通过 <code>@Import</code> 注解导入的，但它并不在 Spring 容器中。</p>
<p><code>MyDao</code> 最终肯定是会在 Spring 容器中的，那这是怎么做到的呢？</p>
<p>这来自 Spring 源源不断地解析配置类与加载 <code>BeanDefinition</code>。</p>
<p>在这之前，需要明白源码中几个集合的含义：</p>
<ul>
<li>
<p><code>String[] candidateNames</code>：每轮解析前，Spring 容器中存在的 <code>BeanDefinition</code> 名称。其中每轮解析，表示执行一次 <code>do...while</code> 循环</p>
</li>
<li>
<p><code>Set&lt;BeanDefinitionHolder&gt; candidates</code>：候选配置类对应的 <code>BeanDefinition</code></p>
</li>
<li>
<p><code>Set&lt;ConfigurationClass&gt; alreadyParsed</code>：已经解析过的配置类，初始值为空</p>
</li>
<li>
<p><code>Set&lt;ConfigurationClass&gt; configClasses</code>：调用 <code>parser.parse(candidates)</code> 后得到的配置类信息</p>
</li>
</ul>
<p>以执行到初始化 <code>configClasses</code> 为例，这些集合中的元素情况是：</p>
<table>
<thead>
<tr>
<th style="text-align:center">集合名称</th>
<th style="text-align:center">存在的元素</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">candidateNames</td>
<td style="text-align:center"><code>config</code> 与 Spring 容器中内置的 <code>BeanDefinition</code> 名称</td>
</tr>
<tr>
<td style="text-align:center">candidates</td>
<td style="text-align:center">仅有 <code>Config</code> 类对应的 <code>BeanDefinition</code></td>
</tr>
<tr>
<td style="text-align:center">alreadyParsed</td>
<td style="text-align:center">空</td>
</tr>
<tr>
<td style="text-align:center">configClasses</td>
<td style="text-align:center"><code>Config</code>、<code>MyController</code>、<code>MyFurtherConfig</code>、<code>MyDao</code></td>
</tr>
</tbody>
</table>
<p>继续阅读源码，接下来执行 <code>configClasses.removeAll(alreadyParsed);</code>，由于 <code>alreadyParsed</code> 依旧为空，因此本行无事发生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.reader == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">ConfigurationClassBeanDefinitionReader</span>(</span><br><span class="line">          registry, <span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.environment,</span><br><span class="line">          <span class="built_in">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.reader.loadBeanDefinitions(configClasses);</span><br></pre></td></tr></table></figure>
<p>接下来使用 <code>reader</code> 将 <code>configClasses</code> 对应的类加载为 <code>BeanDefinition</code>。<code>configClasses</code> 中的 <code>MyDao</code> 会在此时被转换为 <code>BeanDefinition</code>，仅此而已？</p>
<p>非也。</p>
<p><code>loadBeanDefinitions()</code> 还会将配置类中的 Bean 方法也转换为 <code>BeanDefinition</code>，也就是说，此时除 Spring 内置的 <code>BeanDefinition</code> 外，还有如下 <code>BeanDefinition</code>：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>BeanDefinition</code> 的名称</th>
<th style="text-align:center">名称来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>config</code></td>
<td style="text-align:center">对应配置类名称首字母小写</td>
</tr>
<tr>
<td style="text-align:center"><code>myController</code></td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center"><code>myFurtherConfig</code></td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center"><code>myBean</code></td>
<td style="text-align:center">对应的 Bean 方法的方法名</td>
</tr>
<tr>
<td style="text-align:center"><code>myService</code></td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center"><code>myRepository</code></td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center"><code>indi.mofan.component.MyDao</code></td>
<td style="text-align:center">使用 <code>@Import</code> 注解导入</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alreadyParsed.addAll(configClasses);</span><br></pre></td></tr></table></figure>
<p>将这轮解析得到的配置类信息添加到 <code>alreadyParsed</code> 集合中，表示它们已经被解析过，并且容器中也存在对应的 <code>BeanDefinition</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candidates.clear();</span><br></pre></td></tr></table></figure>
<p>清空候选的配置类信息，为下一轮解析做准备。因为调用 <code>loadBeanDefinitions()</code> 方法后，可能会解析出其他配置类，需要将这些配置类作为候选的配置类信息。</p>
<p>获取新的候选配置类信息方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前容器中的 BeanDefinition 数量大于这轮解析前存在的 BeanDefinition 数量</span></span><br><span class="line"><span class="comment">// 这证明解析过程中得到了新的 BeanDefinition，这其中可能存在其他的配置类</span></span><br><span class="line"><span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">    <span class="comment">// 获取到当前容器中的 BeanDefinition 名称</span></span><br><span class="line">    String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">    <span class="comment">// 将这轮解析前的 BeanDefinition 作为旧的候选名称</span></span><br><span class="line">    Set&lt;String&gt; oldCandidateNames = Set.of(candidateNames);</span><br><span class="line">    <span class="comment">// 已经解析过的配置类 class name</span></span><br><span class="line">    Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// alreadyParsedClasses 是由 alreadyParsed 转换得到的</span></span><br><span class="line">    <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">        alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历当前容器中存在的 BeanDefinition 名称</span></span><br><span class="line">    <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">        <span class="comment">// 它们不包含在 oldCandidateNames 中</span></span><br><span class="line">        <span class="comment">// 这些 BeanDefinition 都是本轮解析新增的</span></span><br><span class="line">        <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">            <span class="comment">// 获取到对应的 BeanDefinition</span></span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> registry.getBeanDefinition(candidateName);</span><br><span class="line">            <span class="comment">// 检查 BeanDefinition 是不是可以作为候选的配置类</span></span><br><span class="line">            <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="built_in">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                <span class="comment">// 新增的 BeanDefinition 不代表就没被解析过了</span></span><br><span class="line">                <span class="comment">// @Import 导入的、@ComponentScan 扫描到的都已经被解析过了</span></span><br><span class="line">                !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                <span class="comment">// 经过重重过滤，还是存在，那它作为新的候选配置类</span></span><br><span class="line">                candidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(bd, candidateName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新下一轮解析前，容器中存在的 BeanDefinition</span></span><br><span class="line">    candidateNames = newCandidateNames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>candidates</code> 和 <code>candidateNames</code> 均已被更新，怎么开始下一轮解析呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!candidates.isEmpty());</span><br></pre></td></tr></table></figure>
<p>如果存在新的候选配置类，那就开始下一轮解析，以此进行源源不断的解析。</p>
<h2 id="2-8-解析后的完善"><a class="header-anchor" href="#2-8-解析后的完善"></a>2.8 解析后的完善</h2>
<blockquote>
<p>注册名为 <code>IMPORT_REGISTRY_BEAN_NAME</code> 的 Bean</p>
</blockquote>
<p><code>processConfigBeanDefinitions()</code> 方法还没有完，还需要做最后的完善。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line"><span class="keyword">if</span> (singletonRegistry != <span class="literal">null</span> &amp;&amp; !singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">    singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>singletonRegistry</code> 其实就是表示 Spring 容器，判断容器中是否存在名称为 <code>IMPORT_REGISTRY_BEAN_NAME</code> 的 Bean（注意，是直接注册一个 Bean，而不是 <code>BeanDefinition</code>），如果不存在，就注册一个。</p>
<p>这个 Bean 的类型是 <code>ImportRegistry</code>，用于处理 <code>ImportAware</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImportAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the annotation metadata of the importing @&#123;<span class="doctag">@code</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setImportMetadata</span><span class="params">(AnnotationMetadata importMetadata)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ImportAware</code> 接口需要和 <code>@Import</code> 注解搭配使用，如果 <code>@Import</code> 注解导入的配置类实现了 <code>ImportAware</code> 接口，导入的配置类能够获取到 <code>@Import</code> 注解所在配置类的元数据。</p>
<p>以 <code>@EnableAsync</code> 注解为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(AsyncConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAsync &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@EnableAsync</code> 注解用于启用 SpringBoot 对异步方法的支持，该注解的正确使用需要放在配置类上，常置于 SpringBoot 的主启动类上（主启动类也是一个配置类）。</p>
<p>导入的 <code>AsyncConfigurationSelector</code> 类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfigurationSelector</span> <span class="keyword">extends</span> <span class="title class_">AdviceModeImportSelector</span>&lt;EnableAsync&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;org.springframework.scheduling.aspectj.AspectJAsyncConfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@link</span> ProxyAsyncConfiguration&#125; or &#123;<span class="doctag">@code</span> AspectJAsyncConfiguration&#125;</span></span><br><span class="line"><span class="comment">     * for &#123;<span class="doctag">@code</span> PROXY&#125; and &#123;<span class="doctag">@code</span> ASPECTJ&#125; values of &#123;<span class="doctag">@link</span> EnableAsync#mode()&#125;,</span></span><br><span class="line"><span class="comment">     * respectively.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> PROXY -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;ProxyAsyncConfiguration.class.getName()&#125;;</span><br><span class="line">            <span class="keyword">case</span> ASPECTJ -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME&#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>adviceMode</code> 的值通常是 <code>ProxyAsyncConfiguration</code>，因此 <code>@Import</code> 相当于导入了 <code>ProxyAsyncConfiguration</code>。它是一个配置类，继承 <code>AbstractAsyncConfiguration</code> 抽象类，并实现了 <code>ImportAware</code> 接口。</p>
<p>在 <code>AbstractAsyncConfiguration</code> 类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAsyncConfiguration</span> <span class="keyword">implements</span> <span class="title class_">ImportAware</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> AnnotationAttributes enableAsync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setImportMetadata</span><span class="params">(AnnotationMetadata importMetadata)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 @Import 注解所在配置类的元数据</span></span><br><span class="line">        <span class="comment">// 如果 @EnableAsync 注解作用在主启动类上，相当于获取到主启动类的元数据</span></span><br><span class="line">        <span class="comment">// 自然也就能获得到主启动类上 @EnableAsync 注解的信息（又绕回去了）</span></span><br><span class="line">		<span class="built_in">this</span>.enableAsync = AnnotationAttributes.fromMap(</span><br><span class="line">				importMetadata.getAnnotationAttributes(EnableAsync.class.getName()));</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.enableAsync == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">					<span class="string">&quot;@EnableAsync is not present on importing class &quot;</span> + importMetadata.getClassName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>存储 <code>PropertySourceDescriptors</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store the PropertySourceDescriptors to contribute them Ahead-of-time if necessary</span></span><br><span class="line"><span class="built_in">this</span>.propertySourceDescriptors = parser.getPropertySourceDescriptors();</span><br></pre></td></tr></table></figure>
<p>将解析配置类过程中得到的 <code>PropertySourceDescriptor</code> 存储起来，以便将来 AOT 使用。</p>
<blockquote>
<p>清除缓存</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory cachingMetadataReaderFactory) &#123;</span><br><span class="line">    <span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">    <span class="comment">// for a shared cache since it&#x27;ll be cleared by the ApplicationContext.</span></span><br><span class="line">    cachingMetadataReaderFactory.clearCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清理外部提供的 <code>MetadataReaderFactory</code> 中的缓存，避免占用过高的内存，同时在配置信息发生变更后再次获取时能够获取到最新的信息。</p>
<p>对于共享缓存来说，这个操作是无用的，因为它将被 <code>ApplicationContext</code> 清理。</p>
<h1 id="3-详解处理配置类"><a class="header-anchor" href="#3-详解处理配置类"></a>3. 详解处理配置类</h1>
<p>配置类的处理由 <code>ConfigurationClassParser#doProcessConfigurationClass()</code> 方法完成，前文已经初步认识了这个方法，比如每个步骤的主要含义，但并未进行深入，本节将对其进行补充，抽丝剥茧，层层剖析。</p>
<h2 id="3-1-递归处理成员类"><a class="header-anchor" href="#3-1-递归处理成员类"></a>3.1 递归处理成员类</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">    <span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">    processMemberClasses(configClass, sourceClass, filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果正在处理的配置类 <code>configClass</code> 被 <code>@Component</code> 注解标记，则需要递归处理每个成员（嵌套）类。</p>
<p>进入 <code>processMemberClasses()</code> 方法内部：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processMemberClasses</span><span class="params">(ConfigurationClass configClass, </span></span><br><span class="line"><span class="params">                                  SourceClass sourceClass,</span></span><br><span class="line"><span class="params">                                  Predicate&lt;String&gt; filter)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    Collection&lt;SourceClass&gt; memberClasses = sourceClass.getMemberClasses();</span><br><span class="line">    <span class="keyword">if</span> (!memberClasses.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获取类中的成员类，如果成员类不为空，才继续执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SourceClass&gt; candidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(memberClasses.size());</span><br><span class="line"><span class="keyword">for</span> (SourceClass memberClass : memberClasses) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &amp;&amp;</span><br><span class="line">        !memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) &#123;</span><br><span class="line">        candidates.add(memberClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到所有成员类后，遍历每个成员类。</p>
<p>如果成员类是候选的配置类，并且排除与当前配置类同名的成员类（防止无限循环处理同一个配置类），将符合条件的成员类被添加到 <code>candidates</code> 列表中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OrderComparator.sort(candidates);</span><br></pre></td></tr></table></figure>
<p>之后对候选的成员配置类排个序（实现 <code>PriorityOrdered</code>、<code>Ordered</code> 接口）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (SourceClass candidate : candidates) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.importStack.contains(configClass)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.problemReporter.error(<span class="keyword">new</span> <span class="title class_">CircularImportProblem</span>(configClass, <span class="built_in">this</span>.importStack));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.importStack.push(configClass);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processConfigurationClass(candidate.asConfigClass(configClass), filter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.importStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历候选的成员类：</p>
<ul>
<li>
<p>如果导入栈中包含当前正在处理的配置类，说明存在循环导入，调用 <code>problemReporter.error()</code> 方法抛个异常。</p>
</li>
<li>
<p>否则将当前正在处理的配置类添加到导入栈中，之后以相同的方式处理候选的成员配置类，最终将先前添加的配置类弹出栈。</p>
</li>
</ul>
<h2 id="3-2-处理-PropertySource"><a class="header-anchor" href="#3-2-处理-PropertySource"></a>3.2 处理 @PropertySource</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">    sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class,</span><br><span class="line">    PropertySources.class, <span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.propertySourceRegistry != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.propertySourceRegistry.processPropertySource(propertySource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">                    <span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>AnnotationConfigUtils.attributesForRepeatable()</code> 获取 <code>sourceClass</code> 元数据上的 <code>@PropertySource</code> 和 <code>@PropertySources</code> 注解，之后调用 <code>propertySourceRegistry.processPropertySource()</code> 方法来处理它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">processPropertySource</span><span class="params">(AnnotationAttributes propertySource)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 @PropertySource 注解的属性值</span></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">PropertySourceDescriptor</span> <span class="variable">descriptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertySourceDescriptor</span>(</span><br><span class="line">        Arrays.asList(locations),</span><br><span class="line">        ignoreResourceNotFound, </span><br><span class="line">        name, </span><br><span class="line">        factoryClassToUse, </span><br><span class="line">        encoding);</span><br><span class="line">    <span class="built_in">this</span>.propertySourceProcessor.processPropertySource(descriptor);</span><br><span class="line">    <span class="comment">// AOT 使用</span></span><br><span class="line">    <span class="built_in">this</span>.descriptors.add(descriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>processPropertySource()</code> 方法中，先获取 <code>@PropertySource</code> 注解的每个属性值，然后将它们包装成 <code>PropertySourceDescriptor</code> 对象，接着调用 <code>propertySourceProcessor.processPropertySource()</code> 方法来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPropertySource</span><span class="params">(PropertySourceDescriptor descriptor)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 获取 descriptor 中的信息，包括 name、encoding、locations 等</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resolvedLocation</span> <span class="operator">=</span> <span class="built_in">this</span>.environment.resolveRequiredPlaceholders(location);</span><br><span class="line">            <span class="keyword">for</span> (Resource resource : <span class="built_in">this</span>.resourcePatternResolver.getResources(resolvedLocation)) &#123;</span><br><span class="line">                addPropertySource(factory.createPropertySource(name, <span class="keyword">new</span> <span class="title class_">EncodedResource</span>(resource, encoding)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException | IOException ex) &#123;</span><br><span class="line">            <span class="comment">// Placeholders not resolvable (IllegalArgumentException) or resource not found when trying to open it</span></span><br><span class="line">            <span class="comment">// 占位符处理失败、尝试打开未找到的资源</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>processPropertySource()</code> 方法中，又会把包装好的 <code>PropertySourceDescriptor</code> 对象再拆开，其中最重要的是 <code>locations</code>，表示要加载的配置文件所在的位置。</p>
<p>从 Spring 6.1 开始，<code>locations</code> 的书写支持资源位置通配符，比如 <code>classpath*:/ config/*.properties</code>。</p>
<p>为了处理通配符，需要对每个 <code>location</code> 进行处理，即调用 <code>environment.resolveRequiredPlaceholders()</code> 方法。</p>
<p>之后使用处理过的位置信息去获取资源（配置文件），调用 <code>factory.createPropertySource()</code> 方法将配置文件中的信息封装成 <code>PropertySource</code> 对象，最后调用 <code>addPropertySource()</code> 方法将该对象添加到 <code>Environment</code> 中，这就相当于是将配置文件中的信息绑定到应用上下文了。</p>
<p>怎么创建 <code>PropertySource</code> 对象可以深入 <code>factory.createPropertySource()</code> 方法查看，此处不再叙述。</p>
<p>简单介绍下 <code>addPropertySource()</code> 方法，该方法用于将 <code>PropertySource</code> 对象添加到 <code>Environment</code> 中，在之前会处理多个同名（相同的 <code>name</code>）的 <code>PropertySource</code> 情况。处理方式很简单，将同名的 <code>PropertySource</code> 封装成一个 <code>CompositePropertySource</code>，并保证新添加的 <code>PropertySource</code> 优先级更高。</p>
<p>那为什么会存在多个同名的 <code>PropertySource</code> 呢？</p>
<p>这与 <code>@PropertySource</code> 注解有关：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PropertySource &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    String[] value();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@PropertySource</code> 注解可以指定一个 <code>name</code>，但可以对应多个 <code>value</code>。<code>value</code> 就是配置文件所处的位置（也就是 <code>location</code>），再解析 <code>@PropertySource</code> 注解后，一个 <code>name</code> 就有可能对应多个 <code>PropertySource</code> 对象（即多个配置文件）。</p>
<h2 id="3-3-处理-ComponentScan"><a class="header-anchor" href="#3-3-处理-ComponentScan"></a>3.3 处理 @ComponentScan</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Search for locally declared @ComponentScan annotations first.</span></span><br><span class="line"><span class="comment">// 首先搜索本地声明的 @ComponentScan 注解</span></span><br><span class="line"><span class="comment">// 所谓“本地声明”，就是直接存在于配置类上的，而不是元注解、通过 @Inherited 继承的形式</span></span><br><span class="line">Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">    sourceClass.getMetadata(), ComponentScan.class, ComponentScans.class,</span><br><span class="line">    MergedAnnotation::isDirectlyPresent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fall back to searching for @ComponentScan meta-annotations (which indirectly</span></span><br><span class="line"><span class="comment">// includes locally declared composed annotations).</span></span><br><span class="line"><span class="comment">// 没有直接存在的 @ComponentScan 注解，再去搜索 @ComponentScan 元注解</span></span><br><span class="line"><span class="comment">// 这间接包括本地声明的组合注解</span></span><br><span class="line"><span class="keyword">if</span> (componentScans.isEmpty()) &#123;</span><br><span class="line">    componentScans = </span><br><span class="line">        AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">        sourceClass.getMetadata(), ComponentScan.class, ComponentScans.class, </span><br><span class="line">        MergedAnnotation::isMetaPresent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和先前处理 <code>@PropertySource</code> 注解类似，处理 <code>@ComponentScan</code> 注解的第一步也是先找到配置类上的 <code>@ComponentScan</code> 注解元数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">    !<span class="built_in">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果存在 <code>@ComponentScan</code> 注解，并且满足配置类上的 <code>@Conditional</code> 条件，那么就进一步解析 <code>@ComponentScan</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">    <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">    <span class="comment">// 配置类被 @ComponentScan 标记，立即执行扫描</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">        <span class="built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">    <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">    <span class="comment">// 检查扫描出的 BeanDefinition 以获取其他配置类</span></span><br><span class="line">    <span class="comment">// 并在必要时进行递归解析</span></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bdCand</span> <span class="operator">=</span> holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">        <span class="keyword">if</span> (bdCand == <span class="literal">null</span>) &#123;</span><br><span class="line">            bdCand = holder.getBeanDefinition();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">            parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历每个 <code>@ComponentScan</code> 配置的信息执行对应的扫描，再遍历扫描到的 <code>BeanDefinition</code>，检查它们是否是候选的配置类，如果是，再进行递归解析。</p>
<p>重点放在 <code>componentScanParser.parse()</code> 方法，用于根据 <code>@ComponentScan</code> 配置的信息扫描得到 <code>BeanDefinition</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">parse</span><span class="params">(AnnotationAttributes componentScan, String declaringClass)</span> &#123;</span><br><span class="line">    <span class="comment">// 类路径下 BeanDefinition 的扫描器</span></span><br><span class="line">    <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>.registry,</span><br><span class="line">          componentScan.getBoolean(<span class="string">&quot;useDefaultFilters&quot;</span>), <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 @ComponentScan 的各种属性</span></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要扫描的基础路径</span></span><br><span class="line">    Set&lt;String&gt; basePackages = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 先从 basePackages 中获取</span></span><br><span class="line">    String[] basePackagesArray = componentScan.getStringArray(<span class="string">&quot;basePackages&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String pkg : basePackagesArray) &#123;</span><br><span class="line">       String[] tokenized = StringUtils.tokenizeToStringArray(<span class="built_in">this</span>.environment.resolvePlaceholders(pkg),</span><br><span class="line">             ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">       Collections.addAll(basePackages, tokenized);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再从 basePackageClasses 获取，并追加到 basePackages 中</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : componentScan.getClassArray(<span class="string">&quot;basePackageClasses&quot;</span>)) &#123;</span><br><span class="line">       basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 basePackages 和 basePackageClasses 都没配置扫描路径</span></span><br><span class="line">    <span class="comment">// 以配置类所在的包路径进行扫描</span></span><br><span class="line">    <span class="keyword">if</span> (basePackages.isEmpty()) &#123;</span><br><span class="line">       basePackages.add(ClassUtils.getPackageName(declaringClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scanner.addExcludeFilter(<span class="keyword">new</span> <span class="title class_">AbstractTypeHierarchyTraversingFilter</span>(<span class="literal">false</span>, <span class="literal">false</span>) &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">matchClassName</span><span class="params">(String className)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> declaringClass.equals(className);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 一切准备脱单后，执行 doScan</span></span><br><span class="line">    <span class="keyword">return</span> scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和解析 <code>@PropertySource</code> 类似，先收集注解，再遍历注解并提取出其中的信息，然后执行对应的逻辑。</p>
<p>目前来看，扫描的逻辑由 <code>scanner.doScan()</code> 完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历每个路径</span></span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">        <span class="comment">// 根据路径扫描得到 BeanDefinition</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="comment">// 遍历得到的 BeanDefinition</span></span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            <span class="comment">// 补充 scope 信息</span></span><br><span class="line">            <span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">            candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">            <span class="comment">// 获取 beanName</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="built_in">this</span>.registry);</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition abstractBeanDefinition) &#123;</span><br><span class="line">                <span class="comment">// 进一步追加一些信息</span></span><br><span class="line">                postProcessBeanDefinition(abstractBeanDefinition, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition annotatedBeanDefinition) &#123;</span><br><span class="line">                <span class="comment">// 根据一些常用注解再对 BeanDefinition 进行补充</span></span><br><span class="line">                <span class="comment">// 比如 @Lazy、@Primary、@DependsOn、@Role、@Description</span></span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations(annotatedBeanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查 BeanDefinition 是否需要被注册</span></span><br><span class="line">            <span class="comment">// 比如是否已经注册过同名的 BeanDefinition</span></span><br><span class="line">            <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(candidate, beanName);</span><br><span class="line">                <span class="comment">// 处理代理</span></span><br><span class="line">                definitionHolder =</span><br><span class="line">                    AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">                beanDefinitions.add(definitionHolder);</span><br><span class="line">                <span class="comment">// 注册 BeanDefinition</span></span><br><span class="line">                registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体逻辑比较“朴实无华”：</p>
<ul>
<li>遍历每个扫描路径，得到 <code>BeanDefinition</code></li>
<li>遍历得到的 <code>BeanDefinition</code>，对其内部信息进行一些补充</li>
<li>检查 <code>BeanDefinition</code> 是否需要被注册，检查通过才注册</li>
</ul>
<p>重点在 <code>findCandidateComponents()</code>，它是如何根据路径信息扫描得到 <code>BeanDefinition</code> 的呢？</p>
<p><code>findCandidateComponents()</code> 方法内部包含许多异常信息，这里不再贴源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br></pre></td></tr></table></figure>
<p>先根据路径信息得到一系列 <code>Resource</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> getMetadataReaderFactory().getMetadataReader(resource);</span><br></pre></td></tr></table></figure>
<p>根据 <code>Resource</code> 信息得到元数据信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScannedGenericBeanDefinition</span> <span class="variable">sbd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScannedGenericBeanDefinition</span>(metadataReader);</span><br></pre></td></tr></table></figure>
<p>然后把 <code>metadataReader</code> 包装成 <code>BeanDefinition</code>，最后返回即可。</p>
<p>更深层次的实现比较复杂，感兴趣可以自行查看，阅读源码也不用太过深入，以免陷入无底洞。</p>
<h2 id="3-4-处理-Import"><a class="header-anchor" href="#3-4-处理-Import"></a>3.4 处理 @Import</h2>
<p>再回到 <code>ConfigurationClassParser#doProcessConfigurationClass()</code> 方法中继续配置类的下一步解析，接下来将解析 <code>@Import</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processImports(configClass, sourceClass, getImports(sourceClass), filter, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>getImports()</code></p>
</blockquote>
<p>先看 <code>getImports()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;SourceClass&gt; <span class="title function_">getImports</span><span class="params">(SourceClass sourceClass)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Set&lt;SourceClass&gt; imports = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    Set&lt;SourceClass&gt; visited = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    collectImports(sourceClass, imports, visited);</span><br><span class="line">    <span class="keyword">return</span> imports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个 <code>Set</code> 集合，<code>imports</code> 和 <code>visited</code>，前者作为结果集返回，后者进一步传入了 <code>collectImports()</code> 方法。</p>
<p>如果刷过图相关的算法题，或者工作中处理过循环引用的情况，<code>visited</code> 这个名字应该会很熟悉。一般来说，它常用于标记已经访问过的信息，防止出现无限递归。</p>
<p>进入 <code>collectImports()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">collectImports</span><span class="params">(SourceClass sourceClass, </span></span><br><span class="line"><span class="params">                            Set&lt;SourceClass&gt; imports, </span></span><br><span class="line"><span class="params">                            Set&lt;SourceClass&gt; visited)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 sourceClass 是否已经被导入过</span></span><br><span class="line">    <span class="keyword">if</span> (visited.add(sourceClass)) &#123;</span><br><span class="line">        <span class="comment">// 获取 sourceClass 上的每个注解</span></span><br><span class="line">        <span class="keyword">for</span> (SourceClass annotation : sourceClass.getAnnotations()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">annName</span> <span class="operator">=</span> annotation.getMetadata().getClassName();</span><br><span class="line">            <span class="comment">// 递归处理注解，一个类上可能存在多个 @Import 注解</span></span><br><span class="line">            <span class="comment">// 比如配置类上使用的各种 @EnableXXX 内部可能会有 @Import</span></span><br><span class="line">            <span class="comment">// 配置里自己也可以声明 @Import</span></span><br><span class="line">            <span class="keyword">if</span> (!annName.equals(Import.class.getName())) &#123;</span><br><span class="line">                collectImports(annotation, imports, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 @Import 导入的配置类添加到结果集中</span></span><br><span class="line">        imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), <span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>processImports()</code></p>
</blockquote>
<p><code>@Import</code> 通常有三种使用方式：</p>
<ol>
<li>最简单的，直接导入配置类</li>
<li>导入 <code>ImportSelector</code> 的实现类</li>
<li>导入 <code>ImportBeanDefinitionRegistrar</code> 的实现类</li>
</ol>
<p>对于第二点，<code>ImportSelector</code> 中的 <code>selectImports()</code> 返回了需要导入的配置类的全限定类名，这些名称通常会从文件中读取。</p>
<p>对于第三点，<code>ImportBeanDefinitionRegistrar</code> 中的 <code>registerBeanDefinitions()</code> 方法提供了另一种注册 <code>BeanDefinition</code> 的方法。</p>
<p>在 <code>processImports()</code> 方法中需要对这三种方式进行实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processImports</span><span class="params">(ConfigurationClass configClass,</span></span><br><span class="line"><span class="params">                            SourceClass currentSourceClass,</span></span><br><span class="line"><span class="params">                            Collection&lt;SourceClass&gt; importCandidates,</span></span><br><span class="line"><span class="params">                            Predicate&lt;String&gt; exclusionFilter,</span></span><br><span class="line"><span class="params">                            <span class="type">boolean</span> checkForCircularImports)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在需要导入的配置类</span></span><br><span class="line">    <span class="keyword">if</span> (importCandidates.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理循环导入</span></span><br><span class="line">    <span class="keyword">if</span> (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.problemReporter.error(<span class="keyword">new</span> <span class="title class_">CircularImportProblem</span>(configClass, <span class="built_in">this</span>.importStack));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.importStack.push(configClass);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (SourceClass candidate : importCandidates) &#123;</span><br><span class="line">                <span class="keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line">                    <span class="comment">// Candidate class is an ImportSelector -&gt; delegate to it to determine imports</span></span><br><span class="line">                    <span class="comment">// 处理导入 ImportSelector 的情况</span></span><br><span class="line">                    <span class="comment">// --snip--</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;</span><br><span class="line">                    <span class="comment">// 处理导入 ImportBeanDefinitionRegistrar 的情况</span></span><br><span class="line">                    <span class="comment">// --snip--</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">                    <span class="comment">// process it as an @Configuration class</span></span><br><span class="line">                    <span class="comment">// 处理直接导入配置类的情况</span></span><br><span class="line">                    <span class="comment">// --snip--</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一些异常处理</span></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.importStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>导入 <code>ImportSelector</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line"><span class="type">ImportSelector</span> <span class="variable">selector</span> <span class="operator">=</span> ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class,</span><br><span class="line">       <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br></pre></td></tr></table></figure>
<p>首先获取 <code>ImportSelector</code> 实例，毕竟 Java 是极致面向对象的语言，没有对象实例，仅靠一个类咋玩呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; selectorFilter = selector.getExclusionFilter();</span><br><span class="line"><span class="keyword">if</span> (selectorFilter != <span class="literal">null</span>) &#123;</span><br><span class="line">    exclusionFilter = exclusionFilter.or(selectorFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>processImports()</code> 传入的过滤器和 <code>ImportSelector</code> 自带的过滤器进行合并（<code>or</code> 一下）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (selector <span class="keyword">instanceof</span> DeferredImportSelector deferredImportSelector) &#123;</span><br><span class="line">    <span class="built_in">this</span>.deferredImportSelectorHandler.handle(configClass, deferredImportSelector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>selector</code> 是 <code>DeferredImportSelector</code> 实例，需要额外处理下。</p>
<p><code>Deferred</code> 意为推迟、延迟，也就是说不立即导入对应的类，而是向后推迟，那推迟到什么时候呢？</p>
<p>额外处理的逻辑很简单，其实就是想需要推迟的导入添加到另一个集合中。</p>
<p>当所有的配置类都处理完之后，再处理这些推迟的导入。这在 <code>ConfigurationClassParser#parse()</code> 方法的最后一行能看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> holder.getBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition annotatedBeanDef) &#123;</span><br><span class="line">                <span class="comment">// 解析配置类最初的入口</span></span><br><span class="line">                parse(annotatedBeanDef.getMetadata(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// --snip--</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行推迟的导入</span></span><br><span class="line">    <span class="built_in">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续回到主逻辑中，如果 <code>selector</code> 不是 <code>DeferredImportSelector</code> 实例，就立即执行导入逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取导入的类的全限定类名</span></span><br><span class="line">String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line"><span class="comment">// 将类名包装成 SourceClass 对象</span></span><br><span class="line">Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames, exclusionFilter);</span><br><span class="line"><span class="comment">// 递归导入</span></span><br><span class="line">processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>指定的全限定类名仍有可能是 <code>ImportSelector</code> 或 <code>ImportBeanDefinitionRegistrar</code> 的子类，因此进行递归导入。</p>
<blockquote>
<p>导入 <code>ImportBeanDefinitionRegistrar</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line"><span class="type">ImportBeanDefinitionRegistrar</span> <span class="variable">registrar</span> <span class="operator">=</span></span><br><span class="line">       ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class,</span><br><span class="line">             <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br></pre></td></tr></table></figure>
<p>和导入 <code>ImportSelector</code> 类似，同样需要先获取 <code>ImportBeanDefinitionRegistrar</code> 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br></pre></td></tr></table></figure>
<p><code>ImportBeanDefinitionRegistrar</code> 提供了另一种注册 <code>BeanDefinition</code> 的方式，但并不会直接在这里注册，而是先保存下 <code>ImportBeanDefinitionRegistrar</code> 实例，后续统一执行实例方法进行注册。</p>
<p>先混个眼熟，这些实例是保存在 <code>importBeanDefinitionRegistrars</code> 属性中的。</p>
<p>至于到底是在哪注册的，后文会进一步介绍。</p>
<blockquote>
<p>导入配置类</p>
</blockquote>
<p>在这一步中，也只是先保存需要导入的配置类信息，而不是直接将配置类转换成 <code>BeanDefinition</code> 进行注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.importStack.registerImport(</span><br><span class="line">       currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());</span><br></pre></td></tr></table></figure>
<p>同样先混个眼熟，这些配置类信息是保存在 <code>ConfigurationClassParser</code> 实例的 <code>importStack</code> 字段中。</p>
<p>对于这些配置类自然也需要进一步解析，因此调用 <code>processConfigurationClass()</code> 方法完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结</p>
</blockquote>
<p>到此，<code>@Import</code> 注解已经处理完毕，但可以看到的是，无论导入的是什么类，都没有立即将它们转换成 <code>BeanDefinition</code> 并进行注册，而是将需要导入的类保存起来，后续统一处理。</p>
<h2 id="3-5-处理-ImportResource"><a class="header-anchor" href="#3-5-处理-ImportResource"></a>3.5 处理 @ImportResource</h2>
<p>回归主线，进行解析配置类的下一步：处理 <code>@ImportResource</code> 注解。</p>
<p><code>@ImportResource</code> 用于将外部的配置文件（比如 XML 配置文件）导入到基于 Java 配置的 Spring 应用程序中，这在将 Spring 从传统的 XML 配置向 Java 配置迁移的过程中发挥了重要的作用。</p>
<p>第一步同样是先获取 <code>@ImportResource</code> 注解的信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationAttributes</span> <span class="variable">importResource</span> <span class="operator">=</span></span><br><span class="line">       AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br></pre></td></tr></table></figure>
<p>然后获取 <code>@ImportResource</code> 注解的属性值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (importResource != <span class="literal">null</span>) &#123;</span><br><span class="line">    String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanDefinitionReader</span>&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件的位置会有多个，接下来自然是遍历这些位置信息。</p>
<p>这里没有执行获取配置文件信息的逻辑，而仅仅是将位置信息保存下来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">resolvedResource</span> <span class="operator">=</span> <span class="built_in">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">    configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续混眼熟，配置文件的位置信息存放在 <code>ConfigurationClass</code> 实例的 <code>importedResources</code> 字段中。</p>
<h2 id="3-6-处理-Bean-方法"><a class="header-anchor" href="#3-6-处理-Bean-方法"></a>3.6 处理 @Bean 方法</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line"><span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">    configClass.addBeanMethod(<span class="keyword">new</span> <span class="title class_">BeanMethod</span>(methodMetadata, configClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Bean</code> 方法的处理也是才去相同的策略：</p>
<ul>
<li>先获取到 <code>@Bean</code> 方法</li>
<li>并不立即处理，而是将它们保存到 <code>ConfigurationClass</code> 实例的 <code>beanMethods</code> 字段中</li>
</ul>
<p>至于如何获取 <code>@Bean</code> 方法也很简单。现在已经有配置类对应的 <code>Class</code> 对象了，通过反射能够拿到内部所有的方法，再判断下哪些方法被 <code>@Bean</code> 注解标记就完事了。</p>
<h2 id="3-7-处理-default-方法"><a class="header-anchor" href="#3-7-处理-default-方法"></a>3.7 处理 default 方法</h2>
<p><code>default</code> 方法的处理由 <code>processInterfaces()</code> 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processInterfaces(configClass, sourceClass);</span><br></pre></td></tr></table></figure>
<p>内部实现与处理 <code>@Bean</code> 方法类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processInterfaces</span><span class="params">(ConfigurationClass configClass,</span></span><br><span class="line"><span class="params">                               SourceClass sourceClass)</span> </span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 首先获取配置类的接口信息</span></span><br><span class="line">    <span class="keyword">for</span> (SourceClass ifc : sourceClass.getInterfaces()) &#123;</span><br><span class="line">        <span class="comment">// 获取其中的 Bean 方法</span></span><br><span class="line">        Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(ifc);</span><br><span class="line">        <span class="comment">// 遍历 Bean 方法</span></span><br><span class="line">        <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">            <span class="comment">// 非抽象的 Bean 方法才是 default 方法</span></span><br><span class="line">            <span class="keyword">if</span> (!methodMetadata.isAbstract()) &#123;</span><br><span class="line">                <span class="comment">// 同样将方法信息保存在 beanMethods 字段中</span></span><br><span class="line">                configClass.addBeanMethod(<span class="keyword">new</span> <span class="title class_">BeanMethod</span>(methodMetadata, configClass));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归处理接口的父接口</span></span><br><span class="line">        processInterfaces(configClass, ifc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>default</code> 方法的处理与 <code>@Bean</code> 方法类似，最后甚至也是将它们保存在 <code>ConfigurationClass</code> 实例的 <code>beanMethods</code> 字段中。</p>
<h2 id="3-8-处理超类"><a class="header-anchor" href="#3-8-处理超类"></a>3.8 处理超类</h2>
<p>配置类的解析终于来到最后一步，获取当前配置类的超类，如果有超类就让 <code>doProcessConfigurationClass()</code> 返回，否则返回 <code>null</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process superclass, if any</span></span><br><span class="line"><span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">superclass</span> <span class="operator">=</span> sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">    <span class="keyword">if</span> (superclass != <span class="literal">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp;</span><br><span class="line">          !<span class="built_in">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">       <span class="built_in">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">       <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">       <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>在调用 <code>doProcessConfigurationClass()</code> 方法的上层实现中，会判断是否返回了超类，如果存在，就进行递归处理，这在前文中也提到过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationClassParser#processConfigurationClass()</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processConfigurationClass</span><span class="params">(ConfigurationClass configClass, Predicate&lt;String&gt; filter)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">SourceClass</span> <span class="variable">sourceClass</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sourceClass = asSourceClass(configClass, filter);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回的超类不为 null，递归处理</span></span><br><span class="line">        <span class="keyword">while</span> (sourceClass != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-9-总结"><a class="header-anchor" href="#3-9-总结"></a>3.9 总结</h2>
<p>在 <code>ConfigurationClassParser#doProcessConfigurationClass()</code> 方法中对配置类的各种注解、各种方法都进行了处理，除了处理 <code>@ComponentScan</code> 注解是将目标类转换成 <code>BeanDefinition</code> 外，其他处理基本都采取了“延迟”策略，也就是先收集，后续统一处理，而 <code>doProcessConfigurationClass()</code> 方法中是不涉及统一处理的。</p>
<p>盘点一下收集了哪些内容：</p>
<ul>
<li>导入的 <code>DeferredImportSelector</code> 类存放在 <code>ConfigurationClassParser</code> 实例的 <code>deferredImportSelectorHandler</code> 字段中</li>
<li>导入的 <code>ImportBeanDefinitionRegistrar</code> 类存放在 <code>ConfigurationClass</code> 实例的 <code>importBeanDefinitionRegistrars</code> 字段中</li>
<li>导入的普通配置类存放在 <code>ConfigurationClassParser</code> 实例的 <code>importStack</code> 字段中</li>
<li>通过 <code>@ImportResource</code> 注解导入的配置文件存放在 <code>ConfigurationClass</code> 实例的 <code>importedResources</code> 字段中</li>
<li><code>@Bean</code> 方法、<code>default</code> 方法存放在 <code>ConfigurationClass</code> 实例的 <code>beanMethods</code> 字段中</li>
</ul>
<p>也就是说，如果需要统一处理这些信息，至少需要 <code>ConfigurationClassParser</code> 和 <code>ConfigurationClass</code> 两种实例。</p>
<p>先前已经分析过，导入的 <code>DeferredImportSelector</code> 最终会在 <code>ConfigurationClassParser#parse()</code> 方法最后执行，这也能划分到 <code>doProcessConfigurationClass()</code> 方法的一部分。</p>
<p>因此，如果需要统一处理这些信息，仅需要 <code>ConfigurationClass</code> 实例和 <code>ConfigurationClassParser</code> 实例中的 <code>importStack</code> 信息。</p>
<p>也真是因为 <code>doProcessConfigurationClass()</code> 方法内部更多的是对信息的收集，因此通过示例对调用 <code>ConfigurationClassParser#parse()</code> 方法进行 Debug 时发现并未增加多少 <code>BeanDefinition</code>，除了配置类本身 <code>Config</code> 外，额外的两个是 <code>MyFurtherConfig</code> 和 <code>MyController</code>，它们都是通过 <code>@ComponentScan</code> 扫描得到的。</p>
<p>那统一处理是在哪呢？</p>
<h1 id="4-统一处理"><a class="header-anchor" href="#4-统一处理"></a>4. 统一处理</h1>
<p>目光回到最外层的 <code>ConfigurationClassPostProcessor#processConfigBeanDefinitions()</code> 方法中。</p>
<p>以最初的示例代码而言，调用 <code>ConfigurationClassParser#parse()</code> 方法后，<code>BeanDefinition</code> 的数量并未显著增加，在调用 <code>reader.loadBeanDefinitions()</code> 方法加载 <code>BeanDefinition</code> 后，<code>@Bean</code> 方法、导入的配置类都出现在 <code>BeanDefinition</code> 中。</p>
<p>统一处理由 <code>reader.loadBeanDefinitions()</code> 方法完成。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/SpringBootImages/%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86BeanDefinition.png" alt="统一处理BeanDefinition"></p>
<p>可以看到，构造 <code>reader</code> 对象时传入了 <code>ConfigurationClassParser</code> 实例中的 <code>importStack</code> 信息，调用 <code>loadBeanDefinitions()</code> 方法时，传入了 <code>ConfigurationClass</code> 实例，基本满足先前分析的进行统一处理的要求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> &#123;</span><br><span class="line">    <span class="type">TrackedConditionEvaluator</span> <span class="variable">trackedConditionEvaluator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrackedConditionEvaluator</span>();</span><br><span class="line">    <span class="keyword">for</span> (ConfigurationClass configClass : configurationModel) &#123;</span><br><span class="line">       loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先构造 <code>TrackedConditionEvaluator</code> 实例，用于处理 <code>@Conditional</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TrackedConditionEvaluator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ConfigurationClass, Boolean&gt; skipped = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldSkip</span><span class="params">(ConfigurationClass configClass)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">skip</span> <span class="operator">=</span> <span class="built_in">this</span>.skipped.get(configClass);</span><br><span class="line">		<span class="comment">// 当前配置类未执行过 shouldSkip</span></span><br><span class="line">        <span class="keyword">if</span> (skip == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前配置类是被导入的</span></span><br><span class="line">            <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">allSkipped</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 递归判断导入当前配置类的配置类是否全被跳过</span></span><br><span class="line">                <span class="keyword">for</span> (ConfigurationClass importedBy : configClass.getImportedBy()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!shouldSkip(importedBy)) &#123;</span><br><span class="line">                        allSkipped = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果导入当前配置类的所有配置类都被跳过</span></span><br><span class="line">                <span class="comment">// 那么当前配置类也应该被跳过</span></span><br><span class="line">                <span class="keyword">if</span> (allSkipped) &#123;</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前配置类不是被导入的</span></span><br><span class="line">            <span class="comment">// 或者并不是所有导入当前配置类的配置类都被跳过</span></span><br><span class="line">            <span class="keyword">if</span> (skip == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 执行当前配置类的 shouldSkip</span></span><br><span class="line">                skip = conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 缓存一下</span></span><br><span class="line">            <span class="built_in">this</span>.skipped.put(configClass, skip);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> skip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后遍历每个配置类，即 <code>ConfigurationClass</code> 实例，经过先前的解析，该实例中的信息已经非常丰富了，怎么利用这些信息完成更多 <code>BeanDefinition</code> 的加载是由 <code>loadBeanDefinitionsForConfigurationClass</code> 方法完成。</p>
<h2 id="4-1-概括"><a class="header-anchor" href="#4-1-概括"></a>4.1 概括</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitionsForConfigurationClass</span><span class="params">(</span></span><br><span class="line"><span class="params">    ConfigurationClass configClass, </span></span><br><span class="line"><span class="params">    TrackedConditionEvaluator trackedConditionEvaluator)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前配置类需要被跳过</span></span><br><span class="line">    <span class="keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;</span><br><span class="line">        <span class="comment">// 获取配置类对应的 beanName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> configClass.getBeanName();</span><br><span class="line">        <span class="comment">// 由于当前配置类需要被跳过，因此要从 registry 中移除</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.registry.removeBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同样的，还要从 importRegistry 中移除</span></span><br><span class="line">        <span class="built_in">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载 @Import 导入的配置类的 BeanDefinition</span></span><br><span class="line">    <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">        registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载 @Bean 方法对应的 BeanDefinition</span></span><br><span class="line">    <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">        loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载 @ImportResource 注解导入的配置文件的 BeanDefinition</span></span><br><span class="line">    loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">    <span class="comment">// 加载导入的 ImportBeanDefinitionRegistrar 注册的 BeanDefinition</span></span><br><span class="line">    loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据以上信息可以总结出下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">来源</th>
<th style="text-align:center">存储位置</th>
<th style="text-align:center">实现方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>@Import</code></td>
<td style="text-align:center"><code>ConfigurationClassParser</code> 实例的 <code>importStack</code> 字段</td>
<td style="text-align:center"><code>registerBeanDefinitionForImportedConfigurationClass()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>@Bean</code> 方法</td>
<td style="text-align:center"><code>ConfigurationClass</code> 实例的 <code>beanMethods</code> 字段</td>
<td style="text-align:center"><code>loadBeanDefinitionsForBeanMethod()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>@ImportResource</code></td>
<td style="text-align:center"><code>ConfigurationClass</code> 实例的 <code>importedResources</code> 字段</td>
<td style="text-align:center"><code>loadBeanDefinitionsFromImportedResources()</code></td>
</tr>
<tr>
<td style="text-align:center">导入的 <code>ImportBeanDefinitionRegistrar</code></td>
<td style="text-align:center"><code>ConfigurationClass</code> 实例的 <code>importBeanDefinitionRegistrars</code> 字段</td>
<td style="text-align:center"><code>loadBeanDefinitionsFromRegistrars()</code></td>
</tr>
</tbody>
</table>
<h2 id="4-2-处理-Import"><a class="header-anchor" href="#4-2-处理-Import"></a>4.2 处理 @Import</h2>
<p>统一处理 <code>@Import</code> 导入的配置类由 <code>registerBeanDefinitionForImportedConfigurationClass()</code> 方法完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> configClass.getMetadata();</span><br><span class="line"><span class="type">AnnotatedGenericBeanDefinition</span> <span class="variable">configBeanDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotatedGenericBeanDefinition</span>(metadata);</span><br></pre></td></tr></table></figure>
<p>首先将导入的配置类包装成 <code>BeanDefinition</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> scopeMetadataResolver.resolveScopeMetadata(configBeanDef);</span><br><span class="line">configBeanDef.setScope(scopeMetadata.getScopeName());</span><br></pre></td></tr></table></figure>
<p>补充 <code>scope</code> 信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">configBeanName</span> <span class="operator">=</span> <span class="built_in">this</span>.importBeanNameGenerator.generateBeanName(configBeanDef, <span class="built_in">this</span>.registry);</span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations(configBeanDef, metadata);</span><br></pre></td></tr></table></figure>
<p>处理导入配置类上一些常见的注解，比如 <code>@Lazy</code>、<code>@Primary</code>、<code>@DependsOn</code>、<code>@Role</code>、<code>@Description</code> 等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(configBeanDef, configBeanName);</span><br><span class="line">definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line"><span class="built_in">this</span>.registry.registerBeanDefinition(definitionHolder.getBeanName(), definitionHolder.getBeanDefinition());</span><br><span class="line">configClass.setBeanName(configBeanName);</span><br></pre></td></tr></table></figure>
<p>处理代理，最终注册 <code>BeanDefinition</code> 即可。</p>
<p>整个过程似曾相识，和处理 <code>@ComponentScan</code> 注解将扫描到的类转换成 <code>BeanDefinition</code> 并注册基本一样。</p>
<h2 id="4-3-处理-Bean-方法"><a class="header-anchor" href="#4-3-处理-Bean-方法"></a>4.3 处理 @Bean 方法</h2>
<p>统一处理 <code>@Bean</code> 方法由 <code>loadBeanDefinitionsForBeanMethod()</code> 方法完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConfigurationClass</span> <span class="variable">configClass</span> <span class="operator">=</span> beanMethod.getConfigurationClass();</span><br><span class="line"><span class="type">MethodMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> beanMethod.getMetadata();</span><br><span class="line"><span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> metadata.getMethodName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do we need to mark the bean as skipped by its condition?</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">    configClass.skippedBeanMethods.add(methodName);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (configClass.skippedBeanMethods.contains(methodName)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获取 <code>@Bean</code> 方法的元数据（即 <code>metadata</code>）和方法名称，并判断当前 <code>@Bean</code> 方法是否需要跳过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationAttributes</span> <span class="variable">bean</span> <span class="operator">=</span> AnnotationConfigUtils.attributesFor(metadata, Bean.class);</span><br><span class="line">Assert.state(bean != <span class="literal">null</span>, <span class="string">&quot;No @Bean annotation attributes&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>获取 <code>@Bean</code> 注解的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Consider name and any aliases</span></span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(bean.getStringArray(<span class="string">&quot;name&quot;</span>)));</span><br><span class="line"><span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> (!names.isEmpty() ? names.remove(<span class="number">0</span>) : methodName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register aliases even when overridden</span></span><br><span class="line"><span class="keyword">for</span> (String alias : names) &#123;</span><br><span class="line">    <span class="built_in">this</span>.registry.registerAlias(beanName, alias);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理别名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Has this effectively been overridden before (e.g. via XML)?</span></span><br><span class="line"><span class="keyword">if</span> (isOverriddenByExistingDefinition(beanMethod, beanName)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>( <span class="comment">/***/</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断当前 <code>@Bean</code> 方法对应的 <code>BeanDefinition</code> 是否是要覆盖已有的 <code>BeanDefinition</code>。</p>
<p>如果是覆盖了已有的，直接返回或者抛异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConfigurationClassBeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassBeanDefinition</span>(configClass, metadata, beanName);</span><br><span class="line">beanDef.setSource(<span class="built_in">this</span>.sourceExtractor.extractSource(metadata, configClass.getResource()));</span><br></pre></td></tr></table></figure>
<p>构造 <code>@Bean</code> 方法对应的 <code>BeanDefinition</code>。</p>
<p>接下来是对构造的 <code>BeanDefinition</code> 进行补充与处理代理，最终调用 <code>BeanDefinitionRegistry</code> 的 <code>registerBeanDefinition()</code> 方法完成注册。</p>
<h2 id="4-4-处理-ImportResource"><a class="header-anchor" href="#4-4-处理-ImportResource"></a>4.4 处理 @ImportResource</h2>
<p>统一处理 <code>@ImportResource</code> 注解导入的配置文件由 <code>loadBeanDefinitionsFromImportedResources()</code> 方法完成。</p>
<p>该方法接收的参数列表如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanDefinitionReader</span>&gt;&gt; importedResources</span><br></pre></td></tr></table></figure>
<p><code>Map</code> 的 <code>key</code> 是配置文件所在的位置，<code>value</code> 是解析文件使用的 <code>Reader</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">importedResources.forEach((resource, readerClass) -&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>遍历传入的 <code>Map</code> 依次进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default reader selection necessary?</span></span><br><span class="line"><span class="keyword">if</span> (BeanDefinitionReader.class == readerClass) &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.endsWithIgnoreCase(resource, <span class="string">&quot;.groovy&quot;</span>)) &#123;</span><br><span class="line">       <span class="comment">// When clearly asking for Groovy, that&#x27;s what they&#x27;ll get...</span></span><br><span class="line">       readerClass = GroovyBeanDefinitionReader.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// Primarily &quot;.xml&quot; files but for any other extension as well</span></span><br><span class="line">       readerClass = XmlBeanDefinitionReader.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据不同的文件类型，选择不同的 <code>reader</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Class&lt;?&gt;, BeanDefinitionReader&gt; readerInstanceCache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="type">BeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> readerInstanceCache.get(readerClass);</span><br><span class="line"><span class="keyword">if</span> (reader == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Instantiate the specified BeanDefinitionReader</span></span><br><span class="line">        reader = readerClass.getConstructor(BeanDefinitionRegistry.class)</span><br><span class="line">            .newInstance(<span class="built_in">this</span>.registry);</span><br><span class="line">        <span class="comment">// Delegate the current ResourceLoader to it if possible</span></span><br><span class="line">        <span class="keyword">if</span> (reader <span class="keyword">instanceof</span> AbstractBeanDefinitionReader abdr) &#123;</span><br><span class="line">            abdr.setResourceLoader(<span class="built_in">this</span>.resourceLoader);</span><br><span class="line">            abdr.setEnvironment(<span class="built_in">this</span>.environment);</span><br><span class="line">        &#125;</span><br><span class="line">        readerInstanceCache.put(readerClass, reader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试从缓存中获取 <code>BeanDefinitionReader</code> 实例，如果获取失败，利用 <code>Class</code> 对象通过反射获取实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reader.loadBeanDefinitions(resource);</span><br></pre></td></tr></table></figure>
<p>最后使用 <code>reader</code> 加载配置文件中的 <code>BeanDefinition</code>。</p>
<h2 id="4-5-处理-ImportBeanDefinitionRegistrar"><a class="header-anchor" href="#4-5-处理-ImportBeanDefinitionRegistrar"></a>4.5 处理 ImportBeanDefinitionRegistrar</h2>
<p><code>ImportBeanDefinitionRegistrar</code> 提供了另一种注册 <code>BeanDefinition</code> 的方式，它的处理由 <code>loadBeanDefinitionsFromRegistrars()</code> 方法完成，内部实现极其简单，直接调用 <code>ImportBeanDefinitionRegistrar</code> 里的 <code>registerBeanDefinitions()</code> 方法就完事了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitionsFromRegistrars</span><span class="params">(Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; registrars)</span> &#123;</span><br><span class="line">    registrars.forEach((registrar, metadata) -&gt;</span><br><span class="line">          registrar.registerBeanDefinitions(metadata, <span class="built_in">this</span>.registry, <span class="built_in">this</span>.importBeanNameGenerator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-总结"><a class="header-anchor" href="#5-总结"></a>5. 总结</h1>
<p><code>ConfigurationClassPostProcessor</code> 类主要完成了对 Spring 配置类的解析，在 <a href="../Configuration-Annotation/">@Configuration 注解的那些事</a> 一文中主要介绍了配置类的 Full 模式和 Lite 模式，本文则是在此基础上对 Spring 配置类的详细解析步骤进行了介绍。</p>
<p>在解析配置类的过程中会涉及到多种注解的解析，包括 <code>@Conditional</code>、<code>@Component</code> 及其派生注解、<code>@Import</code>、<code>@ComponentScan</code>、<code>@Configuration</code>、<code>@Bean</code> 等与 Bean 注册相关的注解。</p>
<p><code>ConfigurationClassPostProcessor</code> 以容器中初始存在的配置类作为起点，然后不断寻找更多的配置类，以此进行源源不断地解析。</p>
<p>配置类由 <code>ConfigurationClass</code> 实例表示，在解析过程中，通过对注解、方法的解析不断补充完善这个对象，最后通过 <code>ConfigurationClassBeanDefinitionReader</code> 实例的 <code>loadBeanDefinitions()</code> 方法加载导入的、<code>@Bean</code> 方法对应的 <code>BeanDefinition</code>。</p>
<h1 id="6-写在最后"><a class="header-anchor" href="#6-写在最后"></a>6. 写在最后</h1>
<p>本文原计划在九月初发布，结果身体上总是有各种不适，胸闷、呼吸困难、胸痛的情况时有发生，给自己的学习和生产造成了极大的影响，每周不是在医院就是在去医院的路上，尽管最终并没有检查出什么，而自己却深陷疑病症的漩涡。</p>
<p>国庆过后，自己身体逐渐好转，胃部的不适成为主要症状，胸闷、呼吸困难的次数也基本屈指可数，对自己的影响大大减小，终于在临近 11 月完成了本文。</p>
<p>总之，拒绝熬夜，不要久坐，保持好心情，减少焦虑，快乐度过每一天。</p>
<p>愿看到这里的你身体永远健康，烦恼永远没有。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mofan212.github.io">默烦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mofan212.github.io/posts/How-To-Parse-Spring-Configuration-Classes/">https://mofan212.github.io/posts/How-To-Parse-Spring-Configuration-Classes/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://mofan212.github.io" target="_blank">Mofan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SpringBoot/">SpringBoot</a></div><div class="post-share"><div class="social-share" data-image="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/154.webp" data-sites="wechat,qq,weibo,facebook,twitter"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" target="_blank"><img class="post-qr-code-img" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" target="_blank"><img class="post-qr-code-img" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/How-To-Install-Rust-On-Windows/" title="如何在 Windows 下安装 Rust"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/155.jpg" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">如何在 Windows 下安装 Rust</div></div><div class="info-2"><div class="info-item-1">Windows 下 Rust 的安装、升级与卸载。</div></div></div></a><a class="pagination-related" href="/posts/Spring-BeanDefinition/" title="BeanDefinition"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/153.webp" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">BeanDefinition</div></div><div class="info-2"><div class="info-item-1">Spring 中绕不开的一个类 —— BeanDefinition。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/SpringBoot-Data/" title="SpringBoot与数据库"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2020-12-13</div><div class="info-item-2">SpringBoot与数据库</div></div><div class="info-2"><div class="info-item-1">本文基于 SpringBoot 2.2.4 ，介绍了 SpringBoot 如何整合数据库。</div></div></div></a><a class="pagination-related" href="/posts/Spring-BeanDefinition/" title="BeanDefinition"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/153.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2024-08-11</div><div class="info-item-2">BeanDefinition</div></div><div class="info-2"><div class="info-item-1">Spring 中绕不开的一个类 —— BeanDefinition。</div></div></div></a><a class="pagination-related" href="/posts/Configuration-Annotation/" title="@Configuration 注解的那些事"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/25.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2024-08-08</div><div class="info-item-2">@Configuration 注解的那些事</div></div><div class="info-2"><div class="info-item-1">从源码层面介绍 @Configuration 注解的 Full 模式与 Lite 模式。</div></div></div></a><a class="pagination-related" href="/posts/SpringBoot-Thymeleaf-Development-Process/" title="SpringBoot + Thymeleaf开发流程"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2020-07-20</div><div class="info-item-2">SpringBoot + Thymeleaf开发流程</div></div><div class="info-2"><div class="info-item-1">本文基于 SpringBoot 2.2.4 ，介绍了 SpringBoot 与 Thymeleaf 结合的基础开发流程。</div></div></div></a><a class="pagination-related" href="/posts/SpringBoot-Shutdown-Hook/" title="SpringBoot Shutdown Hook"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/141.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2024-07-11</div><div class="info-item-2">SpringBoot Shutdown Hook</div></div><div class="info-2"><div class="info-item-1">介绍了 System.exit() 方法的源码、SpringBoot 优雅停机等内容。</div></div></div></a><a class="pagination-related" href="/posts/Principles-Of-SpringBoot/" title="SpringBoot原理"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2020-11-05</div><div class="info-item-2">SpringBoot原理</div></div><div class="info-2"><div class="info-item-1">误人子弟系列，不要看，后续找个时间重写。😶</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">默烦</div><div class="author-info-description">彩笔的打怪升级之路...</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">158</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">30</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mofan212"><i class="fab fa-github"></i><span>follow me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:cy.mofan@foxmail.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a><a class="social-icon" href="https://www.travellings.cn/go.html" target="_blank" title="开往"><i class="fas fa-subway"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站所有博文均是博主的学习笔记与个人理解。<strong><font style="color:red">除特别注明外，</font>如需转载，请在文章头部醒目处附带原文链接并<a href="./mine/" style="color:#49B1F5;text-decoration:underline">告知我</a></strong>你将转载。😊</br><strong><font style="color:red">严禁未遵循规范的转载。</font></strong>😡</br><strong>死去的评论系统复活啦！欢迎到留言板畅所欲言！</strong>当然也可以使用更高效的<a target="_blank" href="https://space.bilibili.com/23658864/dynamic" style="color:#49B1F5;text-decoration:underline"> 哔哩哔哩私信 </a>或<a href="mailto:cy.mofan@foxmail.com" style="color:#49B1F5;text-decoration:underline" target="_blank">邮箱</a>。 😉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E5%89%8D%E8%A8%80"><span class="toc-text">0. 前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1-%E6%88%91%E7%9A%84%E8%BF%91%E5%86%B5"><span class="toc-text">0.1 我的近况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-2-%E5%86%85%E5%AE%B9%E6%A6%82%E8%BF%B0"><span class="toc-text">0.2 内容概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-3-%E9%98%85%E8%AF%BB%E5%BB%BA%E8%AE%AE"><span class="toc-text">0.3 阅读建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-4-%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A"><span class="toc-text">0.4 术语解释</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%94%A8%E6%B3%95%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="toc-text">1. 用法与示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Conditional-%E6%B3%A8%E8%A7%A3"><span class="toc-text">1.1 @Conditional 注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Condition-%E6%8E%A5%E5%8F%A3"><span class="toc-text">1.2 Condition 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">1.3 使用示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-text">2. 源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%BC%80%E9%97%A8%E8%A7%81%E5%B1%B1%E5%9C%B0%E8%AF%B4"><span class="toc-text">2.1 开门见山地说</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-processConfigBeanDefinitions"><span class="toc-text">2.2 processConfigBeanDefinitions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E8%A7%A3%E6%9E%90%E6%AF%8F%E4%B8%AA%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">2.3 解析每个配置类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-shouldSkip"><span class="toc-text">2.4 shouldSkip</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-processConfigurationClass"><span class="toc-text">2.5 processConfigurationClass</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E6%A0%A1%E9%AA%8C%E6%AF%8F%E4%B8%AA%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">2.6 校验每个配置类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E6%BA%90%E6%BA%90%E4%B8%8D%E6%96%AD%E5%9C%B0%E8%A7%A3%E6%9E%90"><span class="toc-text">2.7 源源不断地解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E8%A7%A3%E6%9E%90%E5%90%8E%E7%9A%84%E5%AE%8C%E5%96%84"><span class="toc-text">2.8 解析后的完善</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E8%AF%A6%E8%A7%A3%E5%A4%84%E7%90%86%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">3. 详解处理配置类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E9%80%92%E5%BD%92%E5%A4%84%E7%90%86%E6%88%90%E5%91%98%E7%B1%BB"><span class="toc-text">3.1 递归处理成员类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%A4%84%E7%90%86-PropertySource"><span class="toc-text">3.2 处理 @PropertySource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%A4%84%E7%90%86-ComponentScan"><span class="toc-text">3.3 处理 @ComponentScan</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%A4%84%E7%90%86-Import"><span class="toc-text">3.4 处理 @Import</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%A4%84%E7%90%86-ImportResource"><span class="toc-text">3.5 处理 @ImportResource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E5%A4%84%E7%90%86-Bean-%E6%96%B9%E6%B3%95"><span class="toc-text">3.6 处理 @Bean 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E5%A4%84%E7%90%86-default-%E6%96%B9%E6%B3%95"><span class="toc-text">3.7 处理 default 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E5%A4%84%E7%90%86%E8%B6%85%E7%B1%BB"><span class="toc-text">3.8 处理超类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-%E6%80%BB%E7%BB%93"><span class="toc-text">3.9 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86"><span class="toc-text">4. 统一处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%A6%82%E6%8B%AC"><span class="toc-text">4.1 概括</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%A4%84%E7%90%86-Import"><span class="toc-text">4.2 处理 @Import</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%A4%84%E7%90%86-Bean-%E6%96%B9%E6%B3%95"><span class="toc-text">4.3 处理 @Bean 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%A4%84%E7%90%86-ImportResource"><span class="toc-text">4.4 处理 @ImportResource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%A4%84%E7%90%86-ImportBeanDefinitionRegistrar"><span class="toc-text">4.5 处理 ImportBeanDefinitionRegistrar</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-text">5. 总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="toc-text">6. 写在最后</span></a></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>SpringBoot 源码剖析</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/From-Callback-To-LambdaSafe/" title="从回调到 LambdaSafe"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/131.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="从回调到 LambdaSafe"></a><div class="content"><a class="title" href="/posts/From-Callback-To-LambdaSafe/" title="从回调到 LambdaSafe">从回调到 LambdaSafe</a><time datetime="2023-03-11T16:00:00.000Z" title="发表于 2023-03-12 00:00:00">2023-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Get-ApplicationContext/" title="获取 ApplicationContext"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/139.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="获取 ApplicationContext"></a><div class="content"><a class="title" href="/posts/Get-ApplicationContext/" title="获取 ApplicationContext">获取 ApplicationContext</a><time datetime="2023-09-19T16:00:00.000Z" title="发表于 2023-09-20 00:00:00">2023-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Configuration-Annotation/" title="@Configuration 注解的那些事"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/25.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="@Configuration 注解的那些事"></a><div class="content"><a class="title" href="/posts/Configuration-Annotation/" title="@Configuration 注解的那些事">@Configuration 注解的那些事</a><time datetime="2023-09-22T16:00:00.000Z" title="发表于 2023-09-23 00:00:00">2023-09-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Common-Extension-Points-In-Spring-Boot/" title="SpringBoot 常用拓展点"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/140.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="SpringBoot 常用拓展点"></a><div class="content"><a class="title" href="/posts/Common-Extension-Points-In-Spring-Boot/" title="SpringBoot 常用拓展点">SpringBoot 常用拓展点</a><time datetime="2023-10-02T16:00:00.000Z" title="发表于 2023-10-03 00:00:00">2023-10-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/SpringBoot-Shutdown-Hook/" title="SpringBoot Shutdown Hook"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/141.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="SpringBoot Shutdown Hook"></a><div class="content"><a class="title" href="/posts/SpringBoot-Shutdown-Hook/" title="SpringBoot Shutdown Hook">SpringBoot Shutdown Hook</a><time datetime="2023-10-14T16:00:00.000Z" title="发表于 2023-10-15 00:00:00">2023-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Spring-Application-Event/" title="Spring 的事件监听机制"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/151.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Spring 的事件监听机制"></a><div class="content"><a class="title" href="/posts/Spring-Application-Event/" title="Spring 的事件监听机制">Spring 的事件监听机制</a><time datetime="2024-07-13T16:00:00.000Z" title="发表于 2024-07-14 00:00:00">2024-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Spring-BeanDefinition/" title="BeanDefinition"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/153.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="BeanDefinition"></a><div class="content"><a class="title" href="/posts/Spring-BeanDefinition/" title="BeanDefinition">BeanDefinition</a><time datetime="2024-08-10T16:00:00.000Z" title="发表于 2024-08-11 00:00:00">2024-08-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/How-To-Parse-Spring-Configuration-Classes/" title="Spring 配置类的解析"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/154.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Spring 配置类的解析"></a><div class="content"><a class="title" href="/posts/How-To-Parse-Spring-Configuration-Classes/" title="Spring 配置类的解析">Spring 配置类的解析</a><time datetime="2024-10-25T16:00:00.000Z" title="发表于 2024-10-26 00:00:00">2024-10-26</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Docker-Advanced/" title="Docker 高级篇"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/158.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Docker 高级篇"/></a><div class="content"><a class="title" href="/posts/Docker-Advanced/" title="Docker 高级篇">Docker 高级篇</a><time datetime="2025-02-22T16:00:00.000Z" title="更新于 2025-02-23 00:00:00">2025-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/The-Basis-Of-Java-Util-Concurrent/" title="JUC 基础知识"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/63.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="JUC 基础知识"/></a><div class="content"><a class="title" href="/posts/The-Basis-Of-Java-Util-Concurrent/" title="JUC 基础知识">JUC 基础知识</a><time datetime="2025-02-20T16:00:00.000Z" title="更新于 2025-02-21 00:00:00">2025-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Design-Pattern-Strategy-Pattern/" title="【设计模式】策略模式"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/83.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="【设计模式】策略模式"/></a><div class="content"><a class="title" href="/posts/Design-Pattern-Strategy-Pattern/" title="【设计模式】策略模式">【设计模式】策略模式</a><time datetime="2025-02-19T16:00:00.000Z" title="更新于 2025-02-20 00:00:00">2025-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Docker-Basics/" title="Docker 基础篇"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/157.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Docker 基础篇"/></a><div class="content"><a class="title" href="/posts/Docker-Basics/" title="Docker 基础篇">Docker 基础篇</a><time datetime="2025-02-18T16:00:00.000Z" title="更新于 2025-02-19 00:00:00">2025-02-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Quick-Start-To-Arthas/" title="Arthas 快速入门"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/127.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Arthas 快速入门"/></a><div class="content"><a class="title" href="/posts/Quick-Start-To-Arthas/" title="Arthas 快速入门">Arthas 快速入门</a><time datetime="2025-02-03T16:00:00.000Z" title="更新于 2025-02-04 00:00:00">2025-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Goodbye-2024-Hello-2025/" title="再见甲辰，你好乙巳"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/156.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="再见甲辰，你好乙巳"/></a><div class="content"><a class="title" href="/posts/Goodbye-2024-Hello-2025/" title="再见甲辰，你好乙巳">再见甲辰，你好乙巳</a><time datetime="2025-01-29T16:00:00.000Z" title="更新于 2025-01-30 00:00:00">2025-01-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 默烦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.2.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://fastly.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://fastly.jsdelivr.net/npm/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://npm.elemecdn.com/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://fastly.jsdelivr.net/gh/mofan212/blog-static-resources@master/js/mine.min.js"></script><script defer="defer" id="ribbon" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-show-text" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Azathoth,Yog-Sothoth,Shub-Niggurath,Nyarlathotep,Cthulhu,Hastur,Abhoth,Ghroth,Tsathoggua,Cthugha,Deep Ones,Dagon,Chaugnar Faugn,Mordiggian,Shoggoth,Old One,Mi-Go,Great Race of Yith,Flying Polyp,Hounds of Tindalos,Dhole" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://fastly.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'BAFEL7A6K1',
    apiKey: '89fcb5961984c5c054bf04149f345f38',
    indexName: 'mofan212io',
    container: '#docsearch',
    placeholder: '输入关键字进行搜索',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>
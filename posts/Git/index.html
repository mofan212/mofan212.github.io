<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Git理论与使用 | Mofan</title><meta name="author" content="默烦,cy.mofan@foxmail.com"><meta name="copyright" content="默烦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Git 是啥？是饭桶、是蠢货！不想当饭桶？来看下这篇文章吧。">
<meta property="og:type" content="article">
<meta property="og:title" content="Git理论与使用">
<meta property="og:url" content="https://mofan212.github.io/posts/Git/">
<meta property="og:site_name" content="Mofan">
<meta property="og:description" content="Git 是啥？是饭桶、是蠢货！不想当饭桶？来看下这篇文章吧。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/3.jpg">
<meta property="article:published_time" content="2020-05-28T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-26T16:00:00.000Z">
<meta property="article:author" content="默烦">
<meta property="article:tag" content="Git">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/3.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Git理论与使用",
  "url": "https://mofan212.github.io/posts/Git/",
  "image": "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/3.jpg",
  "datePublished": "2020-05-28T16:00:00.000Z",
  "dateModified": "2025-08-26T16:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "默烦",
      "url": "https://mofan212.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/favicon.png"><link rel="canonical" href="https://mofan212.github.io/posts/Git/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 默烦","link":"链接: ","source":"来源: Mofan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://testingcf.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Git理论与使用',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><link rel="stylesheet" href="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources@master/css/myStyle.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/style.css" /><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" /><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Mofan" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources/css/minimal.min.css"/><script src="https://testingcf.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">174</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/reward/"><i class="fa-fw fa-solid fa-coins"></i><span> 赞助</span></a></li><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/post_top_img.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Mofan</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/reward/"><i class="fa-fw fa-solid fa-coins"></i><span> 赞助</span></a></li><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Git理论与使用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-05-28T16:00:00.000Z" title="发表于 2020-05-29 00:00:00">2020-05-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-26T16:00:00.000Z" title="更新于 2025-08-27 00:00:00">2025-08-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Tools/">Tools</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">21k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>72分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;距离本文上次更新已经过去&quot;,&quot;messageNext&quot;:&quot;天，请注意时效性。&quot;,&quot;postUpdate&quot;:&quot;2025-08-27 00:00:00&quot;}" hidden></div><p>封面来源：本文封面来源于 Git 官网，如有侵权，请联系删除。</p>
<p>更多学习链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/mRw24qCRzuk3iHpvy3gw0g">只会用 2005 年的 Git 老命令？这 7 个 Git 新命令，很实用！</a></li>
</ul>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/git-model@2x.png" alt="A successful Git branching model" style="zoom:50%;" />
<h1 id="1-版本控制"><a class="header-anchor" href="#1-版本控制"></a>1. 版本控制</h1>
<blockquote>
<p>版本控制含义</p>
</blockquote>
<p>版本控制（Revision Control）是一种在开发过程中对文件、目录或工程等内容的修改历史进行管理的软件工程技术，使用版本控制后可以通过查看历史修改记录，更方便地恢复到先前的版本。</p>
<p>版本控制可以：</p>
<ul>
<li>实现跨区域多人协同开发</li>
<li>追踪和记载一个或者多个文件的历史记录</li>
<li>组织和保护你的源代码和文档</li>
<li>统计工作量</li>
<li>并行开发、提高开发效率</li>
<li>跟踪记录整个软件的开发过程</li>
<li>减轻开发人员的负担，节省时间，同时降低人为错误</li>
</ul>
<p>简单来说就是 <strong>用于管理多人协同开发项目的技术</strong>。</p>
<blockquote>
<p>版本控制工具</p>
</blockquote>
<p>主流的版本控制软件有：</p>
<ul>
<li><strong>Git</strong></li>
<li><strong>SVN</strong>（Subversion）</li>
<li><strong>CVS</strong>（Concurrent Versions System）</li>
<li><strong>VSS</strong>（Micorosoft Visual SourceSafe）</li>
<li><strong>TFS</strong>（Team Foundation Server）</li>
<li>Visual Studio Online</li>
</ul>
<p>使用最广泛的是 <mark>Git</mark> 与 <mark>SVN</mark>。</p>
<blockquote>
<p>版本控制分类</p>
</blockquote>
<p><strong>1、本地版本控制系统</strong></p>
<p>记录文件每次的更新，对每个版本做一个快照，或是记录补丁文件，适合个人用，如 RCS。它是在一台机器上，记录版本的不同变化，保证内容不会丢失。但在多人开发的情况下，每个人都在不同的系统和电脑上开发，没办法协同工作。</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/本地版本控制.jpg" style="zoom: 67%;" />
<p><strong>2、集中版本控制系统</strong></p>
<p>所有的版本数据都保存在中央服务器上，协同开发者从服务器上同步更新或上传自己的修改，用户只有自己以前所同步的版本，如果不连网，用户就看不到历史版本，也无法切换版本验证，或在不同分支工作。所有数据都保存在单一的服务器上，当服务器损坏时，可能会丢失所有数据，代表产品有 SVN、CVS、VSS 等。</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/集中式版本控制.jpg" alt="集中式版本控制" style="zoom:67%;" />
<p><strong>3、分布式版本控制系统</strong></p>
<p>需要一台服务器作为远程代码仓库，所有版本信息同步到每个用户的本地。用户可以本地离线提交，只需在联网时将修改推送到远程代码仓库即可。每个用户的电脑都是代码仓库，是远程代码仓库的镜像，用户修改和获取代码都是在自己的本地仓库中进行操作。</p>
<p>由于每个用户都保存了所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，不会因为服务器损坏或者网络问题，出现不能工作的情况。</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/分布式版本控制.jpg" style="zoom: 50%;" />
<blockquote>
<p>Git 与 SVN 的区别</p>
</blockquote>
<ul>
<li>
<p>SVN 是集中化的版本控制系统，必须联网使用，Git 是分布式版本控制系统，支持离线操作；</p>
</li>
<li>
<p>SVN 是按照原始文件存储的，体积较大，Git 是按照元数据方式存储的，体积很小；</p>
</li>
<li>
<p>SVN 的分支操作成本较大，会影响到其他开发人员，Git 的分支操作成本更小，不会影响到其他人；</p>
</li>
<li>
<p>SVN 常用于维护文档，Git 常用于维护代码。</p>
</li>
</ul>
<h1 id="2-Git-的历史"><a class="header-anchor" href="#2-Git-的历史"></a>2. Git 的历史</h1>
<p>2002 年，Linux 内核开源社区开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。</p>
<p>2005 年，开发 BitKeeper 的 BitMover  公司结束与 Linux 内核开源社区的合作关系，并收回 Linux 内核开源社区的免费使用权。而后，Linux 的缔造者 Linus Torvalds 使用两周开发出自己的版本系统，也就是如今的 Git！</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/李纳斯·托沃兹.png" alt="李纳斯·托沃兹" style="zoom:50%;" />
<p><span style="text-align: center;display:block;">Linux 和 Git 之父李纳斯·托沃兹（Linus Benedic Torvalds）1969、芬兰</span></p>
<h1 id="3-Git-环境配置"><a class="header-anchor" href="#3-Git-环境配置"></a>3. Git 环境配置</h1>
<h2 id="3-1-安装与卸载-Git"><a class="header-anchor" href="#3-1-安装与卸载-Git"></a>3.1 安装与卸载 Git</h2>
<p>打开 <a target="_blank" rel="noopener" href="https://git-scm.com/">git官网</a>，下载 git 对应操作系统的版本。</p>
<p>如果官网下载太慢，可以使用淘宝镜像下载：<a target="_blank" rel="noopener" href="http://npm.taobao.org/mirrors/git-for-windows/">Git镜像下载</a></p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/Git官网.png" alt="Git官网" style="zoom: 50%;" />
<p>进入镜像后，拖至最下方，进入稳定版的下载，然后根据自己操作系统的情况下载并进行安装。</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/Git镜像下载_1.png" alt="Git镜像下载_1" style="zoom:50%;" />
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/Git镜像下载_2.png" alt="Git镜像下载_2" style="zoom:50%;" />
<p>安装时使用“傻瓜式”安装，无脑下一步即可。<mark>PS：注意按自己需求修改安装路径！</mark>😏</p>
<p>安装时还可以修改默认编辑器，默认是 Vim 编辑器。比如将默认编辑器修改为 NotePad3，找到 NotePad3 的 exe 文件并选择即可。</p>
<p>如果在安装完成后想要修改默认编辑器，可以使用命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将默认编辑器修改为 vim</span></span><br><span class="line">git config --global core.editor vim</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改为 NotePad3（安装路径自行修改）</span></span><br><span class="line">git config --global core.editor &quot;D:\\Notepad3\\Notepad3.exe&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Git 的卸载</p>
</blockquote>
<p>使用国内各种管家软件或打开控制面板进行卸载即可，最后记得删除与 Git 相关的、在 path 下的环境变量！</p>
<blockquote>
<p>启动Git</p>
</blockquote>
<p>安装成功后在开始菜单中会有如下信息：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/%E5%BC%80%E5%A7%8B%E8%8F%9C%E5%8D%95Git%E9%A1%B9.png" alt="开始菜单Git项"></p>
<p><strong>Git Bash：</strong> Unix 与 Linux 风格的命令行（使用最多，推荐使用）</p>
<p><strong>Git CMD：</strong> Windows 风格的命令行</p>
<p><strong>Git GUI：</strong> 图形界面的 Git，不建议初学者使用，尽量先熟悉常用命令</p>
<p>可以在某一目录中点击右键，点击“Git Bash Here”就可以再当前目录下打开 Git Bash。</p>
<h2 id="3-2-Linux-常用命令"><a class="header-anchor" href="#3-2-Linux-常用命令"></a>3.2 Linux 常用命令</h2>
<p>在 Git 的命令行界面也可以使用 Linux 的操作命令，常用的有以下命令：</p>
<p>1、cd：切换目录</p>
<p>2、cd . . ：回退到上一个目录，直接 cd 进入默认目录</p>
<p>3、pwd：显示当前所在的目录路径</p>
<p>4、ls（ll）：都是列出当前目录中的所有文件，只不过 ll（两个 ll）列出的内容更为详细</p>
<p>5、touch：新建一个文件。如 <code>touch index.js</code> 就会在当前目录下新建一个 index.js 文件</p>
<p>6、rm：删除一个文件。如 <code>rm index.js</code> 就会把 index.js 文件删除</p>
<p>7、mkdir：新建一个目录，就是新建一个文件夹</p>
<p>8、rm -r：删除一个文件夹，<code>rm -r src</code> 删除 src 目录</p>
<p>9、mv：移动文件</p>
<p>10、reset：重新初始化终端/清屏</p>
<p>11、clear：清屏</p>
<p>12、history：查看历史命令执行情况</p>
<p>13、help：帮助</p>
<p>14、exit：退出</p>
<h2 id="3-3-Git-的配置"><a class="header-anchor" href="#3-3-Git-的配置"></a>3.3 Git 的配置</h2>
<p>Git 的所有配置信息都保存在本地。</p>
<p>可以使用命令 <code>git config -l</code> 查看全部配置信息：</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/Git配置信息.png" alt="Git配置信息" style="zoom:50%;" />
<p>还可以使用以下命令，查看不同级别的配置信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统 config</span></span><br><span class="line">git config --system --list</span><br><span class="line"><span class="meta prompt_">　　</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前用户（global）配置</span></span><br><span class="line">git config --global  --list</span><br></pre></td></tr></table></figure>
<p><strong>Git 相关的本地配置文件位置：</strong></p>
<ul>
<li>
<p>Git 安装目录 \etc\gitconfig：Git 安装目录下的 gitconfig   --system 系统级配置文件</p>
</li>
<li>
<p>C:\Users\你的用户名\ .gitconfig：只适用于当前登录用户的配置  --global 全局配置文件</p>
</li>
</ul>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/当前用户配置文件信息.png" alt="当前用户配置文件信息" style="zoom:50%;" />
<p>可以直接在这里编辑配置文件，通过命令设置后也会响应到这里。</p>
<blockquote>
<p><strong>设置用户名与邮箱</strong>   这很重要！ 这很重要！ 这很重要！</p>
</blockquote>
<p>安装完 Git 后首先要做的事情是设置用户名和 email 地址。这 <mark>非常重要</mark>，因为每次 Git 提交都会使用该信息，它被永远的嵌入到了提交中。<mark>所以！必须进行设置！！</mark>  <mark>这很重要 * 3</mark></p>
<p>如果刚安装 Git 后没有设置用户名和邮箱，执行 <code>git config --global  --list</code> 就会出现下图中的第一种情况，此时需要按照第二个与第三个类似命令来设置用户名🏃和邮箱📧（我在此处设置的是我自己的用户名 mofan 与我的邮箱，你需要设置属于你自己的用户名和邮箱）。</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/配置文件编写.png" alt="配置文件编写" style="zoom:50%;" />
<p>如果使用了 <code>--global</code> 选项，表示设置了全局的用户名和邮箱。如果希望在一个特定的项目中使用不同的用户名和邮箱，可以在该项目中运行该命令而不添加 <code>--global</code> 选项。总之 <code>--global</code> 为全局配置，不加为某个项目的特定配置。</p>
<p>设置好用户名和邮箱后，再运行 <code>git config --global  --list</code>，就会显示设置的用户名和邮箱了，也可以在 <code>C:\Users\你的用户名\.gitconfig </code> 文件中看到设置的信息。</p>
<h1 id="4-Git-基本理论"><a class="header-anchor" href="#4-Git-基本理论"></a>4. Git 基本理论</h1>
<blockquote>
<p>三大区域</p>
</blockquote>
<p>Git 本地有三个工作区域：工作目录（Working Directory）、暂存区（Stage 或 Index）、资源库（历史记录区、版本库、本地仓库、History、Repository 或 Git Directory）。如果在加上远程的 Git 仓库（Remote Directory）也可以分为四个工作区域。</p>
<p>文件在这四个区域之间的转换关系如下：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/Git%E4%B8%89%E5%A4%A7%E5%8C%BA%E5%9F%9F.png" alt="Git三大区域"></p>
<ul>
<li>Working Directory：工作区，平时存放项目代码的地方。</li>
<li>Stage（Index）：暂存区，用于临时存放改动，事实上它只是一个文件，保存即将提交到文件列表信息。</li>
<li>History：历史记录区，安全存放数据的位置，里面有项目所有版本的数据。</li>
<li>Remote Directory：远程仓库，托管代码的服务器，可以简单的认为是项目组中用于远程数据交换的一台电脑。</li>
</ul>
<blockquote>
<p>三大区域的另一种图示</p>
</blockquote>
<p>本地的三个区域确切的说应该是 Git 仓库中 HEAD 指向的版本：</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/图解三大区域.png" alt="图解三大区域" style="zoom: 67%;" />
<ul>
<li>Directory：使用 Git 管理的一个目录，也就是一个仓库，包含我们的工作空间和 Git 的管理空间。</li>
<li>WorkSpace：需要通过 Git 进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li>
<li>.git：存放 Git 管理信息的目录，初始化仓库的时候自动创建。（<strong>一个隐藏文件夹</strong>）</li>
<li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入 repo 之前，可以把所有的更新放在暂存区。</li>
<li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD 会只是当前的开发分支（branch）。</li>
<li>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复 WorkSpace 中的临时状态。</li>
</ul>
<blockquote>
<p>工作流程</p>
</blockquote>
<p>1、在工作目录中添加、修改文件；</p>
<p>2、将需要进行版本管理的文件放入暂存区域；</p>
<p>3、将暂存区域的文件提交到本地仓库。</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/Git工作流程.png" alt="Git工作流程" style="zoom: 50%;" />
<h1 id="5-Git-项目搭建"><a class="header-anchor" href="#5-Git-项目搭建"></a>5. Git 项目搭建</h1>
<blockquote>
<p>什么是工作目录？</p>
</blockquote>
<p>工作目录（WorkSpace）一般就是希望 Git 进行管理的文件夹，可以是项目的目录，也可以是一个空目录。</p>
<p><s>建议</s><mark>要求</mark>不能有中文。</p>
<blockquote>
<p>创建全新的仓库</p>
</blockquote>
<p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p>
<p>1、在项目的根目录执行以下命令创建全新的仓库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前目录新建一个 Git 代码库</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>2、执行后在当前目录下新增了一个 <code>.git</code> 隐藏目录，当前项目的版本信息和配置信息都会存放在这个目录里。</p>
<blockquote>
<p>克隆远程仓库</p>
</blockquote>
<p>可以使用以下命令将某个项目克隆（下载）到本地：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">克隆一个项目和它的整个代码历史(版本信息)</span></span><br><span class="line">git clone [url]</span><br></pre></td></tr></table></figure>
<p>在 GitHub 上选定一个项目进行测试：</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/复制仓库URL.png" alt="复制仓库URL" style="zoom:50%;" />
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/Git%E4%B9%8Bclone%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.png" alt="Git之clone远程仓库"></p>
<blockquote>
<p>删除远程仓库</p>
</blockquote>
<p><strong>GitHub 中的操作：</strong></p>
<p>进入 GitHub 中需要删除的仓库，点击“Settings”，下拉网页至最后“Danger Zone”，选中并点击“Delete this Repository”，然后根据界面提示进行操作即可。</p>
<p><strong>Gitee 中的操作：</strong></p>
<p>进入 Gitee 中需要删除的仓库，点击“管理” — 仓库设置 — 删除仓库，根据界面提示进行操作即可。</p>
<h1 id="6-Git-文件操作"><a class="header-anchor" href="#6-Git-文件操作"></a>6. Git 文件操作</h1>
<blockquote>
<p>文件的四种状态</p>
</blockquote>
<p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前是什么状态。</p>
<p>1、Untracked：未跟踪，此文件在文件夹中，但没有加入到 Git 库，不参与版本控制。可以通过 <code>git add</code> 状态变为 Staged。</p>
<p>2、Unmodify：文件已经入库，且未修改，即版本库中的文件快照内容与文件夹中完全一致。这种类型的文件有两种去处，如果它被修改，变为 Modified；如果使用 <code>git rm</code> 移出版本库，则变为 Untracked。</p>
<p>3、Modified：文件已修改， 仅仅是修改，并没有进行其他的操作。这个文件也有两个去处，通过 <code>git add</code> 变为暂存 Staged 状态；使用 <code>git checkout</code>  丢弃修改， 返回到 Unmodify 状态。<code>git checkout</code> 表示从库中取出文件，覆盖当前修改，即丢弃当前修改。</p>
<p>4、Staged：暂存状态。通过 <code>git commit</code> 将修改提交到本地仓库， 文件变为 Unmodify 状态。执行 <code>git reset HEAD filename</code> 取消暂存， 变为 Modified 状态。</p>
<blockquote>
<p>查看文件状态</p>
</blockquote>
<p>可以通过以下命令查看到文件的状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看指定文件状态</span></span><br><span class="line">git status [filename]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有文件状态</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure>
<blockquote>
<p>add 与 commit 命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加所有文件到暂存区</span></span><br><span class="line">git add .     </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交暂存区中的内容到本地仓库 -m 提交信息</span></span><br><span class="line">git commit -m &quot;消息内容&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将跟踪的文件直接添加到本地仓库（如果有新增文件，还是得先执行 git add .）</span></span><br><span class="line">git commit -am &quot;消息内容&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>忽略文件</p>
</blockquote>
<p>有时不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等，要求忽略这些文件的修改。</p>
<p>在根目录下建立 <code>.gitignore</code> 文件，将需要被忽略的文件名添加到此文件中。</p>
<p><code>.gitignore</code> 文件内容解析：</p>
<p>1、以井号 <code>#</code> 开始的行表示注释；</p>
<p>2、可以使用 Linux 通配符。例如：星号 <code>*</code> 代表任意多个字符，问号 <code>?</code> 代表一个字符，方括号 <code>[]</code> 代表可选字符范围，大括号 <code>&#123;&#125;</code> 代表可选的字符串等；</p>
<p>3、如果名称的最前面有一个感叹号 <code>!</code>，表示例外规则，满足条件的文件不会被忽略；</p>
<p>4、如果名称的最前面是一个路径分隔符 <code>/</code>，表示要忽略的文件在根目录下；</p>
<p>5、如果名称的最后面是一个路径分隔符 <code>/</code>，表示要忽略的是此目录下的文件。</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*.txt        # 忽略所有 .txt 结尾的文件</span><br><span class="line">!lib.txt     # lib.txt 除外</span><br><span class="line">/temp        # 忽略项目根目录下的 temp 文件</span><br><span class="line">build/       # 忽略 build 目录下的所有文件</span><br><span class="line">doc/*.txt    # 忽略 doc 目录下的所有 txt 文件，不包括子目录下</span><br></pre></td></tr></table></figure>
<p>IDEA 中常用的 <code>.gitignore</code> 文件内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Compiled class file</span></span><br><span class="line">*.class</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Log file</span></span><br><span class="line">*.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">BlueJ files</span></span><br><span class="line">*.ctxt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Mobile Tools <span class="keyword">for</span> Java (J2ME)</span></span><br><span class="line">.mtj.tmp/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Package Files <span class="comment">#</span></span></span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">virtual machine crash logs</span></span><br><span class="line">hs_err_pid*</span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure>
<h1 id="7-GitHub-的使用"><a class="header-anchor" href="#7-GitHub-的使用"></a>7. GitHub 的使用</h1>
<p>可以使用 GitHub 作为代码托管平台，尽管 GitHub 的访问速度不佳，但也不选择 Gitee，而在公司中，还可能使用搭建的的 GitLab 服务器。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/GitHub.png" alt="GitHub"></p>
<ul>
<li>
<p>首先需要注册 GitHub；</p>
</li>
<li>
<p>为了方便使用，<strong>强烈建议</strong> 设置本机绑定 SSH 公钥（gōng yuè），实现免密码登录；</p>
</li>
</ul>
<p>冷知识：公钥、私钥、密钥中，钥都读 <code>yuè</code>。😱</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入 C:\Users(用户)\你的用户名 目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你是第一次设置，在这个目录下看不到.ssh目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在上述目录下右键打开“Git Bash Here”，运行以下命令并生成公钥</span></span><br><span class="line">ssh-keygen -t rsa -C 邮箱或其他描述性文字</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rsa是加密方式</span></span><br></pre></td></tr></table></figure>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/Git秘钥生成.png" alt="Git秘钥生成" style="zoom:50%;" />
<blockquote>
<p>对输入的命令以及执行命令后需要输出的情况进行解析</p>
</blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yanglang/p/9563496.html">SSH-keygen用法</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>以上代码省略了 <code>-f</code> 参数，因此运行上面那条命令后会要求输入一个文件名，用于保存刚才生成的 SSH key 代码，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line"># Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]</span><br></pre></td></tr></table></figure>
<p>也可以不输入文件名，使用默认文件名（<strong>推荐</strong>），那么就会生成 id_rsa 和 id_rsa.pub 两个秘钥文件。</p>
<p>接着又会提示输入两次密码（该密码是 push 文件的时候要输入的密码，而不是 GitHub 管理者的密码），也可以不输入密码，直接按回车。那么 push 的时候就不需要输入密码，直接提交到 GitHub 上了，如：（我在此直接回车，不输入密码）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line"># Enter same passphrase again:</span><br></pre></td></tr></table></figure>
<p>接下来将会显示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Your identification has been saved in /c/Users/you/.ssh/id_rsa.</span><br><span class="line"># Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.</span><br><span class="line"># The key fingerprint is:</span><br><span class="line"># 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com</span><br></pre></td></tr></table></figure>
<p>当看到上面这些信息时就说明 SSH key 已经创建成功，接下来将其添加到 GitHub 的 SSH key 上就可以了。</p>
<ul>
<li>
<p>打开 GitHub 并进行登录，点击右上角头像，选择 Settings，进入设置页面后，点击 Access 下的 SSH and GPG keys，之后点击 New SSH key；</p>
</li>
<li>
<p>打开目录 <code>C:\Users(用户)\你的用户名\.ssh</code>，将 id_rsa.pub 文件内的内容复制到公钥填写处，点击“确定”，输入 GitHub 的密码即可添加成功！</p>
</li>
</ul>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/公钥复制.png" alt="公钥复制" style="zoom: 50%;" />
<p>PS：id_rsa 存放的是私钥，id_rsa.pub 存放的是公钥，需要复制的是公钥 id_rsa.pub 的内容。</p>
<ul>
<li>
<p>运行 Git Bash，输入命令 <code>ssh -T git@github.com</code>（如果使用 Gitee，输入 <code>ssh -T git@gitee.com</code>），然后输入 yes。</p>
</li>
<li>
<p>到此，完成 SSH 免密登录的配置。</p>
</li>
<li>
<p>如果需要新建仓库，点击主界面右上方头像旁的“+”然后选择“New repository”即可：</p>
</li>
</ul>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/GitHub创建仓库.png" alt="GitHub创建仓库" style="zoom:50%;" />
<h1 id="8-IDEA-中集成-Git"><a class="header-anchor" href="#8-IDEA-中集成-Git"></a>8. IDEA 中集成 Git</h1>
<p><strong>以下内容适用于 IDEA 2019.3 版本，其他版本仅供参考。</strong></p>
<blockquote>
<p>IDEA 配置 Git</p>
</blockquote>
<p>首先需要在 IDEA 中配置 Git，打开 IDEA，settings — Version Control — Git — Path to Git executable，在此处配置 Git 安装目录下的 exe 文件。例如：D:\environment\Git\cmd\git.exe，其中 D:\environment\Git 是安装目录。（最新版不需要进行配置，IDEA 已经帮我们配置好，以防万一可以查看一下 😁）</p>
<p>然后可以点击“test”，查看配置是否正确。</p>
<p>还可以选择 settings — Version Control — GitHub，添加 GitHub 账号到 IDEA 中。</p>
<blockquote>
<p>IDEA 项目绑定 Git</p>
</blockquote>
<p>1、新建项目，绑定 Git。</p>
<p><span name="binding">在此给出两种绑定方式（<strong>推荐第二种</strong>）：</span></p>
<ul>
<li>在克隆下来的空项目中使用 IDEA 创建项目。</li>
<li>使用 IDEA 新建一个项目，将 clone 下来的项目中的全部内容（包括隐藏文件夹 <code>.git</code>）复制到新建的项目中（提示同名文件时，替换即可）。</li>
</ul>
<p>为什么这么做？因为 clone 的远程仓库文件中的 .git 文件夹已经绑定了远程仓库，需要新建的项目中也有 .git 文件夹。</p>
<p>IDEA 绑定 Git 后可以在 IDEA 观察到 <strong>文件颜色的变化</strong>：</p>
<ul>
<li><span style="color:Chocolate"><strong>巧克力色</strong> </span>—— 文件尚未添加至暂存区</li>
<li><span style="color:Olive"><strong>橄榄色</strong></span> —— 被忽略而不会被提交的文件</li>
<li><span style="color:Green"><strong>绿色</strong></span> —— 文件已添加至暂存区</li>
<li><strong>黑色</strong> —— 文件已提交至本地库</li>
<li><span style="color:blue"><strong>蓝色</strong></span>  —— 当前文件被修改，但尚未提交至本地库</li>
</ul>
<hr>
<p>2、编写代码，修改文件，使用 IDEA 操作 Git。</p>
<p>可以使用右上角 IDEA 集成的 Git 按钮进行操作，也可以在 IDEA 中的 Terminal 执行 Git 命令完成修改的提交。</p>
<p>在此推荐使用 IDEA 2020.3 及以上的版本，这些版本中的 Git 操作得到了优化。</p>
<blockquote>
<p><span name="ignore">忽略文件创建</span></p>
</blockquote>
<p>不希望将 IDEA 的配置文件（.idea）push 到远程仓库，在 .gitignore 文件中添加 <code>.idea/</code> 即可。如果当前项目中没有 .gitignore 文件，就需要创建 .gitignore 文件。</p>
<p>在 IDEA 中可以右键点击项目，Git — add to .gitignore — 选择 Add to .gitignore 或者 .git/info/exclude。如果选择 Add to .gitignore，后续还需要提交 .gitignore 文件；如果选择 .git/info/exclude，就不用提交 .gitignore 文件，因此推荐使用第二种方式。两种忽略文件的书写方式是一样的。</p>
<blockquote>
<p>IDEA Git 切换版本</p>
</blockquote>
<p><strong>图形化界面操作：</strong></p>
<p>1、右击项目 — Git — Show History（或者直接点击 IDEA 工具栏集成的 Git 操作图标，这个图标像一个钟表）</p>
<p>2、在 IDEA 下方的 Version Control 窗口中选中需要切换的版本，右键点击 — Copy Revision Number （建议将当前版本和想切换的版本的 commit id 都进行复制）</p>
<p>3、右击项目 — Git — Repository — Reset HAND… ，Reset Type 选择 Hard，To commit 粘贴你想切换版本的 commit id，最后点击 Reset 即可。如果从版本 3 切换到版本 1 后，还想回到版本 1，这个时候就只能用命令行的方式了。这也是为什么建议在复制版本号时复制当前和切换的两个版本号。</p>
<p><strong>命令行操作：</strong></p>
<p>1、前两步不变。</p>
<p>2、打开 IDEA 的 Terminal，输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard xxxxxxx #最后的xxx是复制的版本号</span><br></pre></td></tr></table></figure>
<p>3、如果需要把修改 push 到远程仓库，那么可以输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制推送，有风险</span></span><br><span class="line">git push -f -u origin master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>IDEA Git 克隆远程仓库</p>
</blockquote>
<p>1、进入 GitHub 复制项目地址</p>
<p>2、进入 IDEA，菜单栏中点击 VCS — Git — Clone…</p>
<p>3、输入复制的 URL，Directory 必须选择一个空的文件夹，等待 Clone 完成…</p>
<p>4、Clone 完毕后，IDEA 会提示是否创建一个项目，根据需要选择</p>
<p>5、然后 IDEA 又会提示在当前窗口还是新窗口打开，根据需要选择</p>
<p>6、完成后，需要对工程进行设置。菜单栏点击 File — Project Settings，在 Project 中选择 JDK 版本，在 Modules 选择 Clone 的项目。</p>
<p>7、在 Clone 的项目中进行编码，push 到远程仓库时可能需要设置文件忽略。文件忽略方式点击查看：<a href="#ignore">忽略文件创建</a></p>
<p>Clone 远程仓库文件建议使用这种方式：<a href="#binding">项目绑定Git</a></p>
<h1 id="9-Git-分支"><a class="header-anchor" href="#9-Git-分支"></a>9. Git 分支</h1>
<p>切换分支的本质就是移动 HEAD 指针。</p>
<p>为什么要有分支？在 Git 中一定会有一个 master 主分支，也可以创建其他名字的分支。一般将 master 分支作为产品正式上线的分支，除此之外可以创建一个 dev 分支作为开发分支，平时编写的代码都提交到 dev 分支中，等产品上线时合并分支就可以了。如果不使用 dev 分支，平时编写的代码都提交到 master 主分支，万一新编写的代码出现了 BUG，产品又等着上线，那么上线的时间就只能延期了，而且也不方便进行排查修改。</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/Git项目分支.png" alt="Git项目分支" style="zoom:50%;" />
<p>master 主分支应该非常稳定，用来发布新版本，不允许直接在 master 上进行修改。</p>
<p>一个项目通常有多个开发者向一个远程仓库提交代码，为了保证 master  分支的稳定性，一般每人都拉取一个个人分支并分别在自己的个人分支上进行修改，工作完成后，将个人分支合并到 dev 分支上（对应 dev 环境，用于自测），构建代码，进行简单的自测。自测没问题后，将个人分支合并到 master 分支上（对应 test 环境，用于测试），构建代码，交由测试人员进行测试。</p>
<p>当然在实际开发过程中肯定不止这两个分支的，一般还有 test（测试分支）、feature（特性分支）、release（预生产分支）等等。</p>
<p>分支之间的关系类似各个平行宇宙，如果两个平行宇宙互不干扰，那没啥影响，但如果平行宇宙之间相互“入侵”就可能产生一些问题，相当于 Git 中分支的合并。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/%E5%88%86%E6%94%AF%E7%9A%84%E8%BF%90%E7%94%A8.png" alt="分支的运用"></p>
<p>多个分支如果并行存在，相当于同时存在多个版本，不会导致代码冲突。</p>
<p>如果同一个文件中的同一行在不同的分支都进行了修改，在合并分支时就会产生 <strong>冲突</strong>，要想解决冲突，需要手动调整要保留的内容。</p>
<blockquote>
<p>Git 中与分支相关的常用指令</p>
</blockquote>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有本地分支。-a 表示列出所有分支，包括远程分支</span></span><br><span class="line">git branch [-a]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-name]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到某个分支</span></span><br><span class="line">git checkout [branch-name]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并指定分支到当前分支</span></span><br><span class="line">git merge [branch]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除本地分支</span></span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除未合并的本地分支</span></span><br><span class="line">git branch -D [branch-name]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程分支</span></span><br><span class="line">git push origin --delete [branch-name]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程分支（相当于使用一个空分支来覆盖原来的分支）</span></span><br><span class="line">git push origin :branch-name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看本地分支和追踪情况</span></span><br><span class="line">git remote show origin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除对分支的远程跟踪，但这个分支仍然在远程</span></span><br><span class="line">git branch -dr [remote/branch]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新本地 git 分支与远程分支同步（保留本地存在的分支）</span></span><br><span class="line">git remote update origin --prune</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除本地多余分支（即远程已经不存在的分支）</span></span><br><span class="line">git remote prune origin</span><br></pre></td></tr></table></figure>
<blockquote>
<p>IDEA 图形化界面分支操作</p>
</blockquote>
<p><strong>创建分支：</strong></p>
<p>右击项目 — Git — Repository — Branches — New Branch</p>
<p><strong>如何判断当前在哪个分支：</strong></p>
<p>右击项目 — Git — Repository — Branches ，Local Branches 下最上方的就是当前分支。</p>
<p><strong>切换分支：</strong></p>
<p>右击项目 — Git — Repository — Branches ，选中需要切换的分支，单击 Checkout。</p>
<p><strong>合并分支：</strong></p>
<p>右击项目 — Git — Repository — Branches — Merge Changes…</p>
<p><strong>push 到远程仓库：</strong></p>
<p>右击项目 — Git — Repository — push</p>
<blockquote>
<p>IDEA Git 更新本地库</p>
</blockquote>
<p>如果有人在我们 push 代码之前已经将他的代码 push 到远程仓库了，这时再 push 代码到远程仓库时，要保证本地库是最新的。</p>
<p>如何更新本地库？依然可以直接 push 代码到远程仓库，但这时 IDEA 会弹出“Push Rejected”的对话框，点击“Merge”或“Rebase”即可更新本地仓库，<strong>建议选择 Merge。</strong></p>
<p><strong>建议每次提交之前先 pull 拉取最新的代码。</strong></p>
<p>pull 命令行：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36903985/article/details/75529904">Git命令之Pull从库拉取</a></p>
<h1 id="10-团队协作"><a class="header-anchor" href="#10-团队协作"></a>10. 团队协作</h1>
<h2 id="10-1-团队内协作"><a class="header-anchor" href="#10-1-团队内协作"></a>10.1 团队内协作</h2>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/Git%E5%9B%A2%E9%98%9F%E5%86%85%E5%8D%8F%E4%BD%9C.png" alt="Git团队内协作"></p>
<p>假设人员 A 与人员 B 处于同一团队中，如果在同一家公司对同一个项目进行开发的两个人员。</p>
<p>首次由人员 A 初始化仓库，并 push 一系列代码，然后由人员 B clone 项目到本地并开发新的特性，开发完毕后提交 push 到远程仓库，这次人员 A 就可以拉取 pull 远程库的代码看到人员 B 的提交内容。</p>
<h2 id="10-2-跨团队协作"><a class="header-anchor" href="#10-2-跨团队协作"></a>10.2 跨团队协作</h2>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/Git%E8%B7%A8%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C.png" alt="Git跨团队协作"></p>
<p>假设人员 A 与人员 B 处于同一团队中，而人员 C 并不处于这一团队，就像我们首次为开源项目提交代码一样。</p>
<p>从人员 C 的角度出发：对源远程库进行 fork，拉取 fork 的远程库，在本地进行修改后提交到远程库，然后可以发送 pull request，等待审核成功后即可合并到真正的远程库。</p>
<h1 id="11-其他常用命令"><a class="header-anchor" href="#11-其他常用命令"></a>11. 其他常用命令</h1>
<h2 id="11-1-其他常用命令一览"><a class="header-anchor" href="#11-1-其他常用命令一览"></a>11.1 其他常用命令一览</h2>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">git reflog</td>
<td style="text-align:center">查看版本信息</td>
</tr>
<tr>
<td style="text-align:center">git log</td>
<td style="text-align:center">查看版本详细信息</td>
</tr>
<tr>
<td style="text-align:center">git reset --hard 版本号(7 位)</td>
<td style="text-align:center">版本穿梭</td>
</tr>
<tr>
<td style="text-align:center">git reset --hard HEAD~3</td>
<td style="text-align:center">回退到前 3 次提交之前，以此类推，回退到前 n 次提交前</td>
</tr>
<tr>
<td style="text-align:center">git reset --hard HEAD^</td>
<td style="text-align:center">穿梭到上一个版本</td>
</tr>
<tr>
<td style="text-align:center">git add 文件</td>
<td style="text-align:center">将某一文件添加到暂存区</td>
</tr>
<tr>
<td style="text-align:center">git rm --cached 文件</td>
<td style="text-align:center">将某一文件移除暂存区</td>
</tr>
<tr>
<td style="text-align:center">git tag</td>
<td style="text-align:center">列出所有本地标签</td>
</tr>
<tr>
<td style="text-align:center">git tag -l 通配模式文本(*)</td>
<td style="text-align:center">根据符合通配模式文本，列出所有本地标签</td>
</tr>
<tr>
<td style="text-align:center">git tag 标签名</td>
<td style="text-align:center">为最新提交创建轻量标签</td>
</tr>
<tr>
<td style="text-align:center">git tag 标签名 版本号(7位)</td>
<td style="text-align:center">为对应版本号提交创建轻量标签（在后期打标签）</td>
</tr>
<tr>
<td style="text-align:center">git tag -a 标签名 -m 备注文本</td>
<td style="text-align:center">为最新提交创建附注标签</td>
</tr>
<tr>
<td style="text-align:center">git tag -d 标签名</td>
<td style="text-align:center">删除指定标签</td>
</tr>
<tr>
<td style="text-align:center">git remote add 别名 远程仓库地址</td>
<td style="text-align:center">添加远程库</td>
</tr>
<tr>
<td style="text-align:center">git remote -v</td>
<td style="text-align:center">查看添加过的远程库</td>
</tr>
<tr>
<td style="text-align:center">git push 远程库地址或其别名 分支名</td>
<td style="text-align:center">推送到远程库</td>
</tr>
<tr>
<td style="text-align:center">git push 远程库地址或其别名 --tags</td>
<td style="text-align:center">推送所有标签到远程库</td>
</tr>
<tr>
<td style="text-align:center">git fetch</td>
<td style="text-align:center">将远程库的最新内容拉到本地</td>
</tr>
<tr>
<td style="text-align:center">git pull 远程库地址或其别名 分支名</td>
<td style="text-align:center">将远程仓库某一分支最新内容拉取并合并到当前本地分支</td>
</tr>
<tr>
<td style="text-align:center">git help 某一命令或指南</td>
<td style="text-align:center">使用默认浏览器打开某一命令或指南的手册页</td>
</tr>
<tr>
<td style="text-align:center">git show [commit id]</td>
<td style="text-align:center">查看某次 commit 的具体内容</td>
</tr>
</tbody>
</table>
<h2 id="11-2-log-与-reflog-区别"><a class="header-anchor" href="#11-2-log-与-reflog-区别"></a>11.2 log 与 reflog 区别</h2>
<p><code>git log</code> 可以显示所有提交过的版本信息。可以加上参数 <code>--pretty=oneline</code>，只会显示版本号和提交时的备注信息。</p>
<p><code>git reflog </code> 可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）。例如，执行  <code>git reset --hard HEAD~1</code>，退回到上一个版本，用 <code>git log</code> 是看不出来被删除的 commitid，用 <code>git reflog</code> 则可以看到被删除的 commitid。我们就可以买后悔药，恢复到被删除的那个版本。</p>
<p>提交记录过多时，按下 <code>q</code> 可结束浏览。</p>
<blockquote>
<p>log 常见用法</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">git log --oneline</td>
<td style="text-align:center">查看变更列表信息</td>
</tr>
<tr>
<td style="text-align:center">git log -n2 --oneline</td>
<td style="text-align:center">查看最近 2 次变更信息</td>
</tr>
<tr>
<td style="text-align:center">git log</td>
<td style="text-align:center">查看当前分支版本信息</td>
</tr>
<tr>
<td style="text-align:center">git log --all</td>
<td style="text-align:center">查看全部分支变更历史</td>
</tr>
<tr>
<td style="text-align:center">git log --graph</td>
<td style="text-align:center">以图谱的方式显示当前分支版本信息</td>
</tr>
</tbody>
</table>
<h2 id="11-3-git-stash"><a class="header-anchor" href="#11-3-git-stash"></a>11.3 git stash</h2>
<p><code>git stash</code> 也是工作中常用的命令，在此单独列举出来。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>1、假设你现在正在 dev 分支上开发新功能，突然项目出现一个紧急 BUG，需要你立即修复，由于新功能尚未开发完成，你并不想提交它，此时就可以使用 <code>git stash</code> 命令将修改的内容保存至堆栈区。保存完毕后，基于 master 分支新建 hot-fix 分支，对 BUG 进行修改。</p>
<p>2、假设你本应该在 dev 分支上开发新功能，在功能开发完毕时正想提交代码，不料却在 master 分支上进行了开发，为防止切换分支时出现代码冲突，可以使用 <code>git stash</code> 命令将修改内容保存至堆栈区后再切换分支。</p>
<blockquote>
<p>命令解析</p>
</blockquote>
<p>1、<code>git stash</code>：将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录。新增但未提交至暂存区的文件直接执行该命令是不会被保存到堆栈中的。如果想让新增的文件也在执行该命令后保存至堆栈区，需要将该文件交由 Git 管理，即使用 <code>git add 文件</code> 将新增的文件添加至暂存区再执行该命令。</p>
<p>2、<code>git stash save &quot;message&quot;</code>：与 <code>git stash</code> 命令效果一样，只不过可以添加一些备注方便查阅。</p>
<p>3、<code>git stash list</code>：查看当前堆栈区所有内容。</p>
<p>4、<code>git stash pop</code>：将堆栈中第一个 stash 应用到当前工作目录下，并在堆栈中删除对应的 stash（也就是会应用并删除堆栈中最近保存的内容）。如果要应用并删除其他 stash，可以使用 <code>git stash pop stash@&#123;$num&#125;</code>，即 <code>git stash pop stash@&#123;1&#125;</code> 应用并删除第二个 stash。</p>
<p>5、<code>git stash apply</code>：与 <code>git stash pop</code> 命令效果类似，只不过不会删除对应的 stash，进而将同一个 stash 应用到不同的分支上。</p>
<p>6、<code>git stash drop stash@&#123;$num&#125;</code>：删除堆栈上某一个 stash，比如 <code>git stash drop stash@&#123;1&#125;</code> 将会删除堆栈中第二个 satsh。</p>
<p>7、<code>git stash clear</code>：清空堆栈上所有内容。</p>
<p>8、<code>git stash show</code>：查看堆栈中第一个（最新保存的）stash 和当前目录的差异，可以使用 <code>git stash show stash@&#123;$num&#125;</code> 查看指定的 stash 和当前目录差异。还可以添加参数 <code>-p</code> 查看详细的差异，比如 <code>git stash show -p</code> 可以查看堆栈中第一个 stash 和当前目录的详细差异。</p>
<blockquote>
<p>如何只保存部分内容到堆栈</p>
</blockquote>
<p><code>git stash</code> 会将所有未提交的修改（工作区和暂存区）保存至堆栈中，那么如果只保存部分内容呢？</p>
<p>1、将不想存储的文件保存至暂存区，比如 <code>git add a.java, b.java</code>；</p>
<p>2、使用 <code> git stash –keep-index</code> 保存那些未被提交至暂存区的文件到堆栈；</p>
<p>3、使用 <code>git reset</code> 将暂存处的文件移动到工作区。</p>
<h2 id="11-4-cherry-pick"><a class="header-anchor" href="#11-4-cherry-pick"></a>11.4 cherry-pick</h2>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>1、假设本应该在 mofan-master 分支上开发代码并提交，结果在 dev 分支上将代码提交了，此时可以使用 <code>git cherry-pick</code> 将 dev 分支上提交的代码同步到 mofan-master 上，以便自测完成后将 mofan-master 分支合并到 master 分支上。</p>
<p>2、使用 <code>git merge</code> 可以将某一分支的所有变动合并到当前分支上，如果只需要合并部分变动，则可以使用 <code>git cherry-pick</code>。</p>
<blockquote>
<p>命令解析</p>
</blockquote>
<p>1、<code>git cherry-pick 版本号</code>：将指定的提交应用到当前分支，并在当前分支产生一个新的提交（与指定的提交不同的 commitHash）。比如我现在处于 dev 分支上，想将 dev 分支上某次提交应用到 mofan-master 分支上，那么需要先切换至 mofan-master 分支，然后使用 <code>git cherry-pick</code> 并使用那次提交的版本号进行应用。</p>
<p>2、<code>git cherry-pick A版本号 B版本号</code>：将 A 和 B 两次提交应用到当前分支上。</p>
<p>3、<code>git cherry-pick A版本号..B版本号</code>：将 A 到 B 之间的所有提交应用到当前分支上（左开右闭，就是说 A 不会被应用），同时提交 A 必须早于提交 B，否则命令将失败，但不会报错。</p>
<p>4、<code>git cherry-pick A版本号^..B版本号</code>：将 A 到 B 之间的所有提交应用到当前分支上，A 也会被应用。</p>
<blockquote>
<p>常用参数</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-e</td>
<td style="text-align:center">打开外部编辑器，编辑提交信息</td>
</tr>
<tr>
<td style="text-align:center">-n</td>
<td style="text-align:center">只更新工作区和暂存区，不产生新的提交</td>
</tr>
<tr>
<td style="text-align:center">-x</td>
<td style="text-align:center">提交信息后追加 cherry picked from commit …</td>
</tr>
<tr>
<td style="text-align:center">-s</td>
<td style="text-align:center">提交信息后追加操作者签名</td>
</tr>
</tbody>
</table>
<blockquote>
<p>冲突的解决</p>
</blockquote>
<p>在执行该命令时如果产生冲突，cherry pick 会停下来，让用户决定怎么解决冲突。</p>
<p>1、<code>--continue</code>：用户解决冲突并将修改的文件添加至暂存区后，使用 <code>git cherry-pick --continue</code> 命令继续进行 cherry pick。</p>
<p>2、<code>--abort</code>：放弃 cherry pick 并回到操作前的样子。</p>
<p>3、<code>--quit</code>：退出 cherry pick，但不回到操作前的样子（应用了部分提交）。</p>
<blockquote>
<p>缺点</p>
</blockquote>
<p><strong>1、产生冲突。</strong> 假设在 master 分支上在某一文件的某一行新增了内容并进行提交，然后又在 master 分支上对这行内容进行了删除并提交，此时切换为 dev 分支后，先 cherry pick 第二次提交再 cherry pick 第一次提交将会产生冲突，而不是回到最开始未对这行进行修改的样子。</p>
<p><strong>2、诡异的 commit 记录导致上下游分支相同的提交难以追溯。</strong> 假设现在有两个分支分别是 master 和 dev，针对文件 A 进行修改，此刻这两个分支中文件 A 的内容完全相同。先在 dev 分支上对 A 的 <strong>最后一行</strong> 添加内容“abc”，然后把“abc”修改为“abcd”，最后在 <strong>第二行</strong> 新增“123”。接下来切到 master 分支，先 cherry pick 第三次提交，一切顺利，然后在 cherry pick 第二次提交，此时会产生冲突，解决冲突后 cherry pick 第一次提交。最终两个分支的 A 文件内容相同的，但是 commit 记录呢？</p>
<p><strong>dev 分支：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">abcd</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>
<p><strong>master 分支：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abcd</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>真实的 commit 记录应该像 dev 分支的那样，而进行 cherry pick 后的 master 分支的提交记录则大不相同，过程中甚至出现了冲突。（参考链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8e8a023ee8b9">rebase与merge的对比及cherry-pick</a>）</p>
<p><strong>3、无法 cherry pick 到新增的文件。</strong> 同样两个分支，一个文件 A，三个提交。首先在 dev 分支上修改文件 A 并增加文件 B，然后继续修改文件 A 并修改文件 B，最后只修改文件 A。接下来切换到 分支 master，连续三次修改文件 A，并 cherry pick dev 分支上最后一次提交，dev 分支上的变动会出现在 master 上，但新增的文件 B 不会出现。（参考链接：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020158984">git cherry-pick 的一个陷阱！！！</a>）</p>
<p><strong>4、不留下合并记录，导致上下游分支进行一系列开发再次合并时采用错误的版本并且没有冲突提示。</strong> （参考链接：<a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/oldnewthing/20180313-00/?p=98225">Stop cherry-picking, start merging, Part 2: The merge conflict that never happened (but should have)</a>）</p>
<p>基于提交 A 拉取 feature 分支，master 和 feature 分支分别产生 M1 和 F1 提交，这时发现存在重大 BUG 需要临时修复，于是将某一行的配置由 apple 修改为 berry，产生 F2 提交，测试通过后，在 master 分支上 cherry pick F2 提交，这时 master 分支上的 apple 配置也变为 berry。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/%E4%B8%B4%E6%97%B6%E4%BF%AE%E5%A4%8D%E5%B9%B6cherry-pick.png" alt="临时修复并cherry-pick"></p>
<p>然后 master 分支上产生新的提交 M3，这时开发人员找到了 BUG 的源头，原因和 apple 配置无关，因此在 feature 分支上又将 berry 改回 apple，产生 F3 提交。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/%E6%BA%AF%E6%BA%90%E5%B9%B6%E6%94%B9%E5%9B%9E%E5%8E%9F%E9%85%8D%E7%BD%AE.png" alt="溯源并改回原配置"></p>
<p>F3 提交并测试成功后，是时候把修改同步到 master 了，于是将 feature 分支合并到 master 分支上，产生提交 M4。我们的期望是 master 分支上的临时修改能被 feature 分支上的源头修改覆盖，即 master 上的 berry 配置也改回 apple，然后遗憾的是 master 分支上的内容并没有被该改回。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/%E5%90%88%E5%B9%B6%E5%90%8C%E6%97%B6%E5%87%BA%E9%94%99.png" alt="合并同时出错"></p>
<p>这还不是最糟糕的，如果又将 master 分支合并到 feature，这下就完了，配置 berry 也会同步到 feature 上。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/%E5%90%88%E5%B9%B6%E5%88%B0feature%E4%BA%A7%E7%94%9F%E6%9B%B4%E7%B3%9F%E7%B3%95%E7%9A%84%E9%94%99%E8%AF%AF.png" alt="合并到feature产生更糟糕的错误"></p>
<p>产生这样的原因是什么呢？让我们回到第一次合并前：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/%E6%BA%AF%E6%BA%90%E5%B9%B6%E6%94%B9%E5%9B%9E%E5%8E%9F%E9%85%8D%E7%BD%AE.png" alt="溯源并改回原配置"></p>
<p>现在我们进行合并。在合并时，Git 会寻找最近的公共基点，也就是提交 A。然后 Git 以 A 为基数，M3 作为 HEAD，F3 为入站变更进行三向合并。让我们抹除不相干的提交：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/%E6%8A%B9%E9%99%A4%E4%B8%8D%E7%9B%B8%E5%B9%B2%E7%9A%84%E6%8F%90%E4%BA%A4.png" alt="抹除不相干的提交"></p>
<p>对比 master 的基点与头部，会发现由 apple 变为了 berry，但 feature 分支没有任何改变。由于在 feature 上没有任何改变，以为着从 feature 合并到 master 也没有任何改变，也就是 master 上的 berry 不会改变。最终导致在 feature 上是 apple，而在 master 上是 berry。</p>
<h2 id="11-5-git-diff"><a class="header-anchor" href="#11-5-git-diff"></a>11.5 git diff</h2>
<p>使用这个命令可以比较文件或分支之间的不同。</p>
<p>显示暂存区和工作区的差异：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff [file]</span><br></pre></td></tr></table></figure>
<p>显示暂存区和上一次 commit 的差异：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached [file] </span><br><span class="line">git diff --staged [file] # 显示摘要而非差异的详细信息</span><br></pre></td></tr></table></figure>
<p>显示两个分支至之间的差异：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git diff branch1 branch2 --stat # 显示出 branch1 和 branch2 中差异的部分</span><br><span class="line">git diff branch1 branch2 [file] # 显示指定文件的差异</span><br><span class="line">git diff branch1 branch2 # 显示出所有详细差异</span><br><span class="line">git log branch1 ^branch2 # 查看 branch1 有，branch2 没有的 log</span><br><span class="line">git log branch1..branch2 # 查看 branch2 有，branch1 没有的 log</span><br><span class="line">git log branch1...branch2 # 列出两者之间的 log 差异</span><br><span class="line">git log -lefg-right branch1...branch2 # 列出两者之间的 log 差异，并显示属于哪个分支</span><br><span class="line">git log origin/branch1..branch1 # 查看本地分支与远程分支的 log 差异</span><br></pre></td></tr></table></figure>
<p>查找当前项目中的冲突文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --check</span><br></pre></td></tr></table></figure>
<h2 id="11-6-重写历史"><a class="header-anchor" href="#11-6-重写历史"></a>11.6 重写历史</h2>
<p><mark>不建议在多人协作时去修改已经 push 到远程仓库的提交！</mark></p>
<p>有时可能需要修改 <strong>（还未推送到远程仓库的）</strong> 刚提交的提交信息或者刚提交的实际提交内容，此时可以使用 <code>git commit --amend</code> 命令，使用这个命令可以在不增加提交次数的情况下，将新修改的代码追加到最后一次提交中。</p>
<p>PS：amend，读音：<code>[əˈmend]</code>，意为修正、修订。</p>
<p><strong>细节：</strong></p>
<ul>
<li>如果当前无已暂存的修改，执行命令后，不改变最后一次提交的内容，可以修改最后一次提交的信息；</li>
<li>如果当前已存在暂存的修改，执行命令后，将暂存的修改追加到最后一次提交的内容中，当然也可以修改最后一次提交的信息。</li>
</ul>
<blockquote>
<p>修改最后一次 <strong>未推送到远程仓库的</strong> 提交信息</p>
</blockquote>
<p><strong>如果仅仅只想要修改提交信息，需要保证不存在已经暂存的修改。</strong></p>
<p>执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<p>该命令会将最后一次的提交信息载入到编辑器中进行修改， 当保存并关闭编辑器后，编辑器会将更新后的提交信息写入新提交中， <strong>成为新的最后一次提交。</strong></p>
<blockquote>
<p>修改最后一次 <strong>未推送到远程仓库的</strong> 提交内容与提交信息</p>
</blockquote>
<p>如果想要修改最后一次提交的实际内容，首先修改文件并 <strong>暂存（执行 <code>git add</code>）</strong> 它们，然后执行 <code>git commit --amend</code> 命令将新的提交替换掉旧有的最后一次提交，当然，在此也可以修改提交信息。</p>
<p>如果确定在修改提交内容后会修改提交信息，可以直接执行以下命令，而不用再在编辑器中修改提交信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend -m &quot;新的提交信息&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>修改最后一次 <strong>未推送到远程仓库的</strong> 提交内容，而不修改提交信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --no-edit</span><br></pre></td></tr></table></figure>
<p><code>--no-edit</code> 表示无需修改提交信息的关键选项。</p>
<blockquote>
<p>试图修改已经推送到远程仓库的提交</p>
</blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/choumin/article/details/102700360">git commit --amend可能带来的合并冲突</a></p>
<p>由于 <code>git commit --amend</code> 命令会替换最后一次提交，因此当最后一次提交已经推送到远程仓库了，就不要使用这个命令。</p>
<p>如果硬使用这个命令，由于原最后一次的提交被替换了，此时本地与远程的版本不一致，再次推送执行 <code>git push</code> 时将会失败，并提示拉取远端最新代码，而在按照提示拉取最新代码后，大概率又会产生冲突。</p>
<p>当然这可以使用 <code>git push -f</code> 或 <code>git push --force-with-lease</code> 命令 <strong>强制推送</strong> 到远程仓库来解决，但这仍可能存在问题：假设我新增提交 C1，并已经推送到远程仓库，其他同事将远程仓库的 C1 和他本地的 C2 进行合并形成 C3。接下来我执行 <code>git commit --amend</code> 命令修改上次的提交内容并强制推送到远程仓库形成 C4，如果此时那位同事再次合并我最新的提交，那么他又大概率会遇到冲突，因为 C1 和 C4 两次提交之间存在差异。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/%E6%89%A7%E8%A1%8C--amend%E8%AE%A9%E4%BB%96%E4%BA%BA%E9%81%87%E5%88%B0%E5%86%B2%E7%AA%81.png" alt="执行git commit --amend让他人遇到冲突"></p>
<p><strong><code>git commit --amend</code> 的最佳适用场景：</strong></p>
<ul>
<li>修改尚未推送到远程仓库的提交；</li>
<li>在非多人协作或自己的特性分支上修改最后一次提交，此时进行强制推送不会有影响。</li>
</ul>
<blockquote>
<p>其他相关参数</p>
</blockquote>
<p><code>--reset-author</code>：加载提交用户的信息。重新加载新配置的本地用户信息，并更新在追加的提交中。</p>
<p><code>--author=</code>：修改 <code>author</code> 和 <code>email</code> 信息，如：<code>git commit --amend --author='xxx &lt;xxx@xxx.xxx&gt;'</code>。</p>
<h2 id="11-7-回滚与撤销"><a class="header-anchor" href="#11-7-回滚与撤销"></a>11.7 回滚与撤销</h2>
<p>假设现在有两个文件，分别是 test1.txt 和 test2.txt。</p>
<p>test1.txt 的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br></pre></td></tr></table></figure>
<p>test2.txt 的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">000</span><br><span class="line">999</span><br><span class="line">888</span><br></pre></td></tr></table></figure>
<p>此时 A 用户修改了 test1.txt 文件，将 333 改成了 444，test1.txt 变成了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">111</span><br><span class="line">222</span><br><span class="line">444</span><br></pre></td></tr></table></figure>
<p>然后 B 用户修改了 test2.txt 文件，将 888 改成了 777，并新增了 666，test.txt 变成了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000</span><br><span class="line">999</span><br><span class="line">777</span><br><span class="line">666</span><br></pre></td></tr></table></figure>
<p>这时环境出问题了，是用户 A 将 333 修改为 444 导致的，这是需要撤销或回滚代码，那究竟是撤销还是回滚呢？</p>
<blockquote>
<p>回滚</p>
</blockquote>
<p>用户 A 首先执行 <code>git reflog</code> 指令查看将 333 修改为 444 的那次提交的 <strong>前一次提交</strong> 的 commit id：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1a832b5 (HEAD -&gt; master, xxx/master) HEAD@&#123;0&#125;: commit: 333 -&gt; 444</span><br><span class="line">35122a7 HEAD@&#123;1&#125;: commit: 文件初始化</span><br></pre></td></tr></table></figure>
<p>前一次提交的 commit id 为 <code>35122a7</code>，使用此 commit id 执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 35122a7</span><br></pre></td></tr></table></figure>
<p>然后 <strong>强制推送</strong> 到远程分支上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure>
<p>这时去查看远程仓库和本地代码，会发现代码已经回到了将 333 修改为 444 之前的那次提交，除此之外，<strong>B 用户的修改也不见了。</strong></p>
<p>这样的操作存在一个问题，虽然服务器上的代码被还原了，但在实际开发中，往往会有很多人对一个项目进行提交，他们本地的版本依旧是比服务器的版本要高的，如果别人再提交代码，刚刚进行的回退操作又会被覆盖，上面的操作就白操作了。</p>
<p>当然也可以让别人把他们的本地分支删掉，然后从服务器上重新拉取分支，但这可能吗？</p>
<blockquote>
<p>撤销</p>
</blockquote>
<p>因此可以使用撤销，还是需要 A 用户执行 <code>git reflog</code> 指令查看提交记录， <strong>只不过这次需要找将 333 修改为 444 的那次提交的 commit id，</strong> 从前面我们知道，这次提交的 commit id 为 <code>1a832b5</code>，因此它执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert -n 1a832b5</span><br></pre></td></tr></table></figure>
<p>执行这个命令后，Git 的命令行界面会出现 <code> (master|REVERTING)</code> 的字样，并且这个命令表示撤销了指定 commit id 的提交，但是保留了那之后的提交，因此还需要推送那之后的提交（也就是说会产生一次新的提交），执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;撤销 333 -&gt; 444&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>此时 test1.txt 文件的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br></pre></td></tr></table></figure>
<p>test2.txt 文件的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000</span><br><span class="line">999</span><br><span class="line">777</span><br><span class="line">666</span><br></pre></td></tr></table></figure>
<p>很好，撤销了错误的提交，并且还保留的之后的提交。</p>
<blockquote>
<p>撤销 撤销</p>
</blockquote>
<p>撤销完成后，用户 B 又对 test2.txt 进行了修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">000</span><br><span class="line">999</span><br><span class="line">777</span><br><span class="line">555</span><br><span class="line">444</span><br></pre></td></tr></table></figure>
<p>然后 A 用户心想，我那次提交确实有问题，应该将 333 改成 456，那应该怎么回到 444 的版本上将 444 改成 456 呢？</p>
<p>使用 <code>git reflog</code> 查看那次撤销操作的 commit id：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">19d641d (HEAD -&gt; master, xxx/master) HEAD@&#123;0&#125;: pull: Fast-forward</span><br><span class="line">b69ab99 HEAD@&#123;1&#125;: commit: 撤销 333 -&gt; 444</span><br><span class="line">081f410 HEAD@&#123;2&#125;: pull: Fast-forward</span><br><span class="line">35122a7 HEAD@&#123;3&#125;: reset: moving to 35122a7</span><br><span class="line">1a832b5 HEAD@&#123;4&#125;: commit: 333 -&gt; 444</span><br><span class="line">35122a7 HEAD@&#123;5&#125;: commit: 文件初始化</span><br></pre></td></tr></table></figure>
<p>得知那次撤销操作的 commit id 为 <code>b69ab99</code>，那么使用这个 commit id 撤销撤销操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull # 先同步代码</span><br><span class="line">git revert -n b69ab99</span><br><span class="line">git commit -m &quot;撤销 撤销 333 -&gt; 444&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>现在 test1.txt 的文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">111</span><br><span class="line">222</span><br><span class="line">444</span><br></pre></td></tr></table></figure>
<p>test2.txt 的文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">000</span><br><span class="line">999</span><br><span class="line">777</span><br><span class="line">555</span><br><span class="line">444</span><br></pre></td></tr></table></figure>
<p>很棒，符合预期，接下来用户 A 把 444 修改为 456 再提交就行了。</p>
<p><strong>简单总结下：</strong></p>
<p>1、<code>reset</code> 是版本回滚，回滚到某次提交时，那之后的提交都将消失；</p>
<p>2、<code>revert</code> 是撤销，撤销某次提交后，那之后的提交将存储到暂存区，可提交至本地库并推送到远程库产生新的提交。</p>
<h2 id="11-8-其他后悔药"><a class="header-anchor" href="#11-8-其他后悔药"></a>11.8 其他后悔药</h2>
<p>在【11.6 重写历史】中介绍了如何修改提交信息，在【11.7 回滚与撤销】中介绍了怎么回滚或撤销远程库的代码，那怎么撤销在工作区的修改、怎么撤销在暂存区的修改、怎么撤销在本地仓库的修改呢？</p>
<blockquote>
<p>撤销工作区的修改（未使用 <code>git add</code>）</p>
</blockquote>
<p>放弃 <strong>某个</strong> 文件的修改：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filepathname</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如：git checkout -- test.txt</span></span><br></pre></td></tr></table></figure>
<p>放弃 <strong>所有</strong> 文件的修改（两种方式，任选一）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout . # 放弃所有文件的修改</span><br><span class="line">git restore . # 放弃所有文件的修改</span><br></pre></td></tr></table></figure>
<p>使用上述三个命令可以放弃对某个或所有文件的修改，执行命令后，文件回到未被修改前的样子。</p>
<p><mark>谨慎使用，避免白忙活。</mark></p>
<blockquote>
<p>撤销暂存区的修改（已使用了 <code>git add</code>）</p>
</blockquote>
<p>将 <strong>某个</strong> 文件从暂存区移到工作区：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD filepathname</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如：git reset HEAD test.txt</span></span><br></pre></td></tr></table></figure>
<p>将 <strong>所有</strong> 文件从暂存区移到工作区（两种方式，任选一）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD . # 将所有文件从暂存区移到工作区</span><br><span class="line">git  reset  # 将所有文件从暂存区移到工作区</span><br></pre></td></tr></table></figure>
<p>使用上述命令只是将某个或多个文件从暂存区移到工作区，如果需要放弃对文件的修改，还需要执行【撤销工作区的修改】中的命令。</p>
<blockquote>
<p>撤销本地库的修改（已使用了 <code>git commit</code>）</p>
</blockquote>
<p>1、撤销（回滚）某次提交（不保留代码修改）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^ # 回退到上一次提交状态</span><br><span class="line">git reset --hard [commit id] # 回退到某次提交状态 </span><br></pre></td></tr></table></figure>
<p>使用这两个命令不会保留代码的修改，但并不是说就没法再复原了，使用 <code>git reflog</code> 找到那次提交的 commit id，然后再使用第二个命令就能复原。</p>
<p>2、将 commit 和 add 的代码都拉回到工作区（两种方式，任选一）（保留代码的修改）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --mixed HEAD^</span><br><span class="line">git reset HEAD^</span><br></pre></td></tr></table></figure>
<p>3、将 commit 的代码拉回暂存区，已 add 的代码不拉回到工作区（保留代码的修改）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure>
<p>4、撤销暂存区、本地库的修改，使其返回到远程库最新的版本（不保留代码的修改）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all # 从远端获取最新到本地</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">撤销所有修改</span></span><br><span class="line">git reset --hard origin/master # git reset --hard origin/远程分支名</span><br></pre></td></tr></table></figure>
<p><mark>谨慎使用，避免白忙活。</mark></p>
<blockquote>
<p>将某一文件还原至某次提交时，并且不产生新的提交日志</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [commit id] -- filepathname</span><br></pre></td></tr></table></figure>
<p><code>--</code> 作为分隔符，防止 commit id 恰好与 filepathname 一样。</p>
<h2 id="11-9-abort-终止"><a class="header-anchor" href="#11-9-abort-终止"></a>11.9 abort 终止</h2>
<p>当我们使用 merge 或者 cherry-pick 时可能会出现冲突，而在解决冲突时发现冲突太多，想要取消本次 merge 或者 cherry-pick，并还原到 merge 或 cherry-pick 之前所有未提交的更改。那么可以使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort # Git 版本 &gt;= 1.7.4</span><br><span class="line">git reset --merge # Git 版本 &gt;= 1.6.1</span><br></pre></td></tr></table></figure>
<p><mark>注意：</mark> 在 merge 或 cherry-pick 之前要保证没有未提交的文件，如果有未提交的文件，需要使用 commit 进行提交或者使用 stash 进行暂存，否则在某些情况下无法重现这些修改。</p>
<p>上述这两个命令并不是同一事物的新旧语法，使用 <code>git help merge</code> 命令打开手册页并查看 <code>--abort</code> 选项的信息：</p>
<pre>
<em>git merge --abort</em> is equivalent to <em>git reset --merge</em> when <code>MERGE_HEAD</code> is present unless <code>MERGE_AUTOSTASH</code> is also present in which case <em>git merge --abort</em> applies the stash entry to the worktree whereas <em>git reset --merge</em> will save the stashed changes in the stash list.
</pre>
<p>简单来说就是当存在 <code>MERGE_HEAD</code>、并且不存在 <code>MERGE_AUTOSTASH</code> 时，两个命令是相等的。</p>
<p>同样，可以使用 <code>git help reset</code> 命令打开手册页查看 <code>--merge</code> 选项的信息：</p>
<pre>
Resets the index and updates the files in the working tree that are different between <code>&lt;commit&gt;</code> and <code>HEAD</code>, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added). If a file that is different between <code>&lt;commit&gt;</code> and the index has unstaged changes, reset is aborted.
In other words, <code>--merge</code> does something like a <code>git read-tree -u -m &lt;commit&gt;</code>, but carries forward unmerged index entries.
</pre>
<h2 id="11-10-合并-commit"><a class="header-anchor" href="#11-10-合并-commit"></a>11.10 合并 commit</h2>
<blockquote>
<p>合并连续的提交</p>
</blockquote>
<p>假设使用 <code> git log -n4 --oneline</code> 命令后显示的最新 4 条变更信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5d85417 (HEAD -&gt; master) 444</span><br><span class="line">66f9447 333</span><br><span class="line">e462eaf 222</span><br><span class="line">bee7b81 111</span><br></pre></td></tr></table></figure>
<p>此时需要合并最新 3 次提交，即：<code>e462eaf</code> 到 <code>5d85417</code>。以下命令二选一：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3</span><br><span class="line">git rebase -i bee7b81</span><br></pre></td></tr></table></figure>
<p>其中 <code>bee7b81</code> 是 <strong>最近最早无需</strong> 合并的 commit id。执行命令后，进入 Git 默认编辑器，并显示以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick e462eaf 222</span><br><span class="line">pick 66f9447 333</span><br><span class="line">pick 5d85417 444</span><br></pre></td></tr></table></figure>
<p>对上述信息修改为以下内容，然后保存并退出（按 <code>i</code> 进入编辑模式，按 <code>esc</code> 退出编辑模式，按 <code>:wq</code> 对内容进行保存并退出）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick e462eaf 222</span><br><span class="line">s 66f9447 333</span><br><span class="line">s 5d85417 444</span><br></pre></td></tr></table></figure>
<p>这表示将下面的两次提交合并到最上面的提交。退出后又会进入 commit message 修改页面，在这个页面可以使用 <code>#</code> 注释以前的 commit message，也可以添加合并后的 commit message，同样修改完保存并退出。</p>
<p>如果看到 <code>Successfully rebased and updated </code> 的字样就表示合并成功。</p>
<p>再使用 <code>git log -n4 --oneline</code> 查看最新 4 条变更信息，其中最近的两次变更信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">58b2471 (HEAD -&gt; master) 合并 222 - 444</span><br><span class="line">bee7b81 111</span><br></pre></td></tr></table></figure>
<p>可以看到原先 <code>e462eaf</code> 到 <code>5d85417</code> 的提交信息已经不存在，取而代之的是 <code>58b2471</code> 新的 commit id。</p>
<blockquote>
<p>合并过程中的冲突解决</p>
</blockquote>
<p>如果合并过程中出现了冲突，需要 <strong>先解决冲突</strong>，然后再依次执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>
<p>如果想直接放弃合并，可以执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure>
<blockquote>
<p>推送到远程</p>
</blockquote>
<p>要将合并后的 commit 推送到远程，需要使用 <code>-f</code> 选项，即：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure>
<p>如果在自己的分支上开发，不会覆盖他人的提交记录；但如果是在主分支上使用 <code>-f</code>，请谨慎，这有可能会覆盖他人的代码。</p>
<blockquote>
<p>rebase 提供的对提交修改的参数</p>
</blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/small_white_123/article/details/121563248">git rebase的两种用法(最全)</a></p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">缩写</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pick</td>
<td style="text-align:center">p</td>
<td style="text-align:center">保留该 commit</td>
</tr>
<tr>
<td style="text-align:center">reword</td>
<td style="text-align:center">r</td>
<td style="text-align:center">保留该 commit，可以修改该 commit 的注释</td>
</tr>
<tr>
<td style="text-align:center">edit</td>
<td style="text-align:center">e</td>
<td style="text-align:center">保留该 commit，并停下来修改该提交（可以修改提交内容）</td>
</tr>
<tr>
<td style="text-align:center">squash</td>
<td style="text-align:center">s</td>
<td style="text-align:center">将该 commit 合并到前一个 commit</td>
</tr>
<tr>
<td style="text-align:center">fixup</td>
<td style="text-align:center">f</td>
<td style="text-align:center">将该 commit 合并到前一个 commit，但不要保留该提交的注释信息</td>
</tr>
<tr>
<td style="text-align:center">exec</td>
<td style="text-align:center">x</td>
<td style="text-align:center">执行 shell 命令</td>
</tr>
<tr>
<td style="text-align:center">drop</td>
<td style="text-align:center">d</td>
<td style="text-align:center">丢弃该 commit</td>
</tr>
</tbody>
</table>
<p>执行 <code>rebase</code> 命令后会改变原 commit id，一旦对历史提交进行修改，从指定的提交开始往后的所有 commit id 都会发生改变，这在多人协同的场景下是毁灭性的。</p>
<p>假设某分支上有 100 个提交信息，使用 <code>rebase</code> 改了第 50 个提交，那从第 50 到 第 100 之间的所有 commit id 都会发生改变。如果又有其他分支合并到当前分支，将产生 51 个冲突，解决完冲突之后，一共产生 51 * 2 个相同的提交记录。</p>
<p>因此建议：</p>
<ul>
<li>在多人协作下不使用 <code>rebase</code>；</li>
<li>可以对尚未推送至远端的提交或有且仅有自己开发的工程下使用 <code>rebase</code>。</li>
</ul>
<h2 id="11-11-指定当前工作分支与远程分支的链接关系"><a class="header-anchor" href="#11-11-指定当前工作分支与远程分支的链接关系"></a>11.11 指定当前工作分支与远程分支的链接关系</h2>
<p>如果没有指定当前工作目录工作分支跟远程的仓库、分支之间的链接关系，将无法直接使用 <code>git pull</code> 或 <code>git push</code> 命令来拉取或推送，而是需要：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取代码</span></span><br><span class="line">git pull 远程仓库地址别名 远程仓库分支 # 比如：git pull origin master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送代码</span></span><br><span class="line">git push 远程仓库地址别名 远程仓库分支 # 比如：git push origin master</span><br></pre></td></tr></table></figure>
<p>以拉取为例，当没有指定链接关系时将会出现以下提示信息：</p>
<pre>
There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details.
	git pull &lt;remote&gt; &lt;branch&gt;
If you wish to set tracking information for this branch you can do so with:
	git branch --set-upstream-to=origin/&lt;branch&gt; master
</pre>
<p>根据提示信息可知，假设想要指定本地 master 分支对应远程仓库的 master 分支，可以使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=远程仓库地址别名/远程仓库分支 本地分支</span><br></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/master master</span><br></pre></td></tr></table></figure>
<p>链接成功后就可以愉快地直接使用 <code>git pull</code> 和 <code>git push</code> 了。</p>
<h2 id="11-12-更安全的强制推送"><a class="header-anchor" href="#11-12-更安全的强制推送"></a>11.12 更安全的强制推送</h2>
<p>使用 <code>git push -f</code> 进行强制推送时，如果他人在当前分支推送了新的提交，那么这一命令将会“删除”他的提交。就算在推送前同步了远程仓库也是不安全的，从同步完成到真正强制推送成功之间仍存在时间差，在这个时间差之间可能又会产生新的提交。</p>
<p>为避免“删除”在这个时间差之间产生的新的提交，可以使用命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force-with-lease</span><br></pre></td></tr></table></figure>
<p>如果在这个时间差之间远程仓库增加了新的提交，使用上述命令后，推送会被拒绝，此时可以使用 <code>git fetch</code> 获取远程仓库后再合并远程仓库，最后使用上述命令进行强制推送。</p>
<p><mark>注意：</mark> <code>--force-with-lease</code> 并未解决强制推送“删除”他人代码的问题，它解决的是当本地仓库不够新时的强制推送覆盖远程仓库的问题，因此当执行了 <code>git fetch</code> 获取远程仓库且尚未同步远程仓库时仍执意使用此命令进行强制推送，远程仓库仍会被覆盖。</p>
<h1 id="12-其他操作流程"><a class="header-anchor" href="#12-其他操作流程"></a>12. 其他操作流程</h1>
<h2 id="12-1-推送到远程仓库"><a class="header-anchor" href="#12-1-推送到远程仓库"></a>12.1 推送到远程仓库</h2>
<p>有时我们需要将本地未被 Git 管理的代码交由 Git 管理并推送到远程仓库，但在进行这个流程时出现了以下错误导致无法推送到远程仓库：</p>
<pre>
Updates were rejected because the remote contains work that you do
</pre>
<p>这是因为我们在新建本地库后，本地库与远程仓库的内容不一致导致的。</p>
<p>先看下错误的操作流程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加所有文件到本地暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交到本地仓库</span></span><br><span class="line">git commit -m &quot;commit info&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关联远程仓库并取别名</span></span><br><span class="line">git remote add origin 远程仓库地址 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送到远程仓库</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>正确的操作流程需要在推送到远程仓库前同步远程仓库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加所有文件到本地暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交到本地仓库</span></span><br><span class="line">git commit -m &quot;commit info&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关联远程仓库并取别名</span></span><br><span class="line">git remote add origin 远程仓库地址</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步远程仓库（与远程仓库的某个分支进行同步）</span></span><br><span class="line">git pull origin master --allow-unrelated-histories</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送到远程仓库（推送到远程仓库的某个分支，下次推送时可直接使用 git push）</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<h2 id="12-2-拉取远程分支到本地"><a class="header-anchor" href="#12-2-拉取远程分支到本地"></a>12.2 拉取远程分支到本地</h2>
<blockquote>
<p>本地无相关仓库代码，直接拉取即可</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b 远程分支名 仓库地址</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本地已有相关仓库代码</p>
</blockquote>
<p>假设需要拉取的远程分支名为 <code>dev</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看远程分支信息</span></span><br><span class="line">git branch -r</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建本地分支并切换到创建的分支上</span></span><br><span class="line">git checkout -b mydev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">远程分支关联本地分支</span></span><br><span class="line">git branch --set-upstream-to origin/dev mydev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取远程分支（直接使用 git pull 也行）</span></span><br><span class="line">git pull origin dev</span><br></pre></td></tr></table></figure>
<p>由于本地分支名称与关联的远程分支名称不一样（所以创建的本地分支名称最好与需要关联的远程分支名称相同），因此在 <code>push</code> 时得这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin HEAD:dev</span><br></pre></td></tr></table></figure>
<p>除此之外，第二三步创建本地分支并切换到创建的分支上，然后使创建的分支关联远程分支可以合为一步，即：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b mydev origin/dev</span><br></pre></td></tr></table></figure>
<p>也就是说如果我们 <strong>在创建本地分支时忘记关联远程分支</strong>，就可以使用第三部的方式进行关联。</p>
<blockquote>
<p>克隆指定分支的最近一次 commit</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b 分支名 --depth 1 远程仓库地址</span><br></pre></td></tr></table></figure>
<p>使用此命令可以限制克隆的深度，不会下载 Git 历史协作记录，以大大加快克隆的速度。</p>
<p>在执行上述命令后想要把其他远程分支的最近一次 commit 也克隆到本地，那么可以：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote set-branches origin &#x27;目标分支名&#x27;</span><br><span class="line">git fetch --depth 1 origin 目标分支名</span><br><span class="line">git checkout 目标分支名</span><br></pre></td></tr></table></figure>
<h2 id="12-3-GitHub-的默认分支"><a class="header-anchor" href="#12-3-GitHub-的默认分支"></a>12.3 GitHub 的默认分支</h2>
<p>虽然很久前就注册了 GitHub，但由于其访问速度不佳，一直使用的是国内的 Gitee 作为代码托管平台，但从去年开始，Gitee 变得越来越难用，先是部署 Pages 服务时时常出现内容违规的提示导致部署失败，后续又开展实名认证和仓库审核，未进行实名认证的账号无法使用 Pages 服务，仓库未经过审核不能设置为公开，只能是私有。不仅如此，其实名方式也异常严格，一般的实名只需要提交身份证正反面照片即可，而它还需要提供身份证持有人将身份证举至胸前的照片，我实在无法忍受它的一系列操作，只能放弃对它的使用，并计划将后续的代码托管都转移到 GitHub 平台上。</p>
<p>上周在 GitHub 创建仓库时发现仓库的默认分支竟然不是 master 了，而是变成了 main，好在 GitHub 还是挺人性化的，能够在创建仓库时修改默认分支名，一时间也没多想，于是我又将其默认分支修改回 master。</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/GitHub%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93%E6%97%B6%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E5%88%86%E6%94%AF%E5%90%8D.png" alt="GitHub创建仓库时修改默认分支名"></p>
<p>事后稍加思索，愈发疑惑：为什么好端端的要把默认分支名改为 main 呢？Git 的默认分支就是 master，你 GitHub 的默认分支改成了 main，这不是给用户造成了不便？</p>
<p>在好奇心的驱使下，对这个问题进行了简单的搜索。</p>
<p>这是不查不知道，原来在 20 年的 10 月 1 日就实行了，看样子是我“火星”了。那具体原因是什么呢？</p>
<p>回想 20 年除了疫情外还有什么呢？当年 5 月 25 日，美国街头发生一起警察暴力执法事件，致使一黑人男性乔治·弗洛伊德死亡，之后又相继爆发 BLM（Black Lives Matter）运动，简称“黑命贵”。</p>
<p>为了安抚愈演愈烈的民众情绪，同年 6 月，GitHub 宣布替换掉 master 等术语，避免以此联想到奴隶制。后续 MySQL 也宣布将 master、slave、blacklist（黑名单）和 whitelist（白名单）等术语分别替换为 source、replica、blocklist 和 allowlist。</p>
<p>对于这件事我不做评价，只不过习惯性的 <code>git checkout master</code>，在后续要变成 <code>git checkout main</code> 了。</p>
<p>在使用 GitHub 时，除了可以将 GitHub 默认分支又改回 master 外，也可以继续使用 main 作为默认分支。针对已经存在的仓库，如何将其主分支名修改为 main 呢？</p>
<blockquote>
<p>修改主分支名为 main</p>
</blockquote>
<p>首先修改本地仓库主分支名为 main：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m master main</span><br></pre></td></tr></table></figure>
<p>同步至远端（会在远端自动创建 main 分支）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<p>修改 GitHub 仓库默认分支：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/%E5%88%87%E6%8D%A2GitHub%E6%9F%90%E4%B8%80%E4%BB%93%E5%BA%93%E7%9A%84%E9%BB%98%E8%AE%A4%E5%88%86%E6%94%AF%E4%B8%BAmain.png" alt="切换GitHub某一仓库的默认分支为main"></p>
<p>删除远端的 master 分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --delete origin master</span><br></pre></td></tr></table></figure>
<p>修改 Git 本地配置，致使后续创建的仓库的默认主分支名为 main：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">旧版本可能不支持，推荐升级至最新版 Git 后使用</span></span><br><span class="line">git config --global init.defaultBranch main</span><br></pre></td></tr></table></figure>
<h2 id="12-4-修改远程仓库地址"><a class="header-anchor" href="#12-4-修改远程仓库地址"></a>12.4 修改远程仓库地址</h2>
<p>书接上文，决定将 Gitee 上的代码转移到 GitHub 上，后续不再使用 Gitee。那要怎么做呢？</p>
<p>方式很简单，先在 GitHub 上创建一个仓库，然后将本地远程仓库地址修改成 GitHub 上远程仓库的地址后再 <code>push</code> 就行了。修改远程仓库地址主要涉及到以下几个命令：</p>
<p>1、查看本地远程仓库地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>2、删除本地远程仓库地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm 远程仓库地址别名</span><br></pre></td></tr></table></figure>
<p>3、添加远程仓库地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add 远程仓库地址别名  远程仓库地址</span><br></pre></td></tr></table></figure>
<p>4、修改远程仓库地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url 远程仓库地址别名 远程仓库地址</span><br></pre></td></tr></table></figure>
<blockquote>
<p>修改本地远程仓库地址</p>
</blockquote>
<p>先查看本地远程仓库地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>假设出现以下信息：</p>
<pre>
$ git remote -v
origin  git@gitee.com:xxx/xxx.git (fetch)
origin  git@gitee.com:xxx/xxx.git (push)
</pre>
<p>这里的 <code>origin</code> 就是 <strong>远程仓库地址别名</strong>，那么现在有两种做法：</p>
<p>1、删除现有地址，然后新增一个；</p>
<p>2、修改现有地址。</p>
<p>两种都行，为了简单，选用第二种方式，假设把远程仓库地址修改为 <code>git@github.com:xxx/xxxx.git</code>，那么有：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:xxx/xxxx.git</span><br></pre></td></tr></table></figure>
<p>修改完成执行 <code>git push</code> 就可以把本地的代码推送到指定的远程仓库中了。</p>
<blockquote>
<p>新增远程仓库地址</p>
</blockquote>
<p>同样先查看本地远程仓库地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>假设出现以下信息：</p>
<pre>
$ git remote -v
origin  git@gitee.com:xxx/xxx.git (fetch)
origin  git@gitee.com:xxx/xxx.git (push)
</pre>
<p>现在新增一个 GitHub 的远程仓库地址，在 push 时指定推送的目标远程仓库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add github git@github.com:xxx/xxxx.git</span><br></pre></td></tr></table></figure>
<p>再次查看本地远程仓库地址信息：</p>
<pre>
$ git remote -v
github  git@github.com:xxx/xxx.git (fetch)
github  git@github.com:xxx/xxx.git (push)
origin  git@gitee.com:xxx/xxx.git (fetch)
origin  git@gitee.com:xxx/xxx.git (push)
</pre>
<p>如果想向 GitHub 的远程仓库进行推送，那么有：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push github master</span><br></pre></td></tr></table></figure>
<p>这表示将变更信息推送到 <code>github</code> 这个远程仓库地址别名对应的远程仓库的 master 分支上。</p>
<p>如果打算以后都往这个远程仓库进行推送，可以添加 <code>-u</code> 选项，表示后续默认向此远程仓库推送：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u github master</span><br></pre></td></tr></table></figure>
<p>下次只需使用 <code>git push</code> 就会默认往 GitHub 的远程仓库推送了。</p>
<h2 id="12-5-修改历史-commit-用户名和邮箱"><a class="header-anchor" href="#12-5-修改历史-commit-用户名和邮箱"></a>12.5 修改历史 commit 用户名和邮箱</h2>
<p>首先执行 <code>git log</code> 命令查看历史提交信息，假设有一条提交信息如下：</p>
<pre>
commit 2a51550ea114ac4b09203450c1934be22d2fa32b
Author: aaa &lt;bbb@ccc.com&gt;
Date:   xxxx
</pre>
<p>现需要把 Author 中的 <code>aaa</code> 修改为 <code>xxx</code>，邮箱信息 <code>bbb@ccc.com</code> 修改为 <code>yyy@zzz.com</code>，并将修改后的信息推送到远程仓库。那么可以执行以下命令（也可以编写包含以下内容的 Shell 脚本再执行）进行批量修改：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">git filter-branch -f --env-filter &#x27;</span><br><span class="line">OLD_NAME=&quot;aaa&quot;</span><br><span class="line">OLD_EMAIL=&quot;bbb@ccc.com&quot;</span><br><span class="line">CORRECT_NAME=&quot;xxx&quot;</span><br><span class="line">CORRECT_EMAIL=&quot;yyy@zzz.com&quot;</span><br><span class="line">if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$GIT_COMMITTER_NAME&quot; = &quot;$OLD_NAME&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$GIT_AUTHOR_NAME&quot; = &quot;$OLD_NAME&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">fi</span><br><span class="line">&#x27; --tag-name-filter cat -- --branches --tags</span><br></pre></td></tr></table></figure>
<p>如果 commit 记录比较多的话，执行时间可能比较长，耐心等待执行完毕后，再次使用 <code>git log</code> 命令查看是否已经修改成功。</p>
<p>最后执行以下命令将修改推送到远端：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push 远程仓库地址别名 --force --all</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如：git push origin --force --all</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>批量修改命令执行失败</p>
</blockquote>
<p>批量修改命令可能会执行失败，如果执行失败， <strong>执行下面这段命令后再次执行批量修改命令：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --index-filter &#x27;git rm --cached --ignore-unmatch Rakefile&#x27; HEAD</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只修改最近一个 commit 的用户名和邮箱</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --author=&quot;xxx &lt;yyy@zzz.com&gt;&quot;</span><br></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将最近一个 commit 的用户名修改为 mofan，邮箱修改为 yyy@zzz.com</span></span><br><span class="line">git commit --amend --author=&quot;mofan &lt;yyy@zzz.com&gt;&quot;</span><br></pre></td></tr></table></figure>
<p>如果想要将最近一个 commit 的用户名和邮箱修改成当前项目 config 中的用户名和邮箱，也可以：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --reset-author --no-edit</span><br></pre></td></tr></table></figure>
<p>上述命令选择执行后，使用 <code>git push -f</code> 强制推送到远端。</p>
<blockquote>
<p>使用 rebase 修改多个 commit 的用户名和邮箱</p>
</blockquote>
<p>假设有一 commit 历史为 A - B - C - D - E - F， F 为 HEAD， 现在需要修改 C 和 D 的用户名和邮箱：</p>
<ol>
<li>先执行 <code>git rebase -i B</code>，如果想要修改 A，可以执行 <code>git rebase -i -root</code>；</li>
<li>把 C 和 D 两个 commit 前的 pick 改为 edit，然后保存并退出；</li>
<li>rebase 开始时，会暂停在 C，此时执行 <code>git commit --amend --author=&quot;Author xxx &lt;yyy@zzz.com&gt;&quot;</code>；</li>
<li>执行 <code>git rebase --continue</code> 继续 rebase；</li>
<li>接下来会暂停在 D，此时再执行 <code>git commit --amend --author=&quot;Author xxx &lt;yyy@zzz.com&gt;&quot;</code>；</li>
<li>执行 <code>git rebase --continue</code> 继续 rebase 直到结束；</li>
<li>最后执行 <code>git push -f</code> 强制推送到远端。</li>
</ol>
<h2 id="12-6-删除某次提交"><a class="header-anchor" href="#12-6-删除某次提交"></a>12.6 删除某次提交</h2>
<p><strong>不要在多人协作下使用！</strong></p>
<p>假设使用 <code>git log</code> 命令可以看到如下提交信息：</p>
<pre>
commit dddddd
Author: zhangsan &lt;aaa@bbb.com&gt;
Date:   xxxx
&#9;add d.txt
commit cccccc
Merge: 3d3a70e36a 8eb72887fe
Author: zhangsan &lt;aaa@bbb.com&gt;
Date:   xxx
&#9;add c.txt
commit bbbbbb
Author: zhangsan &lt;aaa@bbb.com&gt;
Date:   xxx
&#9;add b.txt
commit aaaaaa
Author: zhangsan &lt;aaa@bbb.com&gt;
Date:   xxx
&#9;add a.txt
</pre>
<p>假设需要删除 commit id 为 <code>cccccc</code> 的这次提交信息，那么需要先找到这次提交的前一次 commit id，即：<code>bbbbbb</code>（距离当前事件最近的提交在最上面，因此前一次提交应该是 <code>bbbbbb</code>），然后使用这个 commit id 执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i bbbbbb</span><br></pre></td></tr></table></figure>
<p>执行命令后，会出现一个文件的编辑界面，在文件中将需要删除的 commit 之前的单词改成 drop，之后保存退出。比如：</p>
<pre>
pick dddddd add d.txt
drop cccccc add c.txt
pick bbbbbb add b.txt
</pre>
<p>比如原先 <code>cccccc</code> 前是 pick，现在改成 drop 后保存退出。</p>
<p>此时可能会产生冲突，解决冲突后，提交到本地仓库，最后执行以下命令将修改强制推送到远程仓库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin HEAD --force</span><br></pre></td></tr></table></figure>
<p><code>origin</code> 是远程仓库地址别名，根据实际情况进行替换。</p>
<h2 id="12-7-修改历史提交内容"><a class="header-anchor" href="#12-7-修改历史提交内容"></a>12.7 修改历史提交内容</h2>
<p><strong>不要在多人协作下使用！</strong></p>
<p>找到需要修改的目标提交的 <strong>前一个</strong> commit id，假设为 <code>aaaaaa</code>，执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i aaaaaa</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要修改第一个提交，应该使用：</span></span><br><span class="line">git rebase -i --root</span><br></pre></td></tr></table></figure>
<p>进入编辑页面，将需要修改的 commit 之前的单词改成 <code>e</code>，然后保存退出，比如：</p>
<pre>
e bbbbbb xxxxxx
pick cccccc xxxxxx
pick dddddd xxxxxx
</pre>
<p>接着完成想要的修改，修改完成后依次执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit --amend --no-edit</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>
<p>如果要把修改推送至远端，再执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure>
<h2 id="12-8-merge-的回退"><a class="header-anchor" href="#12-8-merge-的回退"></a>12.8 merge 的回退</h2>
<p>项目新特性的开发流程一般是基于 <code>test</code> 分支新建特性分支 <code>feat</code>，在功能开发完毕后 <code>cherry-pick</code> 到 <code>dev</code> 分支，在 <code>dev</code> 分支自测无误后再将 <code>feat</code> 分支合并到 <code>test</code> 分支，无论是将 <code>dev</code> 分支直接合并到 <code>test</code> 分支，还是将 <code>test</code> 分支直接合并到 <code>dev</code> 分支，这都将影响团队协作，因此如何回退 <code>merge</code> 而且不影响他人的提交就是一个问题。</p>
<p>推荐使用 <code>revert</code> 命令，而不是 <code>reset</code>。</p>
<p>在进行 <code>merge</code> 操作后，会出现一条类似下方的 log 信息：</p>
<pre>
Merge remote-tracking branch 'origin/xxx' into xxx
</pre>
<p>找到这条 log 信息对应的 commit id，执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert [commit id] -m 1</span><br></pre></td></tr></table></figure>
<p>然后再 <code>push</code> 即可。</p>
<h2 id="12-9-修改最近一次的-commit-时间"><a class="header-anchor" href="#12-9-修改最近一次的-commit-时间"></a>12.9 修改最近一次的 commit 时间</h2>
<p><strong>不要在多人协作下使用！</strong></p>
<p>借助 <code>git commit --amend </code> 实现，比如修改最近一次的 commit 时间为 <code>2023-12-04 20:30:00</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --no-edit --date &quot;Mon 4 Dec 2023 20:30:00 Asia/Shanghai&quot;</span><br></pre></td></tr></table></figure>
<p>最后的日期时间格式必须是：</p>
<pre>
星期 日 月 年 时间 时区
</pre>
<p>在中国，时区应该是 <code>Asia/Shanghai</code>，而不是 <code>CST</code>。</p>
<h2 id="12-10-将其他分支完全覆盖到当前分支"><a class="header-anchor" href="#12-10-将其他分支完全覆盖到当前分支"></a>12.10 将其他分支完全覆盖到当前分支</h2>
<p><strong>不要在多人协作下使用！</strong></p>
<p>在当前分支下依次执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 目标分支名</span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure>
<h1 id="13-遇到的问题"><a class="header-anchor" href="#13-遇到的问题"></a>13. 遇到的问题</h1>
<h2 id="13-1-IDEA-Git-出现-Line-Separators-Warning"><a class="header-anchor" href="#13-1-IDEA-Git-出现-Line-Separators-Warning"></a>13.1 IDEA Git 出现 Line Separators Warning</h2>
<p>当我们使用 IDEA 的 Git Commit 代码时，可能会出现以下窗口：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/LineSeparatorsWarning%E7%AA%97%E5%8F%A3.png" alt="LineSeparatorsWarning窗口"></p>
<p>出现这种情况主要是因为不同的操作系统采用的行分隔符的方式不同。</p>
<p>在 Windows 下采用的是 CRLF 方式，即回车并换行。CR 是老版本 MAC 的做法，即回车，后来 MAC 系统统一成了 LF，LF 也是 Linux 下的做法，即回车。</p>
<p>关于这三者的关系，有兴趣的朋友可以参考这篇文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ArsenalfanInECNU/p/6086665.html">趣谈、浅析CRLF和LF</a></p>
<p>一般操作系统上的运行库会自动决定文本文件的换行格式。 如一个程序在 Windows 上运行就生成 CRLF 换行格式的文本文件，而在 Linux 上运行就生成 LF 格式换行的文本文件。</p>
<p>需要注意的是 <strong>在一个平台上使用另一种换行符的文件文件可能会带来意想不到的问题。</strong></p>
<p>那怎么搞？🤪</p>
<p>通常来说，IDE 或文本编辑器都带有换行符转换功能，使用这个功能可以将文本文件中的换行符在不同格式单互换。</p>
<blockquote>
<p>场景复现</p>
</blockquote>
<p>我是在 Windows 操作系统下新建了一个文件，在对这个文件编写好代码后，需要 Commit 到本地仓库，这个时候就出现了开头的窗口。</p>
<p>这是因为 Windows 下使用的是 CRLF 换行方式，我创建的文件的换行方式也是 CRLF，与仓库中其他文件文件的换行方式不同，所以 IDEA 就弹出了这个窗口。</p>
<blockquote>
<p>解决方式</p>
</blockquote>
<p>解决方式很简单，前往我们新建的文件，将 IDEA 右下角的行分隔符设置由 CRLF 修改为 LF 即可，如：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A1%8C%E5%88%86%E9%9A%94%E7%AC%A6.png" alt="设置文件的行分隔符"></p>
<p><mark>注意：</mark> Windows 下是从 CRLF 改成 LF，而 MAC 下相反。</p>
<p>这样再 Commit 代码就不会出现这个提示框了，问题暂时解决。🤨</p>
<p>为什么说暂时解决，因为我们下次再创建文件时，右下角行分隔符的设置还是 CRLF，虽然也可以点一下修改，那有没有什么一劳永逸的方法？🤔</p>
<p>诶！有的！🧐</p>
<p>这主要是因为 CRLF 是跟随系统来设置的，因为当前系统是 Windows，所以采取的方式就是 CRLF 了。</p>
<p>主需要打开 Settings，切换至 Editor，点击 Code Style，然后将 Line separator 由 <code>System-Dependent</code> 修改为 <code>Unix and MacOS(\n)</code> 即可：</p>
<img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/修改IDEA的默认LineSeparator.png" alt="修改IDEA的默认LineSeparator" style="zoom: 50%;" />
<h2 id="13-2-LF-will-be-replaced-by-CRLF"><a class="header-anchor" href="#13-2-LF-will-be-replaced-by-CRLF"></a>13.2 LF will be replaced by CRLF</h2>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/huihuikuaipao_/article/details/100183521">关于 LF will be replaced by CRLF 问题出现的原因以及解决方式</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/450cd21b36a4">关于git提示“warning: LF will be replaced by CRLF”终极解答</a></p>
<blockquote>
<p>具体分析与解决</p>
</blockquote>
<p>在 Windows 操作系统上使用 Git 命令行提交代码时，有时候会出现这样的警告：</p>
<pre>
warning: LF will be replaced by CRLF in xxxxx
</pre>
<p>原因很简单：Windows 中的换行符为 CRLF，而在 Linux 下的换行符为 LF，所以在将修改的文件添加至暂存区时就会出现提示。</p>
<p>如果你在 Windows 下想要 <strong>开启</strong> 换行符的转化，可以执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交时转换为LF，检出时转换为CRLF</span></span><br><span class="line">git config --global core.autocrlf true</span><br></pre></td></tr></table></figure>
<p>在 Linux 或 Mac 中，行结束符是 LF，但是当 CRLF 引入文件时，我们应当使用 Git 进行修正，可以执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交时转换为LF，检出时不转换</span></span><br><span class="line">git config --global core.autocrlf input</span><br></pre></td></tr></table></figure>
<p>如果仅在 Windows 上进行开发，且开发仅运行在 Windows 上的项目，可以设置 false 取消此功能，把回车保留在版本库中，关闭自动转换的功能即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交检出均不转换</span></span><br><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>
<p>还可以在文件提交时进行 safecrlf 检查：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拒绝提交包含混合换行符的文件</span></span><br><span class="line">git config --global core.safecrlf true   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许提交包含混合换行符的文件</span></span><br><span class="line">git config --global core.safecrlf false   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交包含混合换行符的文件时给出警告</span></span><br><span class="line">git config --global core.safecrlf warn</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结</p>
</blockquote>
<p>一般来说，不建议关闭这个功能，因为实际项目开发时是协同合作，两个开发者的操作系统不一致时常发生，所以建议开启这个功能。</p>
<p>如果是使用在 Windows 上编写自己的项目，关闭这个功能也是可以的。</p>
<p>而且这只是一个警告，可以直接忽略，对我们整体工作不会造成影响！</p>
<h2 id="13-3-git-reset-hard-HEAD-后显示-more"><a class="header-anchor" href="#13-3-git-reset-hard-HEAD-后显示-more"></a>13.3 git reset --hard HEAD^ 后显示 more?</h2>
<p>在 Windows 的 CMD（或 IDEA 的 Terminal）中执行 <code>git reset --hard HEAD^</code> 命令后，显示 <code>more?</code>，自觉告诉我按下回车即可，结果多次按下回车后出现以下错误：</p>
<pre>
fatal: ambiguous argument 'HEAD
': unknown revision or path not in the working tree.
Use '--' to separate paths from revisions, like this:
'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]'
</pre>
<p>这是因为 CMD 中默认的换行符恰好是 <code>^</code>，出现的 <code>more?</code> 就是在询问是否要再输入，而 <code>^</code> 被当成换行符后就被 Git 命令忽略了，因此多次回车后就报错了。</p>
<p>处理方法：</p>
<p>1、加引号：<code>git reset --hard &quot;HEAD^&quot;</code></p>
<p>2、多加个 <code>^</code>：<code>git reset --hard HEAD^^</code></p>
<p>3、换成 <code>~</code>：<code>git reset --hard HEAD~</code> 或者 <code>git reset --hard HEAD~1</code>，这表示回退 1 次提交，单独一个 <code>~</code> 默认是一次</p>
<p>4、不使用 CMD（或 IDEA 的 Terminal）执行 Git 命令，换用 PowerShell 或者 Git bash</p>
<h2 id="13-4-git-pull-提示-warning-ignoring-broken-ref-refs-remotes-origin-HEAD"><a class="header-anchor" href="#13-4-git-pull-提示-warning-ignoring-broken-ref-refs-remotes-origin-HEAD"></a>13.4 git pull 提示 warning: ignoring broken ref refs/remotes/origin/HEAD</h2>
<p>简单的两步即可解决：</p>
<p>1、删除项目的 <code>.git/refs/remotes/origin</code> 目录下的所有文件</p>
<p>2、执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br></pre></td></tr></table></figure>
<h2 id="13-5-unable-to-get-local-issuer-certificate"><a class="header-anchor" href="#13-5-unable-to-get-local-issuer-certificate"></a>13.5 unable to get local issuer certificate</h2>
<p>在执行 <code>git pull</code> 命令时遇到了以下错误信息：</p>
<pre>
fatal: unable to access 'https:xxxxxx': SSL certificate problem: unable to get local issuer certificate
</pre>
<p>这是由于通过 HTTPS 访问 Git 远程仓库时，如果服务器上的 SSL 证书未经过第三方机构的认证，这意味着可能存在很大的风险，Git 进而报错。</p>
<p>可以通过以下命令将 Git 中的 sslverify 关掉：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">作用于当前系统用户</span></span><br><span class="line">git config --global http.sslverify false</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">作用于全局所有用户</span></span><br><span class="line">git config --system http.sslverify false</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">作用于当前仓库</span></span><br><span class="line">git config http.sslverify false</span><br></pre></td></tr></table></figure>
<p>上述命令任选其一即可，它们只是作用范围不同。</p>
<h2 id="13-6-git-status-中文文件名乱码"><a class="header-anchor" href="#13-6-git-status-中文文件名乱码"></a>13.6 git status 中文文件名乱码</h2>
<p>执行以下命令解决：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 git status utf-8 编码</span></span><br><span class="line">git config --global core.quotepath false</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 GUI 界面 utf-8 编码</span></span><br><span class="line">git config --global gui.encoding utf-8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 commit 信息 utf-8 编码</span></span><br><span class="line">git config --global i18n.commit.encoding utf-8 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置输出 <span class="built_in">log</span> utf-8 编码</span></span><br><span class="line">git config --global i18n.logoutputencoding utf-8</span><br></pre></td></tr></table></figure>
<p><strong>一般执行第一条命令即可，</strong> 余下命令仅供参考。</p>
<h2 id="13-7-右键菜单没有-Git-Bash-here"><a class="header-anchor" href="#13-7-右键菜单没有-Git-Bash-here"></a>13.7 右键菜单没有 Git Bash here</h2>
<p>一次 Windows 系统更新后，右键菜单中的「Git Bash here」消失了，百度上的解决方案基本都要修改注册表，但其实没这么麻烦， <strong>重新安装 Git 即可，</strong> 甚至可以趁此机会升级下 Git 的版本。</p>
<h2 id="13-8-fatal-detected-dubious-ownership-in-repository-at"><a class="header-anchor" href="#13-8-fatal-detected-dubious-ownership-in-repository-at"></a>13.8 fatal: detected dubious ownership in repository at</h2>
<p>如果在 Windows 上切换过用户，或者重装过系统，然后在存储盘中的 Git 仓库目录下执行 Git 相关命令，可能会遇到以下错误：</p>
<pre>
fatal: detected dubious ownership in repository at '仓库路径'
'仓库路径/.git' is owned by:
        (inconvertible) (S-1-5-21-1088944263-1020297098-3415021066-1001)
but the current user is:
        xxx (S-1-5-21-1426704721-2800435579-942188405-1001)
To add an exception for this directory, call:<br/>
        git config --global --add safe.directory 仓库路径
</pre>
<p>这是在说：在仓库中检测到「可疑的」所有权。仓库里的 <code>.git</code> 文件夹应该属于用户 A，但是现在的用户是 B。</p>
<p>Git 还很贴心地说，如果要添加这个目录为例外，需要执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --add safe.directory 仓库路径</span><br></pre></td></tr></table></figure>
<p>执行上述命令后，确实可以解决问题。</p>
<p>先前说过，执行 <code>git config --global</code>  命令时，会将对应的配置信息存放在用户目录的 <code>.gitconfig</code> 文件里：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[safe]</span></span><br><span class="line">    <span class="attr">directory</span> = <span class="string">仓库路径</span></span><br></pre></td></tr></table></figure>
<p>如果拥有良好的文件管理习惯，通常会在同一个目录下存放所有的代码，可以将命令中的「仓库路径」替换成这个大目录，一次性将所有仓库标记为「safe」。</p>
<blockquote>
<p>问题的根本</p>
</blockquote>
<p>Git 不会在 <code>.git</code> 中存储仓库所有者的相关信息。</p>
<p>Git 会查看 Windows 中仓库所在文件夹的所有者信息，如果和当前用户不符，就会提示错误。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/73358728/how-to-change-ownership-of-a-local-git-repository-on-windows-11">How to change ownership of a local GIT repository on Windows 11</a></p>
<p>鼠标右击 Git 仓库目录，选择「属性」，点击「安全」选项卡，点击「高级」：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/Windows%E4%B8%8B%E6%9F%A5%E7%9C%8BGit%E4%BB%93%E5%BA%93%E7%9B%AE%E5%BD%95%E7%9A%84%E5%B1%9E%E6%80%A7.png" alt="Windows下查看Git仓库目录的属性"></p>
<p>在新打开的窗口中可以看到一栏名为「所有者」，这个值与错误信息中的用户 A 一致。</p>
<p>点击「更改」，尝试修改该目录的所有者：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/%E5%B0%9D%E8%AF%95%E4%BF%AE%E6%94%B9Git%E4%BB%93%E5%BA%93%E7%9B%AE%E5%BD%95%E7%9A%84%E6%89%80%E6%9C%89%E8%80%85.png" alt="尝试修改Git仓库目录的所有者"></p>
<p>在新打开的窗口中输入自己的用户名，也就是用户目录的名字，之后点击「确定」，回到上一界面：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E6%9B%B4%E6%94%B9Git%E4%BB%93%E5%BA%93%E7%9B%AE%E5%BD%95%E7%9A%84%E6%89%80%E6%9C%89%E8%80%85.png" alt="输入用户名更改Git仓库目录的所有者"></p>
<p>如果登录了微软账号，此时「所有者」一栏中会显示微软账号的姓名和邮箱。</p>
<p>同时还多出了「替换子容器和对象的所有者」单选框，<strong>勾选该单选框，</strong> 之后一路「确定」，完成对所有者的修改：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/%E5%8B%BE%E9%80%89%E6%9B%BF%E6%8D%A2%E5%AD%90%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E8%80%85.png" alt="勾选替换子容器和对象的所有者"></p>
<p>再次在该仓库目录下执行 Git 命令，不再出现错误。</p>
<h2 id="13-9-能访问-GitHub-但不能进行-Git-相关操作"><a class="header-anchor" href="#13-9-能访问-GitHub-但不能进行-Git-相关操作"></a>13.9 能访问 GitHub 但不能进行 Git 相关操作</h2>
<p>能够访问 GitHub，但 Git 相关命令都无法执行成功，并且使用 <code>ping github.com</code> 命令也提示超时。</p>
<p>访问 <a target="_blank" rel="noopener" href="https://www.ipaddress.com/site/www.github.com">GitHub IP Address</a> 获取 GitHub 的动态 IP 地址：</p>
<p><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ToolsImages/%E8%8E%B7%E5%8F%96GitHub%E5%8A%A8%E6%80%81IP%E5%9C%B0%E5%9D%80.png" alt="获取GitHub动态IP地址"></p>
<p>修改 Windows 下 hosts 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">140.82.112.4 github.com</span><br></pre></td></tr></table></figure>
<h1 id="14-其他补充信息"><a class="header-anchor" href="#14-其他补充信息"></a>14. 其他补充信息</h1>
<h2 id="14-1-Commit-Type-类别"><a class="header-anchor" href="#14-1-Commit-Type-类别"></a>14.1 Commit Type 类别</h2>
<p>参考链接：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/touo-rygtz0tG6y8NKw65A">天天用Git，分支开发你怎么弄的？</a></p>
<ul>
<li>feat：添加新特性</li>
<li>fix：修复 BUG</li>
<li>docs：仅仅修改了文档</li>
<li>style：仅仅修改了空格、格式缩进等，未改变代码逻辑</li>
<li>refactor：代码重构，未添加新功能或修复 BUG</li>
<li>perf：增加代码进行性能测试</li>
<li>test：增加测试用例</li>
<li>chore：改变构建流程，增加依赖库、工具等</li>
</ul>
<h2 id="14-2-管理多个用户信息"><a class="header-anchor" href="#14-2-管理多个用户信息"></a>14.2 管理多个用户信息</h2>
<p>参考链接：<a target="_blank" rel="noopener" href="https://garrit.xyz/posts/2023-10-13-organizing-multiple-git-identities"> Organizing multiple Git identities</a></p>
<p>某些情况下，一台电脑可能会有多个 Git 用户，就像“工作一个号，生活一个号”，需要使用与默认用户名与邮箱不同的身份来提交代码。尽管可以每次都在特定的项目中使用以下命令对默认用户信息进行修改，但如果不小心忘记了，就可能遇到不必要的麻烦：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;xxx&quot;</span><br><span class="line">git config user.email &quot;qwe@123.com&quot;</span><br></pre></td></tr></table></figure>
<p>假设工作项目 <strong>总是</strong> 存放在 <code>D:/Code/Work/</code> 目录下，这个目录下的项目需要使用公司内部的邮箱作为用户信息，除此之外其他位置的项目则是使用默认用户信息。</p>
<p>Git 全局的 <code>.gitconfig</code> 配置文件有一个很棒的特性，<strong>能够有条件地包含其他配置文件</strong>。</p>
<p>那么可以修改全局 <code>.gitconfig</code> 配置文件，针对位于 <code>D:/Code/Work/</code> 目录下的项目，使用 <code>.gitconfig-work</code> 配置文件：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[user]</span></span><br><span class="line">    <span class="attr">name</span> = mofan</span><br><span class="line">    <span class="attr">email</span> = cy.mofan@foxmail.com</span><br><span class="line"><span class="section">[includeIf &quot;gitdir:D:/Code/Work/&quot;]</span></span><br><span class="line">    <span class="attr">path</span> = ./.gitconfig-work</span><br></pre></td></tr></table></figure>
<p><code>.gitconfig-work</code> 中的内容如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[user]</span></span><br><span class="line">    <span class="attr">name</span> = 默烦</span><br><span class="line">    <span class="attr">email</span> = example@work.com</span><br></pre></td></tr></table></figure>
<h1 id="100-可能有用的小工具"><a class="header-anchor" href="#100-可能有用的小工具"></a>100. 可能有用的小工具</h1>
<h2 id="100-1-push-sh"><a class="header-anchor" href="#100-1-push-sh"></a>100.1 push.sh</h2>
<p>日常工作中提交代码时常常会频繁切换分支，具体操作步骤是：</p>
<ol>
<li>暂存当前分支上的变更</li>
<li>检出 dev 分支或基于 test 分支创建的个人分支</li>
<li>应用暂存的变更，推送到远端</li>
<li>检出到原分支，将刚刚的提交 <code>cherry-pick</code> 到原分支并推送到远端</li>
</ol>
<p>这些步骤中可能会产生冲突，但在没有冲突的情况下是完全相同的，因此想到编写一个脚本对上述操作完成自动化。</p>
<p>实现过程的参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ouyang_peng/article/details/113568009">【Linux学习】Shell脚本如何执行完毕之后不自动关闭窗口？</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1499794">shell:获取git当前分支或tag</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5167957/is-there-a-better-way-to-find-out-if-a-local-git-branch-exists#">Is there a better way to find out if a local git branch exists?</a></li>
</ul>
<p>脚本地址：<a target="_blank" rel="noopener" href="https://github.com/mofan212/my-tools/blob/master/git/push.sh">my-tools/git/push.sh</a></p>
<h2 id="100-2-pull-sh"><a class="header-anchor" href="#100-2-pull-sh"></a>100.2 pull.sh</h2>
<p>通过完整的项目地址或者项目名称依次在 GitHub、Gitee 上拉取代码，适用场景较为局限，拉取代码时需要两种信息：</p>
<ol>
<li>项目所属用户名</li>
<li>项目名</li>
</ol>
<p>在知道项目名的情况下，一般并不知道项目所属用户名，常用于拉取某一特定用户名下的项目。</p>
<p>脚本地址：<a target="_blank" rel="noopener" href="https://github.com/mofan212/my-tools/blob/master/git/pull.sh">my-tools/git/pull.sh</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mofan212.github.io">默烦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mofan212.github.io/posts/Git/">https://mofan212.github.io/posts/Git/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://mofan212.github.io" target="_blank">Mofan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Git/">Git</a></div><div class="post-share"><div class="social-share" data-image="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/3.jpg" data-sites="wechat,qq,weibo,facebook,x"></div><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" target="_blank"><img class="post-qr-code-img" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" target="_blank"><img class="post-qr-code-img" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/How-to-use-Typora/" title="一款简洁、高自定义化的 Markdown 编辑器——Typora"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/2.jpg" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">一款简洁、高自定义化的 Markdown 编辑器——Typora</div></div><div class="info-2"><div class="info-item-1">我宣布：Typora 是最好的 Markdown 编辑器，没有之一！</div></div></div></a><a class="pagination-related" href="/posts/Principles-Of-SpringBoot/" title="SpringBoot原理"><img class="cover" src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/23.jpg" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">SpringBoot原理</div></div><div class="info-2"><div class="info-item-1">误人子弟系列，不要看，后续找个时间重写。😶</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">默烦</div><div class="author-info-description">彩笔的打怪升级之路...</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">174</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mofan212"><i class="fab fa-github"></i><span>follow me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:cy.mofan@foxmail.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站所有博文均是博主的学习笔记与个人理解。<strong><font style="color:red">除特别注明外，</font>如需转载，请在文章头部醒目处附带原文链接并<a href="./mine/" style="color:#49B1F5;text-decoration:underline">告知我</a></strong>你将转载。😊</br><strong><font style="color:red">严禁未遵循规范的转载。</font></strong>😡</br><strong>死去的评论系统复活啦！欢迎到留言板畅所欲言！</strong>当然也可以使用更高效的<a target="_blank" href="https://space.bilibili.com/23658864/dynamic" style="color:#49B1F5;text-decoration:underline"> 哔哩哔哩私信 </a>或<a href="mailto:cy.mofan@foxmail.com" style="color:#49B1F5;text-decoration:underline" target="_blank">邮箱</a>。 😉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="toc-text">1. 版本控制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Git-%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="toc-text">2. Git 的历史</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Git-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-text">3. Git 环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD-Git"><span class="toc-text">3.1 安装与卸载 Git</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">3.2 Linux 常用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Git-%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-text">3.3 Git 的配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Git-%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA"><span class="toc-text">4. Git 基本理论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Git-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA"><span class="toc-text">5. Git 项目搭建</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Git-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">6. Git 文件操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-GitHub-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">7. GitHub 的使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-IDEA-%E4%B8%AD%E9%9B%86%E6%88%90-Git"><span class="toc-text">8. IDEA 中集成 Git</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Git-%E5%88%86%E6%94%AF"><span class="toc-text">9. Git 分支</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C"><span class="toc-text">10. 团队协作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E5%9B%A2%E9%98%9F%E5%86%85%E5%8D%8F%E4%BD%9C"><span class="toc-text">10.1 团队内协作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E8%B7%A8%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C"><span class="toc-text">10.2 跨团队协作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">11. 其他常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88"><span class="toc-text">11.1 其他常用命令一览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-log-%E4%B8%8E-reflog-%E5%8C%BA%E5%88%AB"><span class="toc-text">11.2 log 与 reflog 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-git-stash"><span class="toc-text">11.3 git stash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-cherry-pick"><span class="toc-text">11.4 cherry-pick</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-git-diff"><span class="toc-text">11.5 git diff</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-6-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2"><span class="toc-text">11.6 重写历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-7-%E5%9B%9E%E6%BB%9A%E4%B8%8E%E6%92%A4%E9%94%80"><span class="toc-text">11.7 回滚与撤销</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-8-%E5%85%B6%E4%BB%96%E5%90%8E%E6%82%94%E8%8D%AF"><span class="toc-text">11.8 其他后悔药</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-9-abort-%E7%BB%88%E6%AD%A2"><span class="toc-text">11.9 abort 终止</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-10-%E5%90%88%E5%B9%B6-commit"><span class="toc-text">11.10 合并 commit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-11-%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E5%88%86%E6%94%AF%E4%B8%8E%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%9A%84%E9%93%BE%E6%8E%A5%E5%85%B3%E7%B3%BB"><span class="toc-text">11.11 指定当前工作分支与远程分支的链接关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-12-%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84%E5%BC%BA%E5%88%B6%E6%8E%A8%E9%80%81"><span class="toc-text">11.12 更安全的强制推送</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">12. 其他操作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E6%8E%A8%E9%80%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-text">12.1 推送到远程仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E6%8B%89%E5%8F%96%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%88%B0%E6%9C%AC%E5%9C%B0"><span class="toc-text">12.2 拉取远程分支到本地</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-GitHub-%E7%9A%84%E9%BB%98%E8%AE%A4%E5%88%86%E6%94%AF"><span class="toc-text">12.3 GitHub 的默认分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80"><span class="toc-text">12.4 修改远程仓库地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-5-%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2-commit-%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1"><span class="toc-text">12.5 修改历史 commit 用户名和邮箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-6-%E5%88%A0%E9%99%A4%E6%9F%90%E6%AC%A1%E6%8F%90%E4%BA%A4"><span class="toc-text">12.6 删除某次提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-7-%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4%E5%86%85%E5%AE%B9"><span class="toc-text">12.7 修改历史提交内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-8-merge-%E7%9A%84%E5%9B%9E%E9%80%80"><span class="toc-text">12.8 merge 的回退</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-9-%E4%BF%AE%E6%94%B9%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1%E7%9A%84-commit-%E6%97%B6%E9%97%B4"><span class="toc-text">12.9 修改最近一次的 commit 时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-10-%E5%B0%86%E5%85%B6%E4%BB%96%E5%88%86%E6%94%AF%E5%AE%8C%E5%85%A8%E8%A6%86%E7%9B%96%E5%88%B0%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF"><span class="toc-text">12.10 将其他分支完全覆盖到当前分支</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">13. 遇到的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-IDEA-Git-%E5%87%BA%E7%8E%B0-Line-Separators-Warning"><span class="toc-text">13.1 IDEA Git 出现 Line Separators Warning</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-LF-will-be-replaced-by-CRLF"><span class="toc-text">13.2 LF will be replaced by CRLF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-git-reset-hard-HEAD-%E5%90%8E%E6%98%BE%E7%A4%BA-more"><span class="toc-text">13.3 git reset --hard HEAD^ 后显示 more?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-4-git-pull-%E6%8F%90%E7%A4%BA-warning-ignoring-broken-ref-refs-remotes-origin-HEAD"><span class="toc-text">13.4 git pull 提示 warning: ignoring broken ref refs&#x2F;remotes&#x2F;origin&#x2F;HEAD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-5-unable-to-get-local-issuer-certificate"><span class="toc-text">13.5 unable to get local issuer certificate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-6-git-status-%E4%B8%AD%E6%96%87%E6%96%87%E4%BB%B6%E5%90%8D%E4%B9%B1%E7%A0%81"><span class="toc-text">13.6 git status 中文文件名乱码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-7-%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%B2%A1%E6%9C%89-Git-Bash-here"><span class="toc-text">13.7 右键菜单没有 Git Bash here</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-8-fatal-detected-dubious-ownership-in-repository-at"><span class="toc-text">13.8 fatal: detected dubious ownership in repository at</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-9-%E8%83%BD%E8%AE%BF%E9%97%AE-GitHub-%E4%BD%86%E4%B8%8D%E8%83%BD%E8%BF%9B%E8%A1%8C-Git-%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-text">13.9 能访问 GitHub 但不能进行 Git 相关操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E5%85%B6%E4%BB%96%E8%A1%A5%E5%85%85%E4%BF%A1%E6%81%AF"><span class="toc-text">14. 其他补充信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-Commit-Type-%E7%B1%BB%E5%88%AB"><span class="toc-text">14.1 Commit Type 类别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AA%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-text">14.2 管理多个用户信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#100-%E5%8F%AF%E8%83%BD%E6%9C%89%E7%94%A8%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7"><span class="toc-text">100. 可能有用的小工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#100-1-push-sh"><span class="toc-text">100.1 push.sh</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#100-2-pull-sh"><span class="toc-text">100.2 pull.sh</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Something-About-Blog/" title="博客搭建与维护"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/42.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="博客搭建与维护"/></a><div class="content"><a class="title" href="/posts/Something-About-Blog/" title="博客搭建与维护">博客搭建与维护</a><time datetime="2026-01-24T16:00:00.000Z" title="更新于 2026-01-25 00:00:00">2026-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Memory-Model/" title="Java 内存模型"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/174.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Java 内存模型"/></a><div class="content"><a class="title" href="/posts/Java-Memory-Model/" title="Java 内存模型">Java 内存模型</a><time datetime="2026-01-02T16:00:00.000Z" title="更新于 2026-01-03 00:00:00">2026-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Bytecode-And-Class-Loading/" title="字节码与类加载"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/173.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="字节码与类加载"/></a><div class="content"><a class="title" href="/posts/Java-Bytecode-And-Class-Loading/" title="字节码与类加载">字节码与类加载</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Class-Resource-Loading-In-Java/" title="Java 的类资源加载"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/103.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Java 的类资源加载"/></a><div class="content"><a class="title" href="/posts/Class-Resource-Loading-In-Java/" title="Java 的类资源加载">Java 的类资源加载</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Annotation-And-Reflection/" title="注解、类的加载、反射"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/20.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="注解、类的加载、反射"/></a><div class="content"><a class="title" href="/posts/Annotation-And-Reflection/" title="注解、类的加载、反射">注解、类的加载、反射</a><time datetime="2026-01-01T16:00:00.000Z" title="更新于 2026-01-02 00:00:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ren-zhi-jue-xing/" title="认知觉醒"><img src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/172.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="认知觉醒"/></a><div class="content"><a class="title" href="/posts/ren-zhi-jue-xing/" title="认知觉醒">认知觉醒</a><time datetime="2025-12-28T16:00:00.000Z" title="更新于 2025-12-29 00:00:00">2025-12-29</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2020 - 2026 By 默烦</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://testingcf.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://testingcf.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://testingcf.jsdelivr.net/npm/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://testingcf.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://gcore.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://testingcf.jsdelivr.net/gh/mofan212/blog-static-resources@master/js/mine.min.js"></script><script src="/js/tip_portal.js"></script><script defer="defer" id="ribbon" src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-show-text" src="https://testingcf.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Azathoth,Yog-Sothoth,Shub-Niggurath,Nyarlathotep,Cthulhu,Hastur,Abhoth,Ghroth,Tsathoggua,Cthugha,Deep Ones,Dagon,Chaugnar Faugn,Mordiggian,Shoggoth,Old One,Mi-Go,Great Race of Yith,Flying Polyp,Hounds of Tindalos,Dhole" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://testingcf.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'BAFEL7A6K1',
    apiKey: '89fcb5961984c5c054bf04149f345f38',
    indexName: 'mofan212io',
    container: '#docsearch',
    placeholder: '输入关键字进行搜索',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>注解、类的加载、反射 | Mofan</title><meta name="author" content="默烦,cy.mofan@foxmail.com"><meta name="copyright" content="默烦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文从 Java 注解出发，介绍了类的加载、类初始化、类加载器以及反射的简单使用。">
<meta property="og:type" content="article">
<meta property="og:title" content="注解、类的加载、反射">
<meta property="og:url" content="https://mofan212.github.io/posts/Annotation-And-Reflection/index.html">
<meta property="og:site_name" content="Mofan">
<meta property="og:description" content="本文从 Java 注解出发，介绍了类的加载、类初始化、类加载器以及反射的简单使用。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/20.jpg">
<meta property="article:published_time" content="2020-05-31T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-31T16:00:00.000Z">
<meta property="article:author" content="默烦">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/20.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "注解、类的加载、反射",
  "url": "https://mofan212.github.io/posts/Annotation-And-Reflection/",
  "image": "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/20.jpg",
  "datePublished": "2020-05-31T16:00:00.000Z",
  "dateModified": "2024-08-31T16:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "默烦",
      "url": "https://mofan212.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/favicon.png"><link rel="canonical" href="https://mofan212.github.io/posts/Annotation-And-Reflection/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 默烦","link":"链接: ","source":"来源: Mofan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://fastly.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '注解、类的加载、反射',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="referrer" content="no-referrer-when-downgrade" /><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/mofan212/blog-static-resources@master/css/myStyle.min.css"><link rel="stylesheet" href="https://cdn.staticfile.net/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono-nl.min.css" /><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Mofan" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/mofan212/blog-static-resources/css/minimal.min.css"/><script src="https://fastly.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">161</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/post_top_img.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Mofan</span></a><a class="nav-page-title" href="/"><span class="site-name">注解、类的加载、反射</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-book-reader"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/schedule/"><i class="fa-fw fas fa-list-alt"></i><span> 计划</span></a></div><div class="menus_item"><a class="site-page" href="/update/"><i class="fa-fw fas fa-tools"></i><span> 维护</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fa fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/milestones/"><i class="fa-fw fa-solid fa-monument"></i><span> 里程碑</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于本站</span></a></li><li><a class="site-page child" href="/mine/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">注解、类的加载、反射</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-05-31T16:00:00.000Z" title="发表于 2020-06-01 00:00:00">2020-06-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-31T16:00:00.000Z" title="更新于 2024-09-01 00:00:00">2024-09-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;距离本文上次更新已经过去&quot;,&quot;messageNext&quot;:&quot;天，请注意时效性。&quot;,&quot;postUpdate&quot;:&quot;2024-09-01 00:00:00&quot;}" hidden></div><p>封面来源：本文封面来源于网络，如有侵权，请联系删除。</p>
<p>参考视频：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ZY4y1n7tg/">一看就懂，详解Java中的类加载器机制，附热加载示例代码演示</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Gt4y1b7Xi/">银行开发岗成功上岸！顶住了Java类加载器连环问，面试过程实录</a></li>
</ul>
<p>类加载器相关代码：<a target="_blank" rel="noopener" href="https://github.com/mofan212/mofan-demo/tree/master/classloader">mofan-demo/classloader</a></p>
<blockquote>
<p>本文基于 JDK 21</p>
</blockquote>
<h1 id="1-注解"><a class="header-anchor" href="#1-注解"></a>1. 注解</h1>
<h2 id="1-1-自定义注解"><a class="header-anchor" href="#1-1-自定义注解"></a>1.1 自定义注解</h2>
<p>使用 <code>@interface</code> 自定义注解，就会自动继承 <code>java.lang.annotation.Annotation</code> 接口。</p>
<p><code>@interface</code> 可以用来声明一个注解，格式：<code>public @interface 注解名 &#123;定义内容&#125;</code>。注解中每一个方法表示声明了一个配置参数，而方法的名称就是参数的名称，返回值类型就是参数的类型（返回值只能是基本类型、Class、String 和 enum），并且可以通过 <code>default</code> 关键词来声明参数的默认值。如果只有一个参数成员，一般参数名为 value。</p>
<p>注解元素必须要有值。定义注解元素时，经常使用空字符串或 0 作为默认值。</p>
<h2 id="1-2-元注解"><a class="header-anchor" href="#1-2-元注解"></a>1.2 元注解</h2>
<p>元注解的作用就是负责注解其他注解，Java 定义了 4 个标准的元注解（meta-annotation）类型，它们被用来提供对其它注解（annotation）类型作说明。</p>
<p>这四个元注解位于 <code>java.lang.annotation</code> 包中，它们分别是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span> <span class="comment">// 用于描述注解的使用范围</span></span><br><span class="line"><span class="meta">@Retention</span> <span class="comment">// 表示需要在什么级别保存该注解信息，用于表述注解的生命周期。SOURCE &lt; CLASS &lt; RUNTIME</span></span><br><span class="line"><span class="meta">@Documented</span> <span class="comment">// 说明该注解将被包含在 javadoc 中</span></span><br><span class="line"><span class="meta">@Inherited</span> <span class="comment">// 说明子类可以继承父类中的该注解</span></span><br></pre></td></tr></table></figure>
<h1 id="2-类的加载"><a class="header-anchor" href="#2-类的加载"></a>2. 类的加载</h1>
<h2 id="2-1-Java-程序的启动与运行"><a class="header-anchor" href="#2-1-Java-程序的启动与运行"></a>2.1 Java 程序的启动与运行</h2>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/JavaImages/Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B.webp" alt="Java程序的启动并运行的过程"></p>
<p>JVM 在启动时，会加载 <code>main()</code> 方法所在的类（这个类被叫做起始类），接着 JVM 会执行 <code>main()</code> 方法，在执行的过程中，可能会触发进一步的执行，继续加载其他的类并执行其他的方法，直到程序退出。</p>
<p>需要注意的是，在加载某个类或执行某个方法时，也可能会触发其他类的加载。</p>
<p>Java 的类加载是在运行时动态完成的，这种动态的特性，正是 Java 语言灵活性的根源。</p>
<h2 id="2-2-类的加载"><a class="header-anchor" href="#2-2-类的加载"></a>2.2 类的加载</h2>
<p>在 Java 中，所有类的加载都是通过类加载器 ClassLoader 来完成。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/JavaImages/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.webp" alt="类的加载过程"></p>
<p>首先使用 Java 代码或 JVM 来触发一个加载动作，然后将类的全限定名传给类加载器，类加载器再通过类名获取到字节码的二进制流，这份二进制流可以通过以下方式获取：</p>
<ul>
<li>从本地磁盘读取类文件</li>
<li>从网络读取类文件</li>
<li>运行时计算生成字节码流</li>
</ul>
<p>最后再根据字节码二进制流创建并加载对应的 Class 对象。</p>
<blockquote>
<p>类的加载</p>
</blockquote>
<p>将 Class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 <code>java.lang.Class</code> 对象。</p>
<blockquote>
<p>类的连接</p>
</blockquote>
<p>类的连接是指将 Java 类的二进制代码合并到 JVM 的运行状态之中的过程。主要分为三步，分别是验证、准备和解析。</p>
<ol>
<li>验证：确保加载的类信息符合 JVM 规范，即加载的 Class 文件的格式是否正确。</li>
<li>准备：正式为类的静态变量（static）分配内存并为其设置默认初始值的阶段。</li>
<li>解析：虚拟机常量池内的符号引用（变量名）替换为直接引用（地址）的过程。</li>
</ol>
<blockquote>
<p>类的初始化</p>
</blockquote>
<p>类的初始化就是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。类构造器 <code>&lt;clinit&gt;()</code> 方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的（类构造器是构造类信息的，不是构造该类对象的构造器）。</p>
<p>当初始化一个类时，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</p>
<p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确加锁和同步。</p>
<h2 id="2-3-类初始化"><a class="header-anchor" href="#2-3-类初始化"></a>2.3 类初始化</h2>
<p><strong>类的主动引用一定会发生类的初始化。</strong> 比如：</p>
<ol>
<li>当虚拟机启动时，初始化 <code>main()</code> 方法所在的类；</li>
<li><code>new</code> 一个对象；</li>
<li>调用类的静态成员（final 常量除外）和静态方法；</li>
<li>使用 <code>java.lang.reflect</code> 包中的方法对类进行反射调用；</li>
<li>初始化一个类时，如果其父类没有被初始化，则会先初始化它的父类。</li>
</ol>
<p><strong>类的被动引用不会发生类的初始化。</strong> 比如：</p>
<ol>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化；</li>
<li>通过数组定义类引用，不会触发此类的初始化；</li>
<li>引用常量不会触发其所在类的初始化（常量在连接阶段就存入调用类的常量池中了）。</li>
</ol>
<h2 id="2-4-类加载器"><a class="header-anchor" href="#2-4-类加载器"></a>2.4 类加载器</h2>
<blockquote>
<p>类加载器</p>
</blockquote>
<p>类加载器（ClassLoader）的作用：将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区中类数据的访问入口。</p>
<p>简单来说，类的加载阶段有这样一个动作：通过一个类的全限定名来获取描述此类的二进制字节流。这个动作放到了 Java 虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类，而实现这个动作的代码模块就叫做类加载器。</p>
<p>类加载器在 Java 程序中起到的作用不局限于类加载阶段。为了确定任意一个类在 JVM 中的唯一性，除了这个类本身以外，还需要加上加载这个类的类加载器作为依据。每一个类加载器，都拥有一个独立的类命名空间。</p>
<p>也就是说，要判断两个类是否相等，只有在这两个类都是由同一个类加载器加载的前提下才有意义。因此就算是两个来自于同一 class 文件，被同一个虚拟机加载的类，但加载它们的类加载器不同，那也不能认为这两个类相等。这里的“相等”不仅仅指使用 <code>equals()</code> 方法比较，还包括 <code>isAssignableFrom()</code> 方法和 <code>isInstance()</code> 方法的返回结果，以及使用 <code>instanceof</code> 关键字进行判断。</p>
<hr>
<p>拓展：<code>Class#isAssignableFrom()</code> 方法与 <code>instanceof</code> 关键词的使用。</p>
<p><code>Class#isAssignableFrom()</code> 方法用于判断某个类是否是另一个类的父类，<code>instanceof</code> 关键词用于判断某个实例是否是某个父类类型。</p>
<p>使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父类.class.isAssignableFrom(子类.class)</span><br><span class="line"></span><br><span class="line">子类实例 <span class="keyword">instanceof</span> 父类类型</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类加载器的种类</p>
</blockquote>
<ol>
<li>启动类加载器（Bootstrap ClassLoader），或者说引导类加载器、根加载器。该类加载器在 JVM 中通常使用 C/C++ 语言原生实现，是 JVM 自带的类加载器（是 JVM 的一部分）。</li>
<li>其他的类加载器。这些类加载器由 Java 语言实现，不在 JVM 中，并且都继承自 <code>java.lang.ClassLoader</code>。</li>
</ol>
<blockquote>
<p>几个系统级别的类加载器</p>
</blockquote>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：这个类加载器负责将存放在 <code>$&#123;JAVA_HONE&#125;\lib</code> <strong>目录中</strong>，或者被 <code>-XbootstrapPath</code> 参数所指定的 <strong>目录中</strong>，并且是虚拟机 <strong>基于一定规则</strong>（如文件名称规则，如 rt.jar）标识的 <strong>类库</strong> 加载到虚拟机内存中。该类加载器无法通过 Java 程序直接获取，如果想委派到启动类加载器直接使用 <code>null</code> 替代即可。</li>
<li>扩展类加载器（Extension ClassLoader）：该类加载器由 <code>sun.misc.Launcher</code> 的静态嵌套类 <code>ExtClassLoader</code> 实现。它负责将 <code>$&#123;JAVA_HONE&#125;\lib\ext</code> 目录下或通过 <code>-Djava.ext.dirs</code> 参数指定的目录下的所有类库装入工作库。开发者可以直接使用此加载器。Java 9 移除了拓展机制，ExtClassLoader 被 PlatformClassLoader 取代，PlatformClassLoader 主要用于加载 Java 平台模块中的类，包括 <code>java.sql</code>、<code>java.xml</code> 中的类。</li>
<li>应用类加载器（Application ClassLoader）：该类加载器由 <code>sun.misc.Launcher</code> 的静态嵌套类 <code>AppClassLoader</code> 实现，由于该类加载器的实例是 <code>ClassLoader</code> 中静态方法 <code>getSystemClassLoader()</code> 中的返回值，因此这个类加载器也被成为 <strong>系统类加载器</strong>。它负责加载用户类路径（ClassPath）或 <code>-Djava.class.path</code> 所指的目录下的所有类库装入工作库，是最常用的加载器。开发者也可以直接使用此加载器。如果程序中没有自定义类加载器，一般情况下该类加载器就是程序中默认使用的类加载器。</li>
<li>线程上下文类加载器（Thread Context ClassLoader）：后面再说。 😉</li>
</ul>
<blockquote>
<p>类加载器之间的关系</p>
</blockquote>
<p>扩展类加载器（Extension ClassLoader）、应用类加载器（Application ClassLoader）以及用户自定义的类加载器都将显式继承抽象类 <code>java.lang.ClassLoader</code>，它们显式拥有一个“父”类加载器，可以将类加载请求直接委派给“父”类加载器 <code>java.lang.ClassLoader</code>。</p>
<p>启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）和应用类加载器（Application ClassLoader）这三者之间并不是继承关系，而是 <strong>组合</strong> 关系。应用类加载器（Application ClassLoader）显式拥有一个“父”类加载器，即扩展类加载器（Extension ClassLoader），而扩展类加载器（Extension ClassLoader）的“父”类加载器则 <strong>隐式</strong> 指向启动类加载器（Bootstrap ClassLoader）。</p>
<h1 id="3-双亲委派模型"><a class="header-anchor" href="#3-双亲委派模型"></a>3. 双亲委派模型</h1>
<h2 id="3-1-基本概念"><a class="header-anchor" href="#3-1-基本概念"></a>3.1 基本概念</h2>
<p>编写的 Java 程序都是由上面四种类加载器相互配合进行类加载的，当然还可以自定义类加载器。其中，启动类加载器、拓展类加载器、系统类加载器和自定义类加载器的关系如下：</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/JavaImages/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.webp" alt="类加载器工作流程"></p>
<p>像上图这样的层次关系被称为 <strong>双亲委派模型（Parents Delegation Model）</strong>，类加载器之间使用双亲委派模型来协作工作。</p>
<p>从 <strong>双亲委派模型</strong> 这个词上来说，可能存在以下误解：</p>
<ul>
<li>“双亲”被误解为存在两个“父/母”类加载器</li>
<li>“Parent”容易被误解为继承关系中的父类</li>
</ul>
<p>除了顶层的启动类加载器（Bootstrap ClassLoader），其他的类加载器有且仅有一个“父”类加载器。类加载器与其“父”类加载器之间的关系不以继承（Inheritance）来实现，而是以组合（Composition）（不是亲爹，最多算干爹🧔‍♂️）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="comment">// Note: VM hardcoded the offset of this field, thus all new fields</span></span><br><span class="line">    <span class="comment">// must be added *after* it.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单验证下类加载器的层次关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Person.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader);</span><br><span class="line">    System.out.println(classLoader.getParent());</span><br><span class="line">    System.out.println(classLoader.getParent().getParent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<pre>
sun.misc.Launcher$AppClassLoader@18b4aac2
sun.misc.Launcher$ExtClassLoader@5caf905d
null    
</pre>
<p>结果符合我们的预期，而最后打印出的 <code>null</code> 说明了 <code>classLoader.getParent()</code> 指的是启动类加载器，因为它没有父类加载器。</p>
<h2 id="3-2-工作机制"><a class="header-anchor" href="#3-2-工作机制"></a>3.2 工作机制</h2>
<p>对于双亲委派模型来说，有几点需要明白：</p>
<ul>
<li>每个 Class 都有对应的 ClassLoader</li>
<li>除 Bootstrap ClassLoader 外（因为它是最顶层的类加载器），每个 ClassLoader 都有一个“父”类加载器（Parent ClassLoader）</li>
<li>对于一个类加载请求，总是优先委派给“父”类加载器来尝试加载（有事干爹先上！💪）</li>
<li>对于用于自定义的类加载器，默认的“父”类加载器是 Application ClassLoader</li>
</ul>
<p>那双亲委派模型的具体工作机制是怎样的呢？</p>
<p>当一个类加载器收到了类加载请求时，它不会自己尝试去加载这个类，而是把这个请求委派给它的父类加载器，直到请求传递到顶层的启动类加载器。如果父类加载器无法完成当前的类加载请求（在它的搜索范围内没有找到需要加载的类），那么父类加载器又会把类加载请求委派给它的子类加载器。当然也可能直到最后这个类加载请求也没法完成，这时就会抛出 <code>ClassNotFoundException</code> 异常。</p>
<p>这里还需要引出 <strong>类缓存</strong> 的概念。所谓类缓存，就是“标准的 JavaSE 类加载器可以按要求查找类，一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过 JVM 垃圾回收机制可以回收这些 Class 对象”。</p>
<p>简单来说，类加载器会缓存自己已经加载过的类。当加载一个类时，首先会从缓存中加载，如果缓存中不存在，再按照前面所说的工作机制去加载类。</p>
<h2 id="3-2-优点"><a class="header-anchor" href="#3-2-优点"></a>3.2 优点</h2>
<p>使用双亲委派模型来协调类加载器之间的关系，可以使 Java 类随着加载它的类加载器一起具备一种带有优先级的层次关系。越顶层的类加载器，对其可见的类总是会被优先加载。</p>
<p>假设在 ClassPath 下自定义了一个 <code>java.lang.String</code> 类，而在 JDK 的 <code>rt.jar</code> 中也存在一个同名的类，无论是哪个类加载器加载自定义的 <code>String</code> 类，最终都是委派给处于最顶层的启动类加载器进行加载，也就是最终会加载位于 <code>rt.jar</code> 中的 <code>String</code> 类，而不是自定义的 <code>String</code> 类，这 <strong>保证了 Java 类型体系的稳定性。</strong></p>
<p>也正因如此，<code>java.lang</code> 包下的类在程序的各个类加载器中被加载时都是相等的（来自同一个 class 文件且被同一个类加载器加载）。</p>
<p>如果不这样，<code>java.lang</code> 包下的 <code>java.lang.Object</code> 类被不同的类加载器加载时将不会相等，那么程序中就会出现多个 <code>java.lang.Object</code> 类。由于其他类都会隐式继承 <code>java.lang.Object</code> 类，当存在多个 <code>Object</code> 类时，程序将变得混乱。</p>
<h2 id="3-3-ClassLoader-中的方法"><a class="header-anchor" href="#3-3-ClassLoader-中的方法"></a>3.3 ClassLoader 中的方法</h2>
<blockquote>
<p><code>loadClass()</code></p>
</blockquote>
<p>双亲委派模型的具体实现在 <code>java.lang.ClassLoader</code> 中的 <code>loadClass()</code> 方法里，该方法能够根据类的全限定名来加载并创建一个 <code>Class</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">// 先检查类是否已经被加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123; <span class="comment">// 如果没被加载</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 有父类加载器时，使用父类加载器进行加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 没有父类加载器时，证明父类加载器是启动类加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 父类加载器加载失败时，使用自身的 findClass 方法进行加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 一些耗时、计数等统计</span></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要遵循双亲委派模型，<code>ClassLoader</code> 的子类 <strong>尽量不要重写</strong> 此方法。</p>
<blockquote>
<p><code>defineClass()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br></pre></td></tr></table></figure>
<p>将字节码的字节流转换为一个 <code>Class</code> 对象。</p>
<p>该方法被 <code>final</code> 修饰，子类无法重写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                     ProtectionDomain protectionDomain)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">    <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> defineClassSourceLocation(protectionDomain);</span><br><span class="line">    <span class="comment">// native 方法</span></span><br><span class="line">    Class&lt;?&gt; c = defineClass1(<span class="built_in">this</span>, name, b, off, len, protectionDomain, source);</span><br><span class="line">    postDefineClass(c, protectionDomain);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终通过一个 native 原生方法，将字节流转换为 <code>Class</code> 对象。</p>
<blockquote>
<p><code>findClass()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据类的全限定名，获取字节码二进制流，并创建对应的 <code>Class</code> 对象。</p>
<p>如果遵循双亲委派模型，通常不会重写 <code>loadClass()</code> 方法，而是选择重写 <code>findClass()</code> 方法。</p>
<p><code>findClass()</code> 方法的通常实现逻辑是：</p>
<ul>
<li>根据参数 <code>name</code> 从指定的来源获取字节码的二进制流</li>
<li>然后调用 <code>defineClass()</code> 方法，创建一个 <code>Class</code> 对象</li>
</ul>
<blockquote>
<p><code>findBootstrapClassOrNull()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class&lt;?&gt; findBootstrapClassOrNull(String name)</span><br></pre></td></tr></table></figure>
<p>根据类的全限定名，委派给 Bootstrap ClassLoader 进行类加载。</p>
<p>该方法是包私有的，这意味着如果要将某个类加载请求委派给 Bootstrap ClassLoader，那么必须间接调用类 <code>ClassLoader</code> 中的某个 <code>public</code> 或 <code>protected</code> 方法。</p>
<blockquote>
<p><code>getParent()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title function_">getParent</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;removal&quot;)</span></span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Check access to the parent class loader</span></span><br><span class="line">        <span class="comment">// If the caller&#x27;s class loader is same as this class loader,</span></span><br><span class="line">        <span class="comment">// permission check is performed.</span></span><br><span class="line">        checkClassLoaderPermission(parent, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取当前 <code>ClassLoader</code> 的“父”类加载器。</p>
<p><code>parent</code> 字段是 <code>private final</code> 的，它只能在构造器中被初始化。</p>
<p><code>parent != null</code> 时，调用 <code>parent.loadClass()</code> 方法将加载请求委派给 <code>parent</code>；<code>parent == null</code> 时，调用 <code>findBootstrapClassOrNull()</code> 方法将请求委派给 Bootstrap ClassLoader。</p>
<h2 id="3-4-类加载器的特性"><a class="header-anchor" href="#3-4-类加载器的特性"></a>3.4 类加载器的特性</h2>
<blockquote>
<p>确定类的“唯一性”</p>
</blockquote>
<p>假设使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 表示某个类的全限定名，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 表示加载定义这个类的类加载器。</p>
<p>那么使用二元组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>N</mi><mo separator="true">,</mo><mi>L</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;N, L&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span> 可以用来确定类的唯一性。</p>
<p>如果两个类相等，那么它们应该满足以下条件：</p>
<ul>
<li>全限定名相等</li>
<li>加载这两个类的类加载器是同一个</li>
</ul>
<p>“相等”一词指的是：</p>
<ul>
<li><code>equals()</code> 方法返回 <code>true</code></li>
<li><code>isAssignableFrom()</code> 方法返回 <code>true</code></li>
<li><code>isInstance()</code> 方法返回 <code>true</code></li>
<li><code>instanceof</code> 关键字返回 <code>true</code></li>
</ul>
<blockquote>
<p>传递性</p>
</blockquote>
<p>假设类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 由类加载器 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 定义加载的，那么类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 中所依赖的其他类也将通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 来进行加载。</p>
<p>通过类加载器的传递性，可以从某个入口类开始，不断使用相同的类加载器，展开加载同一个模块或应用中的其他类。</p>
<p><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/JavaImages/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E4%BC%A0%E9%80%92%E6%80%A7.webp" alt="类加载器的传递性"></p>
<p>整体来说，是以某种递归的形式逐步加载所需要的类。</p>
<p>对于类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 而言，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">L_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 被称为 <code>initial ClassLoader</code>，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 则是 <code>define ClassLoader</code>。</p>
<blockquote>
<p>可见性</p>
</blockquote>
<p>如果类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 对于类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 可见，那么加载类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 的类加载器 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>，也可以直接或通过委派间接加载到类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>。</p>
<p>比如，类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 通过 Application ClassLoader 进行加载的，类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 通过 Extension ClassLoader 进行加载的，那么类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 对于类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 是可见的，反过来，类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 对于类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 则是不可见的。</p>
<h2 id="3-5-打破双亲委派模型"><a class="header-anchor" href="#3-5-打破双亲委派模型"></a>3.5 打破双亲委派模型</h2>
<p>双亲委派模型并非是强制性的约束，它更多是推荐给开发者的一种类加载器的实现方式。在某些时候，由于双亲委派模型自身的局限性，此时不得不主动打破双亲委派模型。</p>
<p>在加载类时，如果不按照“自底向上检查是否已加载类，自顶向下尝试加载类”的方式去加载类，那么就可以叫做破坏双亲委派模型。</p>
<p>已经知道加载类的核心方法是抽象类 <code>ClassLoader</code> 中的 <code>loadClass()</code> 方法，可以通过继承这个抽象类并重写 <code>loadClass()</code> 方法，而且不按照双亲委派模型的方式去加载类，那么就可以打破双亲委派模型。</p>
<p>在 Java 发展史上也有双亲委派模型被破坏的情况，比如：</p>
<ol>
<li>由于 <code>java.lang.ClassLoader</code> 在 JDK1.0 中已经存在，所以会有人继承这个抽象类并重写 <code>loadClass()</code> 方法来实现自定义类加载器。为了在 JDK1.2 中引入双亲委派模型并向前兼容，<code>loadClass()</code> 方法必须要保留并且能够被重写，于是在 <code>ClassLoader</code> 类添加了一个新的被 protected 修饰的 <code>findClass()</code> 方法，并告知开发者不要重写 <code>loadClass()</code> 而是重写 <code>findClass()</code>。由于双亲委派模型的具体实现就在 <code>loadClass()</code> 方法内，并未禁止重写这个方法，因此委派的逻辑就被破坏了。</li>
<li>双亲委派模型存在缺陷（Java SPI 机制）：双亲委派模型很好地解决了各个类加载器加载基础类的统一问题（越基础的类由越上层的类加载器加载），这些基础类大多数情况下作为用户调用的基础类库，但 <strong>这些基础类无法回调用户的代码</strong>。以 JDBC 为例，它规定了如何使用 Java 代码来连接数据库，具体的做法需要交由各个数据库厂商实现。JDBC 位于 rt.jar 中，由 Bootstrap ClassLoader 去加载，但其具体实现是在用户定义的 ClassPath 中，只能由 Application ClassLoader 去加载，因此 Bootstrap ClassLoader 只能委托子类加载器去加载数据库厂商们的具体实现，而这就破坏了双亲委派模型。具体实现方式是引入了线程上下文类加载器（Thread Context ClassLoader），可以通过 <code>java.lang.Thread</code> 的 <code>setContextClassLoader()</code> 方法来设置，然后利用 <code>Thread.current.currentThread().getContextClassLoader()</code> 获得类加载器来加载（如果直接获取，将获取到应用程序类加载器）。</li>
<li>用户对应用程序动态性的热切追求：如代码热替换（HotSwap）、热模块部署等，因此催生出 <code>JSR-291</code> 以及它的业界实现 OSGi，而 OSGi 定制了自己的类加载规则，利用自定义类加载器机制来完成模块化热部署，不再遵循双亲委派模型。</li>
</ol>
<h2 id="3-6-数组类的加载"><a class="header-anchor" href="#3-6-数组类的加载"></a>3.6 数组类的加载</h2>
<blockquote>
<p>数组类的本质</p>
</blockquote>
<p>所有的数组实例都属于 <code>Object</code>，每个数组实例都有对应的 <code>Class</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] ia = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    assertThat(ia.getClass().toString())</span><br><span class="line">            .isEqualTo(<span class="string">&quot;class [I&quot;</span>);</span><br><span class="line">    <span class="comment">// 数组类的父类</span></span><br><span class="line">    assertThat(ia.getClass().getSuperclass())</span><br><span class="line">            .isEqualTo(Object.class);</span><br><span class="line">    <span class="comment">// 数组类的父接口</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = ia.getClass().getInterfaces();</span><br><span class="line">    assertThat(interfaces).containsExactly(Cloneable.class, Serializable.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组类的加载</p>
</blockquote>
<p>数组类并不通过类加载器来加载创建，而是通过 JVM 直接创建的，有专门的 JVM 指令 <code>newarray</code>。</p>
<p>如果数组类的元素类型是引用类型，那最终还是要靠类加载器去创建。</p>
<p>数组类的唯一性，依然需要类加载器来确定：和普通类一样，数组类的唯一性同样依靠二元组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>N</mi><mo separator="true">,</mo><mi>L</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;N, L&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span> 来确定，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 是数组类的类名，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 是与数组类相关联的类加载器。</p>
<blockquote>
<p>与数组类关联的类加载器</p>
</blockquote>
<p>假如数组类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 的组件类型是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>，那么与数组类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 关联的类加载器为：</p>
<ul>
<li>
<p>如果组件类型 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 是引用类型，那么 JVM 会将数组类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 和加载组件类型 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 的类加载器关联起来</p>
</li>
<li>
<p>如果组件类型不是引用类型（例如 <code>int</code> 数组），那么 JVM 会将把数组类 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 标记为与 Bootstrap ClassLoader 关联</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">int</span>[] ia = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    Assertions.assertNull(ia.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">    String[] sa = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">    Assertions.assertNull(sa.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">    Driver[] la = <span class="keyword">new</span> <span class="title class_">Driver</span>[<span class="number">0</span>];</span><br><span class="line">    assertThat(la.getClass().getClassLoader().toString())</span><br><span class="line">            .contains(<span class="string">&quot;jdk.internal.loader.ClassLoaders$PlatformClassLoader&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ArrayClassLoaderTest[] aa = <span class="keyword">new</span> <span class="title class_">ArrayClassLoaderTest</span>[<span class="number">0</span>];</span><br><span class="line">    assertThat(aa.getClass().getClassLoader().toString())</span><br><span class="line">            .contains(<span class="string">&quot;jdk.internal.loader.ClassLoaders$AppClassLoader&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">myLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCommonClassLoader</span>(TestUtils.COMMON_PATH);</span><br><span class="line">    Class&lt;?&gt; serviceCls = Class.forName(</span><br><span class="line">            <span class="string">&quot;indi.mofan.app.CompanyService&quot;</span>,</span><br><span class="line">            <span class="literal">true</span>,</span><br><span class="line">            myLoader);</span><br><span class="line"></span><br><span class="line">    Object[] oa = (Object[]) Array.newInstance(serviceCls, <span class="number">0</span>);</span><br><span class="line">    assertThat(oa.getClass().getClassLoader()).isEqualTo(myLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-7-类加载器与-Tomcat"><a class="header-anchor" href="#3-7-类加载器与-Tomcat"></a>3.7 类加载器与 Tomcat</h2>
<blockquote>
<p>什么场景下使用类加载器？</p>
</blockquote>
<p>在一些系统中，需要加载各种厂商提供的类。</p>
<p>为了防止代码被篡改，这个时候需要进行类加载器的定制，在进行类加载之前，需要先对每个类的类文件进行签名验证。</p>
<p>除此之外，某些关键服务是不允许随便停机的，这就需要进行程序的热更新，这就需要定制类加载器优先加载最新版本的代码，甚至需要优先通过网络下载最新的代码。</p>
<blockquote>
<p>打破双亲委派模型的方式</p>
</blockquote>
<ul>
<li>主动违背类加载器的“传递依赖”原则。例如在一个 Bootstrap ClassLoader 加载的类中，又通过 Application ClassLoader 来加载所依赖的其它类，这就打破了双亲委派模型中的层次结构，逆转了类之间的可见性。典型的是 Java SPI 机制，它在类 ServiceLoader 中，会使用线程上下文类加载器来逆向加载 ClassPath 中的第三方厂商提供的 Service Provider 类。</li>
<li>第二种方式是自定义一个类加载器的类，重写抽象类 <code>java.lang.ClassLoader</code> 中的 <code>loadClass()</code>方法，不再优先委派“父”加载器进行类加载。</li>
</ul>
<blockquote>
<p>为什么说 Tomcat 打破了双亲委派模型</p>
</blockquote>
<p>在使用 Tomcat 时，可以部署多个 war 包，每个 war 包分别代表了不同的 WebApp，可以通过不同的 <code>context-path</code> 来区分。</p>
<p>如果两个 war 包中有相同名称的两个类，比如都是 <code>indi.mofan.User</code>，但它们的实现版本却不一样，比方一个有 <code>userId</code> 字段，另一个没有。</p>
<p>Tomcat 为了保证它们不会冲突，会为每个 WebApp 创建一个类加载器实例。对应的类型是 WebApp ClassLoader，它重写了 <code>loadClass()</code> 方法，优先加载当前 WebApp 中的类，包括目录 <code>/WEB-INF/classes</code> 以及 <code>/WEB-INF/lib</code> 中 jar 包。只有在当前 WebApp 中找不到对应的类时，才委派给上一层<br>
的“父”类加载器，这样就做到了 WebApp 之间的类隔离。</p>
<blockquote>
<p>Tomcat 支持的版本是固定的，比如 Tomcat 9.0 支持 Servlet 4.0，而 Tomcat 10.0 则支持 Servlet 5.0。如果 WebApp 的 war 包中也包含了一个 servlet-api 的 jar 包，那如何保证 WebApp 只会加载到 Tomcat 支持的 servlet-api 呢？因为先前不是说 WebApp ClassLoader 是会优先加载当前应用目录下的类吗？</p>
</blockquote>
<p>Tomcat 作为 WebApp 的宿主进程，有一些内部公共类是对 Tomcat 自身以及所有的 WebApp 是可见的。针对这部分类，Tomcat 在 WebApp ClassLoader 之上，加了一个“父”类加载器 —— Common ClassLoader。</p>
<p>对于 JavaEE API 的核心实现类（Servlet、JSP、EL、WebSocket）是不允许 WebApp ClassLoader 直接加载的，而是先委派给“父”类加载器 Common ClassLoader 进行加载。对于 JDK 中的类，也不允许 WebAppClassLoader 直接加载，会先委派给 JDK 内置的 Extension ClassLoader 或 Bootstrap ClassLoader 先尝试加载。</p>
<p>Tomcat 中默认的类加载器结构：</p>
<pre><code class="highlight mermaid">flowchart BT
bootstrap[&quot;Bootstrap ClassLoader&quot;]
extension[&quot;Extension ClassLoader&quot;]
application[&quot;Application ClassLoader&quot;]
common[&quot;Common ClassLoader&quot;]
webapp1[&quot;WebApp1 ClassLoader&quot;]
webapp2[&quot;WebApp2 ClassLoader&quot;]

common --&gt; application --&gt; extension --&gt; bootstrap
webapp1 --&gt; common
webapp2 --&gt; common</code></pre>
<p>因此，从 WebApp 的角度来看，类的加载顺序应该是这样的：</p>
<ul>
<li>JDK 中的核心类以及扩展类，直接委派给 JDK 内置的 Extension ClassLoader 或 Bootstrap ClassLoader 进行加载</li>
<li>JavaEE API 的核心实现类（Servlet、JSP、EL、WebSocket）委派给 Common ClassLoader 进行加载</li>
<li>WebApp 中 <code>/WEB-INF/classes/</code> 目录和 <code>/WEB-INF/lib/*.jar</code>中的类由 WebApp ClassLoader 进行加载</li>
<li>Tomcat 服务器进程的 ClassPath 中的类，委派给 JDK 内置的 Application ClassLoader 进行加载</li>
<li>Tomcat 和 WebApp 共享的内部公共类，委派给 Common ClassLoader 进行加载</li>
</ul>
<blockquote>
<p>Tomcat 中还有哪些类加载器？</p>
</blockquote>
<p>Tomcat 还提供了 Server ClassLoader 和 Shared ClassLoader。</p>
<p>在默认配置中，这两个类加载器是未定义的，需要在配置文件 <code>conf/catalina.properties</code> 中，通过配置项  <code>server.loader</code> 和 <code>shared.loader</code> 分别配置这两个类加载器的加载目录或 jar 包。</p>
<p>考虑到在不同的 WebApp 中也可以共享一些依赖类库，比如 MySQL 相关的类就可以在不同的 WebApp 之间共享，如果它们的版本相同，就没必要在每个 WebApp 都独自加载一份。此时可以将 MySQL 的相关 jar 包部署在 <code>shared.loader</code> 指定的共享目录下，当 WebApp ClassLoader 自身没有加载到某个类时，就会委派给 Shared ClassLoader 去加载。</p>
<p>如果还想隔绝 WebApp 与 Tomcat 本身的内部类，可以使用 Server ClassLoader 来加载 Tomcat 本身的内部类。</p>
<p>经过拓展，Tomcat 的类加载器结构：</p>
<pre><code class="highlight mermaid">flowchart BT
bootstrap[&quot;Bootstrap ClassLoader&quot;]
extension[&quot;Extension ClassLoader&quot;]
application[&quot;Application ClassLoader&quot;]
common[&quot;Common ClassLoader&quot;]
server[&quot;Server ClassLoader&quot;]:::dash
shared[&quot;Shared ClassLoader&quot;]:::dash
webapp1[&quot;WebApp1 ClassLoader&quot;]
webapp2[&quot;WebApp2 ClassLoader&quot;]

shared --&gt; common --&gt; application --&gt; extension --&gt; bootstrap
server --&gt; common
webapp1 --&gt; shared
webapp2 --&gt; shared

classDef dash stroke-dasharray: 5 5</code></pre>
<p>在结构图中 Server ClassLoader 对 WebApp 而言是不可见的，换言之，WebApp 是无法使用部署在 <code>server.loader</code> 中的类。</p>
<h1 id="4-反射"><a class="header-anchor" href="#4-反射"></a>4. 反射</h1>
<h2 id="4-1-几个相关的类"><a class="header-anchor" href="#4-1-几个相关的类"></a>4.1 几个相关的类</h2>
<ul>
<li><code>java.lang.Class</code>，代表一个类。</li>
<li><code>java.lang.reflect.Method</code>，代表类的方法。</li>
<li><code>java.lang.reflect.Field</code>，代表类的成员变量。</li>
<li><code>java.lang.reflect.Constructor</code>，代表类的构造器。</li>
</ul>
<h2 id="4-2-Class-类"><a class="header-anchor" href="#4-2-Class-类"></a>4.2 Class 类</h2>
<p>通过类的 Class 类可以知道这个类的：</p>
<ul>
<li>属性；</li>
<li>方法和构造器；</li>
<li>实现了哪些接口。</li>
</ul>
<p>对于每个类而言，JRE 都为其保留了一个不变的 Class 属性的对象。一个 Class 对象包含了特定某个结构（class/interface/enum/annotation/primitive type/void/[]）的有关信息。</p>
<p>需要注意的是：</p>
<ul>
<li>Class 类本身也是一个类；</li>
<li>Class 对象只能由系统建立对象；</li>
<li>一个加载的类在 JVM 中只会有一个 Class 实例；</li>
<li>一个 Class 对象对应的是一个加载到 JVM 中的一个 <code>.class</code> 文件；</li>
<li>可以通过任意一个类的实例获取到这个类的 Class 类；</li>
<li>通过 Class 对象可以完整地得到某一个类中所有被加载的结构；</li>
<li>Class 类是反射的根源，要想进行反射，得先获取到对应的 Class 对象。</li>
</ul>
<h2 id="4-3-如何获取-Class-类的实例"><a class="header-anchor" href="#4-3-如何获取-Class-类的实例"></a>4.3 如何获取 Class 类的实例</h2>
<p>若已知具体的类，通过类的 <code>class</code> 属性获取。该方法最为可靠，程序性能最高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br></pre></td></tr></table></figure>
<p>已知某个类的实例，调用该实例的 <code>getClass()</code> 方法获取 <code>Class</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> person.getClass();</span><br></pre></td></tr></table></figure>
<p>已知一个类的全限定名，且该类在类路径下，可通过 <code>Class</code> 类的静态方法获取 <code>forName()</code> 获取。这一方法可能抛出 <code>ClassNotFoundException</code> 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.yang.reflect.Person&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>内置基本数据类型可以直接用 <code>类名.Type</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Integer&gt; type = Integer.TYPE;</span><br></pre></td></tr></table></figure>
<p>还可以利用 <code>ClassLoader</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">&quot;indi.mofan.domain.Person&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>拥有 <code>Class</code> 对象的类型：外部类、成员（成员内部类、静态嵌套类）、局部内部类、匿名内部类、接口、数组、枚举、注解、基本数据类型，void。</p>
<h2 id="4-4-使用反射获取对象的信息"><a class="header-anchor" href="#4-4-使用反射获取对象的信息"></a>4.4 使用反射获取对象的信息</h2>
<p>给定一个 Person 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;<span class="built_in">this</span>.id = id;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;<span class="built_in">this</span>.name = name;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;<span class="keyword">return</span> age;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;<span class="built_in">this</span>.age = age;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用反射创建 Person 对象，并调用该对象的方法、修改该对象成员变量的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获得class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.yang.reflect.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造一个对象</span></span><br><span class="line"><span class="comment">//        Person person = (Person) c1.newInstance();</span></span><br><span class="line"><span class="comment">//        System.out.println(person);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过构造器创建对象</span></span><br><span class="line"><span class="comment">//        Constructor constructor = c1.getDeclaredConstructor(int.class, String.class, int.class);</span></span><br><span class="line"><span class="comment">//        Person person2 = (Person) constructor.newInstance(1,&quot;Yang&quot;,18);</span></span><br><span class="line"><span class="comment">//        System.out.println(person2);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射调用普通方法</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person3</span> <span class="operator">=</span> (Person) c1.newInstance();</span><br><span class="line">        <span class="comment">// 通过反射获取方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">setName</span> <span class="operator">=</span> c1.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// invoke: 激活</span></span><br><span class="line">        <span class="comment">//（对象 ， “方法的值”）</span></span><br><span class="line">        setName.invoke(person3,<span class="string">&quot;mofan&quot;</span>);</span><br><span class="line">        System.out.println(person3.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射操作属性</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person4</span> <span class="operator">=</span> (Person) c1.newInstance();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 不能直接操作私有属性，需要关闭程序的安全检测，</span></span><br><span class="line">        <span class="comment">// 使属性或者方法的setAccessible为true，可提高执行效率</span></span><br><span class="line">        <span class="keyword">if</span> (!name.isAccessible()) &#123;</span><br><span class="line">            name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        name.set(person4,<span class="string">&quot;Yang_2&quot;</span>);</span><br><span class="line">        System.out.println(person4.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用 <code>isAccessible()</code> 方法可以判断 <strong>是否关闭 Java 语言访问控制的检查</strong>，关闭后才能操作私有属性。当未关闭安全检测时，可以使用 <code>setAccessible()</code> 方法并传入 <code>true</code> 表示关闭检查。</p>
<p>在 JDK 9 之后 <code>isAccessible()</code> 方法被废弃，废弃原因是它的方法名称不够准确，会让人觉得此方法用于检查反射的对象是否可访问，而实际上并非如此，作为代替，引入了 <code>canAccess()</code> 方法。</p>
<p><code>canAccess()</code> 方法可以接收一个 <code>Object</code> 类型的参数，如果判断的是一个实例对象的方法或字段，应当传入此实例对象，反之传入 <code>null</code> 即可。</p>
<h2 id="4-5-使用反射获取注解信息"><a class="header-anchor" href="#4-5-使用反射获取注解信息"></a>4.5 使用反射获取注解信息</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.yang.reflect.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射获得注解</span></span><br><span class="line">        Annotation[] annotations = c1.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得注解的 value 的值</span></span><br><span class="line">        <span class="type">Tableyang</span> <span class="variable">tableyang</span> <span class="operator">=</span> (Tableyang) c1.getAnnotation(Tableyang.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> tableyang.value();</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类指定的注解</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">Fieldyang</span> <span class="variable">annotation</span> <span class="operator">=</span> name.getAnnotation(Fieldyang.class);</span><br><span class="line">        System.out.println(annotation.columnName());</span><br><span class="line">        System.out.println(annotation.type());</span><br><span class="line">        System.out.println(annotation.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Tableyang(&quot;db_student&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="meta">@Fieldyang(columnName = &quot;db_id&quot;,type = &quot;int&quot;,length = 10)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="meta">@Fieldyang(columnName = &quot;db_age&quot;,type = &quot;int&quot;,length = 2)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="meta">@Fieldyang(columnName = &quot;db_name&quot;,type = &quot;varchar&quot;,length = 8)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;<span class="built_in">this</span>.id = id;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;<span class="keyword">return</span> age;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;<span class="built_in">this</span>.age = age;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;<span class="built_in">this</span>.name = name;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类名的注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Tableyang&#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性的注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Fieldyang&#123;</span><br><span class="line">    String <span class="title function_">columnName</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">type</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@com.yang.reflect.Tableyang(value=db_student)</span><br><span class="line">db_student</span><br><span class="line">db_name</span><br><span class="line">varchar</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h2 id="4-6-Class-的各种-name"><a class="header-anchor" href="#4-6-Class-的各种-name"></a>4.6 Class 的各种 name</h2>
<p>参考链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/15202997/what-is-the-difference-between-canonical-name-simple-name-and-class-name-in-jav/15203417#">What is the difference between canonical name, simple name and class name in Java Class? </a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Goodbye_Youth/article/details/83536840">Class类 getName()、getCanonicalName()、getSimpleName()、getTypeName() 方法的异同</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lolichan/article/details/84926335">本地类</a></li>
</ul>
<p>在 <code>Class</code> 中有 <code>getName()</code>、<code>getCanonicalName()</code>、<code>getSimpleName()</code> 以及 JDK8 中新增的 <code>getTypeName()</code> 方法。</p>
<blockquote>
<p><code>getName()</code></p>
</blockquote>
<p><code>getName()</code> 返回的信息可以在动态加载某个类时使用。比如使用默认的 <code>ClassLoader</code> 调用 <code>Class.forName()</code> 方法来加载某个类。在某个 <code>ClassLoader</code> 的范围内，所有类 <code>getName()</code> 返回的信息唯一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="built_in">this</span>.name;</span><br><span class="line">    <span class="keyword">return</span> name != <span class="literal">null</span> ? name : initClassName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache the name to reduce the number of calls into the VM.</span></span><br><span class="line"><span class="comment">// This field would be set by VM itself during initClassName call.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> String <span class="title function_">initClassName</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>getCanonicalName()</code></p>
</blockquote>
<p><code>getCanonicalName()</code> 返回的信息可以在 <code>import</code> 语句中使用，也能在 <code>toString()</code> 方法或日志操作时使用。 <mark>注意：</mark> 在一个 <code>ClassLoader</code> 中，<code>getCanonicalName()</code> 返回的信息并不能用来唯一标识一个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getCanonicalName</span><span class="params">()</span> &#123;</span><br><span class="line">    ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class="line">    <span class="type">String</span> <span class="variable">canonicalName</span> <span class="operator">=</span> rd.canonicalName;</span><br><span class="line">    <span class="keyword">if</span> (canonicalName == <span class="literal">null</span>) &#123;</span><br><span class="line">        rd.canonicalName = canonicalName = getCanonicalName0();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> canonicalName == ReflectionData.NULL_SENTINEL? <span class="literal">null</span> : canonicalName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心实现</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getCanonicalName0</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isArray()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">canonicalName</span> <span class="operator">=</span> getComponentType().getCanonicalName();</span><br><span class="line">        <span class="keyword">if</span> (canonicalName != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> canonicalName + <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ReflectionData.NULL_SENTINEL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isHidden() || isLocalOrAnonymousClass())</span><br><span class="line">        <span class="keyword">return</span> ReflectionData.NULL_SENTINEL;</span><br><span class="line">    Class&lt;?&gt; enclosingClass = getEnclosingClass();</span><br><span class="line">    <span class="keyword">if</span> (enclosingClass == <span class="literal">null</span>) &#123; <span class="comment">// top level class</span></span><br><span class="line">        <span class="keyword">return</span> getName();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">enclosingName</span> <span class="operator">=</span> enclosingClass.getCanonicalName();</span><br><span class="line">        <span class="keyword">if</span> (enclosingName == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ReflectionData.NULL_SENTINEL;</span><br><span class="line">        <span class="type">String</span> <span class="variable">simpleName</span> <span class="operator">=</span> getSimpleName();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(enclosingName.length() + simpleName.length() + <span class="number">1</span>)</span><br><span class="line">            .append(enclosingName)</span><br><span class="line">            .append(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            .append(simpleName)</span><br><span class="line">            .toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>isArray()</code> 判断该 Class 对象是否为数组。</p>
<p><code>getComponentType()</code> 返回数组中元素的 Class 对象，如果该对象不是数组，则返回 <code>null</code>。</p>
<p><code>isHidden()</code> 是 JDK15 新增的方法，用于判断一个类是否是隐藏类，像 Lambda 表达式、方法引用就是隐藏类。</p>
<p><code>isLocalOrAnonymousClass()</code> 判断该 Class 对象是否为本地类（定义在一个代码块中的类，比如定义在方法中、静态代码块中）或匿名类。匿名类和本地类在 Java 中无法呈现出类结构，所在位置不能通过名称表示出来，因此 <code>getCanonicalName()</code> 返回 <code>null</code>。</p>
<p><code>getEnclosingClass()</code> 返回该 Class 对象的封装 Class 对象，如果该 Class 对象是顶级类，则返回 <code>null</code>。</p>
<blockquote>
<p><code>getSimpleName()</code></p>
</blockquote>
<p><code>getSimpleName()</code> 返回的信息可以 <strong>不精准地</strong> 来标识一个类，因此不能保证唯一性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getSimpleName</span><span class="params">()</span> &#123;</span><br><span class="line">    ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class="line">    <span class="type">String</span> <span class="variable">simpleName</span> <span class="operator">=</span> rd.simpleName;</span><br><span class="line">    <span class="keyword">if</span> (simpleName == <span class="literal">null</span>) &#123;</span><br><span class="line">        rd.simpleName = simpleName = getSimpleName0();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> simpleName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心实现</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getSimpleName0</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isArray()) &#123;</span><br><span class="line">        <span class="keyword">return</span> getComponentType().getSimpleName() + <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">simpleName</span> <span class="operator">=</span> getSimpleBinaryName();</span><br><span class="line">    <span class="keyword">if</span> (simpleName == <span class="literal">null</span>) &#123; <span class="comment">// top level class</span></span><br><span class="line">        simpleName = getName();</span><br><span class="line">        simpleName = simpleName.substring(simpleName.lastIndexOf(<span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span>); <span class="comment">// strip the package name</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> simpleName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getSimpleBinaryName()</code> 返回该 Class 对象的简单二进制名称。如果该 Class 对象是顶级类，则返回 <code>null</code>；否则以顶级类 <code>getName()</code> 信息的长度为开始截取索引，截取该 Class 对象的 <code>getName()</code> 信息（这是 JDK 8 里的逻辑，JDK 17 中由本地方法实现）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">getSimpleBinaryName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isTopLevelClass())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getSimpleBinaryName0();</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>) <span class="comment">// anonymous class</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑由本地方法实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> String <span class="title function_">getSimpleBinaryName0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>getTypeName()</code></p>
</blockquote>
<p><code>getTypeName()</code> 返回此类型名称的信息字符串，就像 <code>toString()</code> 一样，表示纯粹的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getTypeName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isArray()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; cl = <span class="built_in">this</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">dimensions</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                dimensions++;</span><br><span class="line">                cl = cl.getComponentType();</span><br><span class="line">            &#125; <span class="keyword">while</span> (cl.isArray());</span><br><span class="line">            <span class="keyword">return</span> cl.getName() + <span class="string">&quot;[]&quot;</span>.repeat(dimensions);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">/*FALLTHRU*/</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例对比</p>
</blockquote>
<p>目标测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetNameTestClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalClassInMethod</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;LocalClassInMethod&gt; localClazz = LocalClassInMethod.class;</span><br><span class="line">        System.out.println(localClazz.getName());</span><br><span class="line">        System.out.println(localClazz.getCanonicalName());</span><br><span class="line">        System.out.println(localClazz.getSimpleName());</span><br><span class="line">        System.out.println(localClazz.getTypeName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalClassInStaticBlock</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;LocalClassInStaticBlock&gt; localClazz = LocalClassInStaticBlock.class;</span><br><span class="line">        System.out.println(localClazz.getName());</span><br><span class="line">        System.out.println(localClazz.getCanonicalName());</span><br><span class="line">        System.out.println(localClazz.getSimpleName());</span><br><span class="line">        System.out.println(localClazz.getTypeName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;ConstantValue&quot;, &quot;InstantiationOfUtilityClass&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    Class&lt;Integer&gt; intClazz = <span class="type">int</span>.class;</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;int&quot;</span>, intClazz.getName());</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;int&quot;</span>, intClazz.getCanonicalName());</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;int&quot;</span>, intClazz.getSimpleName());</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;int&quot;</span>, intClazz.getTypeName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本类型数组</span></span><br><span class="line">    Class&lt;<span class="type">byte</span>[]&gt; byteClazz = <span class="type">byte</span>[].class;</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;[B&quot;</span>, byteClazz.getName());</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;byte[]&quot;</span>, byteClazz.getCanonicalName());</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;byte[]&quot;</span>, byteClazz.getSimpleName());</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;byte[]&quot;</span>, byteClazz.getTypeName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串数组</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">String</span>[]&gt; stringArrayClazz = String[].class;</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;[Ljava.lang.String;&quot;</span>, stringArrayClazz.getName());</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;java.lang.String[]&quot;</span>, stringArrayClazz.getCanonicalName());</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;String[]&quot;</span>, stringArrayClazz.getSimpleName());</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;java.lang.String[]&quot;</span>, stringArrayClazz.getTypeName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通类</span></span><br><span class="line">    Class&lt;GetNameTestClass&gt; clazz = GetNameTestClass.class;</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;indi.mofan.pojo.GetNameTestClass&quot;</span>, clazz.getName());</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;indi.mofan.pojo.GetNameTestClass&quot;</span>, clazz.getCanonicalName());</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;GetNameTestClass&quot;</span>, clazz.getSimpleName());</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;indi.mofan.pojo.GetNameTestClass&quot;</span>, clazz.getTypeName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    Class&lt;GetNameTestClass.Inner&gt; innerClazz = GetNameTestClass.Inner.class;</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;indi.mofan.pojo.GetNameTestClass$Inner&quot;</span>, innerClazz.getName());</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;indi.mofan.pojo.GetNameTestClass.Inner&quot;</span>, innerClazz.getCanonicalName());</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;Inner&quot;</span>, innerClazz.getSimpleName());</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;indi.mofan.pojo.GetNameTestClass$Inner&quot;</span>, innerClazz.getTypeName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名内部类</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Runnable</span>&gt; runnableClazz = <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.getClass();</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;indi.mofan.reflection.JavaReflectionUtilTest$1&quot;</span>, runnableClazz.getName());</span><br><span class="line">    Assertions.assertNull(runnableClazz.getCanonicalName());</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;&quot;</span>, runnableClazz.getSimpleName());</span><br><span class="line">    Assertions.assertEquals(<span class="string">&quot;indi.mofan.reflection.JavaReflectionUtilTest$1&quot;</span>, runnableClazz.getTypeName());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;静态代码块本地类: &quot;</span>);</span><br><span class="line">    <span class="type">GetNameTestClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetNameTestClass</span>();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;静态方法中的本地类: &quot;</span>);</span><br><span class="line">    GetNameTestClass.fun();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Lambda 表达式: &quot;</span>);</span><br><span class="line">    Supplier&lt;String&gt; supplier = () -&gt; <span class="string">&quot;Function&quot;</span>;</span><br><span class="line">    <span class="type">var</span> <span class="variable">supplierClazz</span> <span class="operator">=</span> supplier.getClass();</span><br><span class="line">    System.out.println(supplierClazz.getName());</span><br><span class="line">    System.out.println(supplierClazz.getCanonicalName());</span><br><span class="line">    System.out.println(supplierClazz.getSimpleName());</span><br><span class="line">    System.out.println(supplierClazz.getTypeName());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;方法引用: &quot;</span>);</span><br><span class="line">    Function&lt;Integer, String&gt; fun = String::valueOf;</span><br><span class="line">    <span class="type">var</span> <span class="variable">funClazz</span> <span class="operator">=</span> fun.getClass();</span><br><span class="line">    System.out.println(funClazz.getName());</span><br><span class="line">    System.out.println(funClazz.getCanonicalName());</span><br><span class="line">    System.out.println(funClazz.getSimpleName());</span><br><span class="line">    System.out.println(funClazz.getTypeName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试方法后，测试通过，控制台打印出：</p>
<pre>
静态代码块本地类: 
indi.mofan.pojo.GetNameTestClass$1LocalClassInStaticBlock
null
LocalClassInStaticBlock
indi.mofan.pojo.GetNameTestClass$1LocalClassInStaticBlock
静态方法中的本地类: 
indi.mofan.pojo.GetNameTestClass$1LocalClassInMethod
null
LocalClassInMethod
indi.mofan.pojo.GetNameTestClass$1LocalClassInMethod
Lambda 表达式: 
indi.mofan.reflection.JavaReflectionUtilTest$$Lambda$356/0x0000000800ca8c58
null
JavaReflectionUtilTest$$Lambda$356/0x0000000800ca8c58
indi.mofan.reflection.JavaReflectionUtilTest$$Lambda$356/0x0000000800ca8c58
方法引用: 
indi.mofan.reflection.JavaReflectionUtilTest$$Lambda$357/0x0000000800ca8e78
null
JavaReflectionUtilTest$$Lambda$357/0x0000000800ca8e78
indi.mofan.reflection.JavaReflectionUtilTest$$Lambda$357/0x0000000800ca8e78
</pre>
<h2 id="4-7-获取类的泛型信息"><a class="header-anchor" href="#4-7-获取类的泛型信息"></a>4.7 获取类的泛型信息</h2>
<blockquote>
<p><code>getGenericSuperclass()</code></p>
</blockquote>
<p><code>getGenericSuperclass()</code> 方法用于获取含有泛型信息的父类，如果父类不含泛型信息，该方法等价于 <code>getSuperclass()</code> 方法。</p>
<p>在测试类 <code>GetGenericInfoTest</code> 中有这样两个静态嵌套类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyList</span> <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&lt;String&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyLinkList</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">LinkedList</span>&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别获取 <code>MyList</code> 和 <code>MyLinkList</code> 含有泛型信息的父类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetGenericSuperclass</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> MyList.class.getGenericSuperclass();</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;java.util.ArrayList&lt;java.lang.String&gt;&quot;</span>, </span><br><span class="line">                        genericSuperclass.toString());</span><br><span class="line">    Assert.assertTrue(genericSuperclass <span class="keyword">instanceof</span> ParameterizedType);</span><br><span class="line">    <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) genericSuperclass;</span><br><span class="line">    Assert.assertArrayEquals(<span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;String.class&#125;, </span><br><span class="line">                             parameterizedType.getActualTypeArguments());</span><br><span class="line">    Assert.assertEquals(ArrayList.class, parameterizedType.getRawType());</span><br><span class="line">    Assert.assertNull(parameterizedType.getOwnerType());</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;java.util.ArrayList&lt;java.lang.String&gt;&quot;</span>, </span><br><span class="line">                        parameterizedType.getTypeName());</span><br><span class="line"></span><br><span class="line">    genericSuperclass = MyLinkList.class.getGenericSuperclass();</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;java.util.LinkedList&lt;T&gt;&quot;</span>, genericSuperclass.toString());</span><br><span class="line">    Assert.assertTrue(genericSuperclass <span class="keyword">instanceof</span> ParameterizedType);</span><br><span class="line">    parameterizedType = (ParameterizedType) genericSuperclass;</span><br><span class="line">    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>, actualTypeArguments.length);</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;T&quot;</span>, actualTypeArguments[<span class="number">0</span>].toString());</span><br><span class="line">    Assert.assertEquals(LinkedList.class, parameterizedType.getRawType());</span><br><span class="line">    Assert.assertNull(parameterizedType.getOwnerType());</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;java.util.LinkedList&lt;T&gt;&quot;</span>, parameterizedType.getTypeName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 <code>MyList</code> 来说，其父类是 <code>ArrayList</code>，不含泛型参数，其泛型是确切的 <code>String</code> 类型，因此 <code>ParameterizedType</code> 对象的 <code>getActualTypeArguments()</code> 方法返回的是含有 <code>String.class</code> 的数组。由于 <code>ArrayList</code> 不是某个类的嵌套类，因此 <code>getOwnerType()</code> 方法的返回结果是 <code>null</code>。</p>
<p>对 <code>MyLinkList</code> 来说，其父类是 <code>LinkedList</code>，含有泛型参数 <code>T</code>，因此 <code>ParameterizedType</code> 对象的 <code>getActualTypeArguments()</code> 方法返回的信息中含有泛型参数 <code>T</code>。<code>LinkedList</code> 也不是某个类的嵌套类，<code>getOwnerType()</code> 方法的返回结果也是 <code>null</code>。</p>
<p>如果要获取实现的接口的泛型信息呢？还可以使用 <code>getGenericSuperclass()</code> 方法吗？</p>
<p>比如在测试类 <code>GetGenericInfoTest</code> 中有以下接口和嵌套类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span>&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyInterfaceImpl_1</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&lt;String&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyInterfaceImpl_2</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试使用 <code>getGenericSuperclass()</code> 方法获取 <code>MyInterfaceImpl_1</code> 和 <code>MyInterfaceImpl_2</code> 的实现的接口的泛型信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetGenericSuperclass_2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> MyInterface.class.getGenericSuperclass();</span><br><span class="line">    Assert.assertNull(genericSuperclass);</span><br><span class="line"></span><br><span class="line">    genericSuperclass = MyInterfaceImpl_1.class.getGenericSuperclass();</span><br><span class="line">    Assert.assertFalse(genericSuperclass <span class="keyword">instanceof</span> ParameterizedType);</span><br><span class="line"></span><br><span class="line">    genericSuperclass = MyInterfaceImpl_2.class.getGenericSuperclass();</span><br><span class="line">    Assert.assertFalse(genericSuperclass <span class="keyword">instanceof</span> ParameterizedType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很遗憾，使用 <code>getGenericSuperclass()</code> 方法并不能成功获取，获取父接口的泛型信息可以使用 <code>getGenericInterfaces()</code> 方法。</p>
<blockquote>
<p><code>getGenericInterfaces()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetGenericInterfaces</span><span class="params">()</span> &#123;</span><br><span class="line">    Type[] genericInterfaces = MyInterface.class.getGenericInterfaces();</span><br><span class="line">    Assert.assertEquals(<span class="number">0</span>, genericInterfaces.length);</span><br><span class="line"></span><br><span class="line">    genericInterfaces = MyInterfaceImpl_1.class.getGenericInterfaces();</span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>, genericInterfaces.length);</span><br><span class="line">    <span class="keyword">for</span> (Type genericInterface : genericInterfaces) &#123;</span><br><span class="line">        Assert.assertTrue(genericInterface <span class="keyword">instanceof</span> ParameterizedType);</span><br><span class="line">        <span class="type">ParameterizedType</span> <span class="variable">type</span> <span class="operator">=</span> (ParameterizedType) genericInterface;</span><br><span class="line">        Assert.assertArrayEquals(<span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;String.class&#125;, type.getActualTypeArguments());</span><br><span class="line">        Assert.assertEquals(MyInterface.class, type.getRawType());</span><br><span class="line">        Assert.assertEquals(<span class="built_in">this</span>.getClass(), type.getOwnerType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    genericInterfaces = MyInterfaceImpl_2.class.getGenericInterfaces();</span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>, genericInterfaces.length);</span><br><span class="line">    <span class="keyword">for</span> (Type genericInterface : genericInterfaces) &#123;</span><br><span class="line">        Assert.assertTrue(genericInterface <span class="keyword">instanceof</span> ParameterizedType);</span><br><span class="line">        <span class="type">ParameterizedType</span> <span class="variable">type</span> <span class="operator">=</span> (ParameterizedType) genericInterface;</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;T&quot;</span>, type.getActualTypeArguments()[<span class="number">0</span>].toString());</span><br><span class="line">        Assert.assertEquals(MyInterface.class, type.getRawType());</span><br><span class="line">        Assert.assertEquals(<span class="built_in">this</span>.getClass(), type.getOwnerType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 不允许多继承，但允许实现多个接口，因此 <code>getGenericInterfaces()</code> 返回的是一个数组，表示实现的多个接口信息。</p>
<p>在返回的 <code>Type</code> 数组中，如果实现的某个接口带有泛型信息，可以将 <code>Type</code> 对象转换为 <code>ParameterizedType</code> 对象来获取泛型信息。</p>
<p><code>MyInterface</code> 接口是定义在测试类中的嵌套类，因此调用 <code>getOwnerType()</code> 方法返回的是当前测试类的 <code>Class</code> 对象。</p>
<p>只能使用 <code>getGenericInterfaces()</code> 方法来获取实现的接口的泛型信息，而不能获取继承的父类的泛型信息，否则最终得到的 <code>Type</code> 数组是一个空数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> <span class="keyword">extends</span> <span class="title class_">MyClass</span>&lt;String&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetGenericInterfaces_2</span><span class="params">()</span> &#123;</span><br><span class="line">    Type[] genericInterfaces = MyClass.class.getGenericInterfaces();</span><br><span class="line">    Assert.assertEquals(<span class="number">0</span>, genericInterfaces.length);</span><br><span class="line"></span><br><span class="line">    genericInterfaces = SimpleClass.class.getGenericInterfaces();</span><br><span class="line">    Assert.assertEquals(<span class="number">0</span>, genericInterfaces.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要获取其他位置的泛型信息时，参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/gongm24/article/details/121601473">JAVA反射 | 泛型解析</a></p>
<h2 id="4-8-反射调用可变参数方法"><a class="header-anchor" href="#4-8-反射调用可变参数方法"></a>4.8 反射调用可变参数方法</h2>
<p>可变参数可以当成对应的数组类型参数。</p>
<p>如果可变参数类型是引用类型：接收到参数后，会自动拆包取出参数再分配给底层方法，因此需要将传入的数组包装成 <code>Object</code> 对象或者将其作为 <code>Object[]</code> 中的一个元素；</p>
<p>如果可变参数类型是基本类型：不会将参数拆包，因此可以不用包装，但包装了也不会抛出异常，为了统一，可以和引用类型的可变参数一样，都包装一层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">firstMethod</span><span class="params">(<span class="type">int</span>... ints)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call firstMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">secondMethod</span><span class="params">(String... strings)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call secondMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testVaryArgsMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">    Class&lt;MyClass&gt; clazz = MyClass.class;</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">firstMethod</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;firstMethod&quot;</span>, <span class="type">int</span>[].class);</span><br><span class="line">    firstMethod.invoke(obj, <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    firstMethod.invoke(obj, (Object) <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    firstMethod.invoke(obj, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">secondMethod</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;secondMethod&quot;</span>, String[].class);</span><br><span class="line">    assertThatExceptionOfType(IllegalArgumentException.class)</span><br><span class="line">            .isThrownBy(() -&gt; secondMethod.invoke(obj, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;))</span><br><span class="line">            .withMessage(<span class="string">&quot;wrong number of arguments&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强转为 Object</span></span><br><span class="line">    secondMethod.invoke(obj, (Object) <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;);</span><br><span class="line">    <span class="comment">// 或者是 Object[] 中的一个元素</span></span><br><span class="line">    secondMethod.invoke(obj, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mofan212.github.io">默烦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mofan212.github.io/posts/Annotation-And-Reflection/">https://mofan212.github.io/posts/Annotation-And-Reflection/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://mofan212.github.io" target="_blank">Mofan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/20.jpg" data-sites="wechat,qq,weibo,facebook,twitter"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" target="_blank"><img class="post-qr-code-img" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/AliPay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" target="_blank"><img class="post-qr-code-img" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/WeChatPay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/Basic-JS-Knowledge/" title="应该知晓的JS知识"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/21.png" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">应该知晓的JS知识</div></div><div class="info-2"><div class="info-item-1">本文介绍了 JavaScript 中的一些基本概念，以及如何操作 BOM 与 DOM。</div></div></div></a><a class="pagination-related" href="/posts/Supplement-Of-Java-Related-Knowledge-First/" title="Java 相关知识补充"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/1.png" onerror="onerror=null;src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java 相关知识补充</div></div><div class="info-2"><div class="info-item-1">Java 基础知识、特性、技巧的一些补充。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/Design-Pattern-Mediator-Pattern/" title="【设计模式】中介者模式"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/148.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-03</div><div class="info-item-2">【设计模式】中介者模式</div></div><div class="info-2"><div class="info-item-1">本文主要对 Java 设计模式中的中介者模式进行了介绍。</div></div></div></a><a class="pagination-related" href="/posts/Combinator-Pattern/" title="Combinator Pattern"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/149.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-28</div><div class="info-item-2">Combinator Pattern</div></div><div class="info-2"><div class="info-item-1">本文介绍了如何在 Java 中使用 Combinator Pattern。</div></div></div></a><a class="pagination-related" href="/posts/Design-Pattern-Singleton-Pattern/" title="【设计模式】单例模式"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/112.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-10</div><div class="info-item-2">【设计模式】单例模式</div></div><div class="info-2"><div class="info-item-1">本文主要对 Java 设计模式中的单例模式进行了介绍。</div></div></div></a><a class="pagination-related" href="/posts/Design-Pattern-Proxy-Pattern/" title="【设计模式】代理模式"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/19.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-28</div><div class="info-item-2">【设计模式】代理模式</div></div><div class="info-2"><div class="info-item-1">本文对 Java 设计模式中的代理模式进行了介绍，重点介绍了 JDK 动态代理模式和 CGLib 动态代理模式。</div></div></div></a><a class="pagination-related" href="/posts/Design-Pattern-Observer-Pattern/" title="【设计模式】观察者模式"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/91.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-11</div><div class="info-item-2">【设计模式】观察者模式</div></div><div class="info-2"><div class="info-item-1">本文对 Java 设计模式中的观察者模式及其实现与应用进行了介绍。</div></div></div></a><a class="pagination-related" href="/posts/Design-Pattern-Builder-Pattern/" title="【设计模式】建造者模式"><img class="cover" src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/81.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-03</div><div class="info-item-2">【设计模式】建造者模式</div></div><div class="info-2"><div class="info-item-1">本文主要对 Java 设计模式中的建造者模式进行了介绍，同时也介绍了 Lombok 中 @Builder 注解的使用。</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/avatar.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">默烦</div><div class="author-info-description">彩笔的打怪升级之路...</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">161</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mofan212"><i class="fab fa-github"></i><span>follow me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:cy.mofan@foxmail.com" target="_blank" title="邮箱"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站所有博文均是博主的学习笔记与个人理解。<strong><font style="color:red">除特别注明外，</font>如需转载，请在文章头部醒目处附带原文链接并<a href="./mine/" style="color:#49B1F5;text-decoration:underline">告知我</a></strong>你将转载。😊</br><strong><font style="color:red">严禁未遵循规范的转载。</font></strong>😡</br><strong>死去的评论系统复活啦！欢迎到留言板畅所欲言！</strong>当然也可以使用更高效的<a target="_blank" href="https://space.bilibili.com/23658864/dynamic" style="color:#49B1F5;text-decoration:underline"> 哔哩哔哩私信 </a>或<a href="mailto:cy.mofan@foxmail.com" style="color:#49B1F5;text-decoration:underline" target="_blank">邮箱</a>。 😉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%B3%A8%E8%A7%A3"><span class="toc-text">1. 注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">1.1 自定义注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-text">1.2 元注解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">2. 类的加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Java-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E8%BF%90%E8%A1%8C"><span class="toc-text">2.1 Java 程序的启动与运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">2.2 类的加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">2.3 类初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">2.4 类加载器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">3. 双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1 基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-text">3.2 工作机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%BC%98%E7%82%B9"><span class="toc-text">3.2 优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-ClassLoader-%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3.3 ClassLoader 中的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">3.4 类加载器的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">3.5 打破双亲委派模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E6%95%B0%E7%BB%84%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">3.6 数组类的加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E-Tomcat"><span class="toc-text">3.7 类加载器与 Tomcat</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%8F%8D%E5%B0%84"><span class="toc-text">4. 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%87%A0%E4%B8%AA%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="toc-text">4.1 几个相关的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Class-%E7%B1%BB"><span class="toc-text">4.2 Class 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96-Class-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-text">4.3 如何获取 Class 类的实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-text">4.4 使用反射获取对象的信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3%E4%BF%A1%E6%81%AF"><span class="toc-text">4.5 使用反射获取注解信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-Class-%E7%9A%84%E5%90%84%E7%A7%8D-name"><span class="toc-text">4.6 Class 的各种 name</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%B3%9B%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-text">4.7 获取类的泛型信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95"><span class="toc-text">4.8 反射调用可变参数方法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Git/" title="Git理论与使用"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/3.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Git理论与使用"/></a><div class="content"><a class="title" href="/posts/Git/" title="Git理论与使用">Git理论与使用</a><time datetime="2025-06-14T16:00:00.000Z" title="更新于 2025-06-15 00:00:00">2025-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Genericity/" title="Java 泛型"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/58.jpg" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Java 泛型"/></a><div class="content"><a class="title" href="/posts/Java-Genericity/" title="Java 泛型">Java 泛型</a><time datetime="2025-06-09T16:00:00.000Z" title="更新于 2025-06-10 00:00:00">2025-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/The-Structure-Of-JVM/" title="JVM 内存结构"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/161.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="JVM 内存结构"/></a><div class="content"><a class="title" href="/posts/The-Structure-Of-JVM/" title="JVM 内存结构">JVM 内存结构</a><time datetime="2025-05-04T16:00:00.000Z" title="更新于 2025-05-05 00:00:00">2025-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Implement-Dubbo-Default-Service/" title="实现 Dubbo 默认服务"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/160.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="实现 Dubbo 默认服务"/></a><div class="content"><a class="title" href="/posts/Implement-Dubbo-Default-Service/" title="实现 Dubbo 默认服务">实现 Dubbo 默认服务</a><time datetime="2025-04-20T16:00:00.000Z" title="更新于 2025-04-21 00:00:00">2025-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/How-To-Parse-Spring-Configuration-Classes/" title="Spring 配置类的解析"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/154.webp" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Spring 配置类的解析"/></a><div class="content"><a class="title" href="/posts/How-To-Parse-Spring-Configuration-Classes/" title="Spring 配置类的解析">Spring 配置类的解析</a><time datetime="2025-04-12T16:00:00.000Z" title="更新于 2025-04-13 00:00:00">2025-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Java-Lambda-In-Action/" title="Java Lambda In Action"><img src= "https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/loading.gif" data-lazy-src="https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/ArticleCover/159.png" onerror="this.onerror=null;this.src='https://mofan-blog-pics.oss-cn-chengdu.aliyuncs.com/myblog/404.jpg'" alt="Java Lambda In Action"/></a><div class="content"><a class="title" href="/posts/Java-Lambda-In-Action/" title="Java Lambda In Action">Java Lambda In Action</a><time datetime="2025-03-18T16:00:00.000Z" title="更新于 2025-03-19 00:00:00">2025-03-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 默烦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://fastly.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://fastly.jsdelivr.net/npm/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://fastly.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://fastly.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://npm.elemecdn.com/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://fastly.jsdelivr.net/gh/mofan212/blog-static-resources@master/js/mine.min.js"></script><script defer="defer" id="ribbon" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-show-text" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Azathoth,Yog-Sothoth,Shub-Niggurath,Nyarlathotep,Cthulhu,Hastur,Abhoth,Ghroth,Tsathoggua,Cthugha,Deep Ones,Dagon,Chaugnar Faugn,Mordiggian,Shoggoth,Old One,Mi-Go,Great Race of Yith,Flying Polyp,Hounds of Tindalos,Dhole" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"/><script src="https://fastly.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'BAFEL7A6K1',
    apiKey: '89fcb5961984c5c054bf04149f345f38',
    indexName: 'mofan212io',
    container: '#docsearch',
    placeholder: '输入关键字进行搜索',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div></body></html>